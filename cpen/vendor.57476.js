/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/ 		if(executeModules) {
/******/ 			for(i=0; i < executeModules.length; i++) {
/******/ 				result = __webpack_require__(__webpack_require__.s = executeModules[i]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		7: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + ({"0":"i18n-3","1":"i18n-2","2":"i18n-1","3":"i18n-0","4":"monaco"}[chunkId]||chunkId) + ".chunk.js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/ })
/************************************************************************/
/******/ ({

/***/ "+BLB":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("tbG5");
var trees = __webpack_require__("+sRJ");
var adler32 = __webpack_require__("uxo6");
var crc32 = __webpack_require__("X4kj");
var msg = __webpack_require__("gMAY");

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;

var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/* The deflate compression method */
var Z_DEFLATED = 8;

/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS = 256;
/* number of literal bytes 0..255 */
var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES = 30;
/* number of distance codes */
var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length; /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match; /* matched string */
  var len; /* length of current match */
  var best_len = s.prev_length; /* best match length so far */
  var nice_match = s.nice_match; /* stop if match long enough */
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head; /* head of the hash chain */
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;

        //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head; /* head of hash chain */
  var bflush; /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {

          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush; /* set if current block must be flushed */
  var prev; /* byte at distance one to match */
  var scan, strend; /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break; /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast), /* 2 */
new Config(4, 6, 32, 32, deflate_fast), /* 3 */

new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow), /* 5 */
new Config(8, 16, 128, 128, deflate_slow), /* 6 */
new Config(8, 32, 128, 256, deflate_slow), /* 7 */
new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
];

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.status = 0; /* as the name implies */
  this.pending_buf = null; /* output still pending */
  this.pending_buf_size = 0; /* size of pending_buf */
  this.pending_out = 0; /* next pending byte to output to the stream */
  this.pending = 0; /* nb of bytes in the pending buffer */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null; /* gzip header information to write */
  this.gzindex = 0; /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1; /* value of flush param for previous deflate call */

  this.w_size = 0; /* LZ77 window size (32K by default) */
  this.w_bits = 0; /* log2(w_size)  (8..16) */
  this.w_mask = 0; /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null; /* Heads of the hash chains or NIL. */

  this.ins_h = 0; /* hash index of string to be inserted */
  this.hash_size = 0; /* number of elements in hash table */
  this.hash_bits = 0; /* log2(hash_size) */
  this.hash_mask = 0; /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0; /* length of best match */
  this.prev_match = 0; /* previous match */
  this.match_available = 0; /* set if previous match exists */
  this.strstart = 0; /* start of string to insert */
  this.match_start = 0; /* start of matching string */
  this.lookahead = 0; /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0; /* compression level (1..9) */
  this.strategy = 0; /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc = null; /* desc. for literal tree */
  this.d_desc = null; /* desc. for distance tree */
  this.bl_desc = null; /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0; /* number of elements in the heap */
  this.heap_max = 0; /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0; /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0; /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0; /* bit length of current block with optimal trees */
  this.static_len = 0; /* bit length of current block with static trees */
  this.matches = 0; /* number of string matches in current block */
  this.insert = 0; /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2; /* write gzip wrapper instead */
    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;

        s.status = BUSY_STATE;
        putShortMSB(s, header);

        /* Save the adler32 of the preset dictionary: */
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }
        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  }

  //#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment /* != Z_NULL*/) {
        beg = s.pending; /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  //#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/ /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}

/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0; /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

/***/ }),

/***/ "+KPf":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("rQTS");

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};

/***/ }),

/***/ "+puC":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var internalObjectKeys = __webpack_require__("p7FV");
var hiddenKeys = __webpack_require__("pup0").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

/***/ }),

/***/ "+sRJ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__("tbG5");

/* Public constants ==========================================================*/
/* ===========================================================================*/

//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY = 0;
var Z_TEXT = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN = 2;

/*============================================================================*/

function zero(buf) {
  var len = buf.length;while (--len >= 0) {
    buf[len] = 0;
  }
}

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits = /* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

var extra_dbits = /* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

var extra_blbits = /* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree = static_tree; /* static tree or NULL */
  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
  this.extra_base = extra_base; /* base index for extra_bits */
  this.elems = elems; /* max number of elements in the tree */
  this.max_length = max_length; /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree; /* the dynamic tree */
  this.max_code = 0; /* largest code with non zero frequency */
  this.stat_desc = stat_desc; /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h; /* heap index */
  var n, m; /* iterate over the tree elements */
  var bits; /* bit length */
  var xbits; /* extra bits */
  var f; /* frequency */
  var overflow = 0; /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] /*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2] /*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--; /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
        tree[m * 2 + 1] /*.Len*/ = bits;
      }
      n--;
    }
  }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0; /* running code value */
  var bits; /* bit index */
  var n; /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1] /*.Len*/;
    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */
    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n; /* iterates over tree elements */
  var bits; /* bit counter */
  var length; /* length value */
  var code; /* code value */
  var dist; /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] /*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] /*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] /*.Len*/ = 5;
    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}

/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] /*.Freq*/ = 0;
  }

  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s); /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  //  while (len--) {
  //    put_byte(s, *buf++);
  //  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1; /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}

// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist; /* distance of matched string */
  var lc; /* match length or unmatched char (if dist == 0) */
  var lx = 0; /* running index in l_buf */
  var code; /* the code to send */
  var extra; /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra); /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree); /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra); /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");
    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m; /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node; /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2] /*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] /*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] /*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1] /*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems; /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1 /*SMALLEST*/];
    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1 /*SMALLEST*/);
    /***/

    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1 /*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1 /*SMALLEST*/);
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] /*.Freq*/ += count;
    } else if (curlen !== 0) {

      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }
      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n; /* iterates over all tree elements */
  var prevlen = -1; /* last emitted length */
  var curlen; /* length of current code */

  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  var count = 0; /* repeat count of the current code */
  var max_count = 7; /* max repeat count */
  var min_count = 4; /* min repeat count */

  /* tree[max_code+1].Len = -1; */ /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex; /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank; /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}

var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s) {

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}

/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
  var max_blindex = 0; /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--; /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  }

  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility

  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif

  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

/***/ }),

/***/ "/+WI":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */
  this.time = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags = 0;
  /* operating system */
  this.os = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done = false;
}

module.exports = GZheader;

/***/ }),

/***/ "/7yg":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("xWhT") && !__webpack_require__("b3E9")(function () {
  return Object.defineProperty(__webpack_require__("Nfni")('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "/QFk":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ../node_modules/@emmetio/config/dist/config.es.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var defaultSyntaxes = {
	markup: 'html',
	stylesheet: 'css'
};

var knownSyntaxes = {
	markup: ['html', 'xml', 'xsl', 'jsx', 'js', 'pug', 'slim', 'haml'],
	stylesheet: ['css', 'sass', 'scss', 'less', 'sss', 'stylus']
};

/**
 * Config resolver: returns compiled config that can be used in
 * `@emmetio/expand-abbreviation` module for expanding abbreviations
 * @param {EmmetConfig} config Config object
 * @param {EmmetConfigParams} [params] Additional params like `.syntax` and `.project` for
 * config resolving
 * @returns {Object}
 */
function compileConfig(config, params) {
	params = createParams(config, params || {});

	var resolved = resolveConfig(config, params);

	// Copy extra fields from original config
	var knownFields = ['globals', 'syntax', 'project'];
	for (var p in config) {
		if (knownFields.indexOf(p) === -1) {
			resolved[p] = config[p];
		}
	}

	return resolved;
}

/**
 * Resolves config for markup syntax
 * @param {EmmetConfig} config
 * @param {EmmetConfigParams} params
 * @return {Object}
 */
function resolveConfig(config, ref) {
	var type = ref.type;
	var syntax = ref.syntax;
	var project = ref.project;

	return {
		syntax: syntax,
		type: type,
		project: project,
		format: mergeConfig(config, 'format', type, syntax, project),
		profile: mergeConfig(config, 'profile', type, syntax, project),
		options: mergeConfig(config, 'options', type, syntax, project),
		variables: mergeConfig(config, 'variables', type, syntax, project),
		snippets: getConfig(config, 'snippets', type, syntax, project).filter(Boolean)
	};
}

/**
 * @param {EmmetConfig} config 
 * @param {EmmetConfigParams} params 
 * @returns {EmmetConfigParams}
 */
function createParams(config, params) {
	var type = params.type;
	var syntax = params.syntax;

	if (!type && !syntax) {
		type = 'markup';
		syntax = defaultSyntaxes[type];
	} else if (!type && syntax) {
		if (knownSyntaxes.markup.indexOf(syntax) !== -1) {
			type = 'markup';
		} else if (knownSyntaxes.stylesheet.indexOf(syntax) !== -1) {
			type = 'stylesheet';
		} else {
			type = get(config, ['syntax', syntax, 'type']) || get(config, ['project', params.project, 'syntax', syntax, 'type']);
		}
	} else if (!syntax) {
		syntax = defaultSyntaxes[type];
	}

	return _extends({}, params, { type: type, syntax: syntax });
}

function mergeConfig(config, key, type, syntax, project) {
	return getConfig(config, key, type, syntax, project).reduce(function (out, obj) {
		return _extends({}, out, obj);
	}, {});
}

function getConfig(config, key, type, syntax, project) {
	return [get(config, ['globals', type, key]), get(config, ['project', project, 'globals', type, key]), get(config, ['syntax', syntax, key]), get(config, ['project', project, 'syntax', syntax, key])].filter(Boolean);
}

/**
 * Safe dot-property getter for `obj`: returns value of `obj` by given `key`,
 * separated by `.`, but doesn’t throw error if any of the property key exists
 * @param {Object} obj
 * @param {String[]} key
 * @param {*} [defaultValue] 
 * @return {*}
 */
function get(obj, key, defaultValue) {
	var result = obj;

	for (var i = 0; i < key.length; i++) {
		if (result == null) {
			break;
		}

		result = result[key[i]];
	}

	return result != null ? result : defaultValue;
}

/* harmony default export */ var config_es = (compileConfig);
//# sourceMappingURL=config.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/stream-reader/dist/stream-reader.es.js
/**
 * A streaming, character code-based string reader
 */
let StreamReader = class StreamReader {
	constructor(string, start, end) {
		if (end == null && typeof string === 'string') {
			end = string.length;
		}

		this.string = string;
		this.pos = this.start = start || 0;
		this.end = end;
	}

	/**
  * Returns true only if the stream is at the end of the file.
  * @returns {Boolean}
  */
	eof() {
		return this.pos >= this.end;
	}

	/**
  * Creates a new stream instance which is limited to given `start` and `end`
  * range. E.g. its `eof()` method will look at `end` property, not actual
  * stream end
  * @param  {Point} start
  * @param  {Point} end
  * @return {StreamReader}
  */
	limit(start, end) {
		return new this.constructor(this.string, start, end);
	}

	/**
  * Returns the next character code in the stream without advancing it.
  * Will return NaN at the end of the file.
  * @returns {Number}
  */
	peek() {
		return this.string.charCodeAt(this.pos);
	}

	/**
  * Returns the next character in the stream and advances it.
  * Also returns <code>undefined</code> when no more characters are available.
  * @returns {Number}
  */
	next() {
		if (this.pos < this.string.length) {
			return this.string.charCodeAt(this.pos++);
		}
	}

	/**
  * `match` can be a character code or a function that takes a character code
  * and returns a boolean. If the next character in the stream 'matches'
  * the given argument, it is consumed and returned.
  * Otherwise, `false` is returned.
  * @param {Number|Function} match
  * @returns {Boolean}
  */
	eat(match) {
		const ch = this.peek();
		const ok = typeof match === 'function' ? match(ch) : ch === match;

		if (ok) {
			this.next();
		}

		return ok;
	}

	/**
  * Repeatedly calls <code>eat</code> with the given argument, until it
  * fails. Returns <code>true</code> if any characters were eaten.
  * @param {Object} match
  * @returns {Boolean}
  */
	eatWhile(match) {
		const start = this.pos;
		while (!this.eof() && this.eat(match)) {}
		return this.pos !== start;
	}

	/**
  * Backs up the stream n characters. Backing it up further than the
  * start of the current token will cause things to break, so be careful.
  * @param {Number} n
  */
	backUp(n) {
		this.pos -= n || 1;
	}

	/**
  * Get the string between the start of the current token and the
  * current stream position.
  * @returns {String}
  */
	current() {
		return this.substring(this.start, this.pos);
	}

	/**
  * Returns substring for given range
  * @param  {Number} start
  * @param  {Number} [end]
  * @return {String}
  */
	substring(start, end) {
		return this.string.slice(start, end);
	}

	/**
  * Creates error object with current stream state
  * @param {String} message
  * @return {Error}
  */
	error(message) {
		const err = new Error(`${message} at char ${this.pos + 1}`);
		err.originalMessage = message;
		err.pos = this.pos;
		err.string = this.string;
		return err;
	}
};


/* harmony default export */ var stream_reader_es = (StreamReader);
// CONCATENATED MODULE: ../node_modules/@emmetio/stream-reader-utils/dist/stream-reader-utils.es.js
var stream_reader_utils_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * Methods for consuming quoted values
 */

const SINGLE_QUOTE = 39; // '
const DOUBLE_QUOTE = 34; // "

const defaultOptions = {
	escape: 92, // \ character
	throws: false
};

/**
 * Consumes 'single' or "double"-quoted string from given string, if possible
 * @param  {StreamReader} stream
 * @param  {Number}  options.escape A character code of quote-escape symbol
 * @param  {Boolean} options.throws Throw error if quotes string can’t be properly consumed
 * @return {Boolean} `true` if quoted string was consumed. The contents
 *                   of quoted string will be availabe as `stream.current()`
 */
var eatQuoted = function (stream, options) {
	options = options ? stream_reader_utils_es__extends({}, defaultOptions, options) : defaultOptions;
	const start = stream.pos;
	const quote = stream.peek();

	if (stream.eat(isQuote)) {
		while (!stream.eof()) {
			switch (stream.next()) {
				case quote:
					stream.start = start;
					return true;

				case options.escape:
					stream.next();
					break;
			}
		}

		// If we’re here then stream wasn’t properly consumed.
		// Revert stream and decide what to do
		stream.pos = start;

		if (options.throws) {
			throw stream.error('Unable to consume quoted string');
		}
	}

	return false;
};

function isQuote(code) {
	return code === SINGLE_QUOTE || code === DOUBLE_QUOTE;
}

/**
 * Check if given code is a number
 * @param  {Number}  code
 * @return {Boolean}
 */
function isNumber(code) {
	return code > 47 && code < 58;
}

/**
 * Check if given character code is alpha code (letter through A to Z)
 * @param  {Number}  code
 * @param  {Number}  [from]
 * @param  {Number}  [to]
 * @return {Boolean}
 */
function isAlpha(code, from, to) {
	from = from || 65; // A
	to = to || 90; // Z
	code &= ~32; // quick hack to convert any char code to uppercase char code

	return code >= from && code <= to;
}

/**
 * Check if given character code is alpha-numeric (letter through A to Z or number)
 * @param  {Number}  code
 * @return {Boolean}
 */
function isAlphaNumeric(code) {
	return isNumber(code) || isAlpha(code);
}

function isWhiteSpace(code) {
	return code === 32 /* space */
	|| code === 9 /* tab */
	|| code === 160; /* non-breaking space */
}

/**
 * Check if given character code is a space
 * @param  {Number}  code
 * @return {Boolean}
 */
function isSpace(code) {
	return isWhiteSpace(code) || code === 10 /* LF */
	|| code === 13; /* CR */
}

const defaultOptions$1 = {
	escape: 92, // \ character
	throws: false
};

/**
 * Eats paired characters substring, for example `(foo)` or `[bar]`
 * @param  {StreamReader} stream
 * @param  {Number} open      Character code of pair openinig
 * @param  {Number} close     Character code of pair closing
 * @param  {Object} [options]
 * @return {Boolean}       Returns `true` if chacarter pair was successfully
 *                         consumed, it’s content will be available as `stream.current()`
 */
function eatPair(stream, open, close, options) {
	options = options ? stream_reader_utils_es__extends({}, defaultOptions$1, options) : defaultOptions$1;
	const start = stream.pos;

	if (stream.eat(open)) {
		let stack = 1,
		    ch;

		while (!stream.eof()) {
			if (eatQuoted(stream, options)) {
				continue;
			}

			ch = stream.next();
			if (ch === open) {
				stack++;
			} else if (ch === close) {
				stack--;
				if (!stack) {
					stream.start = start;
					return true;
				}
			} else if (ch === options.escape) {
				stream.next();
			}
		}

		// If we’re here then paired character can’t be consumed
		stream.pos = start;

		if (options.throws) {
			throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);
		}
	}

	return false;
}


// CONCATENATED MODULE: ../node_modules/@emmetio/field-parser/dist/field-parser.es.js



const DOLLAR = 36; // $
const COLON = 58; // :
const ESCAPE = 92; // \
const OPEN_BRACE = 123; // {
const CLOSE_BRACE = 125; // }

/**
 * Finds fields in given string and returns object with field-less string
 * and array of fields found
 * @param  {String} string
 * @return {Object}
 */
function parse(string) {
	const stream = new stream_reader_es(string);
	const fields = [];
	let cleanString = '',
	    offset = 0,
	    pos = 0;
	let code, field;

	while (!stream.eof()) {
		code = stream.peek();
		pos = stream.pos;

		if (code === ESCAPE) {
			stream.next();
			stream.next();
		} else if (field = consumeField(stream, cleanString.length + pos - offset)) {
			fields.push(field);
			cleanString += stream.string.slice(offset, pos) + field.placeholder;
			offset = stream.pos;
		} else {
			stream.next();
		}
	}

	return new FieldString(cleanString + stream.string.slice(offset), fields);
}

/**
 * Marks given `string` with `fields`: wraps each field range with
 * `${index:placeholder}` (by default) or any other token produced by `token`
 * function, if provided
 * @param  {String} string String to mark
 * @param  {Array} fields Array of field descriptor. A field descriptor is a
 * `{index, location, length}` array. It is important that fields in array
 * must be ordered by their location in string: some fields my refer the same
 * location so they must appear in order that user expects.
 * @param  {Function} [token] Function that generates field token. This function
 * received two arguments: `index` and `placeholder` and should return string
 * @return {String}  String with marked fields
 */
function mark(string, fields, token) {
	token = token || createToken;

	// order fields by their location and appearence
	// NB field ranges should not overlap! (not supported yet)
	const ordered = fields.map((field, order) => ({ order, field, end: field.location + field.length })).sort((a, b) => a.end - b.end || a.order - b.order);

	// mark ranges in string
	let offset = 0;
	const result = ordered.map(item => {
		const placeholder = string.substr(item.field.location, item.field.length);
		const prefix = string.slice(offset, item.field.location);
		offset = item.end;
		return prefix + token(item.field.index, placeholder);
	});

	return result.join('') + string.slice(offset);
}

/**
 * Creates field token for string
 * @param  {Number} index       Field index
 * @param  {String} placeholder Field placeholder, could be empty string
 * @return {String}
 */
function createToken(index, placeholder) {
	return placeholder ? `\${${index}:${placeholder}}` : `\${${index}}`;
}

/**
 * Consumes field from current stream position: it can be an `$index` or
 * or `${index}` or `${index:placeholder}`
 * @param  {StreamReader} stream
 * @param  {Number}       location Field location in *clean* string
 * @return {Field} Object with `index` and `placeholder` properties if
 * field was successfully consumed, `null` otherwise
 */
function consumeField(stream, location) {
	const start = stream.pos;

	if (stream.eat(DOLLAR)) {
		// Possible start of field
		let index = consumeIndex(stream);
		let placeholder = '';

		// consumed $index placeholder
		if (index != null) {
			return new Field(index, placeholder, location);
		}

		if (stream.eat(OPEN_BRACE)) {
			index = consumeIndex(stream);
			if (index != null) {
				if (stream.eat(COLON)) {
					placeholder = consumePlaceholder(stream);
				}

				if (stream.eat(CLOSE_BRACE)) {
					return new Field(index, placeholder, location);
				}
			}
		}
	}

	// If we reached here then there’s no valid field here, revert
	// back to starting position
	stream.pos = start;
}

/**
 * Consumes a placeholder: value right after `:` in field. Could be empty
 * @param  {StreamReader} stream
 * @return {String}
 */
function consumePlaceholder(stream) {
	let code;
	const stack = [];
	stream.start = stream.pos;

	while (!stream.eof()) {
		code = stream.peek();

		if (code === OPEN_BRACE) {
			stack.push(stream.pos);
		} else if (code === CLOSE_BRACE) {
			if (!stack.length) {
				break;
			}
			stack.pop();
		}
		stream.next();
	}

	if (stack.length) {
		throw stream.error('Unable to find matching "}" for curly brace at ' + stack.pop());
	}

	return stream.current();
}

/**
 * Consumes integer from current stream position
 * @param  {StreamReader} stream
 * @return {Number}
 */
function consumeIndex(stream) {
	stream.start = stream.pos;
	if (stream.eatWhile(isNumber)) {
		return Number(stream.current());
	}
}

let Field = class Field {
	constructor(index, placeholder, location) {
		this.index = index;
		this.placeholder = placeholder;
		this.location = location;
		this.length = this.placeholder.length;
	}
};
let FieldString = class FieldString {
	/**
  * @param {String} string
  * @param {Field[]} fields
  */
	constructor(string, fields) {
		this.string = string;
		this.fields = fields;
	}

	mark(token) {
		return mark(this.string, this.fields, token);
	}

	toString() {
		return this.string;
	}
};


/* harmony default export */ var field_parser_es = (parse);

//# sourceMappingURL=field-parser.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/extract-abbreviation/dist/extract-abbreviation.es.js
var extract_abbreviation_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * Minimalistic backwards stream reader
 */
let extract_abbreviation_es_StreamReader = class StreamReader {
	constructor(string, start) {
		this.string = string;
		this.start = start || 0;
		this.pos = this.string.length;
	}

	sol() {
		return this.pos === this.start;
	}

	peek(offset) {
		return this.string.charCodeAt(this.pos - 1 + (offset || 0));
	}

	prev() {
		if (!this.sol()) {
			return this.string.charCodeAt(--this.pos);
		}
	}

	eat(match) {
		if (this.sol()) {
			return false;
		}

		const ok = typeof match === 'function' ? match(this.peek()) : match === this.peek();

		if (ok) {
			this.pos--;
		}

		return ok;
	}

	eatWhile(match) {
		const start = this.pos;
		while (this.eat(match)) {}
		return this.pos < start;
	}
};

/**
 * Quotes-related utilities
 */

const extract_abbreviation_es_SINGLE_QUOTE = 39; // '
const extract_abbreviation_es_DOUBLE_QUOTE = 34; // "
const extract_abbreviation_es_ESCAPE = 92; // \

/**
 * Check if given character code is a quote
 * @param  {Number}  c
 * @return {Boolean}
 */
function extract_abbreviation_es_isQuote(c) {
	return c === extract_abbreviation_es_SINGLE_QUOTE || c === extract_abbreviation_es_DOUBLE_QUOTE;
}

/**
 * Consumes quoted value, if possible
 * @param  {StreamReader} stream
 * @return {Boolean}      Returns `true` is value was consumed
 */
function extract_abbreviation_es_eatQuoted(stream) {
	const start = stream.pos;
	const quote = stream.prev();

	if (extract_abbreviation_es_isQuote(quote)) {
		while (!stream.sol()) {
			if (stream.prev() === quote && stream.peek() !== extract_abbreviation_es_ESCAPE) {
				return true;
			}
		}
	}

	stream.pos = start;
	return false;
}

const TAB = 9;
const SPACE = 32;
const DASH = 45; // -
const SLASH = 47; // /
const extract_abbreviation_es_COLON = 58; // :
const EQUALS = 61; // =
const ANGLE_LEFT = 60; // <
const ANGLE_RIGHT = 62; // >

/**
 * Check if given reader’s current position points at the end of HTML tag
 * @param  {StreamReader} stream
 * @return {Boolean}
 */
var isAtHTMLTag = function (stream) {
	const start = stream.pos;

	if (!stream.eat(ANGLE_RIGHT)) {
		return false;
	}

	let ok = false;
	stream.eat(SLASH); // possibly self-closed element

	while (!stream.sol()) {
		stream.eatWhile(extract_abbreviation_es_isWhiteSpace);

		if (eatIdent(stream)) {
			// ate identifier: could be a tag name, boolean attribute or unquoted
			// attribute value
			if (stream.eat(SLASH)) {
				// either closing tag or invalid tag
				ok = stream.eat(ANGLE_LEFT);
				break;
			} else if (stream.eat(ANGLE_LEFT)) {
				// opening tag
				ok = true;
				break;
			} else if (stream.eat(extract_abbreviation_es_isWhiteSpace)) {
				// boolean attribute
				continue;
			} else if (stream.eat(EQUALS)) {
				// simple unquoted value or invalid attribute
				if (eatIdent(stream)) {
					continue;
				}
				break;
			} else if (eatAttributeWithUnquotedValue(stream)) {
				// identifier was a part of unquoted value
				ok = true;
				break;
			}

			// invalid tag
			break;
		}

		if (eatAttribute(stream)) {
			continue;
		}

		break;
	}

	stream.pos = start;
	return ok;
};

/**
 * Eats HTML attribute from given string.
 * @param  {StreamReader} state
 * @return {Boolean}       `true` if attribute was consumed.
 */
function eatAttribute(stream) {
	return eatAttributeWithQuotedValue(stream) || eatAttributeWithUnquotedValue(stream);
}

/**
 * @param  {StreamReader} stream
 * @return {Boolean}
 */
function eatAttributeWithQuotedValue(stream) {
	const start = stream.pos;
	if (extract_abbreviation_es_eatQuoted(stream) && stream.eat(EQUALS) && eatIdent(stream)) {
		return true;
	}

	stream.pos = start;
	return false;
}

/**
 * @param  {StreamReader} stream
 * @return {Boolean}
 */
function eatAttributeWithUnquotedValue(stream) {
	const start = stream.pos;
	if (stream.eatWhile(isUnquotedValue) && stream.eat(EQUALS) && eatIdent(stream)) {
		return true;
	}

	stream.pos = start;
	return false;
}

/**
 * Eats HTML identifier from stream
 * @param  {StreamReader} stream
 * @return {Boolean}
 */
function eatIdent(stream) {
	return stream.eatWhile(isIdent);
}

/**
 * Check if given character code belongs to HTML identifier
 * @param  {Number}  c
 * @return {Boolean}
 */
function isIdent(c) {
	return c === extract_abbreviation_es_COLON || c === DASH || extract_abbreviation_es_isAlpha(c) || extract_abbreviation_es_isNumber(c);
}

/**
 * Check if given character code is alpha code (letter though A to Z)
 * @param  {Number}  c
 * @return {Boolean}
 */
function extract_abbreviation_es_isAlpha(c) {
	c &= ~32; // quick hack to convert any char code to uppercase char code
	return c >= 65 && c <= 90; // A-Z
}

/**
 * Check if given code is a number
 * @param  {Number}  c
 * @return {Boolean}
 */
function extract_abbreviation_es_isNumber(c) {
	return c > 47 && c < 58;
}

/**
 * Check if given code is a whitespace
 * @param  {Number}  c
 * @return {Boolean}
 */
function extract_abbreviation_es_isWhiteSpace(c) {
	return c === SPACE || c === TAB;
}

/**
 * Check if given code may belong to unquoted attribute value
 * @param  {Number}  c
 * @return {Boolean}
 */
function isUnquotedValue(c) {
	return c && c !== EQUALS && !extract_abbreviation_es_isWhiteSpace(c) && !extract_abbreviation_es_isQuote(c);
}

const extract_abbreviation_es_code = ch => ch.charCodeAt(0);
const SQUARE_BRACE_L = extract_abbreviation_es_code('[');
const SQUARE_BRACE_R = extract_abbreviation_es_code(']');
const ROUND_BRACE_L = extract_abbreviation_es_code('(');
const ROUND_BRACE_R = extract_abbreviation_es_code(')');
const CURLY_BRACE_L = extract_abbreviation_es_code('{');
const CURLY_BRACE_R = extract_abbreviation_es_code('}');

const specialChars = new Set('#.*:$-_!@%^+>/'.split('').map(extract_abbreviation_es_code));
const bracePairs = new Map().set(SQUARE_BRACE_L, SQUARE_BRACE_R).set(ROUND_BRACE_L, ROUND_BRACE_R).set(CURLY_BRACE_L, CURLY_BRACE_R);

const extract_abbreviation_es_defaultOptions = {
	syntax: 'markup',
	lookAhead: null,
	prefix: ''
};

/**
 * Extracts Emmet abbreviation from given string.
 * The goal of this module is to extract abbreviation from current editor’s line,
 * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where
 * `|` is a current caret position.
 * @param {String}  line A text line where abbreviation should be expanded
 * @param {Number}  [pos] Caret position in line. If not given, uses end-of-line
 * @param {Object}  [options]
 * @param {Boolean} [options.lookAhead] Allow parser to look ahead of `pos` index for
 * searching of missing abbreviation parts. Most editors automatically inserts
 * closing braces for `[`, `{` and `(`, which will most likely be right after
 * current caret position. So in order to properly expand abbreviation, user
 * must explicitly move caret right after auto-inserted braces. With this option
 * enabled, parser will search for closing braces right after `pos`. Default is `true`
 * @param {String} [options.syntax] Name of context syntax of expanded abbreviation.
 * Either 'markup' (default) or 'stylesheet'. In 'stylesheet' syntax, braces `[]`
 * and `{}` are not supported thus not extracted.
 * @param {String} [options.prefix] A string that should precede abbreviation in
 * order to make it successfully extracted. If given, the abbreviation will be
 * extracted from the nearest `prefix` occurrence.
 * @return {Object} Object with `abbreviation` and its `location` in given line
 * if abbreviation can be extracted, `null` otherwise
 */
function extractAbbreviation(line, pos, options) {
	// make sure `pos` is within line range
	pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));

	if (typeof options === 'boolean') {
		options = extract_abbreviation_es__extends({}, extract_abbreviation_es_defaultOptions, { lookAhead: options });
	} else {
		options = extract_abbreviation_es__extends({}, extract_abbreviation_es_defaultOptions, options);
	}

	if (options.lookAhead == null || options.lookAhead === true) {
		pos = offsetPastAutoClosed(line, pos, options);
	}

	let c;
	const start = getStartOffset(line, pos, options.prefix);
	if (start === -1) {
		return null;
	}

	const stream = new extract_abbreviation_es_StreamReader(line, start);
	stream.pos = pos;
	const stack = [];

	while (!stream.sol()) {
		c = stream.peek();

		if (isCloseBrace(c, options.syntax)) {
			stack.push(c);
		} else if (isOpenBrace(c, options.syntax)) {
			if (stack.pop() !== bracePairs.get(c)) {
				// unexpected brace
				break;
			}
		} else if (has(stack, SQUARE_BRACE_R) || has(stack, CURLY_BRACE_R)) {
			// respect all characters inside attribute sets or text nodes
			stream.pos--;
			continue;
		} else if (isAtHTMLTag(stream) || !isAbbreviation(c)) {
			break;
		}

		stream.pos--;
	}

	if (!stack.length && stream.pos !== pos) {
		// found something, remove some invalid symbols from the
		// beginning and return abbreviation
		const abbreviation = line.slice(stream.pos, pos).replace(/^[*+>^]+/, '');
		return {
			abbreviation,
			location: pos - abbreviation.length,
			start: options.prefix ? start - options.prefix.length : pos - abbreviation.length,
			end: pos
		};
	}
}

/**
 * Returns new `line` index which is right after characters beyound `pos` that
 * editor will likely automatically close, e.g. }, ], and quotes
 * @param {String} line
 * @param {Number} pos
 * @return {Number}
 */
function offsetPastAutoClosed(line, pos, options) {
	// closing quote is allowed only as a next character
	if (extract_abbreviation_es_isQuote(line.charCodeAt(pos))) {
		pos++;
	}

	// offset pointer until non-autoclosed character is found
	while (isCloseBrace(line.charCodeAt(pos), options.syntax)) {
		pos++;
	}

	return pos;
}

/**
 * Returns start offset (left limit) in `line` where we should stop looking for
 * abbreviation: it’s nearest to `pos` location of `prefix` token
 * @param {String} line
 * @param {Number} pos
 * @param {String} prefix
 * @return {Number}
 */
function getStartOffset(line, pos, prefix) {
	if (!prefix) {
		return 0;
	}

	const stream = new extract_abbreviation_es_StreamReader(line);
	const compiledPrefix = String(prefix).split('').map(extract_abbreviation_es_code);
	stream.pos = pos;
	let result;

	while (!stream.sol()) {
		if (consumePair(stream, SQUARE_BRACE_R, SQUARE_BRACE_L) || consumePair(stream, CURLY_BRACE_R, CURLY_BRACE_L)) {
			continue;
		}

		result = stream.pos;
		if (consumeArray(stream, compiledPrefix)) {
			return result;
		}

		stream.pos--;
	}

	return -1;
}

/**
 * Consumes full character pair, if possible
 * @param {StreamReader} stream
 * @param {Number} close
 * @param {Number} open
 * @return {Boolean}
 */
function consumePair(stream, close, open) {
	const start = stream.pos;
	if (stream.eat(close)) {
		while (!stream.sol()) {
			if (stream.eat(open)) {
				return true;
			}

			stream.pos--;
		}
	}

	stream.pos = start;
	return false;
}

/**
 * Consumes all character codes from given array, right-to-left, if possible
 * @param {StreamReader} stream
 * @param {Number[]} arr
 */
function consumeArray(stream, arr) {
	const start = stream.pos;
	let consumed = false;

	for (let i = arr.length - 1; i >= 0 && !stream.sol(); i--) {
		if (!stream.eat(arr[i])) {
			break;
		}

		consumed = i === 0;
	}

	if (!consumed) {
		stream.pos = start;
	}

	return consumed;
}

function has(arr, value) {
	return arr.indexOf(value) !== -1;
}

function isAbbreviation(c) {
	return c > 64 && c < 91 || // uppercase letter
	c > 96 && c < 123 // lowercase letter
	|| c > 47 && c < 58 // number
	|| specialChars.has(c); // special character
}

function isOpenBrace(c, syntax) {
	return c === ROUND_BRACE_L || syntax === 'markup' && (c === SQUARE_BRACE_L || c === CURLY_BRACE_L);
}

function isCloseBrace(c, syntax) {
	return c === ROUND_BRACE_R || syntax === 'markup' && (c === SQUARE_BRACE_R || c === CURLY_BRACE_R);
}

/* harmony default export */ var extract_abbreviation_es = (extractAbbreviation);
// CONCATENATED MODULE: ../node_modules/@emmetio/node/dist/node.es.js
var node_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * Attribute descriptor of parsed abbreviation node
 * @param {String} name Attribute name
 * @param {String} value Attribute value
 * @param {Object} options Additional custom attribute options
 * @param {Boolean} options.boolean Attribute is boolean (e.g. name equals value)
 * @param {Boolean} options.implied Attribute is implied (e.g. must be outputted
 * only if contains non-null value)
 */
let Attribute = class Attribute {
	constructor(name, value, options) {
		this.name = name;
		this.value = value != null ? value : null;
		this.options = options || {};
	}

	/**
  * Create a copy of current attribute
  * @return {Attribute}
  */
	clone() {
		return new Attribute(this.name, this.value, node_es__extends({}, this.options));
	}

	/**
  * A string representation of current node
  */
	valueOf() {
		return `${this.name}="${this.value}"`;
	}
};

/**
 * A parsed abbreviation AST node. Nodes build up an abbreviation AST tree
 */

let Node = class Node {
	/**
  * Creates a new node
  * @param {String} [name] Node name
  * @param {Array} [attributes] Array of attributes to add
  */
	constructor(name, attributes) {
		// own properties
		this.name = name || null;
		this.value = null;
		this.repeat = null;
		this.selfClosing = false;

		this.children = [];

		/** @type {Node} Pointer to parent node */
		this.parent = null;

		/** @type {Node} Pointer to next sibling */
		this.next = null;

		/** @type {Node} Pointer to previous sibling */
		this.previous = null;

		this._attributes = [];

		if (Array.isArray(attributes)) {
			attributes.forEach(attr => this.setAttribute(attr));
		}
	}

	/**
  * Array of current node attributes
  * @return {Attribute[]} Array of attributes
  */
	get attributes() {
		return this._attributes;
	}

	/**
  * A shorthand to retreive node attributes as map
  * @return {Object}
  */
	get attributesMap() {
		return this.attributes.reduce((out, attr) => {
			out[attr.name] = attr.options.boolean ? attr.name : attr.value;
			return out;
		}, {});
	}

	/**
  * Check if current node is a grouping one, e.g. has no actual representation
  * and is used for grouping subsequent nodes only
  * @return {Boolean}
  */
	get isGroup() {
		return !this.name && !this.value && !this._attributes.length;
	}

	/**
  * Check if given node is a text-only node, e.g. contains only value
  * @return {Boolean}
  */
	get isTextOnly() {
		return !this.name && !!this.value && !this._attributes.length;
	}

	/**
  * Returns first child node
  * @return {Node}
  */
	get firstChild() {
		return this.children[0];
	}

	/**
  * Returns last child of current node
  * @return {Node}
  */
	get lastChild() {
		return this.children[this.children.length - 1];
	}

	/**
  * Return index of current node in its parent child list
  * @return {Number} Returns -1 if current node is a root one
  */
	get childIndex() {
		return this.parent ? this.parent.children.indexOf(this) : -1;
	}

	/**
  * Returns next sibling of current node
  * @return {Node}
  */
	get nextSibling() {
		return this.next;
	}

	/**
  * Returns previous sibling of current node
  * @return {Node}
  */
	get previousSibling() {
		return this.previous;
	}

	/**
  * Returns array of unique class names in current node
  * @return {String[]}
  */
	get classList() {
		const attr = this.getAttribute('class');
		return attr && attr.value ? attr.value.split(/\s+/g).filter(uniqueClass) : [];
	}

	/**
  * Convenient alias to create a new node instance
  * @param {String} [name] Node name
  * @param {Object} [attributes] Attributes hash
  * @return {Node}
  */
	create(name, attributes) {
		return new Node(name, attributes);
	}

	/**
  * Sets given attribute for current node
  * @param {String|Object|Attribute} name Attribute name or attribute object
  * @param {String} [value] Attribute value
  */
	setAttribute(name, value) {
		const attr = createAttribute(name, value);
		const curAttr = this.getAttribute(name);
		if (curAttr) {
			this.replaceAttribute(curAttr, attr);
		} else {
			this._attributes.push(attr);
		}
	}

	/**
  * Check if attribute with given name exists in node
  * @param  {String} name
  * @return {Boolean}
  */
	hasAttribute(name) {
		return !!this.getAttribute(name);
	}

	/**
  * Returns attribute object by given name
  * @param  {String} name
  * @return {Attribute}
  */
	getAttribute(name) {
		if (typeof name === 'object') {
			name = name.name;
		}

		for (var i = 0; i < this._attributes.length; i++) {
			const attr = this._attributes[i];
			if (attr.name === name) {
				return attr;
			}
		}
	}

	/**
  * Replaces attribute with new instance
  * @param {String|Attribute} curAttribute Current attribute name or instance
  * to replace
  * @param {String|Object|Attribute} newName New attribute name or attribute object
  * @param {String} [newValue] New attribute value
  */
	replaceAttribute(curAttribute, newName, newValue) {
		if (typeof curAttribute === 'string') {
			curAttribute = this.getAttribute(curAttribute);
		}

		const ix = this._attributes.indexOf(curAttribute);
		if (ix !== -1) {
			this._attributes.splice(ix, 1, createAttribute(newName, newValue));
		}
	}

	/**
  * Removes attribute with given name
  * @param  {String|Attribute} attr Atrtibute name or instance
  */
	removeAttribute(attr) {
		if (typeof attr === 'string') {
			attr = this.getAttribute(attr);
		}

		const ix = this._attributes.indexOf(attr);
		if (ix !== -1) {
			this._attributes.splice(ix, 1);
		}
	}

	/**
  * Removes all attributes from current node
  */
	clearAttributes() {
		this._attributes.length = 0;
	}

	/**
  * Adds given class name to class attribute
  * @param {String} token Class name token
  */
	addClass(token) {
		token = normalize(token);

		if (!this.hasAttribute('class')) {
			this.setAttribute('class', token);
		} else if (token && !this.hasClass(token)) {
			this.setAttribute('class', this.classList.concat(token).join(' '));
		}
	}

	/**
  * Check if current node contains given class name
  * @param {String} token Class name token
  * @return {Boolean}
  */
	hasClass(token) {
		return this.classList.indexOf(normalize(token)) !== -1;
	}

	/**
  * Removes given class name from class attribute
  * @param {String} token Class name token
  */
	removeClass(token) {
		token = normalize(token);
		if (this.hasClass(token)) {
			this.setAttribute('class', this.classList.filter(name => name !== token).join(' '));
		}
	}

	/**
  * Appends child to current node
  * @param {Node} node
  */
	appendChild(node) {
		this.insertAt(node, this.children.length);
	}

	/**
  * Inserts given `newNode` before `refNode` child node
  * @param {Node} newNode
  * @param {Node} refNode
  */
	insertBefore(newNode, refNode) {
		this.insertAt(newNode, this.children.indexOf(refNode));
	}

	/**
  * Insert given `node` at `pos` position of child list
  * @param {Node} node
  * @param {Number} pos
  */
	insertAt(node, pos) {
		if (pos < 0 || pos > this.children.length) {
			throw new Error('Unable to insert node: position is out of child list range');
		}

		const prev = this.children[pos - 1];
		const next = this.children[pos];

		node.remove();
		node.parent = this;
		this.children.splice(pos, 0, node);

		if (prev) {
			node.previous = prev;
			prev.next = node;
		}

		if (next) {
			node.next = next;
			next.previous = node;
		}
	}

	/**
  * Removes given child from current node
  * @param {Node} node
  */
	removeChild(node) {
		const ix = this.children.indexOf(node);
		if (ix !== -1) {
			this.children.splice(ix, 1);
			if (node.previous) {
				node.previous.next = node.next;
			}

			if (node.next) {
				node.next.previous = node.previous;
			}

			node.parent = node.next = node.previous = null;
		}
	}

	/**
  * Removes current node from its parent
  */
	remove() {
		if (this.parent) {
			this.parent.removeChild(this);
		}
	}

	/**
  * Creates a detached copy of current node
  * @param {Boolean} deep Clone node contents as well
  * @return {Node}
  */
	clone(deep) {
		const clone = new Node(this.name);
		clone.value = this.value;
		clone.selfClosing = this.selfClosing;
		if (this.repeat) {
			clone.repeat = node_es__extends({}, this.repeat);
		}

		this._attributes.forEach(attr => clone.setAttribute(attr.clone()));

		if (deep) {
			this.children.forEach(child => clone.appendChild(child.clone(true)));
		}

		return clone;
	}

	/**
  * Walks on each descendant node and invokes given `fn` function on it.
  * The function receives two arguments: the node itself and its depth level
  * from current node. If function returns `false`, it stops walking
  * @param {Function} fn
  */
	walk(fn, _level) {
		_level = _level || 0;
		let ctx = this.firstChild;

		while (ctx) {
			// in case if context node will be detached during `fn` call
			const next = ctx.next;

			if (fn(ctx, _level) === false || ctx.walk(fn, _level + 1) === false) {
				return false;
			}

			ctx = next;
		}
	}

	/**
  * A helper method for transformation chaining: runs given `fn` function on
  * current node and returns the same node
  */
	use(fn) {
		const args = [this];
		for (var i = 1; i < arguments.length; i++) {
			args.push(arguments[i]);
		}

		fn.apply(null, args);
		return this;
	}

	toString() {
		const attrs = this.attributes.map(attr => {
			attr = this.getAttribute(attr.name);
			const opt = attr.options;
			let out = `${opt && opt.implied ? '!' : ''}${attr.name || ''}`;
			if (opt && opt.boolean) {
				out += '.';
			} else if (attr.value != null) {
				out += `="${attr.value}"`;
			}
			return out;
		});

		let out = `${this.name || ''}`;
		if (attrs.length) {
			out += `[${attrs.join(' ')}]`;
		}

		if (this.value != null) {
			out += `{${this.value}}`;
		}

		if (this.selfClosing) {
			out += '/';
		}

		if (this.repeat) {
			out += `*${this.repeat.count ? this.repeat.count : ''}`;
			if (this.repeat.value != null) {
				out += `@${this.repeat.value}`;
			}
		}

		return out;
	}
};

/**
 * Attribute factory
 * @param  {String|Attribute|Object} name  Attribute name or attribute descriptor
 * @param  {*} value Attribute value
 * @return {Attribute}
 */

function createAttribute(name, value) {
	if (name instanceof Attribute) {
		return name;
	}

	if (typeof name === 'string') {
		return new Attribute(name, value);
	}

	if (name && typeof name === 'object') {
		return new Attribute(name.name, name.value, name.options);
	}
}

/**
 * @param  {String} str
 * @return {String}
 */
function normalize(str) {
	return String(str).trim();
}

function uniqueClass(item, i, arr) {
	return item && arr.indexOf(item) === i;
}

/* harmony default export */ var node_es = (Node);
// CONCATENATED MODULE: ../node_modules/@emmetio/abbreviation/dist/abbreviation.es.js




const ASTERISK = 42; // *

/**
 * Consumes node repeat token from current stream position and returns its
 * parsed value
 * @param  {StringReader} stream
 * @return {Object}
 */
function consumeRepeat(stream) {
	if (stream.eat(ASTERISK)) {
		stream.start = stream.pos;

		// XXX think about extending repeat syntax with through numbering
		return { count: stream.eatWhile(isNumber) ? +stream.current() : null };
	}
}

const opt = { throws: true };

/**
 * Consumes quoted literal from current stream position and returns it’s inner,
 * unquoted, value
 * @param  {StringReader} stream
 * @return {String} Returns `null` if unable to consume quoted value from current
 * position
 */
function consumeQuoted(stream) {
	if (eatQuoted(stream, opt)) {
		return stream.current().slice(1, -1);
	}
}

const TEXT_START = 123; // {
const TEXT_END = 125; // }
const abbreviation_es_ESCAPE = 92; // \ character

/**
 * Consumes text node `{...}` from stream
 * @param  {StreamReader} stream
 * @return {String} Returns consumed text value (without surrounding braces) or
 * `null` if there’s no text at starting position
 */
function consumeText(stream) {
	// NB using own implementation instead of `eatPair()` from @emmetio/stream-reader-utils
	// to disable quoted value consuming
	const start = stream.pos;

	if (stream.eat(TEXT_START)) {
		let stack = 1,
		    ch;
		let result = '';
		let offset = stream.pos;

		while (!stream.eof()) {
			ch = stream.next();
			if (ch === TEXT_START) {
				stack++;
			} else if (ch === TEXT_END) {
				stack--;
				if (!stack) {
					stream.start = start;
					return result + stream.substring(offset, stream.pos - 1);
				}
			} else if (ch === abbreviation_es_ESCAPE) {
				ch = stream.next();
				if (ch === TEXT_START || ch === TEXT_END) {
					result += stream.substring(offset, stream.pos - 2) + String.fromCharCode(ch);
					offset = stream.pos;
				}
			}
		}

		// If we’re here then paired character can’t be consumed
		stream.pos = start;
		throw stream.error(`Unable to find closing ${String.fromCharCode(TEXT_END)} for text start`);
	}

	return null;
}

const EXCL = 33; // .
const DOT = 46; // .
const abbreviation_es_EQUALS = 61; // =
const ATTR_OPEN = 91; // [
const ATTR_CLOSE = 93; // ]

const reAttributeName = /^\!?[\w\-:\$@]+\.?$|^\!?\[[\w\-:\$@]+\]\.?$/;

/**
 * Consumes attributes defined in square braces from given stream.
 * Example:
 * [attr col=3 title="Quoted string" selected. support={react}]
 * @param {StringReader} stream
 * @returns {Array} Array of consumed attributes
 */
function consumeAttributes(stream) {
	if (!stream.eat(ATTR_OPEN)) {
		return null;
	}

	const result = [];
	let token, attr;

	while (!stream.eof()) {
		stream.eatWhile(isWhiteSpace);

		if (stream.eat(ATTR_CLOSE)) {
			return result; // End of attribute set
		} else if ((token = consumeQuoted(stream)) != null) {
			// Consumed quoted value: anonymous attribute
			result.push({
				name: null,
				value: token
			});
		} else if (eatUnquoted(stream)) {
			// Consumed next word: could be either attribute name or unquoted default value
			token = stream.current();

			// In angular attribute names can be surrounded by []
			if (token[0] === '[' && stream.peek() === ATTR_CLOSE) {
				stream.next();
				token = stream.current();
			}

			if (!reAttributeName.test(token)) {
				// anonymous attribute
				result.push({ name: null, value: token });
			} else {
				// Looks like a regular attribute
				attr = parseAttributeName(token);
				result.push(attr);

				if (stream.eat(abbreviation_es_EQUALS)) {
					// Explicitly defined value. Could be a word, a quoted string
					// or React-like expression
					if ((token = consumeQuoted(stream)) != null) {
						attr.value = token;
					} else if ((token = consumeText(stream)) != null) {
						attr.value = token;
						attr.options = {
							before: '{',
							after: '}'
						};
					} else if (eatUnquoted(stream)) {
						attr.value = stream.current();
					}
				}
			}
		} else {
			throw stream.error('Expected attribute name');
		}
	}

	throw stream.error('Expected closing "]" brace');
}

function parseAttributeName(name) {
	const options = {};

	// If a first character in attribute name is `!` — it’s an implied
	// default attribute
	if (name.charCodeAt(0) === EXCL) {
		name = name.slice(1);
		options.implied = true;
	}

	// Check for last character: if it’s a `.`, user wants boolean attribute
	if (name.charCodeAt(name.length - 1) === DOT) {
		name = name.slice(0, name.length - 1);
		options.boolean = true;
	}

	const attr = { name };
	if (Object.keys(options).length) {
		attr.options = options;
	}

	return attr;
}

/**
 * Eats token that can be an unquoted value from given stream
 * @param  {StreamReader} stream
 * @return {Boolean}
 */
function eatUnquoted(stream) {
	const start = stream.pos;
	if (stream.eatWhile(isUnquoted)) {
		stream.start = start;
		return true;
	}
}

function isUnquoted(code) {
	return !isSpace(code) && !isQuote(code) && code !== ATTR_CLOSE && code !== abbreviation_es_EQUALS;
}

const HASH = 35; // #
const DOT$1 = 46; // .
const abbreviation_es_SLASH = 47; // /

/**
 * Consumes a single element node from current abbreviation stream
 * @param  {StringReader} stream
 * @return {Node}
 */
function consumeElement(stream) {
	// consume element name, if provided
	const start = stream.pos;
	const node = new node_es(eatName(stream));
	let next;

	while (!stream.eof()) {
		if (stream.eat(DOT$1)) {
			node.addClass(eatName(stream));
		} else if (stream.eat(HASH)) {
			node.setAttribute('id', eatName(stream));
		} else if (stream.eat(abbreviation_es_SLASH)) {
			// A self-closing indicator must be at the end of non-grouping node
			if (node.isGroup) {
				stream.backUp(1);
				throw stream.error('Unexpected self-closing indicator');
			}
			node.selfClosing = true;
			if (next = consumeRepeat(stream)) {
				node.repeat = next;
			}
			break;
		} else if (next = consumeAttributes(stream)) {
			for (let i = 0, il = next.length; i < il; i++) {
				node.setAttribute(next[i]);
			}
		} else if ((next = consumeText(stream)) !== null) {
			node.value = next;
		} else if (next = consumeRepeat(stream)) {
			node.repeat = next;
		} else {
			break;
		}
	}

	if (start === stream.pos) {
		throw stream.error(`Unable to consume abbreviation node, unexpected ${stream.peek()}`);
	}

	return node;
}

function eatName(stream) {
	stream.start = stream.pos;
	stream.eatWhile(isName);
	return stream.current();
}

function isName(code) {
	return isAlphaNumeric(code) || code === 45 /* - */
	|| code === 58 /* : */
	|| code === 36 /* $ */
	|| code === 64 /* @ */
	|| code === 33 /* ! */
	|| code === 95 /* _ */
	|| code === 37 /* % */;
}

const GROUP_START = 40; // (
const GROUP_END = 41; // )
const OP_SIBLING = 43; // +
const OP_CHILD = 62; // >
const OP_CLIMB = 94; // ^

/**
 * Parses given string into a node tree
 * @param  {String} str Abbreviation to parse
 * @return {Node}
 */
function abbreviation_es_parse(str) {
	const stream = new stream_reader_es(str.trim());
	const root = new node_es();
	let ctx = root,
	    groupStack = [],
	    ch;

	while (!stream.eof()) {
		ch = stream.peek();

		if (ch === GROUP_START) {
			// start of group
			// The grouping node should be detached to properly handle
			// out-of-bounds `^` operator. Node will be attached right on group end
			const node = new node_es();
			groupStack.push([node, ctx, stream.pos]);
			ctx = node;
			stream.next();
			continue;
		} else if (ch === GROUP_END) {
			// end of group
			const lastGroup = groupStack.pop();
			if (!lastGroup) {
				throw stream.error('Unexpected ")" group end');
			}

			const node = lastGroup[0];
			ctx = lastGroup[1];
			stream.next();

			// a group can have a repeater
			if (node.repeat = consumeRepeat(stream)) {
				ctx.appendChild(node);
			} else {
				// move all children of group into parent node
				while (node.firstChild) {
					ctx.appendChild(node.firstChild);
				}
			}
			// for convenience, groups can be joined with optional `+` operator
			stream.eat(OP_SIBLING);

			continue;
		}

		const node = consumeElement(stream);
		ctx.appendChild(node);

		if (stream.eof()) {
			break;
		}

		switch (stream.peek()) {
			case OP_SIBLING:
				stream.next();
				continue;

			case OP_CHILD:
				stream.next();
				ctx = node;
				continue;

			case OP_CLIMB:
				// it’s perfectly valid to have multiple `^` operators
				while (stream.eat(OP_CLIMB)) {
					ctx = ctx.parent || ctx;
				}
				continue;
		}
	}

	if (groupStack.length) {
		stream.pos = groupStack.pop()[2];
		throw stream.error('Expected group close');
	}

	return root;
}

/**
 * Parses given abbreviation and un-rolls it into a full tree: recursively
 * replaces repeated elements with actual nodes
 * @param  {String} abbr
 * @return {Node}
 */
function index(abbr) {
	const tree = abbreviation_es_parse(abbr);
	tree.walk(unroll);
	return tree;
}

function unroll(node) {
	if (!node.repeat || !node.repeat.count) {
		return;
	}

	const parent = node.parent;
	let ix = parent.children.indexOf(node);

	for (let i = 0; i < node.repeat.count; i++) {
		const clone = node.clone(true);
		clone.repeat.value = i + 1;
		clone.walk(unroll);

		if (clone.isGroup) {
			while (clone.children.length > 0) {
				clone.firstChild.repeat = clone.repeat;
				parent.insertAt(clone.firstChild, ix++);
			}
		} else {
			parent.insertAt(clone, ix++);
		}
	}

	node.parent.removeChild(node);
}

/* harmony default export */ var abbreviation_es = (index);
//# sourceMappingURL=abbreviation.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/html-snippets-resolver/node_modules/@emmetio/abbreviation/dist/abbreviation.es.js




const abbreviation_es_ASTERISK = 42; // *

/**
 * Consumes node repeat token from current stream position and returns its
 * parsed value
 * @param  {StringReader} stream
 * @return {Object}
 */
function abbreviation_es_consumeRepeat(stream) {
	if (stream.eat(abbreviation_es_ASTERISK)) {
		stream.start = stream.pos;

		// XXX think about extending repeat syntax with through numbering
		return { count: stream.eatWhile(isNumber) ? +stream.current() : null };
	}
}

const abbreviation_es_opt = { throws: true };

/**
 * Consumes quoted literal from current stream position and returns it’s inner,
 * unquoted, value
 * @param  {StringReader} stream
 * @return {String} Returns `null` if unable to consume quoted value from current
 * position
 */
function abbreviation_es_consumeQuoted(stream) {
	if (eatQuoted(stream, abbreviation_es_opt)) {
		return stream.current().slice(1, -1);
	}
}

const abbreviation_es_TEXT_START = 123; // {
const abbreviation_es_TEXT_END = 125; // }
const dist_abbreviation_es_ESCAPE = 92; // \ character

/**
 * Consumes text node `{...}` from stream
 * @param  {StreamReader} stream
 * @return {String} Returns consumed text value (without surrounding braces) or
 * `null` if there’s no text at starting position
 */
function abbreviation_es_consumeText(stream) {
	// NB using own implementation instead of `eatPair()` from @emmetio/stream-reader-utils
	// to disable quoted value consuming
	const start = stream.pos;

	if (stream.eat(abbreviation_es_TEXT_START)) {
		let stack = 1,
		    ch;
		let result = '';
		let offset = stream.pos;

		while (!stream.eof()) {
			ch = stream.next();
			if (ch === abbreviation_es_TEXT_START) {
				stack++;
			} else if (ch === abbreviation_es_TEXT_END) {
				stack--;
				if (!stack) {
					stream.start = start;
					return result + stream.substring(offset, stream.pos - 1);
				}
			} else if (ch === dist_abbreviation_es_ESCAPE) {
				ch = stream.next();
				if (ch === abbreviation_es_TEXT_START || ch === abbreviation_es_TEXT_END) {
					result += stream.substring(offset, stream.pos - 2) + String.fromCharCode(ch);
					offset = stream.pos;
				}
			}
		}

		// If we’re here then paired character can’t be consumed
		stream.pos = start;
		throw stream.error(`Unable to find closing ${String.fromCharCode(abbreviation_es_TEXT_END)} for text start`);
	}

	return null;
}

const abbreviation_es_EXCL = 33; // .
const abbreviation_es_DOT = 46; // .
const dist_abbreviation_es_EQUALS = 61; // =
const abbreviation_es_ATTR_OPEN = 91; // [
const abbreviation_es_ATTR_CLOSE = 93; // ]

const abbreviation_es_reAttributeName = /^\!?[\w\-:\$@]+\.?$/;

/**
 * Consumes attributes defined in square braces from given stream.
 * Example:
 * [attr col=3 title="Quoted string" selected. support={react}]
 * @param {StringReader} stream
 * @returns {Array} Array of consumed attributes
 */
function abbreviation_es_consumeAttributes(stream) {
	if (!stream.eat(abbreviation_es_ATTR_OPEN)) {
		return null;
	}

	const result = [];
	let token, attr;

	while (!stream.eof()) {
		stream.eatWhile(isWhiteSpace);

		if (stream.eat(abbreviation_es_ATTR_CLOSE)) {
			return result; // End of attribute set
		} else if ((token = abbreviation_es_consumeQuoted(stream)) != null) {
			// Consumed quoted value: anonymous attribute
			result.push({
				name: null,
				value: token
			});
		} else if (abbreviation_es_eatUnquoted(stream)) {
			// Consumed next word: could be either attribute name or unquoted default value
			token = stream.current();
			if (!abbreviation_es_reAttributeName.test(token)) {
				// anonymous attribute
				result.push({ name: null, value: token });
			} else {
				// Looks like a regular attribute
				attr = abbreviation_es_parseAttributeName(token);
				result.push(attr);

				if (stream.eat(dist_abbreviation_es_EQUALS)) {
					// Explicitly defined value. Could be a word, a quoted string
					// or React-like expression
					if ((token = abbreviation_es_consumeQuoted(stream)) != null) {
						attr.value = token;
					} else if ((token = abbreviation_es_consumeText(stream)) != null) {
						attr.value = token;
						attr.options = {
							before: '{',
							after: '}'
						};
					} else if (abbreviation_es_eatUnquoted(stream)) {
						attr.value = stream.current();
					}
				}
			}
		} else {
			throw stream.error('Expected attribute name');
		}
	}

	throw stream.error('Expected closing "]" brace');
}

function abbreviation_es_parseAttributeName(name) {
	const options = {};

	// If a first character in attribute name is `!` — it’s an implied
	// default attribute
	if (name.charCodeAt(0) === abbreviation_es_EXCL) {
		name = name.slice(1);
		options.implied = true;
	}

	// Check for last character: if it’s a `.`, user wants boolean attribute
	if (name.charCodeAt(name.length - 1) === abbreviation_es_DOT) {
		name = name.slice(0, name.length - 1);
		options.boolean = true;
	}

	const attr = { name };
	if (Object.keys(options).length) {
		attr.options = options;
	}

	return attr;
}

/**
 * Eats token that can be an unquoted value from given stream
 * @param  {StreamReader} stream
 * @return {Boolean}
 */
function abbreviation_es_eatUnquoted(stream) {
	const start = stream.pos;
	if (stream.eatWhile(abbreviation_es_isUnquoted)) {
		stream.start = start;
		return true;
	}
}

function abbreviation_es_isUnquoted(code) {
	return !isSpace(code) && !isQuote(code) && code !== abbreviation_es_ATTR_OPEN && code !== abbreviation_es_ATTR_CLOSE && code !== dist_abbreviation_es_EQUALS;
}

const abbreviation_es_HASH = 35; // #
const abbreviation_es_DOT$1 = 46; // .
const dist_abbreviation_es_SLASH = 47; // /

/**
 * Consumes a single element node from current abbreviation stream
 * @param  {StringReader} stream
 * @return {Node}
 */
function abbreviation_es_consumeElement(stream) {
	// consume element name, if provided
	const start = stream.pos;
	const node = new node_es(abbreviation_es_eatName(stream));
	let next;

	while (!stream.eof()) {
		if (stream.eat(abbreviation_es_DOT$1)) {
			node.addClass(abbreviation_es_eatName(stream));
		} else if (stream.eat(abbreviation_es_HASH)) {
			node.setAttribute('id', abbreviation_es_eatName(stream));
		} else if (stream.eat(dist_abbreviation_es_SLASH)) {
			// A self-closing indicator must be at the end of non-grouping node
			if (node.isGroup) {
				stream.backUp(1);
				throw stream.error('Unexpected self-closing indicator');
			}
			node.selfClosing = true;
			if (next = abbreviation_es_consumeRepeat(stream)) {
				node.repeat = next;
			}
			break;
		} else if (next = abbreviation_es_consumeAttributes(stream)) {
			for (let i = 0, il = next.length; i < il; i++) {
				node.setAttribute(next[i]);
			}
		} else if ((next = abbreviation_es_consumeText(stream)) !== null) {
			node.value = next;
		} else if (next = abbreviation_es_consumeRepeat(stream)) {
			node.repeat = next;
		} else {
			break;
		}
	}

	if (start === stream.pos) {
		throw stream.error(`Unable to consume abbreviation node, unexpected ${stream.peek()}`);
	}

	return node;
}

function abbreviation_es_eatName(stream) {
	stream.start = stream.pos;
	stream.eatWhile(abbreviation_es_isName);
	return stream.current();
}

function abbreviation_es_isName(code) {
	return isAlphaNumeric(code) || code === 45 /* - */
	|| code === 58 /* : */
	|| code === 36 /* $ */
	|| code === 64 /* @ */
	|| code === 33 /* ! */
	|| code === 95 /* _ */
	|| code === 37 /* % */;
}

const abbreviation_es_GROUP_START = 40; // (
const abbreviation_es_GROUP_END = 41; // )
const abbreviation_es_OP_SIBLING = 43; // +
const abbreviation_es_OP_CHILD = 62; // >
const abbreviation_es_OP_CLIMB = 94; // ^

/**
 * Parses given string into a node tree
 * @param  {String} str Abbreviation to parse
 * @return {Node}
 */
function dist_abbreviation_es_parse(str) {
	const stream = new stream_reader_es(str.trim());
	const root = new node_es();
	let ctx = root,
	    groupStack = [],
	    ch;

	while (!stream.eof()) {
		ch = stream.peek();

		if (ch === abbreviation_es_GROUP_START) {
			// start of group
			// The grouping node should be detached to properly handle
			// out-of-bounds `^` operator. Node will be attached right on group end
			const node = new node_es();
			groupStack.push([node, ctx, stream.pos]);
			ctx = node;
			stream.next();
			continue;
		} else if (ch === abbreviation_es_GROUP_END) {
			// end of group
			const lastGroup = groupStack.pop();
			if (!lastGroup) {
				throw stream.error('Unexpected ")" group end');
			}

			const node = lastGroup[0];
			ctx = lastGroup[1];
			stream.next();

			// a group can have a repeater
			if (node.repeat = abbreviation_es_consumeRepeat(stream)) {
				ctx.appendChild(node);
			} else {
				// move all children of group into parent node
				while (node.firstChild) {
					ctx.appendChild(node.firstChild);
				}
			}
			// for convenience, groups can be joined with optional `+` operator
			stream.eat(abbreviation_es_OP_SIBLING);

			continue;
		}

		const node = abbreviation_es_consumeElement(stream);
		ctx.appendChild(node);

		if (stream.eof()) {
			break;
		}

		switch (stream.peek()) {
			case abbreviation_es_OP_SIBLING:
				stream.next();
				continue;

			case abbreviation_es_OP_CHILD:
				stream.next();
				ctx = node;
				continue;

			case abbreviation_es_OP_CLIMB:
				// it’s perfectly valid to have multiple `^` operators
				while (stream.eat(abbreviation_es_OP_CLIMB)) {
					ctx = ctx.parent || ctx;
				}
				continue;
		}
	}

	if (groupStack.length) {
		stream.pos = groupStack.pop()[2];
		throw stream.error('Expected group close');
	}

	return root;
}

/**
 * Parses given abbreviation and un-rolls it into a full tree: recursively
 * replaces repeated elements with actual nodes
 * @param  {String} abbr
 * @return {Node}
 */
function abbreviation_es_index(abbr) {
	const tree = dist_abbreviation_es_parse(abbr);
	tree.walk(abbreviation_es_unroll);
	return tree;
}

function abbreviation_es_unroll(node) {
	if (!node.repeat || !node.repeat.count) {
		return;
	}

	const parent = node.parent;
	let ix = parent.children.indexOf(node);

	for (let i = 0; i < node.repeat.count; i++) {
		const clone = node.clone(true);
		clone.repeat.value = i + 1;
		clone.walk(abbreviation_es_unroll);

		if (clone.isGroup) {
			while (clone.children.length > 0) {
				clone.firstChild.repeat = clone.repeat;
				parent.insertAt(clone.firstChild, ix++);
			}
		} else {
			parent.insertAt(clone, ix++);
		}
	}

	node.parent.removeChild(node);
}

/* harmony default export */ var dist_abbreviation_es = (abbreviation_es_index);
//# sourceMappingURL=abbreviation.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/html-snippets-resolver/dist/html-snippets-resolver.es.js
var html_snippets_resolver_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/**
 * For every node in given `tree`, finds matching snippet from `registry` and
 * resolves it into a parsed abbreviation. Resolved node is then updated or
 * replaced with matched abbreviation tree.
 *
 * A HTML registry basically contains aliases to another Emmet abbreviations,
 * e.g. a predefined set of name, attribues and so on, possibly a complex
 * abbreviation with multiple elements. So we have to get snippet, parse it
 * and recursively resolve it.
 *
 * @param  {Node} tree                 Parsed Emmet abbreviation
 * @param  {SnippetsRegistry} registry Registry with all available snippets
 * @return {Node} Updated tree
 */

var html_snippets_resolver_es_index = function (tree, registry) {
    tree.walk(node => resolveNode(node, registry));
    return tree;
};

function resolveNode(node, registry) {
    const stack = new Set();
    const resolve = node => {
        const snippet = registry.resolve(node.name);
        // A snippet in stack means circular reference.
        // It can be either a user error or a perfectly valid snippet like
        // "img": "img[src alt]/", e.g. an element with predefined shape.
        // In any case, simply stop parsing and keep element as is
        if (!snippet || stack.has(snippet)) {
            return;
        }

        // In case if matched snippet is a function, pass control into it
        if (typeof snippet.value === 'function') {
            return snippet.value(node, registry, resolve);
        }

        const tree = dist_abbreviation_es(snippet.value);

        stack.add(snippet);
        tree.walk(resolve);
        stack.delete(snippet);

        // move current node contents into new tree
        const childTarget = findDeepestNode(tree);
        merge(childTarget, node);

        while (tree.firstChild) {
            node.parent.insertBefore(tree.firstChild, node);
        }

        childTarget.parent.insertBefore(node, childTarget);
        childTarget.remove();
    };

    resolve(node);
}

/**
 * Adds data from first node into second node and returns it
 * @param  {Node} from
 * @param  {Node} to
 * @return {Node}
 */
function merge(from, to) {
    to.name = from.name;

    if (from.selfClosing) {
        to.selfClosing = true;
    }

    if (from.value != null) {
        to.value = from.value;
    }

    if (from.repeat) {
        to.repeat = html_snippets_resolver_es__extends({}, from.repeat);
    }

    return mergeAttributes(from, to);
}

/**
 * Transfer attributes from first element to second one and preserve first
 * element’s attributes order
 * @param  {Node} from
 * @param  {Node} to
 * @return {Node}
 */
function mergeAttributes(from, to) {
    mergeClassNames(from, to);

    // It’s important to preserve attributes order: ones in `from` have higher
    // pripority than in `to`. Collect attributes in map in order they should
    // appear in `to`
    const attrMap = new Map();

    let attrs = from.attributes;
    for (let i = 0; i < attrs.length; i++) {
        attrMap.set(attrs[i].name, attrs[i].clone());
    }

    attrs = to.attributes.slice();
    for (let i = 0, attr, a; i < attrs.length; i++) {
        attr = attrs[i];
        if (attrMap.has(attr.name)) {
            a = attrMap.get(attr.name);
            a.value = attr.value;

            // If user explicitly wrote attribute in abbreviation, it’s no longer
            // implied and should be outputted even if value is empty
            if (a.options.implied) {
                a.options.implied = false;
            }
        } else {
            attrMap.set(attr.name, attr);
        }

        to.removeAttribute(attr);
    }

    const newAttrs = Array.from(attrMap.values());
    for (let i = 0; i < newAttrs.length; i++) {
        to.setAttribute(newAttrs[i]);
    }

    return to;
}

/**
 * Adds class names from first node to second one
 * @param  {Node} from
 * @param  {Node} to
 * @return {Node}
 */
function mergeClassNames(from, to) {
    const classNames = from.classList;
    for (let i = 0; i < classNames.length; i++) {
        to.addClass(classNames[i]);
    }

    return to;
}

/**
 * Finds node which is the deepest for in current node or node iteself.
 * @param  {Node} node
 * @return {Node}
 */
function findDeepestNode(node) {
    while (node.children.length) {
        node = node.children[node.children.length - 1];
    }

    return node;
}

/* harmony default export */ var html_snippets_resolver_es = (html_snippets_resolver_es_index);
// CONCATENATED MODULE: ../node_modules/@emmetio/implicit-tag/dist/implicit-tag.es.js
const inlineElements = new Set('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(','));
const elementMap = {
    p: 'span',
    ul: 'li',
    ol: 'li',
    table: 'tr',
    tr: 'td',
    tbody: 'tr',
    thead: 'tr',
    tfoot: 'tr',
    colgroup: 'col',
    select: 'option',
    optgroup: 'option',
    audio: 'source',
    video: 'source',
    object: 'param',
    map: 'area'
};

/**
 * Returns best child node name for given parent node name
 * @param  {String} parentName Name of parent node
 * @return {String}
 */
function resolveImplicitName(parentName) {
    parentName = (parentName || '').toLowerCase();
    return elementMap[parentName] || (inlineElements.has(parentName) ? 'span' : 'div');
}

/* harmony default export */ var implicit_tag_es = (resolveImplicitName);
// CONCATENATED MODULE: ../node_modules/@emmetio/html-transform/dist/html-transform.es.js
var html_transform_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/**
 * Adds missing tag names for given tree depending on node’s parent name
 */
var implicitTags = function (tree) {
  tree.walk(node => {
    // resolve only nameless nodes without content
    if (node.name == null && node.attributes.length) {
      node.name = implicit_tag_es(node.parent.name);
    }
  });
  return tree;
};

/**
 * Locates all occurances of given `token` which are not escaped (e.g. are not
 * preceded with `\`) given in `str`
 * @param  {String} str
 * @return {Array}  Array of token ranges
 */
function findUnescapedTokens(str, token) {
  const result = new Set();
  const tlen = token.length;

  // 1. Find all occurances of tokens
  let pos = 0;
  while ((pos = str.indexOf(token, pos)) !== -1) {
    result.add(pos);
    pos += tlen;
  }

  if (result.size) {
    // 2. Remove ones that escaped
    let pos = 0;
    const len = str.length;

    while (pos < len) {
      if (str[pos++] === '\\') {
        result.delete(pos++);
      }
    }
  }

  return Array.from(result).map(ix => html_transform_es_range(ix, tlen));
}

/**
 * Replaces `ranges`, generated by `range()` function, with given `value` in `str`
 * @param  {String} str    Where to replace ranges
 * @param  {Array} ranges Ranes, created by `range()` function
 * @param  {String|Function} value  Replacement value. If it’s a function, it
 * will take a range value as argument and should return a new string
 * @return {String}
 */
function replaceRanges(str, ranges, value) {
  // should walk from the end of array to keep ranges valid after replacement
  for (let i = ranges.length - 1; i >= 0; i--) {
    const r = ranges[i];

    let offset = 0;
    let offsetLength = 0;
    let descendingOrder = false;

    if (str.substr(r[0] + r[1], 1) === '@') {
      if (str.substr(r[0] + r[1] + 1, 1) === '-') {
        descendingOrder = true;
      }
      const matches = str.substr(r[0] + r[1] + 1 + Number(descendingOrder)).match(/^(\d+)/);
      if (matches) {
        offsetLength = matches[1].length + 1 + Number(descendingOrder);
        offset = parseInt(matches[1]) - 1;
      } else {
        offsetLength = 2;
      }
    }

    str = str.substring(0, r[0]) + (typeof value === 'function' ? value(str.substr(r[0], r[1]), offset, descendingOrder) : value) + str.substring(r[0] + r[1] + offsetLength);
  }

  return str;
}

function html_transform_es_range(start, length) {
  return [start, length];
}

const numberingToken = '$';

/**
 * Numbering of expanded abbreviation: finds all nodes with `$` in value
 * or attributes and replaces its occurances with repeater value
 */
var applyNumbering = function (tree) {
  tree.walk(applyNumbering$1);
  return tree;
};

/**
 * Applies numbering for given node: replaces occurances of numbering token
 * in node’s name, content and attributes
 * @param  {Node} node
 * @return {Node}
 */
function applyNumbering$1(node) {
  const repeater = findRepeater(node);

  if (repeater && repeater.value != null) {
    // NB replace numbering in nodes with explicit repeater only:
    // it solves issues with abbreviations like `xsl:if[test=$foo]` where
    // `$foo` is preferred output
    const value = repeater.value;
    const count = repeater.count;

    node.name = replaceNumbering(node.name, value, count);
    node.value = replaceNumbering(node.value, value, count);
    node.attributes.forEach(attr => {
      const copy = node.getAttribute(attr.name).clone();
      copy.name = replaceNumbering(attr.name, value, count);
      copy.value = replaceNumbering(attr.value, value, count);
      node.replaceAttribute(attr.name, copy);
    });
  }

  return node;
}

/**
 * Returns repeater object for given node
 * @param  {Node} node
 * @return {Object}
 */
function findRepeater(node) {
  while (node) {
    if (node.repeat) {
      return node.repeat;
    }

    node = node.parent;
  }
}

/**
 * Replaces numbering in given string
 * @param  {String} str
 * @param  {Number} value
 * @return {String}
 */
function replaceNumbering(str, value, count) {
  // replace numbering in strings only: skip explicit wrappers that could
  // contain unescaped numbering tokens
  if (typeof str === 'string') {
    const ranges = getNumberingRanges(str);
    return replaceNumberingRanges(str, ranges, value, count);
  }

  return str;
}

/**
 * Returns numbering ranges, e.g. ranges of `$` occurances, in given string.
 * Multiple adjacent ranges are combined
 * @param  {String} str
 * @return {Array}
 */
function getNumberingRanges(str) {
  return findUnescapedTokens(str || '', numberingToken).reduce((out, range$$1) => {
    // skip ranges that actually belongs to output placeholder or tabstops
    if (!/[#{]/.test(str[range$$1[0] + 1] || '')) {
      const lastRange = out[out.length - 1];
      if (lastRange && lastRange[0] + lastRange[1] === range$$1[0]) {
        lastRange[1] += range$$1[1];
      } else {
        out.push(range$$1);
      }
    }

    return out;
  }, []);
}

/**
 * @param  {String} str
 * @param  {Array} ranges
 * @param  {Number} value
 * @return {String}
 */
function replaceNumberingRanges(str, ranges, value, count) {
  const replaced = replaceRanges(str, ranges, (token, offset, descendingOrder) => {
    let _value = descendingOrder ? String(offset + count - value + 1) : String(value + offset);
    // pad values for multiple numbering tokens, e.g. 3 for $$$ becomes 003
    while (_value.length < token.length) {
      _value = '0' + _value;
    }
    return _value;
  });

  // unescape screened numbering tokens
  return unescapeString(replaced);
}

/**
 * Unescapes characters, screened with `\`, in given string
 * @param  {String} str
 * @return {String}
 */
function unescapeString(str) {
  let i = 0,
      result = '';
  const len = str.length;

  while (i < len) {
    const ch = str[i++];
    result += ch === '\\' ? str[i++] || '' : ch;
  }

  return result;
}

/** Placeholder for inserted content */
const placeholder = '$#';

/** Placeholder for caret */
const caret = '|';

const reUrl = /^((?:https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
const reEmail = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/;
const reProto = /^([a-z]+:)?\/\//i;

/**
 * Inserts content into node with implicit repeat count: this node is then
 * duplicated for each content item and content itself is inserted either into
 * deepest child or instead of a special token.
 *
 * This method uses two distinct steps: `prepare()` and `insert()` since most
 * likely these steps will be used separately to properly insert content
 * with unescaped `$` numbering markers.
 *
 * @param {Node} tree Parsed abbreviation
 * @param {String[]} content Array of content items to insert
 * @return {Node}
 */
/**
 * Finds nodes with implicit repeat and creates `amount` copies of it in tree
 * @param  {Node} tree
 * @param  {Number} amount
 * @return {Node}
 */
function prepare(tree, amount) {
  amount = amount || 1;
  tree.walk(node => {
    if (node.repeat && node.repeat.count === null) {
      for (let i = 0; i < amount; i++) {
        const clone = node.clone(true);
        clone.repeat.implicit = true;
        clone.repeat.count = amount;
        clone.repeat.value = i + 1;
        clone.repeat.index = i;
        node.parent.insertBefore(clone, node);
      }

      node.remove();
    }
  });

  return tree;
}

/**
 * Inserts content into implicitly repeated nodes, created by `prepare()` method
 * @param  {Node} tree
 * @param  {String[]} content
 * @return {Node}
 */
function insert(tree, content) {
  if (Array.isArray(content) && content.length) {
    let updated = false;
    tree.walk(node => {
      if (node.repeat && node.repeat.implicit) {
        updated = true;
        insertContent(node, content[node.repeat.index]);
      }
    });

    if (!updated) {
      // no node with implicit repeat was found, insert content as
      // deepest child
      setNodeContent(html_transform_es_findDeepestNode(tree), content.join('\n'));
    }
  }

  return tree;
}

/**
 * Inserts `content` into given `node`: either replaces output placeholders
 * or inserts it into deepest child node
 * @param  {Node} node
 * @param  {String} content
 * @return {Node}
 */
function insertContent(node, content) {
  let inserted = insertContentIntoPlaceholder(node, content);
  node.walk(child => inserted |= insertContentIntoPlaceholder(child, content));

  if (!inserted) {
    // no placeholders were found in node, insert content into deepest child
    setNodeContent(html_transform_es_findDeepestNode(node), content);
  }

  return node;
}

/**
 * Inserts given `content` into placeholders for given `node`. Placeholders
 * might be available in attribute values and node content
 * @param  {Node} node
 * @param  {String} content
 * @return {Boolean} Returns `true` if placeholders were found and replaced in node
 */
function insertContentIntoPlaceholder(node, content) {
  const state = { replaced: false };

  node.value = replacePlaceholder(node.value, content, state);
  node.attributes.forEach(attr => {
    if (attr.value) {
      node.setAttribute(attr.name, replacePlaceholder(attr.value, content, state));
    }
  });

  return state.replaced;
}

/**
 * Replaces all placeholder occurances in given `str` with `value`
 * @param  {String} str
 * @param  {String} value
 * @param  {Object} [_state] If provided, set `replaced` property of given
 * object to `true` if placeholder was found and replaced
 * @return {String}
 */
function replacePlaceholder(str, value, _state) {
  if (typeof str === 'string') {
    const ranges = findUnescapedTokens(str, placeholder);
    if (ranges.length) {
      if (_state) {
        _state.replaced = true;
      }

      str = replaceRanges(str, ranges, value);
    }
  }

  return str;
}

/**
 * Finds node which is the deepest for in current node or node iteself.
 * @param  {Node} node
 * @return {Node}
 */
function html_transform_es_findDeepestNode(node) {
  while (node.children.length) {
    node = node.children[node.children.length - 1];
  }

  return node;
}

/**
 * Updates content of given node
 * @param {Node} node
 * @param {String} content
 */
function setNodeContent(node, content) {
  // find caret position and replace it with content, if possible
  if (node.value) {
    const ranges = findUnescapedTokens(node.value, caret);
    if (ranges.length) {
      node.value = replaceRanges(node.value, ranges, content);
      return;
    }
  }

  if (node.name.toLowerCase() === 'a' || node.hasAttribute('href')) {
    // special case: inserting content into `<a>` tag
    if (reUrl.test(content)) {
      node.setAttribute('href', (reProto.test(content) ? '' : 'http://') + content);
    } else if (reEmail.test(content)) {
      node.setAttribute('href', 'mailto:' + content);
    }
  }

  node.value = content;
}

const html_transform_es_defaultOptions = {
  element: '__',
  modifier: '_'
};

const reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;
const reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;
const blockCandidates1 = className => /^[a-z]\-/i.test(className);
const blockCandidates2 = className => /^[a-z]/i.test(className);

/**
 * BEM transformer: updates class names written as `-element` and
 * `_modifier` into full class names as described in BEM specs. Also adds missing
 * class names: fir example, if node contains `.block_modifier` class, ensures
 * that element contains `.block` class as well
 */
var bem = function (tree, options) {
  options = html_transform_es__extends({}, html_transform_es_defaultOptions, options);

  tree.walk(node => expandClassNames(node, options));

  const lookup = createBlockLookup(tree);
  tree.walk(node => expandShortNotation(node, lookup, options));

  return tree;
};

/**
 * Expands existing class names in BEM notation in given `node`.
 * For example, if node contains `b__el_mod` class name, this method ensures
 * that element contains `b__el` class as well
 * @param  {Node} node
 * @param  {Object} options
 * @return {Set}
 */
function expandClassNames(node, options) {
  const classNames = node.classList.reduce((out, cl) => {
    // remove all modifiers and element prefixes from class name to get a base element name
    const ix = cl.indexOf('_');
    if (ix > 0 && !cl.startsWith('-')) {
      out.add(cl.slice(0, ix));
      out.add(cl.slice(ix));
      return out;
    }

    return out.add(cl);
  }, new Set());

  if (classNames.size) {
    node.setAttribute('class', Array.from(classNames).join(' '));
  }
}

/**
 * Expands short BEM notation, e.g. `-element` and `_modifier`
 * @param  {Node} node      Parsed Emmet abbreviation node
 * @param  {Map} lookup     BEM block name lookup
 * @param  {Object} options
 */
function expandShortNotation(node, lookup, options) {
  const classNames = node.classList.reduce((out, cl) => {
    let prefix, m;
    const originalClass = cl;

    // parse element definition (could be only one)
    if (m = cl.match(reElement)) {
      prefix = getBlockName(node, lookup, m[1]) + options.element + m[2];
      out.add(prefix);
      cl = cl.slice(m[0].length);
    }

    // parse modifiers definitions 
    if (m = cl.match(reModifier)) {
      if (!prefix) {
        prefix = getBlockName(node, lookup, m[1]);
        out.add(prefix);
      }

      out.add(`${prefix}${options.modifier}${m[2]}`);
      cl = cl.slice(m[0].length);
    }

    if (cl === originalClass) {
      // class name wasn’t modified: it’s not a BEM-specific class,
      // add it as-is into output
      out.add(originalClass);
    }

    return out;
  }, new Set());

  const arrClassNames = Array.from(classNames).filter(Boolean);
  if (arrClassNames.length) {
    node.setAttribute('class', arrClassNames.join(' '));
  }
}

/**
 * Creates block name lookup for each node in given tree, e.g. finds block
 * name explicitly for each node
 * @param  {Node} tree
 * @return {Map}
 */
function createBlockLookup(tree) {
  const lookup = new Map();

  tree.walk(node => {
    const classNames = node.classList;
    if (classNames.length) {
      // guess best block name from class or use parent’s block name
      lookup.set(node, find(classNames, blockCandidates1) || find(classNames, blockCandidates2) || lookup.get(node.parent));
    }
  });

  return lookup;
}

/**
 * Returns block name for given `node` by `prefix`, which tells the depth of
 * of parent node lookup
 * @param  {Node} node
 * @param  {Map} lookup
 * @param  {String} prefix
 * @return {String}
 */
function getBlockName(node, lookup, prefix) {
  let depth = prefix.length > 1 ? prefix.length : 0;

  // NB don’t walk up to root node, stay at first root child in case of
  // too deep prefix
  while (node.parent && node.parent.parent && depth--) {
    node = node.parent;
  }

  return lookup.get(node) || '';
}

function find(arr, filter) {
  for (let i = 0; i < arr.length; i++) {
    if (reElement.test(arr[i]) || reModifier.test(arr[i])) {
      break;
    }
    if (filter(arr[i])) {
      return arr[i];
    }
  }
}

/**
 * JSX transformer: replaces `class` and `for` attributes with `className` and
 * `htmlFor` attributes respectively
 */
var jsx = function (tree) {
  tree.walk(node => {
    replace(node, 'class', 'className');
    replace(node, 'for', 'htmlFor');
  });
  return tree;
};

function replace(node, oldName, newName) {
  let attr = node.getAttribute(oldName);
  if (attr) {
    attr.name = newName;
  }
}

const reSupporterNames = /^xsl:(variable|with\-param)$/i;

/**
 * XSL transformer: removes `select` attributes from certain nodes that contain
 * children
 */
var xsl = function (tree) {
  tree.walk(node => {
    if (reSupporterNames.test(node.name || '') && (node.children.length || node.value)) {
      node.removeAttribute('select');
    }
  });
  return tree;
};

const supportedAddons = { bem, jsx, xsl };

/**
 * Runs additional transforms on given tree.
 * These transforms may introduce side-effects and unexpected result
 * so they are not applied by default, authors must specify which addons
 * in `addons` argument as `{addonName: addonOptions}`
 * @param {Node} tree Parsed Emmet abbreviation
 * @param {Object} addons Add-ons to apply and their options
 */
var addons = function (tree, addons) {
  Object.keys(addons || {}).forEach(key => {
    if (key in supportedAddons) {
      const addonOpt = typeof addons[key] === 'object' ? addons[key] : null;
      tree = tree.use(supportedAddons[key], addonOpt);
    }
  });

  return tree;
};

/**
 * Applies basic HTML-specific transformations for given parsed abbreviation:
 * – resolve implied tag names
 * – insert repeated content
 * – resolve node numbering
 */
var html_transform_es_index = function (tree, content, appliedAddons) {
  if (typeof content === 'string') {
    content = [content];
  } else if (content && typeof content === 'object' && !Array.isArray(content)) {
    appliedAddons = content;
    content = null;
  }

  return tree.use(implicitTags).use(prepare, Array.isArray(content) ? content.length : null).use(applyNumbering).use(insert, content).use(addons, appliedAddons);
};

/* harmony default export */ var html_transform_es = (html_transform_es_index);
// CONCATENATED MODULE: ../node_modules/@emmetio/variable-resolver/dist/variable-resolver.es.js
/**
 * Replaces all unescaped ${variable} occurances in given parsed abbreviation
 * `tree` with values provided in `variables` hash. Precede `$` with `\` to
 * escape it and skip replacement
 * @param {Node} tree Parsed abbreviation tree
 * @param {Object} variables Variables values
 * @return {Node}
 */
function replaceVariables(tree, variables) {
    variables = variables || {};
    tree.walk(node => replaceInNode(node, variables));
    return tree;
}

function replaceInNode(node, variables) {
    // Replace variables in attributes.
    const attrs = node.attributes;

    for (let i = 0, il = attrs.length; i < il; i++) {
        const attr = attrs[i];
        if (typeof attr.value === 'string') {
            node.setAttribute(attr.name, replaceInString(attr.value, variables));
        }
    }

    if (node.value != null) {
        node.value = replaceInString(node.value, variables);
    }

    return node;
}

/**
 * Replaces all unescaped `${variable}` occurances in given string with values
 * from `variables` object
 * @param  {String} string
 * @param  {Object} variables
 * @return {String}
 */
function replaceInString(string, variables) {
    const model = createModel(string);
    let offset = 0;
    let output = '';

    for (let i = 0, il = model.variables.length; i < il; i++) {
        const v = model.variables[i];
        let value = v.name in variables ? variables[v.name] : v.name;
        if (typeof value === 'function') {
            value = value(model.string, v, offset + v.location);
        }

        output += model.string.slice(offset, v.location) + value;
        offset = v.location + v.length;
    }

    return output + model.string.slice(offset);
}

/**
 * Creates variable model from given string. The model contains a `string` with
 * all escaped variable tokens written without escape symbol and `variables`
 * property with all unescaped variables and their ranges
 * @param  {String} string
 * @return {Object}
 */
function createModel(string) {
    const reVariable = /\$\{([a-z][\w\-]*)\}/ig;
    const escapeCharCode = 92; // `\` symbol
    const variables = [];

    // We have to replace unescaped (e.g. not preceded with `\`) tokens.
    // Instead of writing a stream parser, we’ll cut some edges here:
    // 1. Find all tokens
    // 2. Walk string char-by-char and resolve only tokens that are not escaped
    const tokens = new Map();
    let m;
    while (m = reVariable.exec(string)) {
        tokens.set(m.index, m);
    }

    if (tokens.size) {
        let start = 0,
            pos = 0,
            len = string.length;
        let output = '';
        while (pos < len) {
            if (string.charCodeAt(pos) === escapeCharCode && tokens.has(pos + 1)) {
                // Found escape symbol that escapes variable: we should
                // omit this symbol in output string and skip variable
                const token = tokens.get(pos + 1);
                output += string.slice(start, pos) + token[0];
                start = pos = token.index + token[0].length;
                tokens.delete(pos + 1);
                continue;
            }

            pos++;
        }

        string = output + string.slice(start);

        // Not using `.map()` here to reduce memory allocations
        const validMatches = Array.from(tokens.values());
        for (let i = 0, il = validMatches.length; i < il; i++) {
            const token = validMatches[i];
            variables.push({
                name: token[1],
                location: token.index,
                length: token[0].length
            });
        }
    }

    return { string, variables };
}

/* harmony default export */ var variable_resolver_es = (replaceVariables);
// CONCATENATED MODULE: ../node_modules/@emmetio/output-renderer/dist/output-renderer.es.js
var output_renderer_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



const defaultFieldsRenderer = text => text;

/**
 * Output node is an object containing generated output for given Emmet
 * abbreviation node. Output node can be passed to various processors that
 * may shape-up final node output. The final output is simply a concatenation
 * of `.open`, `.text` and `.close` properties and its `.before*` and `.after*`
 * satellites
 * @param {Node}     node           Parsed Emmet abbreviation node
 * @param {Function} fieldsRenderer A function for rendering fielded text (text with
 * tabstops) for current node. @see ./render.js for details
 */
let OutputNode = class OutputNode {
	constructor(node, fieldsRenderer, options) {
		if (typeof fieldsRenderer === 'object') {
			options = fieldsRenderer;
			fieldsRenderer = null;
		}

		this.node = node;
		this._fieldsRenderer = fieldsRenderer || defaultFieldsRenderer;

		this.open = null;
		this.beforeOpen = '';
		this.afterOpen = '';

		this.close = null;
		this.beforeClose = '';
		this.afterClose = '';

		this.text = null;
		this.beforeText = '';
		this.afterText = '';

		this.indent = '';
		this.newline = '';

		if (options) {
			output_renderer_es__extends(this, options);
		}
	}

	clone() {
		return new this.constructor(this.node, this);
	}

	/**
  * Properly indents given multiline text
  * @param {String} text
  */
	indentText(text) {
		const lines = splitByLines(text);
		if (lines.length === 1) {
			// no newlines, nothing to indent
			return text;
		}

		// No newline and no indent means no formatting at all:
		// in this case we should replace newlines with spaces
		const nl = !this.newline && !this.indent ? ' ' : this.newline;
		return lines.map((line, i) => i ? this.indent + line : line).join(nl);
	}

	/**
  * Renders given text with fields
  * @param {String} text
  * @return {String}
  */
	renderFields(text) {
		return this._fieldsRenderer(text);
	}

	toString(children) {
		const open = this._wrap(this.open, this.beforeOpen, this.afterOpen);
		const close = this._wrap(this.close, this.beforeClose, this.afterClose);
		const text = this._wrap(this.text, this.beforeText, this.afterText);

		return open + text + (children != null ? children : '') + close;
	}

	_wrap(str, before, after) {
		before = before != null ? before : '';
		after = after != null ? after : '';

		// automatically trim whitespace for non-empty wraps
		if (str != null) {
			str = before ? str.replace(/^\s+/, '') : str;
			str = after ? str.replace(/\s+$/, '') : str;
			return before + this.indentText(str) + after;
		}

		return '';
	}
};

/**
 * Splits given text by lines
 * @param  {String} text
 * @return {String[]}
 */

function splitByLines(text) {
	return (text || '').split(/\r\n|\r|\n/g);
}

/**
 * Default output of field (tabstop)
 * @param  {Number} index       Field index
 * @param  {String} placeholder Field placeholder, can be null
 * @return {String}
 */
const defaultField = (index, placeholder) => placeholder || '';

/**
 * Renders given parsed abbreviation `tree` via `formatter` function.

 * @param {Node}     tree      Parsed Emmet abbreviation
 * @param {Function} [field]   Optional function to format field/tabstop (@see `defaultField`)
 * @param {Function} formatter Output formatter function. It takes an output node—
 * a special wrapper for parsed node that holds formatting and output properties—
 * and updates its output properties to shape-up node’s output.
 * Function arguments:
 * 	– `outNode`: OutputNode
 * 	– `renderFields`: a helper function that parses fields/tabstops from given
 * 	   text and replaces them with `field` function output.
 * 	   It also takes care about field indicies and ensures that the same indicies
 * 	   from different nodes won’t collide
 */
function render(tree, field, formatter) {
	if (typeof formatter === 'undefined') {
		formatter = field;
		field = null;
	}

	field = field || defaultField;

	// Each node may contain fields like `${1:placeholder}`.
	// Since most modern editors will link all fields with the same
	// index, we have to ensure that different nodes has their own indicies.
	// We’ll use this `fieldState` object to globally increment field indices
	// during output
	const fieldState = { index: 1 };

	const fieldsRenderer = text => text == null ? field(fieldState.index++) : getFieldsModel(text, fieldState).mark(field);

	return run(tree.children, formatter, fieldsRenderer);
}

function run(nodes, formatter, fieldsRenderer) {
	return nodes.map(node => {
		const outNode = formatter(new OutputNode(node, fieldsRenderer));
		return outNode ? outNode.toString(run(node.children, formatter, fieldsRenderer)) : '';
	}).join('');
}

/**
 * Returns fields (tab-stops) model with properly updated indices that won’t
 * collide with fields in other nodes of foprmatted tree
 * @param  {String|Object} text Text to get fields model from or model itself
 * @param  {Object} fieldState Abbreviation tree-wide field state reference
 * @return {Object} Field model
 */
function getFieldsModel(text, fieldState) {
	const model = typeof text === 'object' ? text : field_parser_es(text);
	let largestIndex = -1;

	model.fields.forEach(field => {
		field.index += fieldState.index;
		if (field.index > largestIndex) {
			largestIndex = field.index;
		}
	});

	if (largestIndex !== -1) {
		fieldState.index = largestIndex + 1;
	}

	return model;
}

/* harmony default export */ var output_renderer_es = (render);
// CONCATENATED MODULE: ../node_modules/@emmetio/markup-formatters/dist/markup-formatters.es.js
var markup_formatters_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




const TOKEN = /^(.*?)([A-Z_]+)(.*?)$/;
const TOKEN_OPEN = 91; // [
const TOKEN_CLOSE = 93; // ]

/**
 * A basic templating engine.
 * Takes every `[TOKEN]` from given string and replaces it with
 * `TOKEN` value from given `data` attribute. The token itself may contain
 * various characters between `[`, token name and `]`. Contents of `[...]` will
 * be outputted only if `TOKEN` value is not empty. Also, only `TOKEN` name will
 * be replaced with actual value, all other characters will remain as is.
 *
 * Example:
 * ```
 * template('[<NAME>]', {NAME: 'foo'}) -> "<foo>"
 * template('[<NAME>]', {}) -> ""
 * ```
 */
function template(str, data) {
	if (str == null) {
		return str;
	}

	// NB since token may contain inner `[` and `]`, we can’t just use regexp
	// for replacement, should manually parse string instead
	const stack = [];
	const replacer = (str, left, token, right) => data[token] != null ? left + data[token] + right : '';

	let output = '';
	let offset = 0,
	    i = 0;
	let code, lastPos;

	while (i < str.length) {
		code = str.charCodeAt(i);
		if (code === TOKEN_OPEN) {
			stack.push(i);
		} else if (code === TOKEN_CLOSE) {
			lastPos = stack.pop();
			if (!stack.length) {
				output += str.slice(offset, lastPos) + str.slice(lastPos + 1, i).replace(TOKEN, replacer);
				offset = i + 1;
			}
		}

		i++;
	}

	return output + str.slice(offset);
}

/**
 * Various utility methods used by formatters
 */

/**
 * Splits given text by lines
 * @param  {String} text
 * @return {String[]}
 */
function markup_formatters_es_splitByLines(text) {
	return (text || '').split(/\r\n|\r|\n/g);
}

/**
 * Check if given node is a first child in its parent
 * @param  {Node}  node
 * @return {Boolean}
 */
function isFirstChild(node) {
	return node.parent.firstChild === node;
}

/**
 * Check if given node is a root node
 * @param  {Node}  node
 * @return {Boolean}
 */
function isRoot(node) {
	return node && !node.parent;
}

/**
 * Check if given node is a pseudo-snippet: a text-only node with explicitly
 * defined children
 * @param  {Node}  node
 * @return {Boolean}
 */
function isPseudoSnippet(node) {
	return node.isTextOnly && !!node.children.length;
}

/**
 * Handles pseudo-snippet node.
 * A pseudo-snippet is a text-only node with explicitly defined children.
 * For such case, we have to figure out if pseudo-snippet contains fields
 * (tab-stops) in node value and “split” it: make contents before field with
 * lowest index node’s “open” part and contents after lowest index — “close”
 * part. With this trick a final output will look like node’s children
 * are nested inside node value
 * @param  {OutputNode} outNode
 * @return {Boolean} Returns “true” if given node is a pseudo-snippets,
 * `false` otherwise
 */
function handlePseudoSnippet(outNode) {
	const node = outNode.node; // original abbreviaiton node

	if (isPseudoSnippet(node)) {
		const fieldsModel = field_parser_es(node.value);
		const field = findLowestIndexField(fieldsModel);
		if (field) {
			const parts = splitFieldsModel(fieldsModel, field);
			outNode.open = outNode.renderFields(parts[0]);
			outNode.close = outNode.renderFields(parts[1]);
		} else {
			outNode.text = outNode.renderFields(fieldsModel);
		}

		return true;
	}

	return false;
}

/**
 * Finds field with lowest index in given text
 * @param  {Object} model
 * @return {Object}
 */
function findLowestIndexField(model) {
	return model.fields.reduce((result, field) => !result || field.index < result.index ? field : result, null);
}

/**
 * Splits given fields model in two parts by given field
 * @param  {Object} model
 * @param  {Object} field
 * @return {Array} Two-items array
 */
function splitFieldsModel(model, field) {
	const ix = model.fields.indexOf(field);

	const left = new model.constructor(model.string.slice(0, field.location), model.fields.slice(0, ix));

	const right = new model.constructor(model.string.slice(field.location + field.length), model.fields.slice(ix + 1));

	return [left, right];
}

const commentOptions = {
	// enable node commenting
	enabled: false,

	// attributes that should trigger node commenting on specific node,
	// if commenting is enabled
	trigger: ['id', 'class'],

	// comment before opening tag
	before: '',

	// comment after closing tag
	after: '\n<!-- /[#ID][.CLASS] -->'
};

/**
 * Renders given parsed Emmet abbreviation as HTML, formatted according to
 * `profile` options
 * @param  {Node}     tree    Parsed Emmet abbreviation
 * @param  {Profile}  profile Output profile
 * @param  {Object}  [options] Additional formatter options
 * @return {String}
 */
function html(tree, profile, options) {
	options = markup_formatters_es__extends({}, options);
	const format = getFormatOptions(options);

	return output_renderer_es(tree, options.field, outNode => {
		outNode = setFormatting(outNode, profile);

		if (!handlePseudoSnippet(outNode)) {
			const node = outNode.node;

			if (node.name) {
				const name = profile.name(node.name);
				const attrs = formatAttributes(outNode, profile);

				outNode.open = `<${name}${attrs}${node.selfClosing ? profile.selfClose() : ''}>`;
				if (!node.selfClosing) {
					outNode.close = `</${name}>`;
				}

				commentNode(outNode, format.comment);
			}

			// Do not generate fields for nodes with empty value and children
			// or if node is self-closed
			if (node.value || !node.children.length && !node.selfClosing) {
				outNode.text = outNode.renderFields(node.value);
			}
		}

		return outNode;
	});
}

/**
 * Updates formatting properties for given output node
 * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node
 * @param  {Profile}    profile Output profile
 * @return {OutputNode}
 */
function setFormatting(outNode, profile) {
	const node = outNode.node;

	if (shouldFormatNode(node, profile)) {
		outNode.indent = profile.indent(getIndentLevel(node, profile));
		outNode.newline = '\n';
		const prefix = outNode.newline + outNode.indent;

		// do not format the very first node in output
		if (!isRoot(node.parent) || !isFirstChild(node)) {
			outNode.beforeOpen = prefix;
			if (node.isTextOnly) {
				outNode.beforeText = prefix;
			}
		}

		if (hasInnerFormatting(node, profile)) {
			if (!node.isTextOnly) {
				outNode.beforeText = prefix + profile.indent(1);
			}
			outNode.beforeClose = prefix;
		}
	}

	return outNode;
}

/**
 * Check if given node should be formatted
 * @param  {Node} node
 * @param  {Profile} profile
 * @return {Boolean}
 */
function shouldFormatNode(node, profile) {
	if (!profile.get('format')) {
		return false;
	}

	if (node.parent.isTextOnly && node.parent.children.length === 1 && field_parser_es(node.parent.value).fields.length) {
		// Edge case: do not format the only child of text-only node,
		// but only if parent contains fields
		return false;
	}

	return isInline(node, profile) ? shouldFormatInline(node, profile) : true;
}

/**
 * Check if given inline node should be formatted as well, e.g. it contains
 * enough adjacent siblings that should force formatting
 * @param  {Node} node
 * @param  {Profile} profile
 * @return {Boolean}
 */
function shouldFormatInline(node, profile) {
	if (!isInline(node, profile)) {
		return false;
	}

	if (isPseudoSnippet(node)) {
		return true;
	}

	// check if inline node is the next sibling of block-level node
	if (node.childIndex === 0) {
		// first node in parent: format if it’s followed by a block-level element
		let next = node;
		while (next = next.nextSibling) {
			if (!isInline(next, profile)) {
				return true;
			}
		}
	} else if (!isInline(node.previousSibling, profile)) {
		// node is right after block-level element
		return true;
	}

	if (profile.get('inlineBreak')) {
		// check for adjacent inline elements before and after current element
		let adjacentInline = 1;
		let before = node,
		    after = node;

		while (isInlineElement(before = before.previousSibling, profile)) {
			adjacentInline++;
		}

		while (isInlineElement(after = after.nextSibling, profile)) {
			adjacentInline++;
		}

		if (adjacentInline >= profile.get('inlineBreak')) {
			return true;
		}
	}

	// Another edge case: inline node contains node that should receive foramtting
	for (let i = 0, il = node.children.length; i < il; i++) {
		if (shouldFormatNode(node.children[i], profile)) {
			return true;
		}
	}

	return false;
}

/**
 * Check if given node contains inner formatting, e.g. any of its children should
 * be formatted
 * @param  {Node} node
 * @param  {Profile} profile
 * @return {Boolean}
 */
function hasInnerFormatting(node, profile) {
	// check if node if forced for inner formatting
	const nodeName = (node.name || '').toLowerCase();
	if (profile.get('formatForce').indexOf(nodeName) !== -1) {
		return true;
	}

	// check if any of children should receive formatting
	// NB don’t use `childrent.some()` to reduce memory allocations
	for (let i = 0; i < node.children.length; i++) {
		if (shouldFormatNode(node.children[i], profile)) {
			return true;
		}
	}

	return false;
}

/**
 * Outputs attributes of given abbreviation node as HTML attributes
 * @param  {OutputNode} outNode
 * @param  {Profile}    profile
 * @return {String}
 */
function formatAttributes(outNode, profile) {
	const node = outNode.node;

	return node.attributes.map(attr => {
		if (attr.options.implied && attr.value == null) {
			return null;
		}

		const attrName = profile.attribute(attr.name);
		let attrValue = null;

		// handle boolean attributes
		if (attr.options.boolean || profile.get('booleanAttributes').indexOf(attrName.toLowerCase()) !== -1) {
			if (profile.get('compactBooleanAttributes') && attr.value == null) {
				return ` ${attrName}`;
			} else if (attr.value == null) {
				attrValue = attrName;
			}
		}

		if (attrValue == null) {
			attrValue = outNode.renderFields(attr.value);
		}

		return attr.options.before && attr.options.after ? ` ${attrName}=${attr.options.before + attrValue + attr.options.after}` : ` ${attrName}=${profile.quote(attrValue)}`;
	}).join('');
}

/**
 * Check if given node is inline-level
 * @param  {Node}  node
 * @param  {Profile}  profile
 * @return {Boolean}
 */
function isInline(node, profile) {
	return node && node.isTextOnly || isInlineElement(node, profile);
}

/**
 * Check if given node is inline-level element, e.g. element with explicitly
 * defined node name
 * @param  {Node}  node
 * @param  {Profile}  profile
 * @return {Boolean}
 */
function isInlineElement(node, profile) {
	return node && profile.isInline(node);
}

/**
 * Computes indent level for given node
 * @param  {Node} node
 * @param  {Profile} profile
 * @param  {Number} level
 * @return {Number}
 */
function getIndentLevel(node, profile) {
	// Increase indent level IF NOT:
	// * parent is text-only node
	// * there’s a parent node with a name that is explicitly set to decrease level
	const skip = profile.get('formatSkip') || [];
	let level = node.parent.isTextOnly ? -2 : -1;
	let ctx = node;
	while (ctx = ctx.parent) {
		if (skip.indexOf((ctx.name || '').toLowerCase()) === -1) {
			level++;
		}
	}

	return level < 0 ? 0 : level;
}

/**
 * Comments given output node, if required
 * @param  {OutputNode} outNode
 * @param  {Object} options
 */
function commentNode(outNode, options) {
	const node = outNode.node;

	if (!options.enabled || !options.trigger || !node.name) {
		return;
	}

	const attrs = outNode.node.attributes.reduce((out, attr) => {
		if (attr.name && attr.value != null) {
			out[attr.name.toUpperCase().replace(/-/g, '_')] = attr.value;
		}

		return out;
	}, {});

	// add comment only if attribute trigger is present
	for (let i = 0, il = options.trigger.length; i < il; i++) {
		if (options.trigger[i].toUpperCase() in attrs) {
			outNode.open = template(options.before, attrs) + outNode.open;
			if (outNode.close) {
				outNode.close += template(options.after, attrs);
			}
			break;
		}
	}
}

function getFormatOptions(options) {
	const format = markup_formatters_es__extends({}, options && options.format);
	format.comment = markup_formatters_es__extends({}, commentOptions, format.comment);
	return format;
}

const reId = /^id$/i;
const reClass = /^class$/i;
const defaultAttrOptions = {
	primary: attrs => attrs.join(''),
	secondary: attrs => attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${attr.value}`).join(', ')
};

const defaultNodeOptions = {
	open: null,
	close: null,
	omitName: /^div$/i,
	attributes: defaultAttrOptions
};

function indentFormat(outNode, profile, options) {
	options = markup_formatters_es__extends({}, defaultNodeOptions, options);
	const node = outNode.node;

	outNode.indent = profile.indent(getIndentLevel$1(node, profile));
	outNode.newline = '\n';

	// Do not format the very first node in output
	if (!isRoot(node.parent) || !isFirstChild(node)) {
		outNode.beforeOpen = outNode.newline + outNode.indent;
	}

	if (node.name) {
		const data = markup_formatters_es__extends({
			NAME: profile.name(node.name),
			SELF_CLOSE: node.selfClosing ? options.selfClose : null
		}, getAttributes(outNode, profile, options.attributes));

		// omit tag name if node has primary attributes
		if (options.omitName && options.omitName.test(data.NAME) && data.PRIMARY_ATTRS) {
			data.NAME = null;
		}

		if (options.open != null) {
			outNode.open = template(options.open, data);
		}

		if (options.close != null) {
			outNode.close = template(options.close, data);
		}
	}

	return outNode;
}

/**
 * Formats attributes of given node into a string.
 * @param  {OutputNode} node          Output node wrapper
 * @param  {Profile}    profile       Output profile
 * @param  {Object}     options       Additional formatting options
 * @return {String}
 */
function getAttributes(outNode, profile, options) {
	options = markup_formatters_es__extends({}, defaultAttrOptions, options);
	const primary = [],
	      secondary = [];
	const node = outNode.node;

	node.attributes.forEach(attr => {
		if (attr.options.implied && attr.value == null) {
			return null;
		}

		const name = profile.attribute(attr.name);
		const value = outNode.renderFields(attr.value);

		if (reId.test(name)) {
			value && primary.push(`#${value}`);
		} else if (reClass.test(name)) {
			value && primary.push(`.${value.replace(/\s+/g, '.')}`);
		} else {
			const isBoolean = attr.value == null && (attr.options.boolean || profile.get('booleanAttributes').indexOf(name.toLowerCase()) !== -1);

			secondary.push({ name, value, isBoolean });
		}
	});

	return {
		PRIMARY_ATTRS: options.primary(primary) || null,
		SECONDARY_ATTRS: options.secondary(secondary) || null
	};
}

/**
 * Computes indent level for given node
 * @param  {Node} node
 * @return {Number}
 */
function getIndentLevel$1(node) {
	let level = node.parent.isTextOnly ? -2 : -1;
	let ctx = node;
	while (ctx = ctx.parent) {
		level++;
	}

	return level < 0 ? 0 : level;
}

const reNl = /\n|\r/;

/**
 * Renders given parsed Emmet abbreviation as HAML, formatted according to
 * `profile` options
 * @param  {Node}    tree      Parsed Emmet abbreviation
 * @param  {Profile} profile   Output profile
 * @param  {Object}  [options] Additional formatter options
 * @return {String}
 */
function haml(tree, profile, options) {
	options = options || {};
	const nodeOptions = {
		open: '[%NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)][SELF_CLOSE]',
		selfClose: '/',
		attributes: {
			secondary(attrs) {
				return attrs.map(attr => attr.isBoolean ? `${attr.name}${profile.get('compactBooleanAttributes') ? '' : '=true'}` : `${attr.name}=${profile.quote(attr.value)}`).join(' ');
			}
		}
	};

	return output_renderer_es(tree, options.field, outNode => {
		outNode = indentFormat(outNode, profile, nodeOptions);
		outNode = updateFormatting(outNode, profile);

		if (!handlePseudoSnippet(outNode)) {
			const node = outNode.node;

			// Do not generate fields for nodes with empty value and children
			// or if node is self-closed
			if (node.value || !node.children.length && !node.selfClosing) {
				outNode.text = outNode.renderFields(formatNodeValue(node, profile));
			}
		}

		return outNode;
	});
}

/**
 * Updates formatting properties for given output node
 * NB Unlike HTML, HAML is indent-based format so some formatting options from
 * `profile` will not take effect, otherwise output will be broken
 * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node
 * @param  {Profile}    profile Output profile
 * @return {OutputNode}
 */
function updateFormatting(outNode, profile) {
	const node = outNode.node;

	if (!node.isTextOnly && node.value) {
		// node with text: put a space before single-line text
		outNode.beforeText = reNl.test(node.value) ? outNode.newline + outNode.indent + profile.indent(1) : ' ';
	}

	return outNode;
}
/**
 * Formats value of given node: for multiline text we should add a ` |` suffix
 * at the end of each line. Also ensure that text is perfectly aligned.
 * @param  {Node}    node
 * @param  {Profile} profile
 * @return {String|null}
 */
function formatNodeValue(node, profile) {
	if (node.value != null && reNl.test(node.value)) {
		const lines = markup_formatters_es_splitByLines(node.value);
		const indent = profile.indent(1);
		const maxLength = lines.reduce((prev, line) => Math.max(prev, line.length), 0);

		return lines.map((line, i) => `${i ? indent : ''}${pad(line, maxLength)} |`).join('\n');
	}

	return node.value;
}

function pad(text, len) {
	while (text.length < len) {
		text += ' ';
	}

	return text;
}

const reNl$1 = /\n|\r/;
const secondaryAttrs = {
	none: '[ SECONDARY_ATTRS]',
	round: '[(SECONDARY_ATTRS)]',
	curly: '[{SECONDARY_ATTRS}]',
	square: '[[SECONDARY_ATTRS]'
};

/**
 * Renders given parsed Emmet abbreviation as Slim, formatted according to
 * `profile` options
 * @param  {Node}    tree      Parsed Emmet abbreviation
 * @param  {Profile} profile   Output profile
 * @param  {Object}  [options] Additional formatter options
 * @return {String}
 */
function slim(tree, profile, options) {
	options = options || {};
	const SECONDARY_ATTRS = options.attributeWrap && secondaryAttrs[options.attributeWrap] || secondaryAttrs.none;

	const booleanAttr = SECONDARY_ATTRS === secondaryAttrs.none ? attr => `${attr.name}=true` : attr => attr.name;

	const nodeOptions = {
		open: `[NAME][PRIMARY_ATTRS]${SECONDARY_ATTRS}[SELF_CLOSE]`,
		selfClose: '/',
		attributes: {
			secondary(attrs) {
				return attrs.map(attr => attr.isBoolean ? booleanAttr(attr) : `${attr.name}=${profile.quote(attr.value)}`).join(' ');
			}
		}
	};

	return output_renderer_es(tree, options.field, outNode => {
		outNode = indentFormat(outNode, profile, nodeOptions);
		outNode = updateFormatting$1(outNode, profile);

		if (!handlePseudoSnippet(outNode)) {
			const node = outNode.node;

			// Do not generate fields for nodes with empty value and children
			// or if node is self-closed
			if (node.value || !node.children.length && !node.selfClosing) {
				outNode.text = outNode.renderFields(formatNodeValue$1(node, profile));
			}
		}

		return outNode;
	});
}

/**
 * Updates formatting properties for given output node
 * NB Unlike HTML, Slim is indent-based format so some formatting options from
 * `profile` will not take effect, otherwise output will be broken
 * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node
 * @param  {Profile}    profile Output profile
 * @return {OutputNode}
 */
function updateFormatting$1(outNode, profile) {
	const node = outNode.node;
	const parent = node.parent;

	// Edge case: a single inline-level child inside node without text:
	// allow it to be inlined
	if (profile.get('inlineBreak') === 0 && isInline$1(node, profile) && !isRoot(parent) && parent.value == null && parent.children.length === 1) {
		outNode.beforeOpen = ': ';
	}

	if (!node.isTextOnly && node.value) {
		// node with text: put a space before single-line text
		outNode.beforeText = reNl$1.test(node.value) ? outNode.newline + outNode.indent + profile.indent(1) : ' ';
	}

	return outNode;
}

/**
 * Formats value of given node: for multiline text we should precede each
 * line with `| ` with one-level deep indent
 * @param  {Node} node
 * @param  {Profile} profile
 * @return {String|null}
 */
function formatNodeValue$1(node, profile) {
	if (node.value != null && reNl$1.test(node.value)) {
		const indent = profile.indent(1);
		return markup_formatters_es_splitByLines(node.value).map((line, i) => `${indent}${i ? ' ' : '|'} ${line}`).join('\n');
	}

	return node.value;
}

/**
 * Check if given node is inline-level
 * @param  {Node}  node
 * @param  {Profile}  profile
 * @return {Boolean}
 */
function isInline$1(node, profile) {
	return node && (node.isTextOnly || profile.isInline(node));
}

const reNl$2 = /\n|\r/;

/**
 * Renders given parsed Emmet abbreviation as Pug, formatted according to
 * `profile` options
 * @param  {Node}    tree      Parsed Emmet abbreviation
 * @param  {Profile} profile   Output profile
 * @param  {Object}  [options] Additional formatter options
 * @return {String}
 */
function pug(tree, profile, options) {
	options = options || {};
	const nodeOptions = {
		open: '[NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)]',
		attributes: {
			secondary(attrs) {
				return attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${profile.quote(attr.value)}`).join(', ');
			}
		}
	};

	return output_renderer_es(tree, options.field, outNode => {
		outNode = indentFormat(outNode, profile, nodeOptions);
		outNode = updateFormatting$2(outNode, profile);

		if (!handlePseudoSnippet(outNode)) {
			const node = outNode.node;
			// Do not generate fields for nodes with empty value and children
			// or if node is self-closed
			if (node.value || !node.children.length && !node.selfClosing) {
				outNode.text = outNode.renderFields(formatNodeValue$2(node, profile));
			}
		}

		return outNode;
	});
}

/**
 * Updates formatting properties for given output node
 * NB Unlike HTML, Pug is indent-based format so some formatting options from
 * `profile` will not take effect, otherwise output will be broken
 * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node
 * @param  {Profile}    profile Output profile
 * @return {OutputNode}
 */
function updateFormatting$2(outNode, profile) {
	const node = outNode.node;

	if (!node.isTextOnly && node.value) {
		// node with text: put a space before single-line text
		outNode.beforeText = reNl$2.test(node.value) ? outNode.newline + outNode.indent + profile.indent(1) : ' ';
	}

	return outNode;
}

/**
 * Formats value of given node: for multiline text we should precede each
 * line with `| ` with one-level deep indent
 * @param  {Node} node
 * @param  {Profile} profile
 * @return {String|null}
 */
function formatNodeValue$2(node, profile) {
	if (node.value != null && reNl$2.test(node.value)) {
		const indent = profile.indent(1);
		return markup_formatters_es_splitByLines(node.value).map(line => `${indent}| ${line}`).join('\n');
	}

	return node.value;
}

const supportedSyntaxes = { html, haml, slim, pug };

/**
 * Outputs given parsed abbreviation in specified syntax
 * @param {Node}     tree     Parsed abbreviation tree
 * @param {Profile}  profile  Output profile
 * @param {String}   [syntax] Output syntax. If not given, `html` syntax is used
 * @param {Function} options.field A function to output field/tabstop for
 * host editor. This function takes two arguments: `index` and `placeholder` and
 * should return a string that represents tabstop in host editor. By default
 * only a placeholder is returned
 * @example
 * {
 * 	field(index, placeholder) {
 * 		// return field in TextMate-style, e.g. ${1} or ${2:foo}
 * 		return `\${${index}${placeholder ? ':' + placeholder : ''}}`;
 *  }
 * }
 * @return {String}
 */
function markup_formatters_es_index(tree, profile, syntax, options) {
	if (typeof syntax === 'object') {
		options = syntax;
		syntax = null;
	}

	if (!supports(syntax)) {
		// fallback to HTML if given syntax is not supported
		syntax = 'html';
	}

	return supportedSyntaxes[syntax](tree, profile, options);
}

/**
 * Check if given syntax is supported
 * @param {String} syntax
 * @return {Boolean}
 */
function supports(syntax) {
	return !!syntax && syntax in supportedSyntaxes;
}

/* harmony default export */ var markup_formatters_es = (markup_formatters_es_index);

//# sourceMappingURL=markup-formatters.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js




/**
 * A wrapper for holding CSS value
 */
let CSSValue = class CSSValue {
	constructor() {
		this.type = 'css-value';
		this.value = [];
	}

	get size() {
		return this.value.length;
	}

	add(value) {
		this.value.push(value);
	}

	has(value) {
		return this.value.indexOf(value) !== -1;
	}

	toString() {
		return this.value.join(' ');
	}
};


const css_abbreviation_es_HASH = 35; // #
const css_abbreviation_es_DOT = 46; // .

/**
 * Consumes a color token from given string
 * @param  {StreamReader} stream
 * @return {Color} Returns consumend color object, `undefined` otherwise
 */
function consumeColor(stream) {
	// supported color variations:
	// #abc   → #aabbccc
	// #0     → #000000
	// #fff.5 → rgba(255, 255, 255, 0.5)
	// #t     → transparent
	if (stream.peek() === css_abbreviation_es_HASH) {
		stream.start = stream.pos;
		stream.next();

		stream.eat(116) /* t */ || stream.eatWhile(isHex);
		const base = stream.current();

		// a hex color can be followed by `.num` alpha value
		stream.start = stream.pos;
		if (stream.eat(css_abbreviation_es_DOT) && !stream.eatWhile(isNumber)) {
			throw stream.error('Unexpected character for alpha value of color');
		}

		return new Color(base, stream.current());
	}
}

let Color = class Color {
	constructor(value, alpha) {
		this.type = 'color';
		this.raw = value;
		this.alpha = Number(alpha != null && alpha !== '' ? alpha : 1);
		value = value.slice(1); // remove #

		let r = 0,
		    g = 0,
		    b = 0;

		if (value === 't') {
			this.alpha = 0;
		} else {
			switch (value.length) {
				case 0:
					break;

				case 1:
					r = g = b = value + value;
					break;

				case 2:
					r = g = b = value;
					break;

				case 3:
					r = value[0] + value[0];
					g = value[1] + value[1];
					b = value[2] + value[2];
					break;

				default:
					value += value;
					r = value.slice(0, 2);
					g = value.slice(2, 4);
					b = value.slice(4, 6);
			}
		}

		this.r = parseInt(r, 16);
		this.g = parseInt(g, 16);
		this.b = parseInt(b, 16);
	}

	/**
  * Output current color as hex value
  * @param {Boolean} shor Produce short value (e.g. #fff instead of #ffffff), if possible
  * @return {String}
  */
	toHex(short) {
		const fn = short && isShortHex(this.r) && isShortHex(this.g) && isShortHex(this.b) ? toShortHex : toHex;

		return '#' + fn(this.r) + fn(this.g) + fn(this.b);
	}

	/**
  * Output current color as `rgba?(...)` CSS color
  * @return {String}
  */
	toRGB() {
		const values = [this.r, this.g, this.b];
		if (this.alpha !== 1) {
			values.push(this.alpha.toFixed(8).replace(/\.?0+$/, ''));
		}

		return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;
	}

	toString(short) {
		if (!this.r && !this.g && !this.b && !this.alpha) {
			return 'transparent';
		}
		return this.alpha === 1 ? this.toHex(short) : this.toRGB();
	}
};

/**
 * Check if given code is a hex value (/0-9a-f/)
 * @param  {Number}  code
 * @return {Boolean}
 */

function isHex(code) {
	return isNumber(code) || isAlpha(code, 65, 70); // A-F
}

function isShortHex(hex) {
	return !(hex % 17);
}

function toShortHex(num) {
	return (num >> 4).toString(16);
}

function toHex(num) {
	return css_abbreviation_es_pad(num.toString(16), 2);
}

function css_abbreviation_es_pad(value, len) {
	while (value.length < len) {
		value = '0' + value;
	}
	return value;
}

/**
 * @param  {Number}  code
 * @return {Boolean}
 */
function isAlphaNumericWord(code) {
	return isNumber(code) || isAlphaWord(code);
}

/**
 * @param  {Number}  code
 * @return {Boolean}
 */
function isAlphaWord(code) {
	return code === 95 /* _ */ || isAlpha(code);
}

const PERCENT = 37; // %
const css_abbreviation_es_DOT$1 = 46; // .
const css_abbreviation_es_DASH = 45; // -

/**
 * Consumes numeric CSS value (number with optional unit) from current stream,
 * if possible
 * @param  {StreamReader} stream
 * @return {NumericValue}
 */
function consumeNumericValue(stream) {
	stream.start = stream.pos;
	if (eatNumber(stream)) {
		const num = stream.current();
		stream.start = stream.pos;

		// eat unit, which can be a % or alpha word
		stream.eat(PERCENT) || stream.eatWhile(isAlphaWord);
		return new NumericValue(num, stream.current());
	}
}

/**
 * A numeric CSS value with optional unit
 */
let NumericValue = class NumericValue {
	constructor(value, unit) {
		this.type = 'numeric';
		this.value = Number(value);
		this.unit = unit || '';
	}

	toString() {
		return `${this.value}${this.unit}`;
	}
};

/**
 * Eats number value from given stream
 * @param  {StreamReader} stream
 * @return {Boolean} Returns `true` if number was consumed
 */

function eatNumber(stream) {
	const start = stream.pos;
	const negative = stream.eat(css_abbreviation_es_DASH);
	const afterNegative = stream.pos;

	stream.eatWhile(isNumber);

	const prevPos = stream.pos;
	if (stream.eat(css_abbreviation_es_DOT$1) && !stream.eatWhile(isNumber)) {
		// Number followed by a dot, but then no number
		stream.pos = prevPos;
	}

	// Edge case: consumed dash only: not a number, bail-out
	if (stream.pos === afterNegative) {
		stream.pos = start;
	}

	return stream.pos !== start;
}

const css_abbreviation_es_DOLLAR = 36; // $
const DASH$1 = 45; // -
const AT = 64; // @

/**
 * Consumes a keyword: either a variable (a word that starts with $ or @) or CSS
 * keyword or shorthand
 * @param  {StreamReader} stream
 * @param  {Boolean} [short] Use short notation for consuming value.
 * The difference between “short” and “full” notation is that first one uses
 * alpha characters only and used for extracting keywords from abbreviation,
 * while “full” notation also supports numbers and dashes
 * @return {String} Consumed variable
 */
function consumeKeyword(stream, short) {
	stream.start = stream.pos;

	if (stream.eat(css_abbreviation_es_DOLLAR) || stream.eat(AT)) {
		// SCSS or LESS variable
		stream.eatWhile(isVariableName);
	} else if (short) {
		stream.eatWhile(isAlphaWord);
	} else {
		stream.eatWhile(isKeyword);
	}

	return stream.start !== stream.pos ? new Keyword(stream.current()) : null;
}

let Keyword = class Keyword {
	constructor(value) {
		this.type = 'keyword';
		this.value = value;
	}

	toString() {
		return this.value;
	}
};


function isKeyword(code) {
	return isAlphaNumericWord(code) || code === DASH$1;
}

function isVariableName(code) {
	return code === 45 /* - */ || isAlphaNumericWord(code);
}

const css_abbreviation_es_opt = { throws: true };

/**
 * Consumes 'single' or "double"-quoted string from given string, if possible
 * @param  {StreamReader} stream
 * @return {String}
 */
function css_abbreviation_es_consumeQuoted(stream) {
	if (eatQuoted(stream, css_abbreviation_es_opt)) {
		return new QuotedString(stream.current());
	}
}

let QuotedString = class QuotedString {
	constructor(value) {
		this.type = 'string';
		this.value = value;
	}

	toString() {
		return this.value;
	}
};


const LBRACE = 40; // (
const RBRACE = 41; // )
const COMMA = 44; // ,

/**
 * Consumes arguments from given string.
 * Arguments are comma-separated list of CSS values inside round braces, e.g.
 * `(1, a2, 'a3')`. Nested lists and quoted strings are supported
 * @param  {StreamReader} stream
 * @return {Array}        Array of arguments, `null` if arguments cannot be consumed
 */
function consumeArgumentList(stream) {
	if (!stream.eat(LBRACE)) {
		// not an argument list
		return null;
	}

	let arg;
	const argsList = [];

	while (!stream.eof()) {
		if (arg = consumeArgument(stream)) {
			argsList.push(arg);
		} else {
			// didn’t consumed argument, expect argument separator or end-of-arguments
			stream.eatWhile(isWhiteSpace);

			if (stream.eat(RBRACE)) {
				// end of arguments list
				break;
			}

			if (!stream.eat(COMMA)) {
				throw stream.error('Expected , or )');
			}
		}
	}

	return argsList;
}

/**
 * Consumes a single argument. An argument is a `CSSValue`, e.g. it could be
 * a space-separated string of value
 * @param  {StreamReader} stream
 * @return {CSSValue}
 */
function consumeArgument(stream) {
	const result = new CSSValue();
	let value;

	while (!stream.eof()) {
		stream.eatWhile(isWhiteSpace);
		value = consumeNumericValue(stream) || consumeColor(stream) || css_abbreviation_es_consumeQuoted(stream) || consumeKeywordOrFunction(stream);

		if (!value) {
			break;
		}

		result.add(value);
	}

	return result.size ? result : null;
}

/**
 * Consumes either function call like `foo()` or keyword like `foo`
 * @param  {StreamReader} stream
 * @return {Keyword|FunctionCall}
 */
function consumeKeywordOrFunction(stream) {
	const kw = consumeKeyword(stream);
	if (kw) {
		const args = consumeArgumentList(stream);
		return args ? new FunctionCall(kw.toString(), args) : kw;
	}
}

let FunctionCall = class FunctionCall {
	/**
  * @param {String} name Function name
  * @param {Array}  args Function arguments
  */
	constructor(name, args) {
		this.type = 'function';
		this.name = name;
		this.args = args || [];
	}

	toString() {
		return `${this.name}(${this.args.join(', ')})`;
	}
};


const css_abbreviation_es_EXCL = 33; // !
const DOLLAR$1 = 36; // $
const PLUS = 43; // +
const DASH$2 = 45; // -
const css_abbreviation_es_COLON = 58; // :
const AT$1 = 64; // @

/**
 * Parses given Emmet CSS abbreviation and returns it as parsed Node tree
 * @param {String} abbr
 * @return {Node}
 */
function css_abbreviation_es_index(abbr) {
	const root = new node_es();
	const stream = new stream_reader_es(abbr);

	while (!stream.eof()) {
		let node = new node_es(consumeIdent(stream));
		node.value = consumeValue(stream);

		const args = consumeArgumentList(stream);
		if (args) {
			// technically, arguments in CSS are anonymous Emmet Node attributes,
			// but since Emmet can support only one anonymous, `null`-name
			// attribute (for good reasons), we’ll use argument index as name
			for (let i = 0; i < args.length; i++) {
				node.setAttribute(String(i), args[i]);
			}
		}

		// Consume `!important` modifier at the end of expression
		if (stream.eat(css_abbreviation_es_EXCL)) {
			node.value.add('!');
		}

		root.appendChild(node);

		// CSS abbreviations cannot be nested, only listed
		if (!stream.eat(PLUS)) {
			break;
		}
	}

	if (!stream.eof()) {
		throw stream.error('Unexpected character');
	}

	return root;
}

/**
 * Consumes CSS property identifier from given stream
 * @param  {StreamReader} stream
 * @return {String}
 */
function consumeIdent(stream) {
	stream.start = stream.pos;
	stream.eatWhile(isIdentPrefix);
	stream.eatWhile(css_abbreviation_es_isIdent);
	return stream.start !== stream.pos ? stream.current() : null;
}

/**
 * Consumes embedded value from Emmet CSS abbreviation stream
 * @param  {StreamReader} stream
 * @return {CSSValue}
 */
function consumeValue(stream) {
	const values = new CSSValue();
	let value;

	while (!stream.eof()) {
		// use colon as value separator
		stream.eat(css_abbreviation_es_COLON);
		if (value = consumeNumericValue(stream) || consumeColor(stream)) {
			// edge case: a dash after unit-less numeric value or color should
			// be treated as value separator, not negative sign
			if (!value.unit) {
				stream.eat(DASH$2);
			}
		} else {
			stream.eat(DASH$2);
			value = consumeKeyword(stream, true);
		}

		if (!value) {
			break;
		}

		values.add(value);
	}

	return values;
}

/**
 * @param  {Number}  code
 * @return {Boolean}
 */
function css_abbreviation_es_isIdent(code) {
	return isAlphaWord(code);
}

/**
 * @param  {Number}  code
 * @return {Boolean}
 */
function isIdentPrefix(code) {
	return code === AT$1 || code === DOLLAR$1 || code === css_abbreviation_es_EXCL;
}

/* harmony default export */ var css_abbreviation_es = (css_abbreviation_es_index);
// CONCATENATED MODULE: ../node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/css-snippets-resolver/dist/css-snippets-resolver.es.js
var css_snippets_resolver_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

const css_snippets_resolver_es_DASH = 45; // -

/**
 * Calculates fuzzy match score of how close `abbr` matches given `string`.
 * @param  {String} abbr        Abbreviation to score
 * @param  {String} string      String to match
 * @param  {Number} [fuzziness] Fuzzy factor
 * @return {Number}             Match score
 */
function stringScore(abbr, string) {
	abbr = abbr.toLowerCase();
	string = string.toLowerCase();

	if (abbr === string) {
		return 1;
	}

	// a string MUST start with the same character as abbreviation
	if (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {
		return 0;
	}

	const abbrLength = abbr.length;
	const stringLength = string.length;
	let i = 1,
	    j = 1,
	    score = stringLength;
	let ch1, ch2, found, acronym;

	while (i < abbrLength) {
		ch1 = abbr.charCodeAt(i);
		found = false;
		acronym = false;

		while (j < stringLength) {
			ch2 = string.charCodeAt(j);

			if (ch1 === ch2) {
				found = true;
				score += (stringLength - j) * (acronym ? 2 : 1);
				break;
			}

			// add acronym bonus for exactly next match after unmatched `-`
			acronym = ch2 === css_snippets_resolver_es_DASH;
			j++;
		}

		if (!found) {
			break;
		}

		i++;
	}

	return score && score * (i / abbrLength) / sum(stringLength);
}

/**
 * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n
 * @param  {Number} n
 * @return {Number}
 */
function sum(n) {
	return n * (n + 1) / 2;
}

const reProperty = /^([a-z-]+)(?:\s*:\s*([^\n\r]+))?$/;
const css_snippets_resolver_es_DASH$1 = 45; // -

/**
 * Creates a special structure for resolving CSS properties from plain CSS
 * snippets.
 * Almost all CSS snippets are aliases for real CSS properties with available
 * value variants, optionally separated by `|`. Most values are keywords that
 * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,
 * more specific properties, like `border` and `border-style`. For such cases
 * keywords from more specific properties should be available in shorthands too.
 * @param {Snippet[]} snippets
 * @return {CSSSnippet[]}
 */
function cssSnippets(snippets) {
	return nest(snippets.map(snippet => new CSSSnippet(snippet.key, snippet.value)));
}

let CSSSnippet = class CSSSnippet {
	constructor(key, value) {
		this.key = key;
		this.value = value;
		this.property = null;

		// detect if given snippet is a property
		const m = value && value.match(reProperty);
		if (m) {
			this.property = m[1];
			this.value = m[2];
		}

		this.dependencies = [];
	}

	addDependency(dep) {
		this.dependencies.push(dep);
	}

	get defaultValue() {
		return this.value != null ? splitValue(this.value)[0] : null;
	}

	/**
  * Returns list of unique keywords for current CSS snippet and its dependencies
  * @return {String[]}
  */
	keywords() {
		const stack = [];
		const keywords = new Set();
		let i = 0,
		    item,
		    candidates;

		if (this.property) {
			// scan valid CSS-properties only
			stack.push(this);
		}

		while (i < stack.length) {
			// NB Keep items in stack instead of push/pop to avoid possible
			// circular references
			item = stack[i++];

			if (item.value) {
				candidates = splitValue(item.value).filter(css_snippets_resolver_es_isKeyword);

				// extract possible keywords from snippet value
				for (let j = 0; j < candidates.length; j++) {
					keywords.add(candidates[j].trim());
				}

				// add dependencies into scan stack
				for (let j = 0, deps = item.dependencies; j < deps.length; j++) {
					if (stack.indexOf(deps[j]) === -1) {
						stack.push(deps[j]);
					}
				}
			}
		}

		return Array.from(keywords);
	}
};

/**
 * Nests more specific CSS properties into shorthand ones, e.g.
 * background-position-x -> background-position -> background
 * @param  {CSSSnippet[]} snippets
 * @return {CSSSnippet[]}
 */

function nest(snippets) {
	snippets = snippets.sort(snippetsSort);
	const stack = [];

	// For sorted list of CSS properties, create dependency graph where each
	// shorthand property contains its more specific one, e.g.
	// background -> background-position -> background-position-x
	for (let i = 0, cur, prev; i < snippets.length; i++) {
		cur = snippets[i];

		if (!cur.property) {
			// not a CSS property, skip it
			continue;
		}

		// Check if current property belongs to one from parent stack.
		// Since `snippets` array is sorted, items are perfectly aligned
		// from shorthands to more specific variants
		while (stack.length) {
			prev = stack[stack.length - 1];

			if (cur.property.indexOf(prev.property) === 0 && cur.property.charCodeAt(prev.property.length) === css_snippets_resolver_es_DASH$1) {
				prev.addDependency(cur);
				stack.push(cur);
				break;
			}

			stack.pop();
		}

		if (!stack.length) {
			stack.push(cur);
		}
	}

	return snippets;
}

/**
 * A sorting function for array of snippets
 * @param  {CSSSnippet} a
 * @param  {CSSSnippet} b
 * @return {Number}
 */
function snippetsSort(a, b) {
	if (a.key === b.key) {
		return 0;
	}

	return a.key < b.key ? -1 : 1;
}

/**
 * Check if given string is a keyword candidate
 * @param  {String}  str
 * @return {Boolean}
 */
function css_snippets_resolver_es_isKeyword(str) {
	return (/^\s*[\w-]+/.test(str)
	);
}

function splitValue(value) {
	return String(value).split('|');
}

const globalKeywords = ['auto', 'inherit', 'unset'];
const unitlessProperties = ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'];

const css_snippets_resolver_es_defaultOptions = {
	intUnit: 'px',
	floatUnit: 'em',
	unitAliases: {
		e: 'em',
		p: '%',
		x: 'ex',
		r: 'rem'
	},
	fuzzySearchMinScore: 0
};

/**
 * For every node in given `tree`, finds matching snippet from `registry` and
 * updates node with snippet data.
 *
 * This resolver uses fuzzy matching for searching matched snippets and their
 * keyword values.
 */

function css_snippets_resolver_es_index(tree, registry, options) {
	options = css_snippets_resolver_es__extends({}, css_snippets_resolver_es_defaultOptions, options);
	options.unitAliases = css_snippets_resolver_es__extends({}, css_snippets_resolver_es_defaultOptions.unitAliases, options && options.unitAliases);

	const snippets = convertToCSSSnippets(registry);

	tree.walk(node => css_snippets_resolver_es_resolveNode(node, snippets, options));
	return tree;
}

function convertToCSSSnippets(registry) {
	return cssSnippets(registry.all({ type: 'string' }));
}

/**
 * Resolves given node: finds matched CSS snippets using fuzzy match and resolves
 * keyword aliases from node value
 * @param  {Node} node
 * @param  {CSSSnippet[]} snippets
 * @param  {Object} options
 * @return {Node}
 */
function css_snippets_resolver_es_resolveNode(node, snippets, options) {
	if (options.property) {
		// Resolve as value of given CSS property
		return resolveAsPropertyValue(node, snippets.find(snippet => snippet.property === options.property), options);
	}

	const snippet = findBestMatch(node.name, snippets, 'key', options.fuzzySearchMinScore);

	if (!snippet) {
		// Edge case: `!important` snippet
		return node.name === '!' ? setNodeAsText(node, '!important') : node;
	}

	return snippet.property ? resolveAsProperty(node, snippet, options) : resolveAsSnippet(node, snippet);
}

/**
 * Resolves given parsed abbreviation node as CSS property
 * @param {Node} node
 * @param {CSSSnippet} snippet
 * @param  {Object} formatOptions
 * @return {Node}
 */
function resolveAsProperty(node, snippet, formatOptions) {
	const abbr = node.name;
	node.name = snippet.property;

	if (node.value && typeof node.value === 'object') {
		// resolve keyword shortcuts
		const keywords = snippet.keywords();

		if (!node.value.size) {
			// no value defined, try to resolve unmatched part as a keyword alias
			let kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);

			if (!kw) {
				// no matching value, try to get default one
				kw = snippet.defaultValue;
				if (kw && kw.indexOf('${') === -1) {
					// Quick and dirty test for existing field. If not, wrap
					// default value in a field
					kw = `\${1:${kw}}`;
				}
			}

			if (kw) {
				node.value.add(kw);
			}
		} else {
			// replace keyword aliases in current node value
			for (let i = 0, token; i < node.value.value.length; i++) {
				token = node.value.value[i];

				if (token === '!') {
					token = `${!i ? '${1} ' : ''}!important`;
				} else if (isKeyword$1(token)) {
					token = findBestMatch(token.value, keywords) || findBestMatch(token.value, globalKeywords) || token;
				} else if (isNumericValue(token)) {
					token = resolveNumericValue(node.name, token, formatOptions);
				}

				node.value.value[i] = token;
			}
		}
	}

	return node;
}

/**
 * Resolves given parsed abbreviation node as a snippet: a plain code chunk
 * @param {Node} node
 * @param {CSSSnippet} snippet
 * @return {Node}
 */
function resolveAsSnippet(node, snippet) {
	return setNodeAsText(node, snippet.value);
}

/**
 * Resolves given parsed abbreviation node as property value of given `snippet`:
 * tries to find best matching keyword from CSS snippet
 * @param {Node} node
 * @param {CSSSnippet} snippet
 * @param {Object} options
 * @return {Node}
 */
function resolveAsPropertyValue(node, snippet, options) {
	// Possible resolved result for CSS property:
	// * matched snippet keyword
	// * color (starts with #)
	// Everything else should result the same as input abbreviation
	let keywords = globalKeywords.slice();
	if (snippet) {
		keywords = keywords.concat(snippet.keywords());
	}

	const values = [node.name].concat(node.value.value).filter(Boolean).map(value => {
		if (typeof value === 'string' || value.type === 'keyword') {
			value = String(value);
			return findBestMatch(value, keywords, null, options.fuzzySearchMinScore) || value;
		}

		return value;
	});

	node.name = null;
	node.value.value = values;

	return node;
}

/**
 * Sets given parsed abbreviation node as a text snippet
 * @param {Node} node
 * @param {String} text
 * @return {Node}
 */
function setNodeAsText(node, text) {
	node.name = null;
	node.value = text;
	return node;
}

/**
 * Finds best matching item from `items` array
 * @param {String} abbr  Abbreviation to match
 * @param {Array}  items List of items for match
 * @param {String} [key] If `items` is a list of objects, use `key` as object
 * property to test against
 * @param {Number} fuzzySearchMinScore The minimum score the best matched item should have to be a valid match.
 * @return {*}
 */
function findBestMatch(abbr, items, key, fuzzySearchMinScore) {
	if (!abbr) {
		return null;
	}

	let matchedItem = null;
	let maxScore = 0;
	fuzzySearchMinScore = fuzzySearchMinScore || 0;

	for (let i = 0, item; i < items.length; i++) {
		item = items[i];
		const score = stringScore(abbr, getScoringPart(item, key));

		if (score === 1) {
			// direct hit, no need to look further
			return item;
		}

		if (score && score >= maxScore) {
			maxScore = score;
			matchedItem = item;
		}
	}

	return maxScore >= fuzzySearchMinScore ? matchedItem : null;
}

function getScoringPart(item, key) {
	const value = item && typeof item === 'object' ? item[key] : item;
	const m = (value || '').match(/^[\w-@]+/);
	return m ? m[0] : value;
}

/**
 * Returns a part of `abbr` that wasn’t directly matched agains `string`.
 * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`
 * since `a` wasn’t found in string stream
 * @param {String} abbr
 * @param {String} string
 * @return {String}
 */
function getUnmatchedPart(abbr, string) {
	for (let i = 0, lastPos = 0; i < abbr.length; i++) {
		lastPos = string.indexOf(abbr[i], lastPos);
		if (lastPos === -1) {
			return abbr.slice(i);
		}
		lastPos++;
	}

	return '';
}

/**
 * Check if given CSS value token is a keyword
 * @param {*} token
 * @return {Boolean}
 */
function isKeyword$1(token) {
	return tokenTypeOf(token, 'keyword');
}

/**
 * Check if given CSS value token is a numeric value
 * @param  {*}  token
 * @return {Boolean}
 */
function isNumericValue(token) {
	return tokenTypeOf(token, 'numeric');
}

function tokenTypeOf(token, type) {
	return token && typeof token === 'object' && token.type === type;
}

/**
 * Resolves numeric value for given CSS property
 * @param  {String} property    CSS property name
 * @param  {NumericValue} token CSS numeric value token
 * @param  {Object} formatOptions Formatting options for units
 * @return {NumericValue}
 */
function resolveNumericValue(property, token, formatOptions) {
	if (token.unit) {
		token.unit = formatOptions.unitAliases[token.unit] || token.unit;
	} else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {
		// use `px` for integers, `em` for floats
		// NB: num|0 is a quick alternative to Math.round(0)
		token.unit = token.value === (token.value | 0) ? formatOptions.intUnit : formatOptions.floatUnit;
	}

	return token;
}

/* harmony default export */ var css_snippets_resolver_es = (css_snippets_resolver_es_index);

//# sourceMappingURL=css-snippets-resolver.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/stylesheet-formatters/dist/stylesheet-formatters.es.js
var stylesheet_formatters_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




const defaultFormatOptions = {
	shortHex: true,
	between: ': ',
	after: ';'
};

/**
 * Renders given parsed Emmet CSS abbreviation as CSS-like
 * stylesheet, formatted according to `profile` options
 * @param  {Node}     tree    Parsed Emmet abbreviation
 * @param  {Profile}  profile Output profile
 * @param  {Object}  [options] Additional formatter options
 * @return {String}
 */
function css(tree, profile, options) {
	options = options || {};
	const formatOpt = stylesheet_formatters_es__extends({}, defaultFormatOptions, options && options.format);

	return output_renderer_es(tree, options.field, outNode => {
		const node = outNode.node;
		let value = stringifyValue(node, formatOpt);

		if (node.attributes.length) {
			const fieldValues = node.attributes.map(attr => stringifyValue(attr, formatOpt));
			value = injectFields(value, fieldValues);
		}

		outNode.open = node.name && profile.name(node.name);
		outNode.afterOpen = formatOpt.between;
		outNode.text = outNode.renderFields(value || null);

		if (outNode.open && (!outNode.text || !outNode.text.endsWith(';'))) {
			outNode.afterText = formatOpt.after;
		}

		if (profile.get('format')) {
			outNode.newline = '\n';
			if (tree.lastChild !== node) {
				outNode.afterText += outNode.newline;
			}
		}

		return outNode;
	});
}

/**
 * Injects given field values at each field of given string
 * @param  {String}   string
 * @param  {String[]} attributes
 * @return {FieldString}
 */
function injectFields(string, values) {
	const fieldsModel = field_parser_es(string);
	const fieldsAmount = fieldsModel.fields.length;

	if (fieldsAmount) {
		values = values.slice();
		if (values.length > fieldsAmount) {
			// More values that output fields: collapse rest values into
			// a single token
			values = values.slice(0, fieldsAmount - 1).concat(values.slice(fieldsAmount - 1).join(', '));
		}

		while (values.length) {
			const value = values.shift();
			const field = fieldsModel.fields.shift();
			const delta = value.length - field.length;

			fieldsModel.string = fieldsModel.string.slice(0, field.location) + value + fieldsModel.string.slice(field.location + field.length);

			// Update location of the rest fields in string
			for (let i = 0, il = fieldsModel.fields.length; i < il; i++) {
				fieldsModel.fields[i].location += delta;
			}
		}
	}

	return fieldsModel;
}

function stringifyValue(node, options) {
	if (node.value && typeof node.value === 'object' && node.value.type === 'css-value') {
		return node.value.value.map(token => {
			if (token && typeof token === 'object') {
				return token.type === 'color' ? token.toString(options.shortHex) : token.toString();
			}

			return String(token);
		}).join(' ');
	}

	return node.value != null ? String(node.value) : '';
}

const syntaxFormat = {
	css: {
		between: ': ',
		after: ';'
	},
	scss: 'css',
	less: 'css',
	sass: {
		between: ': ',
		after: ''
	},
	stylus: {
		between: ' ',
		after: ''
	}
};

/**
 * Outputs given parsed abbreviation in specified stylesheet syntax
 * @param {Node}     tree     Parsed abbreviation tree
 * @param {Profile}  profile  Output profile
 * @param {String}   [syntax] Output syntax. If not given, `css` syntax is used
 * @param {Function} options.field A function to output field/tabstop for
 * host editor. This function takes two arguments: `index` and `placeholder` and
 * should return a string that represents tabstop in host editor. By default
 * only a placeholder is returned
 * @example
 * {
 * 	field(index, placeholder) {
 * 		// return field in TextMate-style, e.g. ${1} or ${2:foo}
 * 		return `\${${index}${placeholder ? ':' + placeholder : ''}}`;
 *  }
 * }
 * @return {String}
 */
function stylesheet_formatters_es_index(tree, profile, syntax, options) {
	if (typeof syntax === 'object') {
		options = syntax;
		syntax = null;
	}

	if (!stylesheet_formatters_es_supports(syntax)) {
		// fallback to CSS if given syntax is not supported
		syntax = 'css';
	}

	options = stylesheet_formatters_es__extends({}, options, {
		format: getFormat(syntax, options)
	});

	// CSS abbreviations doesn’t support nesting so simply
	// output root node children
	return css(tree, profile, options);
}

/**
 * Check if given syntax is supported
 * @param {String} syntax
 * @return {Boolean}
 */
function stylesheet_formatters_es_supports(syntax) {
	return !!syntax && syntax in syntaxFormat;
}

/**
 * Returns formatter object for given syntax
 * @param  {String} syntax
 * @param  {Object} [options]
 * @return {Object} Formatter object as defined in `syntaxFormat`
 */
function getFormat(syntax, options) {
	let format = syntaxFormat[syntax];
	if (typeof format === 'string') {
		format = syntaxFormat[format];
	}

	return stylesheet_formatters_es__extends({}, format, options && options.format);
}

/* harmony default export */ var stylesheet_formatters_es = (stylesheet_formatters_es_index);

//# sourceMappingURL=stylesheet-formatters.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/snippets/dist/snippets.es.js
var snippets_es_html = {
	"a": "a[href]",
	"a:blank": "a[href='http://${0}' target='_blank' rel='noopener noreferrer']",
	"a:link": "a[href='http://${0}']",
	"a:mail": "a[href='mailto:${0}']",
	"a:tel": "a[href='tel:+${0}']",
	"abbr": "abbr[title]",
	"acr|acronym": "acronym[title]",
	"base": "base[href]/",
	"basefont": "basefont/",
	"br": "br/",
	"frame": "frame/",
	"hr": "hr/",
	"bdo": "bdo[dir]",
	"bdo:r": "bdo[dir=rtl]",
	"bdo:l": "bdo[dir=ltr]",
	"col": "col/",
	"link": "link[rel=stylesheet href]/",
	"link:css": "link[href='${1:style}.css']",
	"link:print": "link[href='${1:print}.css' media=print]",
	"link:favicon": "link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']",
	"link:mf|link:manifest": "link[rel='manifest' href='${1:manifest.json}']",
	"link:touch": "link[rel=apple-touch-icon href='${1:favicon.png}']",
	"link:rss": "link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']",
	"link:atom": "link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']",
	"link:im|link:import": "link[rel=import href='${1:component}.html']",
	"meta": "meta/",
	"meta:utf": "meta[http-equiv=Content-Type content='text/html;charset=UTF-8']",
	"meta:vp": "meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']",
	"meta:compat": "meta[http-equiv=X-UA-Compatible content='${1:IE=7}']",
	"meta:edge": "meta:compat[content='${1:ie=edge}']",
	"meta:redirect": "meta[http-equiv=refresh content='0; url=${1:http://example.com}']",
	"style": "style",
	"script": "script[!src]",
	"script:src": "script[src]",
	"img": "img[src alt]/",
	"img:s|img:srcset": "img[srcset src alt]",
	"img:z|img:sizes": "img[sizes srcset src alt]",
	"picture": "picture",
	"src|source": "source/",
	"src:sc|source:src": "source[src type]",
	"src:s|source:srcset": "source[srcset]",
	"src:t|source:type": "source[srcset type='${1:image/}']",
	"src:z|source:sizes": "source[sizes srcset]",
	"src:m|source:media": "source[media='(${1:min-width: })' srcset]",
	"src:mt|source:media:type": "source:media[type='${2:image/}']",
	"src:mz|source:media:sizes": "source:media[sizes srcset]",
	"src:zt|source:sizes:type": "source[sizes srcset type='${1:image/}']",
	"iframe": "iframe[src frameborder=0]",
	"embed": "embed[src type]/",
	"object": "object[data type]",
	"param": "param[name value]/",
	"map": "map[name]",
	"area": "area[shape coords href alt]/",
	"area:d": "area[shape=default]",
	"area:c": "area[shape=circle]",
	"area:r": "area[shape=rect]",
	"area:p": "area[shape=poly]",
	"form": "form[action]",
	"form:get": "form[method=get]",
	"form:post": "form[method=post]",
	"label": "label[for]",
	"input": "input[type=${1:text}]/",
	"inp": "input[name=${1} id=${1}]",
	"input:h|input:hidden": "input[type=hidden name]",
	"input:t|input:text": "inp[type=text]",
	"input:search": "inp[type=search]",
	"input:email": "inp[type=email]",
	"input:url": "inp[type=url]",
	"input:p|input:password": "inp[type=password]",
	"input:datetime": "inp[type=datetime]",
	"input:date": "inp[type=date]",
	"input:datetime-local": "inp[type=datetime-local]",
	"input:month": "inp[type=month]",
	"input:week": "inp[type=week]",
	"input:time": "inp[type=time]",
	"input:tel": "inp[type=tel]",
	"input:number": "inp[type=number]",
	"input:color": "inp[type=color]",
	"input:c|input:checkbox": "inp[type=checkbox]",
	"input:r|input:radio": "inp[type=radio]",
	"input:range": "inp[type=range]",
	"input:f|input:file": "inp[type=file]",
	"input:s|input:submit": "input[type=submit value]",
	"input:i|input:image": "input[type=image src alt]",
	"input:b|input:button": "input[type=button value]",
	"input:reset": "input:button[type=reset]",
	"isindex": "isindex/",
	"select": "select[name=${1} id=${1}]",
	"select:d|select:disabled": "select[disabled.]",
	"opt|option": "option[value]",
	"textarea": "textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]",
	"marquee": "marquee[behavior direction]",
	"menu:c|menu:context": "menu[type=context]",
	"menu:t|menu:toolbar": "menu[type=toolbar]",
	"video": "video[src]",
	"audio": "audio[src]",
	"html:xml": "html[xmlns=http://www.w3.org/1999/xhtml]",
	"keygen": "keygen/",
	"command": "command/",
	"btn:s|button:s|button:submit": "button[type=submit]",
	"btn:r|button:r|button:reset": "button[type=reset]",
	"btn:d|button:d|button:disabled": "button[disabled.]",
	"fst:d|fset:d|fieldset:d|fieldset:disabled": "fieldset[disabled.]",

	"bq": "blockquote",
	"fig": "figure",
	"figc": "figcaption",
	"pic": "picture",
	"ifr": "iframe",
	"emb": "embed",
	"obj": "object",
	"cap": "caption",
	"colg": "colgroup",
	"fst": "fieldset",
	"btn": "button",
	"optg": "optgroup",
	"tarea": "textarea",
	"leg": "legend",
	"sect": "section",
	"art": "article",
	"hdr": "header",
	"ftr": "footer",
	"adr": "address",
	"dlg": "dialog",
	"str": "strong",
	"prog": "progress",
	"mn": "main",
	"tem": "template",
	"fset": "fieldset",
	"datag": "datagrid",
	"datal": "datalist",
	"kg": "keygen",
	"out": "output",
	"det": "details",
	"cmd": "command",

	"ri:d|ri:dpr": "img:s",
	"ri:v|ri:viewport": "img:z",
	"ri:a|ri:art": "pic>src:m+img",
	"ri:t|ri:type": "pic>src:t+img",

	"!!!": "{<!DOCTYPE html>}",
	"doc": "html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body",
	"!|html:5": "!!!+doc",

	"c": "{<!-- ${0} -->}",
	"cc:ie": "{<!--[if IE]>${0}<![endif]-->}",
	"cc:noie": "{<!--[if !IE]><!-->${0}<!--<![endif]-->}"
};

var snippets_es_css = {
	"@f": "@font-face {\n\tfont-family: ${1};\n\tsrc: url(${1});\n}",
	"@ff": "@font-face {\n\tfont-family: '${1:FontName}';\n\tsrc: url('${2:FileName}.eot');\n\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\n\t\t url('${2:FileName}.woff') format('woff'),\n\t\t url('${2:FileName}.ttf') format('truetype'),\n\t\t url('${2:FileName}.svg#${1:FontName}') format('svg');\n\tfont-style: ${3:normal};\n\tfont-weight: ${4:normal};\n}",
	"@i|@import": "@import url(${0});",
	"@kf": "@keyframes ${1:identifier} {\n\t${2}\n}",
	"@m|@media": "@media ${1:screen} {\n\t${0}\n}",
	"ac": "align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly",
	"ai": "align-items:start|end|flex-start|flex-end|center|baseline|stretch",
	"anim": "animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}",
	"animdel": "animation-delay:${1:time}",
	"animdir": "animation-direction:normal|reverse|alternate|alternate-reverse",
	"animdur": "animation-duration:${1:0}s",
	"animfm": "animation-fill-mode:both|forwards|backwards",
	"animic": "animation-iteration-count:1|infinite",
	"animn": "animation-name",
	"animps": "animation-play-state:running|paused",
	"animtf": "animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})",
	"ap": "appearance:none",
	"as": "align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch",
	"b": "bottom",
	"bd": "border:${1:1px} ${2:solid} ${3:#000}",
	"bdb": "border-bottom:${1:1px} ${2:solid} ${3:#000}",
	"bdbc": "border-bottom-color:${1:#000}",
	"bdbi": "border-bottom-image:url(${0})",
	"bdbk": "border-break:close",
	"bdbli": "border-bottom-left-image:url(${0})|continue",
	"bdblrs": "border-bottom-left-radius",
	"bdbri": "border-bottom-right-image:url(${0})|continue",
	"bdbrrs": "border-bottom-right-radius",
	"bdbs": "border-bottom-style",
	"bdbw": "border-bottom-width",
	"bdc": "border-color:${1:#000}",
	"bdci": "border-corner-image:url(${0})|continue",
	"bdcl": "border-collapse:collapse|separate",
	"bdf": "border-fit:repeat|clip|scale|stretch|overwrite|overflow|space",
	"bdi": "border-image:url(${0})",
	"bdl": "border-left:${1:1px} ${2:solid} ${3:#000}",
	"bdlc": "border-left-color:${1:#000}",
	"bdlen": "border-length",
	"bdli": "border-left-image:url(${0})",
	"bdls": "border-left-style",
	"bdlw": "border-left-width",
	"bdr": "border-right:${1:1px} ${2:solid} ${3:#000}",
	"bdrc": "border-right-color:${1:#000}",
	"bdri": "border-right-image:url(${0})",
	"bdrs": "border-radius",
	"bdrst": "border-right-style",
	"bdrw": "border-right-width",
	"bds": "border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset",
	"bdsp": "border-spacing",
	"bdt": "border-top:${1:1px} ${2:solid} ${3:#000}",
	"bdtc": "border-top-color:${1:#000}",
	"bdti": "border-top-image:url(${0})",
	"bdtli": "border-top-left-image:url(${0})|continue",
	"bdtlrs": "border-top-left-radius",
	"bdtri": "border-top-right-image:url(${0})|continue",
	"bdtrrs": "border-top-right-radius",
	"bdts": "border-top-style",
	"bdtw": "border-top-width",
	"bdw": "border-width",
	"bfv": "backface-visibility:hidden|visible",
	"bg": "background:${1:#000}",
	"bga": "background-attachment:fixed|scroll",
	"bgbk": "background-break:bounding-box|each-box|continuous",
	"bgc": "background-color:#${1:fff}",
	"bgcp": "background-clip:padding-box|border-box|content-box|no-clip",
	"bgi": "background-image:url(${0})",
	"bgo": "background-origin:padding-box|border-box|content-box",
	"bgp": "background-position:${1:0} ${2:0}",
	"bgpx": "background-position-x",
	"bgpy": "background-position-y",
	"bgr": "background-repeat:no-repeat|repeat-x|repeat-y|space|round",
	"bgsz": "background-size:contain|cover",
	"bxsh": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none",
	"bxsz": "box-sizing:border-box|content-box|border-box",
	"c": "color:${1:#000}",
	"cl": "clear:both|left|right|none",
	"cm": "/* ${0} */",
	"cnt": "content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters({$0})",
	"coi": "counter-increment",
	"colm": "columns",
	"colmc": "column-count",
	"colmf": "column-fill",
	"colmg": "column-gap",
	"colmr": "column-rule",
	"colmrc": "column-rule-color",
	"colmrs": "column-rule-style",
	"colmrw": "column-rule-width",
	"colms": "column-span",
	"colmw": "column-width",
	"cor": "counter-reset",
	"cp": "clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})",
	"cps": "caption-side:top|bottom",
	"cur": "cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text",
	"d": "display:grid|inline-grid|subgrid|block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group",
	"ec": "empty-cells:show|hide",
	"f": "font:${1:1em} ${2:sans-serif}",
	"fd": "font-display:auto|block|swap|fallback|optional",
	"fef": "font-effect:none|engrave|emboss|outline",
	"fem": "font-emphasize",
	"femp": "font-emphasize-position:before|after",
	"fems": "font-emphasize-style:none|accent|dot|circle|disc",
	"ff": "font-family:serif|sans-serif|cursive|fantasy|monospace",
	"fft": "font-family:\"Times New Roman\", Times, Baskerville, Georgia, serif",
	"ffa": "font-family:Arial, \"Helvetica Neue\", Helvetica, sans-serif",
	"ffv": "font-family:Verdana, Geneva, sans-serif",
	"fl": "float:left|right|none",
	"fs": "font-style:italic|normal|oblique",
	"fsm": "font-smoothing:antialiased|subpixel-antialiased|none",
	"fst": "font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
	"fv": "font-variant:normal|small-caps",
	"fvs": "font-variation-settings:normal|inherit|initial|unset",
	"fw": "font-weight:normal|bold|bolder|lighter",
	"fx": "flex",
	"fxb": "flex-basis:fill|max-content|min-content|fit-content|content",
	"fxd": "flex-direction:row|row-reverse|column|column-reverse",
	"fxf": "flex-flow",
	"fxg": "flex-grow",
	"fxsh": "flex-shrink",
	"fxw": "flex-wrap:nowrap|wrap|wrap-reverse",
	"fz": "font-size",
	"fza": "font-size-adjust",
	"gtc": "grid-template-columns:repeat()|minmax()",
	"gtr": "grid-template-rows:repeat()|minmax()",
	"gta": "grid-template-areas",
	"gt": "grid-template",
	"gg": "grid-gap",
	"gcg": "grid-column-gap",
	"grg": "grid-row-gap",
	"gac": "grid-auto-columns:auto|minmax()",
	"gar": "grid-auto-rows:auto|minmax()",
	"gaf": "grid-auto-flow:row|column|dense|inherit|initial|unset",
	"gd": "grid",
	"gc": "grid-column",
	"gcs": "grid-column-start",
	"gce": "grid-column-end",
	"gr": "grid-row",
	"grs": "grid-row-start",
	"gre": "grid-row-end",
	"ga": "grid-area",
	"h": "height",
	"jc": "justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly",
	"ji": "justify-items:start|end|center|stretch",
	"js": "justify-self:start|end|center|stretch",
	"l": "left",
	"lg": "background-image:linear-gradient(${1})",
	"lh": "line-height",
	"lis": "list-style",
	"lisi": "list-style-image",
	"lisp": "list-style-position:inside|outside",
	"list": "list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman",
	"lts": "letter-spacing:normal",
	"m": "margin",
	"mah": "max-height",
	"mar": "max-resolution",
	"maw": "max-width",
	"mb": "margin-bottom",
	"mih": "min-height",
	"mir": "min-resolution",
	"miw": "min-width",
	"ml": "margin-left",
	"mr": "margin-right",
	"mt": "margin-top",
	"ol": "outline",
	"olc": "outline-color:${1:#000}|invert",
	"olo": "outline-offset",
	"ols": "outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset",
	"olw": "outline-width|thin|medium|thick",
	"op": "opacity",
	"ord": "order",
	"ori": "orientation:landscape|portrait",
	"orp": "orphans",
	"ov": "overflow:hidden|visible|hidden|scroll|auto",
	"ovs": "overflow-style:scrollbar|auto|scrollbar|panner|move|marquee",
	"ovx": "overflow-x:hidden|visible|hidden|scroll|auto",
	"ovy": "overflow-y:hidden|visible|hidden|scroll|auto",
	"p": "padding",
	"pb": "padding-bottom",
	"pgba": "page-break-after:auto|always|left|right",
	"pgbb": "page-break-before:auto|always|left|right",
	"pgbi": "page-break-inside:auto|avoid",
	"pl": "padding-left",
	"pos": "position:relative|absolute|relative|fixed|static",
	"pr": "padding-right",
	"pt": "padding-top",
	"q": "quotes",
	"qen": "quotes:'\\201C' '\\201D' '\\2018' '\\2019'",
	"qru": "quotes:'\\00AB' '\\00BB' '\\201E' '\\201C'",
	"r": "right",
	"rsz": "resize:none|both|horizontal|vertical",
	"t": "top",
	"ta": "text-align:left|center|right|justify",
	"tal": "text-align-last:left|center|right",
	"tbl": "table-layout:fixed",
	"td": "text-decoration:none|underline|overline|line-through",
	"te": "text-emphasis:none|accent|dot|circle|disc|before|after",
	"th": "text-height:auto|font-size|text-size|max-size",
	"ti": "text-indent",
	"tj": "text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan",
	"to": "text-outline:${1:0} ${2:0} ${3:#000}",
	"tov": "text-overflow:ellipsis|clip",
	"tr": "text-replace",
	"trf": "transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})",
	"trfo": "transform-origin",
	"trfs": "transform-style:preserve-3d",
	"trs": "transition:${1:prop} ${2:time}",
	"trsde": "transition-delay:${1:time}",
	"trsdu": "transition-duration:${1:time}",
	"trsp": "transition-property:${1:prop}",
	"trstf": "transition-timing-function:${1:fn}",
	"tsh": "text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}",
	"tt": "text-transform:uppercase|lowercase|capitalize|none",
	"tw": "text-wrap:none|normal|unrestricted|suppress",
	"us": "user-select:none",
	"v": "visibility:hidden|visible|collapse",
	"va": "vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub",
	"w": "width",
	"whs": "white-space:nowrap|pre|pre-wrap|pre-line|normal",
	"whsc": "white-space-collapse:normal|keep-all|loose|break-strict|break-all",
	"wid": "widows",
	"wm": "writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl",
	"wob": "word-break:normal|keep-all|break-all",
	"wos": "word-spacing",
	"wow": "word-wrap:none|unrestricted|suppress|break-word|normal",
	"z": "z-index",
	"zom": "zoom:1"
};

var snippets_es_xsl = {
	"tm|tmatch": "xsl:template[match mode]",
	"tn|tname": "xsl:template[name]",
	"call": "xsl:call-template[name]",
	"ap": "xsl:apply-templates[select mode]",
	"api": "xsl:apply-imports",
	"imp": "xsl:import[href]",
	"inc": "xsl:include[href]",
	"ch": "xsl:choose",
	"wh|xsl:when": "xsl:when[test]",
	"ot": "xsl:otherwise",
	"if": "xsl:if[test]",
	"par": "xsl:param[name]",
	"pare": "xsl:param[name select]",
	"var": "xsl:variable[name]",
	"vare": "xsl:variable[name select]",
	"wp": "xsl:with-param[name select]",
	"key": "xsl:key[name match use]",
	"elem": "xsl:element[name]",
	"attr": "xsl:attribute[name]",
	"attrs": "xsl:attribute-set[name]",
	"cp": "xsl:copy[select]",
	"co": "xsl:copy-of[select]",
	"val": "xsl:value-of[select]",
	"for|each": "xsl:for-each[select]",
	"tex": "xsl:text",
	"com": "xsl:comment",
	"msg": "xsl:message[terminate=no]",
	"fall": "xsl:fallback",
	"num": "xsl:number[value]",
	"nam": "namespace-alias[stylesheet-prefix result-prefix]",
	"pres": "xsl:preserve-space[elements]",
	"strip": "xsl:strip-space[elements]",
	"proc": "xsl:processing-instruction[name]",
	"sort": "xsl:sort[select order]",
	"choose": "xsl:choose>xsl:when+xsl:otherwise",
	"xsl": "!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\n|}",
	"!!!": "{<?xml version=\"1.0\" encoding=\"UTF-8\"?>}"
};

var snippets_es_index = { html: snippets_es_html, css: snippets_es_css, xsl: snippets_es_xsl };

/* harmony default export */ var snippets_es = (snippets_es_index);
// CONCATENATED MODULE: ../node_modules/@emmetio/lorem/dist/lorem.es.js
var lorem_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



var latin = {
	"common": ["lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipisicing", "elit"],
	"words": ["exercitationem", "perferendis", "perspiciatis", "laborum", "eveniet", "sunt", "iure", "nam", "nobis", "eum", "cum", "officiis", "excepturi", "odio", "consectetur", "quasi", "aut", "quisquam", "vel", "eligendi", "itaque", "non", "odit", "tempore", "quaerat", "dignissimos", "facilis", "neque", "nihil", "expedita", "vitae", "vero", "ipsum", "nisi", "animi", "cumque", "pariatur", "velit", "modi", "natus", "iusto", "eaque", "sequi", "illo", "sed", "ex", "et", "voluptatibus", "tempora", "veritatis", "ratione", "assumenda", "incidunt", "nostrum", "placeat", "aliquid", "fuga", "provident", "praesentium", "rem", "necessitatibus", "suscipit", "adipisci", "quidem", "possimus", "voluptas", "debitis", "sint", "accusantium", "unde", "sapiente", "voluptate", "qui", "aspernatur", "laudantium", "soluta", "amet", "quo", "aliquam", "saepe", "culpa", "libero", "ipsa", "dicta", "reiciendis", "nesciunt", "doloribus", "autem", "impedit", "minima", "maiores", "repudiandae", "ipsam", "obcaecati", "ullam", "enim", "totam", "delectus", "ducimus", "quis", "voluptates", "dolores", "molestiae", "harum", "dolorem", "quia", "voluptatem", "molestias", "magni", "distinctio", "omnis", "illum", "dolorum", "voluptatum", "ea", "quas", "quam", "corporis", "quae", "blanditiis", "atque", "deserunt", "laboriosam", "earum", "consequuntur", "hic", "cupiditate", "quibusdam", "accusamus", "ut", "rerum", "error", "minus", "eius", "ab", "ad", "nemo", "fugit", "officia", "at", "in", "id", "quos", "reprehenderit", "numquam", "iste", "fugiat", "sit", "inventore", "beatae", "repellendus", "magnam", "recusandae", "quod", "explicabo", "doloremque", "aperiam", "consequatur", "asperiores", "commodi", "optio", "dolor", "labore", "temporibus", "repellat", "veniam", "architecto", "est", "esse", "mollitia", "nulla", "a", "similique", "eos", "alias", "dolore", "tenetur", "deleniti", "porro", "facere", "maxime", "corrupti"]
};

var ru = {
	"common": ["далеко-далеко", "за", "словесными", "горами", "в стране", "гласных", "и согласных", "живут", "рыбные", "тексты"],
	"words": ["вдали", "от всех", "они", "буквенных", "домах", "на берегу", "семантика", "большого", "языкового", "океана", "маленький", "ручеек", "даль", "журчит", "по всей", "обеспечивает", "ее", "всеми", "необходимыми", "правилами", "эта", "парадигматическая", "страна", "которой", "жаренные", "предложения", "залетают", "прямо", "рот", "даже", "всемогущая", "пунктуация", "не", "имеет", "власти", "над", "рыбными", "текстами", "ведущими", "безорфографичный", "образ", "жизни", "однажды", "одна", "маленькая", "строчка", "рыбного", "текста", "имени", "lorem", "ipsum", "решила", "выйти", "большой", "мир", "грамматики", "великий", "оксмокс", "предупреждал", "о", "злых", "запятых", "диких", "знаках", "вопроса", "коварных", "точках", "запятой", "но", "текст", "дал", "сбить", "себя", "толку", "он", "собрал", "семь", "своих", "заглавных", "букв", "подпоясал", "инициал", "за", "пояс", "пустился", "дорогу", "взобравшись", "первую", "вершину", "курсивных", "гор", "бросил", "последний", "взгляд", "назад", "силуэт", "своего", "родного", "города", "буквоград", "заголовок", "деревни", "алфавит", "подзаголовок", "своего", "переулка", "грустный", "реторический", "вопрос", "скатился", "его", "щеке", "продолжил", "свой", "путь", "дороге", "встретил", "рукопись", "она", "предупредила", "моей", "все", "переписывается", "несколько", "раз", "единственное", "что", "меня", "осталось", "это", "приставка", "возвращайся", "ты", "лучше", "свою", "безопасную", "страну", "послушавшись", "рукописи", "наш", "продолжил", "свой", "путь", "вскоре", "ему", "повстречался", "коварный", "составитель", "рекламных", "текстов", "напоивший", "языком", "речью", "заманивший", "свое", "агентство", "которое", "использовало", "снова", "снова", "своих", "проектах", "если", "переписали", "то", "живет", "там", "до", "сих", "пор"]
};

var sp = {
	"common": ["mujer", "uno", "dolor", "más", "de", "poder", "mismo", "si"],
	"words": ["ejercicio", "preferencia", "perspicacia", "laboral", "paño", "suntuoso", "molde", "namibia", "planeador", "mirar", "demás", "oficinista", "excepción", "odio", "consecuencia", "casi", "auto", "chicharra", "velo", "elixir", "ataque", "no", "odio", "temporal", "cuórum", "dignísimo", "facilismo", "letra", "nihilista", "expedición", "alma", "alveolar", "aparte", "león", "animal", "como", "paria", "belleza", "modo", "natividad", "justo", "ataque", "séquito", "pillo", "sed", "ex", "y", "voluminoso", "temporalidad", "verdades", "racional", "asunción", "incidente", "marejada", "placenta", "amanecer", "fuga", "previsor", "presentación", "lejos", "necesariamente", "sospechoso", "adiposidad", "quindío", "pócima", "voluble", "débito", "sintió", "accesorio", "falda", "sapiencia", "volutas", "queso", "permacultura", "laudo", "soluciones", "entero", "pan", "litro", "tonelada", "culpa", "libertario", "mosca", "dictado", "reincidente", "nascimiento", "dolor", "escolar", "impedimento", "mínima", "mayores", "repugnante", "dulce", "obcecado", "montaña", "enigma", "total", "deletéreo", "décima", "cábala", "fotografía", "dolores", "molesto", "olvido", "paciencia", "resiliencia", "voluntad", "molestias", "magnífico", "distinción", "ovni", "marejada", "cerro", "torre", "y", "abogada", "manantial", "corporal", "agua", "crepúsculo", "ataque", "desierto", "laboriosamente", "angustia", "afortunado", "alma", "encefalograma", "materialidad", "cosas", "o", "renuncia", "error", "menos", "conejo", "abadía", "analfabeto", "remo", "fugacidad", "oficio", "en", "almácigo", "vos", "pan", "represión", "números", "triste", "refugiado", "trote", "inventor", "corchea", "repelente", "magma", "recusado", "patrón", "explícito", "paloma", "síndrome", "inmune", "autoinmune", "comodidad", "ley", "vietnamita", "demonio", "tasmania", "repeler", "apéndice", "arquitecto", "columna", "yugo", "computador", "mula", "a", "propósito", "fantasía", "alias", "rayo", "tenedor", "deleznable", "ventana", "cara", "anemia", "corrupto"]
};

const langs = { latin, ru, sp };

const lorem_es_defaultOptions = {
	wordCount: 30,
	skipCommon: false,
	lang: 'latin'
};

/**
 * Replaces given parsed Emmet abbreviation node with nodes filled with
 * Lorem Ipsum stub text.
 * @param {Node} node
 * @return {Node}
 */
var lorem_es_index = function (node, options) {
	options = lorem_es__extends({}, lorem_es_defaultOptions, options);
	const dict = langs[options.lang] || langs.latin;
	const startWithCommon = !options.skipCommon && !isRepeating(node);

	if (!node.repeat && !lorem_es_isRoot(node.parent)) {
		// non-repeating element, insert text stub as a content of parent node
		// and remove current one
		node.parent.value = paragraph(dict, options.wordCount, startWithCommon);
		node.remove();
	} else {
		// Replace named node with generated content
		node.value = paragraph(dict, options.wordCount, startWithCommon);
		node.name = node.parent.name ? implicit_tag_es(node.parent.name) : null;
	}

	return node;
};

function lorem_es_isRoot(node) {
	return !node.parent;
}

/**
 * Returns random integer between <code>from</code> and <code>to</code> values
 * @param {Number} from
 * @param {Number} to
 * @returns {Number}
 */
function rand(from, to) {
	return Math.floor(Math.random() * (to - from) + from);
}

/**
 * @param {Array} arr
 * @param {Number} count
 * @returns {Array}
 */
function sample(arr, count) {
	const len = arr.length;
	const iterations = Math.min(len, count);
	const result = new Set();

	while (result.size < iterations) {
		result.add(arr[rand(0, len)]);
	}

	return Array.from(result);
}

function choice(val) {
	return val[rand(0, val.length - 1)];
}

function sentence(words, end) {
	if (words.length) {
		words = [capitalize(words[0])].concat(words.slice(1));
	}

	return words.join(' ') + (end || choice('?!...')); // more dots than question marks
}

function capitalize(word) {
	return word[0].toUpperCase() + word.slice(1);
}

/**
 * Insert commas at randomly selected words. This function modifies values
 * inside <code>words</code> array
 * @param {Array} words
 */
function insertCommas(words) {
	if (words.length < 2) {
		return words;
	}

	words = words.slice();
	const len = words.length;
	const hasComma = /,$/;
	let totalCommas = 0;

	if (len > 3 && len <= 6) {
		totalCommas = rand(0, 1);
	} else if (len > 6 && len <= 12) {
		totalCommas = rand(0, 2);
	} else {
		totalCommas = rand(1, 4);
	}

	for (let i = 0, pos, word; i < totalCommas; i++) {
		pos = rand(0, len - 2);
		if (!hasComma.test(words[pos])) {
			words[pos] += ',';
		}
	}

	return words;
}

/**
 * Generate a paragraph of "Lorem ipsum" text
 * @param {Object} dict Words dictionary (see `lang/*.json`)
 * @param {Number} wordCount Words count in paragraph
 * @param {Boolean} startWithCommon Should paragraph start with common
 * "lorem ipsum" sentence.
 * @returns {String}
 */
function paragraph(dict, wordCount, startWithCommon) {
	const result = [];
	let totalWords = 0;
	let words;

	if (startWithCommon && dict.common) {
		words = dict.common.slice(0, wordCount);
		totalWords += words.length;
		result.push(sentence(insertCommas(words), '.'));
	}

	while (totalWords < wordCount) {
		words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));
		totalWords += words.length;
		result.push(sentence(insertCommas(words)));
	}

	return result.join(' ');
}

/**
 * Check if given node is in repeating context, e.g. node itself or one of its
 * parent is repeated
 * @param  {Node}  node
 * @return {Boolean}
 */
function isRepeating(node) {
	while (node.parent) {
		if (node.repeat && node.repeat.value && node.repeat.value > 1) {
			return true;
		}

		node = node.parent;
	}

	return false;
}

/* harmony default export */ var lorem_es = (lorem_es_index);
// CONCATENATED MODULE: ../node_modules/@emmetio/snippets-registry/dist/snippets-registry.es.js
let Snippet = class Snippet {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
};
let SnippetsStorage = class SnippetsStorage {
    constructor(data) {
        this._string = new Map();
        this._regexp = new Map();
        this._disabled = false;

        this.load(data);
    }

    get disabled() {
        return this._disabled;
    }

    /**
     * Disables current store. A disabled store always returns `undefined`
     * on `get()` method
     */
    disable() {
        this._disabled = true;
    }

    /**
     * Enables current store.
     */
    enable() {
        this._disabled = false;
    }

    /**
     * Registers a new snippet item
     * @param {String|Regexp} key
     * @param {String|Function} value
     */
    set(key, value) {
        if (typeof key === 'string') {
            key.split('|').forEach(k => this._string.set(k, new Snippet(k, value)));
        } else if (key instanceof RegExp) {
            this._regexp.set(key, new Snippet(key, value));
        } else {
            throw new Error('Unknow snippet key: ' + key);
        }

        return this;
    }

    /**
     * Returns a snippet matching given key. It first tries to find snippet
     * exact match in a string key map, then tries to match one with regexp key
     * @param {String} key
     * @return {Snippet}
     */
    get(key) {
        if (this.disabled) {
            return undefined;
        }

        if (this._string.has(key)) {
            return this._string.get(key);
        }

        const keys = Array.from(this._regexp.keys());
        for (let i = 0, il = keys.length; i < il; i++) {
            if (keys[i].test(key)) {
                return this._regexp.get(keys[i]);
            }
        }
    }

    /**
     * Batch load of snippets data
     * @param {Object|Map} data
     */
    load(data) {
        this.reset();
        if (data instanceof Map) {
            data.forEach((value, key) => this.set(key, value));
        } else if (data && typeof data === 'object') {
            Object.keys(data).forEach(key => this.set(key, data[key]));
        }
    }

    /**
     * Clears all stored snippets
     */
    reset() {
        this._string.clear();
        this._regexp.clear();
    }

    /**
     * Returns all available snippets from given store
     */
    values() {
        if (this.disabled) {
            return [];
        }

        const string = Array.from(this._string.values());
        const regexp = Array.from(this._regexp.values());
        return string.concat(regexp);
    }
};

/**
 * A snippets registry. Contains snippets, separated by store and sorted by
 * priority: a store with higher priority takes precedence when resolving snippet
 * for given key
 */

let SnippetsRegistry = class SnippetsRegistry {
    /**
     * Creates snippets registry, filled with given `data`
     * @param {Object|Array} data Registry snippets. If array is given, adds items
     * from array in order of precedence, registers global snippets otherwise
     */
    constructor(data) {
        this._registry = [];

        if (Array.isArray(data)) {
            data.forEach((snippets, level) => this.add(level, snippets));
        } else if (typeof data === 'object') {
            this.add(data);
        }
    }

    /**
     * Return store for given level
     * @param {Number} level
     * @return {SnippetsStorage}
     */
    get(level) {
        for (let i = 0; i < this._registry.length; i++) {
            const item = this._registry[i];
            if (item.level === level) {
                return item.store;
            }
        }
    }

    /**
     * Adds new store for given level
     * @param {Number} [level] Store level (priority). Store with higher level
     * takes precedence when resolving snippets
     * @param {Object} [snippets] A snippets data for new store
     * @return {SnipetsStorage}
     */
    add(level, snippets) {
        if (level != null && typeof level === 'object') {
            snippets = level;
            level = 0;
        }

        const store = new SnippetsStorage(snippets);

        // remove previous store from same level
        this.remove(level);

        this._registry.push({ level, store });
        this._registry.sort((a, b) => b.level - a.level);

        return store;
    }

    /**
     * Remove registry with given level or store
     * @param {Number|SnippetsStorage} data Either level or snippets store
     */
    remove(data) {
        this._registry = this._registry.filter(item => item.level !== data && item.store !== data);
    }

    /**
     * Returns snippet from registry that matches given name
     * @param {String} name
     * @return {Snippet}
     */
    resolve(name) {
        for (let i = 0; i < this._registry.length; i++) {
            const snippet = this._registry[i].store.get(name);
            if (snippet) {
                return snippet;
            }
        }
    }

    /**
     * Returns all available snippets from current registry. Snippets with the
     * same key are resolved by their storage priority.
     * @param {Object} options
     * @param {Object} options.type Return snippets only of given type: 'string'
     * or 'regexp'. Returns all snippets if not defined
     * @return {Array}
     */
    all(options) {
        options = options || {};
        const result = new Map();

        const fillResult = snippet => {
            const type = snippet.key instanceof RegExp ? 'regexp' : 'string';
            if ((!options.type || options.type === type) && !result.has(snippet.key)) {
                result.set(snippet.key, snippet);
            }
        };

        this._registry.forEach(item => {
            item.store.values().forEach(fillResult);
        });

        return Array.from(result.values());
    }

    /**
     * Removes all stores from registry
     */
    clear() {
        this._registry.length = 0;
    }
};


/* harmony default export */ var snippets_registry_es = (SnippetsRegistry);
// CONCATENATED MODULE: ../node_modules/@emmetio/output-profile/dist/output-profile.es.js
var output_profile_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * @type {EmmetOutputProfile}
 */
var output_profile_es_defaultOptions = {
	indent: '\t',
	tagCase: '',
	attributeCase: '',
	attributeQuotes: 'double',
	format: true,
	formatSkip: ['html'],
	formatForce: ['body'],
	inlineBreak: 3,
	compactBooleanAttributes: false,
	booleanAttributes: ['contenteditable', 'seamless', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate', 'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly', 'required', 'reversed', 'selected', 'typemustmatch'],
	selfClosingStyle: 'html',
	inlineElements: ['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo', 'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q', 's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'textarea', 'tt', 'u', 'var']
};

/**
 * Creates output profile for given options
 */
let Profile = class Profile {
	/**
  * @param {EmmetOutputProfile} options 
  */
	constructor(options) {
		/** @type {EmmetOutputProfile} */
		this.options = output_profile_es__extends({}, output_profile_es_defaultOptions, options);
		this.quoteChar = this.options.attributeQuotes === 'single' ? '\'' : '"';
	}

	/**
  * Returns value of given option name
  * @param {String} name
  * @return {*}
  */
	get(name) {
		return this.options[name];
	}

	/**
  * Quote given string according to profile
  * @param {String} str String to quote
  * @return {String}
  */
	quote(str) {
		return `${this.quoteChar}${str != null ? str : ''}${this.quoteChar}`;
	}

	/**
  * Output given tag name according to options
  * @param {String} name
  * @return {String}
  */
	name(name) {
		return strcase(name, this.options.tagCase);
	}

	/**
  * Outputs attribute name according to current settings
  * @param {String} attr Attribute name
  * @return {String}
  */
	attribute(attr) {
		return strcase(attr, this.options.attributeCase);
	}

	/**
  * Check if given attribute is boolean
  * @param {Object} attr
  * @return {Boolean}
  */
	isBooleanAttribute(attr) {
		return attr.options.boolean || this.get('booleanAttributes').indexOf((attr.name || '').toLowerCase()) !== -1;
	}

	/**
  * Returns a token for self-closing tag, depending on current options
  * @return {String}
  */
	selfClose() {
		switch (this.options.selfClosingStyle) {
			case 'xhtml':
				return ' /';
			case 'xml':
				return '/';
			default:
				return '';
		}
	}

	/**
  * Returns indent for given level
  * @param {Number} level Indentation level
  * @return {String}
  */
	indent(level) {
		level = level || 0;
		let output = '';
		while (level--) {
			output += this.options.indent;
		}

		return output;
	}

	/**
  * Check if given tag name belongs to inline-level element
  * @param {Object|String} node Parsed node or tag name
  * @return {Boolean}
  */
	isInline(node) {
		if (typeof node === 'string') {
			return this.get('inlineElements').indexOf(node.toLowerCase()) !== -1;
		}

		// inline node is a node either with inline-level name or text-only node
		return node.name != null ? this.isInline(node.name) : node.isTextOnly;
	}

	/**
  * Outputs formatted field for given params
  * @param {Number} index Field index
  * @param {String} [placeholder] Field placeholder, can be empty
  * @return {String}
  */
	field(index, placeholder) {
		return this.options.field(index, placeholder);
	}
};

function strcase(string, type) {
	if (type) {
		return type === 'upper' ? string.toUpperCase() : string.toLowerCase();
	}

	return string;
}

/* harmony default export */ var output_profile_es = (Profile);
// CONCATENATED MODULE: ../node_modules/@emmetio/expand-abbreviation/dist/expand.es.js
var expand_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };














/**
 * Expands given abbreviation into code
 * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation
 * @param  {Object} config
 * @return {String}
 */
function expand(abbr, config) {
	config = expand_es__extends({}, config);

	if (typeof abbr === 'string') {
		abbr = expand_es_parse(abbr, config);
	}

	return markup_formatters_es(abbr, config.profile, config.syntax, config);
}

/**
 * Parses given Emmet abbreviation into a final abbreviation tree with all
 * required transformations applied
 * @param {String} Abbreviation to parse
 * @param  {Object} config
 * @return {Node}
 */
function expand_es_parse(abbr, config) {
	return abbreviation_es(abbr).use(html_snippets_resolver_es, config.snippets).use(variable_resolver_es, config.variables).use(html_transform_es, config.text, config.options);
}

/**
 * Expands given abbreviation into code
 * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation
 * @param  {Object} config
 * @return {String}
 */
function expand$1(abbr, config) {
	config = config || {};

	if (typeof abbr === 'string') {
		abbr = parse$1(abbr, config);
	}

	return stylesheet_formatters_es(abbr, config.profile, config.syntax, config);
}

/**
 * Parses given Emmet abbreviation into a final abbreviation tree with all
 * required transformations applied
 * @param {String|Node} abbr Abbreviation to parse or already parsed abbreviation
 * @param  {Object} config
 * @return {Node}
 */
function parse$1(abbr, config) {
	if (typeof abbr === 'string') {
		abbr = css_abbreviation_es(abbr);
	}

	return abbr.use(css_snippets_resolver_es, config.snippets, config.options);
}

const reLorem = /^lorem([a-z]*)(\d*)$/i;

/**
 * Constructs a snippets registry, filled with snippets, for given options
 * @param  {String} syntax  Abbreviation syntax
 * @param  {Object|Object[]} snippets Additional snippets
 * @return {SnippetsRegistry}
 */
function snippetsRegistryFactory(type, syntax, snippets) {
	const registrySnippets = [];

	if (type === 'markup') {
		registrySnippets.push(snippets_es.html);
	} else if (type === 'stylesheet') {
		registrySnippets.push(snippets_es.css);
	}

	if (syntax in snippets_es && registrySnippets.indexOf(snippets_es[syntax]) === -1) {
		registrySnippets.push(snippets_es[syntax]);
	}

	if (Array.isArray(snippets)) {
		snippets.forEach(item => {
			// if array item is a string, treat it as a reference to globally
			// defined snippets
			registrySnippets.push(typeof item === 'string' ? snippets_es[item] : item);
		});
	} else if (typeof snippets === 'object') {
		registrySnippets.push(snippets);
	}

	const registry = new snippets_registry_es(registrySnippets.filter(Boolean));

	// for non-stylesheet syntaxes add Lorem Ipsum generator
	if (type !== 'stylesheet') {
		registry.get(0).set(reLorem, loremGenerator);
	}

	return registry;
}

function loremGenerator(node) {
	const options = {};
	const m = node.name.match(reLorem);
	if (m[1]) {
		options.lang = m[1];
	}

	if (m[2]) {
		options.wordCount = +m[2];
	}

	return lorem_es(node, options);
}

/**
 * Default variables used in snippets to insert common values into predefined snippets
 * @type {Object}
 */
const defaultVariables = {
	lang: 'en',
	locale: 'en-US',
	charset: 'UTF-8'
};

/**
 * A list of syntaxes that should use Emmet CSS abbreviations:
 * a variations of default abbreviation that holds values right in abbreviation name
 * @type {Array}
 */
const stylesheetSyntaxes = ['css', 'sass', 'scss', 'less', 'stylus', 'sss'];

const expand_es_defaultOptions = {
	/**
  * Type of abbreviation to parse: 'markup' or 'stylesheet'.
  * Can be auto-detected from `syntax` property. Default is 'markup'
  */
	type: null,

	/**
  * Abbreviation output syntax
  * @type {String}
  */
	syntax: 'html',

	/**
  * Field/tabstop generator for editor. Most editors support TextMate-style
  * fields: ${0} or ${1:item}. So for TextMate-style fields this function
  * will look like this:
  * @example
  * (index, placeholder) => `\${${index}${placeholder ? ':' + placeholder : ''}}`
  *
  * @param  {Number} index         Placeholder index. Fields with the same indices
  * should be linked
  * @param  {String} [placeholder] Field placeholder
  * @return {String}
  */
	field: (index, placeholder) => placeholder || '',

	/**
  * Insert given text string(s) into expanded abbreviation
  * If array of strings is given, the implicitly repeated element (e.g. `li*`)
  * will be repeated by the amount of items in array
  * @type {String|String[]}
  */
	text: null,

	/**
  * Either predefined output profile or options for output profile. Used for
  * abbreviation output
  * @type {Profile|Object}
  */
	profile: null,

	/**
  * Custom variables for variable resolver
  * @see @emmetio/variable-resolver
  * @type {Object}
  */
	variables: {},

	/**
  * Custom predefined snippets for abbreviation. The expanded abbreviation
  * will try to match given snippets that may contain custom elements,
  * predefined attributes etc.
  * May also contain array of items: either snippets (Object) or references
  * to default syntax snippets (String; the key in default snippets hash)
  * @see @emmetio/snippets
  * @type {Object|SnippetsRegistry}
  */
	snippets: {},

	/**
  * Hash of additional transformations that should be applied to expanded
  * abbreviation, like BEM or JSX. Since these transformations introduce
  * side-effect, they are disabled by default and should be enabled by
  * providing a transform name as a key and transform options as value:
  * @example
  * {
  *     bem: {element: '--'},
  *     jsx: true // no options, just enable transform
  * }
  * @see @emmetio/html-transform/lib/addons
  * @type {Object}
  */
	options: null,

	/**
  * Additional options for syntax formatter
  * @see @emmetio/markup-formatters
  * @type {Object}
  */
	format: null
};

/**
 * Expands given abbreviation into string, formatted according to provided
 * syntax and options
 * @param  {String|Node} abbr       Abbreviation string or parsed abbreviation tree
 * @param  {String|Object} [config] Parsing and formatting options (object) or
 * abbreviation syntax (string)
 * @return {String}
 */
function expand$2(abbr, config) {
	config = createOptions(config);

	return getType(config.type, config.syntax) === 'stylesheet' ? expand$1(abbr, config) : expand(abbr, config);
}

/**
 * Parses given abbreviation into AST tree. This tree can be later formatted to
 * string with `expand` function
 * @param  {String} abbr             Abbreviation to parse
 * @param  {String|Object} [options] Parsing and formatting options (object) or
 * abbreviation syntax (string)
 * @return {Node}
 */
function parse$2(abbr, options) {
	options = createOptions(options);

	return getType(options.type, options.syntax) === 'stylesheet' ? parse$1(abbr, options) : expand_es_parse(abbr, options);
}

/**
 * Creates snippets registry for given syntax and additional `snippets`
 * @param  {String} type     Abbreviation type, 'markup' or 'stylesheet'
 * @param  {String} syntax   Snippets syntax, used for retrieving predefined snippets
 * @param  {SnippetsRegistry|Object|Object[]} [snippets] Additional snippets
 * @return {SnippetsRegistry}
 */
function createSnippetsRegistry(type, syntax, snippets) {
	// Backward-compatibility with <0.6
	if (type && type !== 'markup' && type !== 'stylesheet') {
		snippets = syntax;
		syntax = type;
		type = 'markup';
	}

	return snippets instanceof snippets_registry_es ? snippets : snippetsRegistryFactory(type, syntax, snippets);
}

function createOptions(options) {
	if (typeof options === 'string') {
		options = { syntax: options };
	}

	options = expand_es__extends({}, expand_es_defaultOptions, options);
	if (options.type == null && options.syntax) {
		options.type = isStylesheet(options.syntax) ? 'stylesheet' : 'markup';
	}

	options.format = expand_es__extends({ field: options.field }, options.format);
	options.profile = createProfile(options);
	options.variables = expand_es__extends({}, defaultVariables, options.variables);
	options.snippets = createSnippetsRegistry(options.type, options.syntax, options.snippets);

	return options;
}

/**
 * Check if given syntax belongs to stylesheet markup.
 * Emmet uses different abbreviation flavours: one is a default markup syntax,
 * used for HTML, Slim, Pug etc, the other one is used for stylesheets and
 * allows embedded values in abbreviation name
 * @param  {String}  syntax
 * @return {Boolean}
 */
function isStylesheet(syntax) {
	return stylesheetSyntaxes.indexOf(syntax) !== -1;
}

/**
 * Creates output profile from given options
 * @param  {Object} options
 * @return {Profile}
 */
function createProfile(options) {
	return options.profile instanceof output_profile_es ? options.profile : new output_profile_es(options.profile);
}

/**
 * Returns type of abbreviation expander: either 'markup' or 'stylesheet'
 * @param {String} type
 * @param {String} [syntax]
 */
function getType(type, syntax) {
	if (type) {
		return type === 'stylesheet' ? 'stylesheet' : 'markup';
	}

	return isStylesheet(syntax) ? 'stylesheet' : 'markup';
}


//# sourceMappingURL=expand.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/css-snippets-resolver/dist/css-snippets-resolver.es.js
var dist_css_snippets_resolver_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

const dist_css_snippets_resolver_es_DASH = 45; // -

/**
 * Calculates fuzzy match score of how close `abbr` matches given `string`.
 * @param  {String} abbr        Abbreviation to score
 * @param  {String} string      String to match
 * @param  {Number} [fuzziness] Fuzzy factor
 * @return {Number}             Match score
 */
function css_snippets_resolver_es_stringScore(abbr, string) {
	abbr = abbr.toLowerCase();
	string = string.toLowerCase();

	if (abbr === string) {
		return 1;
	}

	// a string MUST start with the same character as abbreviation
	if (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {
		return 0;
	}

	const abbrLength = abbr.length;
	const stringLength = string.length;
	let i = 1,
	    j = 1,
	    score = stringLength;
	let ch1, ch2, found, acronym;

	while (i < abbrLength) {
		ch1 = abbr.charCodeAt(i);
		found = false;
		acronym = false;

		while (j < stringLength) {
			ch2 = string.charCodeAt(j);

			if (ch1 === ch2) {
				found = true;
				score += (stringLength - j) * (acronym ? 2 : 1);
				break;
			}

			// add acronym bonus for exactly next match after unmatched `-`
			acronym = ch2 === dist_css_snippets_resolver_es_DASH;
			j++;
		}

		if (!found) {
			break;
		}

		i++;
	}

	return score && score * (i / abbrLength) / css_snippets_resolver_es_sum(stringLength);
}

/**
 * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n
 * @param  {Number} n
 * @return {Number}
 */
function css_snippets_resolver_es_sum(n) {
	return n * (n + 1) / 2;
}

const css_snippets_resolver_es_reProperty = /^([a-z\-]+)(?:\s*:\s*([^\n\r]+))?$/;
const dist_css_snippets_resolver_es_DASH$1 = 45; // -

/**
 * Creates a special structure for resolving CSS properties from plain CSS
 * snippets.
 * Almost all CSS snippets are aliases for real CSS properties with available
 * value variants, optionally separated by `|`. Most values are keywords that
 * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,
 * more specific properties, like `border` and `border-style`. For such cases
 * keywords from more specific properties should be available in shorthands too.
 * @param {Snippet[]} snippets
 * @return {CSSSnippet[]}
 */
function css_snippets_resolver_es_cssSnippets(snippets) {
	return css_snippets_resolver_es_nest(snippets.map(snippet => new css_snippets_resolver_es_CSSSnippet(snippet.key, snippet.value)));
}

let css_snippets_resolver_es_CSSSnippet = class CSSSnippet {
	constructor(key, value) {
		this.key = key;
		this.value = value;
		this.property = null;

		// detect if given snippet is a property
		const m = value && value.match(css_snippets_resolver_es_reProperty);
		if (m) {
			this.property = m[1];
			this.value = m[2];
		}

		this.dependencies = [];
	}

	addDependency(dep) {
		this.dependencies.push(dep);
	}

	get defaultValue() {
		return this.value != null ? css_snippets_resolver_es_splitValue(this.value)[0] : null;
	}

	/**
     * Returns list of unique keywords for current CSS snippet and its dependencies
     * @return {String[]}
     */
	keywords() {
		const stack = [];
		const keywords = new Set();
		let i = 0,
		    item,
		    candidates;

		if (this.property) {
			// scan valid CSS-properties only
			stack.push(this);
		}

		while (i < stack.length) {
			// NB Keep items in stack instead of push/pop to avoid possible
			// circular references
			item = stack[i++];

			if (item.value) {
				candidates = css_snippets_resolver_es_splitValue(item.value).filter(dist_css_snippets_resolver_es_isKeyword);

				// extract possible keywords from snippet value
				for (let j = 0; j < candidates.length; j++) {
					keywords.add(candidates[j].trim());
				}

				// add dependencies into scan stack
				for (let j = 0, deps = item.dependencies; j < deps.length; j++) {
					if (stack.indexOf(deps[j]) === -1) {
						stack.push(deps[j]);
					}
				}
			}
		}

		return Array.from(keywords);
	}
};

/**
 * Nests more specific CSS properties into shorthand ones, e.g.
 * background-position-x -> background-position -> background
 * @param  {CSSSnippet[]} snippets
 * @return {CSSSnippet[]}
 */

function css_snippets_resolver_es_nest(snippets) {
	snippets = snippets.sort(css_snippets_resolver_es_snippetsSort);
	const stack = [];

	// For sorted list of CSS properties, create dependency graph where each
	// shorthand property contains its more specific one, e.g.
	// backgound -> background-position -> background-position-x
	for (let i = 0, cur, prev; i < snippets.length; i++) {
		cur = snippets[i];

		if (!cur.property) {
			// not a CSS property, skip it
			continue;
		}

		// Check if current property belongs to one from parent stack.
		// Since `snippets` array is sorted, items are perfectly aligned
		// from shorthands to more specific variants
		while (stack.length) {
			prev = stack[stack.length - 1];

			if (cur.property.indexOf(prev.property) === 0 && cur.property.charCodeAt(prev.property.length) === dist_css_snippets_resolver_es_DASH$1) {
				prev.addDependency(cur);
				stack.push(cur);
				break;
			}

			stack.pop();
		}

		if (!stack.length) {
			stack.push(cur);
		}
	}

	return snippets;
}

/**
 * A sorting function for array of snippets
 * @param  {CSSSnippet} a
 * @param  {CSSSnippet} b
 * @return {Number}
 */
function css_snippets_resolver_es_snippetsSort(a, b) {
	if (a.key === b.key) {
		return 0;
	}

	return a.key < b.key ? -1 : 1;
}

/**
 * Check if given string is a keyword candidate
 * @param  {String}  str
 * @return {Boolean}
 */
function dist_css_snippets_resolver_es_isKeyword(str) {
	return (/^\s*[\w-]+/.test(str)
	);
}

function css_snippets_resolver_es_splitValue(value) {
	return String(value).split('|');
}

const css_snippets_resolver_es_globalKeywords = ['auto', 'inherit', 'unset'];
const css_snippets_resolver_es_unitlessProperties = ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'];

const dist_css_snippets_resolver_es_defaultOptions = {
	intUnit: 'px',
	floatUnit: 'em',
	unitAliases: {
		e: 'em',
		p: '%',
		x: 'ex',
		r: 'rem'
	},
	fuzzySearchMinScore: 0
};

/**
 * For every node in given `tree`, finds matching snippet from `registry` and
 * updates node with snippet data.
 *
 * This resolver uses fuzzy matching for searching matched snippets and their
 * keyword values.
 */

function dist_css_snippets_resolver_es_index(tree, registry, options) {
	options = dist_css_snippets_resolver_es__extends({}, dist_css_snippets_resolver_es_defaultOptions, options);
	options.unitAliases = dist_css_snippets_resolver_es__extends({}, dist_css_snippets_resolver_es_defaultOptions.unitAliases, options && options.unitAliases);

	const snippets = css_snippets_resolver_es_convertToCSSSnippets(registry);

	tree.walk(node => dist_css_snippets_resolver_es_resolveNode(node, snippets, options));
	return tree;
}

function css_snippets_resolver_es_convertToCSSSnippets(registry) {
	return css_snippets_resolver_es_cssSnippets(registry.all({ type: 'string' }));
}

/**
 * Resolves given node: finds matched CSS snippets using fuzzy match and resolves
 * keyword aliases from node value
 * @param  {Node} node
 * @param  {CSSSnippet[]} snippets
 * @param  {Object} options
 * @return {Node}
 */
function dist_css_snippets_resolver_es_resolveNode(node, snippets, options) {
	const snippet = css_snippets_resolver_es_findBestMatch(node.name, snippets, 'key', options.fuzzySearchMinScore);

	if (!snippet) {
		// Edge case: `!important` snippet
		return node.name === '!' ? css_snippets_resolver_es_setNodeAsText(node, '!important') : node;
	}

	return snippet.property ? css_snippets_resolver_es_resolveAsProperty(node, snippet, options) : css_snippets_resolver_es_resolveAsSnippet(node, snippet);
}

/**
 * Resolves given parsed abbreviation node as CSS property
 * @param {Node} node
 * @param {CSSSnippet} snippet
 * @param  {Object} formatOptions
 * @return {Node}
 */
function css_snippets_resolver_es_resolveAsProperty(node, snippet, formatOptions) {
	const abbr = node.name;
	node.name = snippet.property;

	if (node.value && typeof node.value === 'object') {
		// resolve keyword shortcuts
		const keywords = snippet.keywords();

		if (!node.value.size) {
			// no value defined, try to resolve unmatched part as a keyword alias
			let kw = css_snippets_resolver_es_findBestMatch(css_snippets_resolver_es_getUnmatchedPart(abbr, snippet.key), keywords);

			if (!kw) {
				// no matching value, try to get default one
				kw = snippet.defaultValue;
				if (kw && kw.indexOf('${') === -1) {
					// Quick and dirty test for existing field. If not, wrap
					// default value in a field
					kw = `\${1:${kw}}`;
				}
			}

			if (kw) {
				node.value.add(kw);
			}
		} else {
			// replace keyword aliases in current node value
			for (let i = 0, token; i < node.value.value.length; i++) {
				token = node.value.value[i];

				if (token === '!') {
					token = `${!i ? '${1} ' : ''}!important`;
				} else if (css_snippets_resolver_es_isKeyword$1(token)) {
					token = css_snippets_resolver_es_findBestMatch(token.value, keywords) || css_snippets_resolver_es_findBestMatch(token.value, css_snippets_resolver_es_globalKeywords) || token;
				} else if (css_snippets_resolver_es_isNumericValue(token)) {
					token = css_snippets_resolver_es_resolveNumericValue(node.name, token, formatOptions);
				}

				node.value.value[i] = token;
			}
		}
	}

	return node;
}

/**
 * Resolves given parsed abbreviation node as a snippet: a plain code chunk
 * @param {Node} node
 * @param {CSSSnippet} snippet
 * @return {Node}
 */
function css_snippets_resolver_es_resolveAsSnippet(node, snippet) {
	return css_snippets_resolver_es_setNodeAsText(node, snippet.value);
}

/**
 * Sets given parsed abbreviation node as a text snippet
 * @param {Node} node
 * @param {String} text
 * @return {Node}
 */
function css_snippets_resolver_es_setNodeAsText(node, text) {
	node.name = null;
	node.value = text;
	return node;
}

/**
 * Finds best matching item from `items` array
 * @param {String} abbr  Abbreviation to match
 * @param {Array}  items List of items for match
 * @param {String} [key] If `items` is a list of objects, use `key` as object
 * property to test against
 * @param {Number} fuzzySearchMinScore The minimum score the best matched item should have to be a valid match.
 * @return {*}
 */
function css_snippets_resolver_es_findBestMatch(abbr, items, key, fuzzySearchMinScore) {
	if (!abbr) {
		return null;
	}

	let matchedItem = null;
	let maxScore = 0;
	fuzzySearchMinScore = fuzzySearchMinScore || 0;

	for (let i = 0, item; i < items.length; i++) {
		item = items[i];
		const score = css_snippets_resolver_es_stringScore(abbr, css_snippets_resolver_es_getScoringPart(item, key));

		if (score === 1) {
			// direct hit, no need to look further
			return item;
		}

		if (score && score >= maxScore) {
			maxScore = score;
			matchedItem = item;
		}
	}

	return maxScore >= fuzzySearchMinScore ? matchedItem : null;
}

function css_snippets_resolver_es_getScoringPart(item, key) {
	const value = item && typeof item === 'object' ? item[key] : item;
	const m = (value || '').match(/^[\w-@]+/);
	return m ? m[0] : value;
}

/**
 * Returns a part of `abbr` that wasn’t directly matched agains `string`.
 * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`
 * since `a` wasn’t found in string stream
 * @param {String} abbr
 * @param {String} string
 * @return {String}
 */
function css_snippets_resolver_es_getUnmatchedPart(abbr, string) {
	for (let i = 0, lastPos = 0; i < abbr.length; i++) {
		lastPos = string.indexOf(abbr[i], lastPos);
		if (lastPos === -1) {
			return abbr.slice(i);
		}
		lastPos++;
	}

	return '';
}

/**
 * Check if given CSS value token is a keyword
 * @param {*} token
 * @return {Boolean}
 */
function css_snippets_resolver_es_isKeyword$1(token) {
	return css_snippets_resolver_es_tokenTypeOf(token, 'keyword');
}

/**
 * Check if given CSS value token is a numeric value
 * @param  {*}  token
 * @return {Boolean}
 */
function css_snippets_resolver_es_isNumericValue(token) {
	return css_snippets_resolver_es_tokenTypeOf(token, 'numeric');
}

function css_snippets_resolver_es_tokenTypeOf(token, type) {
	return token && typeof token === 'object' && token.type === type;
}

/**
 * Resolves numeric value for given CSS property
 * @param  {String} property    CSS property name
 * @param  {NumericValue} token CSS numeric value token
 * @param  {Object} formatOptions Formatting options for units
 * @return {NumericValue}
 */
function css_snippets_resolver_es_resolveNumericValue(property, token, formatOptions) {
	if (token.unit) {
		token.unit = formatOptions.unitAliases[token.unit] || token.unit;
	} else if (token.value !== 0 && css_snippets_resolver_es_unitlessProperties.indexOf(property) === -1) {
		// use `px` for integers, `em` for floats
		// NB: num|0 is a quick alternative to Math.round(0)
		token.unit = token.value === (token.value | 0) ? formatOptions.intUnit : formatOptions.floatUnit;
	}

	return token;
}

/* harmony default export */ var dist_css_snippets_resolver_es = (dist_css_snippets_resolver_es_index);

//# sourceMappingURL=css-snippets-resolver.es.js.map
// CONCATENATED MODULE: ../node_modules/@emmetio/html-matcher/dist/html-matcher.es.js
var html_matcher_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




let html_matcher_es_Node = class Node {
	constructor(stream, type, open, close) {
		this.stream = stream;
		this.type = type;
		this.open = open;
		this.close = close;

		this.children = [];
		this.parent = null;
	}

	/**
  * Returns node name
  * @return {String}
  */
	get name() {
		if (this.type === 'tag' && this.open) {
			return this.open && this.open.name && this.open.name.value;
		}

		return '#' + this.type;
	}

	/**
  * Returns attributes of current node
  * @return {Array}
  */
	get attributes() {
		return this.open && this.open.attributes;
	}

	/**
  * Returns node’s start position in stream
  * @return {*}
  */
	get start() {
		return this.open && this.open.start;
	}

	/**
  * Returns node’s start position in stream
  * @return {*}
  */
	get end() {
		return this.close ? this.close.end : this.open && this.open.end;
	}

	get firstChild() {
		return this.children[0];
	}

	get nextSibling() {
		const ix = this.getIndex();
		return ix !== -1 ? this.parent.children[ix + 1] : null;
	}

	get previousSibling() {
		const ix = this.getIndex();
		return ix !== -1 ? this.parent.children[ix - 1] : null;
	}

	/**
  * Returns current element’s index in parent list of child nodes
  * @return {Number}
  */
	getIndex() {
		return this.parent ? this.parent.children.indexOf(this) : -1;
	}

	/**
  * Adds given node as a child
  * @param {Node} node
  * @return {Node} Current node
  */
	addChild(node) {
		this.removeChild(node);
		this.children.push(node);
		node.parent = this;
		return this;
	}

	/**
  * Removes given node from current node’s child list
  * @param  {Node} node
  * @return {Node} Current node
  */
	removeChild(node) {
		const ix = this.children.indexOf(node);
		if (ix !== -1) {
			this.children.splice(ix, 1);
			node.parent = null;
		}

		return this;
	}
};

/**
 * A token factory method
 * @param  {StreamReader}   stream
 * @param  {Point|Function} start  Tokens’ start location or stream consumer
 * @param  {Point}          [end]  Tokens’ end location
 * @return {Token}
 */

var html_matcher_es_token = function (stream, start, end) {
	return typeof start === 'function' ? eatToken(stream, start) : new Token(stream, start, end);
};

/**
 * Consumes characters from given stream that matches `fn` call and returns it
 * as token, if consumed
 * @param  {StreamReader} stream
 * @param  {Function} test
 * @return {Token}
 */
function eatToken(stream, test) {
	const start = stream.pos;
	if (stream.eatWhile(test)) {
		return new Token(stream, start, stream.pos);
	}

	stream.pos = start;
}

/**
 * A structure describing text fragment in content stream
 */
let Token = class Token {
	/**
  * @param {ContentStreamReader} stream
  * @param {Point} start         Tokens’ start location in content stream
  * @param {Point} end           Tokens’ end location in content stream
  */
	constructor(stream, start, end) {
		this.stream = stream;
		this.start = start != null ? start : stream.start;
		this.end = end != null ? end : stream.pos;
		this._value = null;
	}

	/**
  * Returns token textual value
  * NB implemented as getter to reduce unnecessary memory allocations for
  * strings that not required
  * @return {String}
  */
	get value() {
		if (this._value === null) {
			const start = this.stream.start;
			const end = this.stream.pos;

			this.stream.start = this.start;
			this.stream.pos = this.end;
			this._value = this.stream.current();

			this.stream.start = start;
			this.stream.pos = end;
		}

		return this._value;
	}

	toString() {
		return this.value;
	}

	valueOf() {
		return `${this.value} [${this.start}; ${this.end}]`;
	}
};


const LANGLE = 60;
const RANGLE = 62; // < and >
const LSQUARE = 91;
const RSQUARE = 93; // [ and ]
const LROUND = 40;
const RROUND = 41; // ( and )
const LCURLY = 123;
const RCURLY = 125; // { and }

const html_matcher_es_opt = { throws: true };

/**
 * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded
 * quoted values
 * @param  {StreamReader} stream
 * @return {Token} A token with consumed paired character
 */
var eatPaired = function (stream) {
	const start = stream.pos;
	const consumed = eatPair(stream, LANGLE, RANGLE, html_matcher_es_opt) || eatPair(stream, LSQUARE, RSQUARE, html_matcher_es_opt) || eatPair(stream, LROUND, RROUND, html_matcher_es_opt) || eatPair(stream, LCURLY, RCURLY, html_matcher_es_opt);

	if (consumed) {
		return html_matcher_es_token(stream, start);
	}
};

const SLASH$1 = 47; // /
const html_matcher_es_EQUALS = 61; // =
const RIGHT_ANGLE$1 = 62; // >

/**
 * Consumes attributes from given stream
 * @param {StreamReader} stream
 * @return {Array} Array of consumed attributes
 */
var eatAttributes = function (stream) {
	const result = [];
	let name, value, attr;

	while (!stream.eof()) {
		stream.eatWhile(isSpace);
		attr = { start: stream.pos };

		// A name could be a regular name or expression:
		// React-style – <div {...props}>
		// Angular-style – <div [ng-for]>
		if (attr.name = eatAttributeName(stream)) {
			// Consumed attribute name. Can be an attribute with name
			// or boolean attribute. The value can be React-like expression
			if (stream.eat(html_matcher_es_EQUALS)) {
				attr.value = eatAttributeValue(stream);
			} else {
				attr.boolean = true;
			}
			attr.end = stream.pos;
			result.push(attr);
		} else if (isTerminator(stream.peek())) {
			// look for tag terminator in order to skip any other possible characters
			// (maybe junk)
			break;
		} else {
			stream.next();
		}
	}

	return result;
};

/**
 * Consumes attribute name from current location
 * @param  {StreamReader} stream
 * @return {Token}
 */
function eatAttributeName(stream) {
	return eatPaired(stream) || html_matcher_es_token(stream, isAttributeName);
}

/**
 * Consumes attribute value from given location
 * @param  {StreamReader} stream
 * @return {Token}
 */
function eatAttributeValue(stream) {
	const start = stream.pos;
	if (eatQuoted(stream)) {
		// Should return token that points to unquoted value.
		// Use stream readers’ public API to traverse instead of direct
		// manipulation
		const current = stream.pos;
		let valueStart, valueEnd;

		stream.pos = start;
		stream.next();
		valueStart = stream.start = stream.pos;

		stream.pos = current;
		stream.backUp(1);
		valueEnd = stream.pos;

		const result = html_matcher_es_token(stream, valueStart, valueEnd);
		stream.pos = current;
		return result;
	}

	return eatPaired(stream) || html_matcher_es_eatUnquoted(stream);
}

/**
 * Check if given code belongs to attribute name.
 * NB some custom HTML variations allow non-default values in name, like `*ngFor`
 * @param  {Number}  code
 * @return {Boolean}
 */
function isAttributeName(code) {
	return code !== html_matcher_es_EQUALS && !isTerminator(code) && !isSpace(code);
}

/**
 * Check if given code is tag terminator
 * @param  {Number}  code
 * @return {Boolean}
 */
function isTerminator(code) {
	return code === RIGHT_ANGLE$1 || code === SLASH$1;
}

/**
 * Eats unquoted value from stream
 * @param  {StreamReader} stream
 * @return {Token}
 */
function html_matcher_es_eatUnquoted(stream) {
	return html_matcher_es_token(stream, html_matcher_es_isUnquoted);
}

/**
 * Check if given character code is valid unquoted value
 * @param  {Number}  code
 * @return {Boolean}
 */
function html_matcher_es_isUnquoted(code) {
	return !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);
}

const html_matcher_es_DASH = 45; // -
const html_matcher_es_DOT = 46; // .
const html_matcher_es_SLASH = 47; // /
const html_matcher_es_COLON = 58; // :
const LEFT_ANGLE = 60; // <
const RIGHT_ANGLE = 62; // >
const UNDERSCORE = 95; // _

/**
 * Parses tag definition (open or close tag) from given stream state
 * @param {StreamReader} stream Content stream reader
 * @return {Object}
 */
var tag = function (stream) {
	const start = stream.pos;

	if (stream.eat(LEFT_ANGLE)) {
		const model = { type: stream.eat(html_matcher_es_SLASH) ? 'close' : 'open' };

		if (model.name = eatTagName(stream)) {
			if (model.type !== 'close') {
				model.attributes = eatAttributes(stream);
				stream.eatWhile(isSpace);
				model.selfClosing = stream.eat(html_matcher_es_SLASH);
			}

			if (stream.eat(RIGHT_ANGLE)) {
				// tag properly closed
				return html_matcher_es__extends(html_matcher_es_token(stream, start), model);
			}
		}
	}

	// invalid tag, revert to original position
	stream.pos = start;
	return null;
};

/**
 * Eats HTML identifier (tag or attribute name) from given stream
 * @param  {StreamReader} stream
 * @return {Token}
 */
function eatTagName(stream) {
	return html_matcher_es_token(stream, isTagName);
}

/**
 * Check if given character code can be used as HTML/XML tag name
 * @param  {Number}  code
 * @return {Boolean}
 */
function isTagName(code) {
	return isAlphaNumeric(code) || code === html_matcher_es_COLON // colon is used for namespaces
	|| code === html_matcher_es_DOT // in rare cases declarative tag names may have dots in names
	|| code === html_matcher_es_DASH || code === UNDERSCORE;
}

/**
 * Eats array of character codes from given stream
 * @param  {StreamReader} stream
 * @param  {Number[]} codes  Array of character codes
 * @return {Boolean}
 */
function eatArray(stream, codes) {
	const start = stream.pos;

	for (let i = 0; i < codes.length; i++) {
		if (!stream.eat(codes[i])) {
			stream.pos = start;
			return false;
		}
	}

	stream.start = start;
	return true;
}

/**
 * Consumes section from given string which starts with `open` character codes
 * and ends with `close` character codes
 * @param  {StreamReader} stream
 * @param  {Number[]} open
 * @param  {Number[]} close
 * @return {Boolean}  Returns `true` if section was consumed
 */
function eatSection(stream, open, close, allowUnclosed) {
	const start = stream.pos;
	if (eatArray(stream, open)) {
		// consumed `<!--`, read next until we find ending part or reach the end of input
		while (!stream.eof()) {
			if (eatArray(stream, close)) {
				return true;
			}

			stream.next();
		}

		// unclosed section is allowed
		if (allowUnclosed) {
			return true;
		}

		stream.pos = start;
		return false;
	}

	// unable to find section, revert to initial position
	stream.pos = start;
	return null;
}

/**
 * Converts given string into array of character codes
 * @param  {String} str
 * @return {Number[]}
 */
function toCharCodes(str) {
	return str.split('').map(ch => ch.charCodeAt(0));
}

const html_matcher_es_open = toCharCodes('<!--');
const html_matcher_es_close = toCharCodes('-->');

/**
 * Consumes HTML comment from given stream
 * @param  {StreamReader} stream
 * @return {Token}
 */
var comment = function (stream) {
	const start = stream.pos;
	if (eatSection(stream, html_matcher_es_open, html_matcher_es_close, true)) {
		const result = html_matcher_es_token(stream, start);
		result.type = 'comment';
		return result;
	}

	return null;
};

const open$1 = toCharCodes('<![CDATA[');
const close$1 = toCharCodes(']]>');

/**
 * Consumes CDATA from given stream
 * @param  {StreamReader} stream
 * @return {Token}
 */
var cdata = function (stream) {
	const start = stream.pos;
	if (eatSection(stream, open$1, close$1, true)) {
		const result = html_matcher_es_token(stream, start);
		result.type = 'cdata';
		return result;
	}

	return null;
};

const html_matcher_es_defaultOptions = {
	/**
  * Expect XML content in searching content. It alters how should-be-empty
  * elements are treated: for example, in XML mode parser will try to locate
  * closing pair for `<br>` tag
  * @type {Boolean}
  */
	xml: false,

	special: ['script', 'style'],

	/**
  * List of elements that should be treated as empty (e.g. without closing tag)
  * in non-XML syntax
  * @type {Array}
  */
	empty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr', 'col', 'embed', 'input', 'param', 'source', 'track']
};

/**
 * Parses given content into a DOM-like structure
 * @param  {String|StreamReader} content
 * @param  {Object} options
 * @return {Node}
 */
function html_matcher_es_parse(content, options) {
	options = html_matcher_es__extends({}, html_matcher_es_defaultOptions, options);
	const stream = typeof content === 'string' ? new stream_reader_es(content) : content;

	const root = new html_matcher_es_Node(stream, 'root');
	const empty = new Set(options.empty);
	const special = options.special.reduce((map, name) => map.set(name, toCharCodes(`</${name}>`)), new Map());
	const isEmpty = (token, name) => token.selfClosing || !options.xml && empty.has(name);

	let m,
	    node,
	    name,
	    stack = [root];

	while (!stream.eof()) {
		if (m = match(stream)) {
			name = getName(m);

			if (m.type === 'open') {
				// opening tag
				node = new html_matcher_es_Node(stream, 'tag', m);
				last(stack).addChild(node);
				if (special.has(name)) {
					node.close = consumeSpecial(stream, special.get(name));
				} else if (!isEmpty(m, name)) {
					stack.push(node);
				}
			} else if (m.type === 'close') {
				// closing tag, find it’s matching opening tag
				for (let i = stack.length - 1; i > 0; i--) {
					if (stack[i].name.toLowerCase() === name) {
						stack[i].close = m;
						stack = stack.slice(0, i);
						break;
					}
				}
			} else {
				last(stack).addChild(new html_matcher_es_Node(stream, m.type, m));
			}
		} else {
			stream.next();
		}
	}

	return root;
}

/**
 * Matches known token in current state of given stream
 * @param  {ContentStreamReader} stream
 * @return {Token}
 */
function match(stream) {
	// fast-path optimization: check for `<` code
	if (stream.peek() === 60 /* < */) {
			return comment(stream) || cdata(stream) || tag(stream);
		}
}

/**
 * @param  {StreamReader} stream
 * @param  {Number[]} codes
 * @return {Token}
 */
function consumeSpecial(stream, codes) {
	const start = stream.pos;
	let m;

	while (!stream.eof()) {
		if (eatArray(stream, codes)) {
			stream.pos = stream.start;
			return tag(stream);
		}
		stream.next();
	}

	stream.pos = start;
	return null;
}

/**
 * Returns name of given matched token
 * @param  {Token} tag
 * @return {String}
 */
function getName(tag$$1) {
	return tag$$1.name ? tag$$1.name.value.toLowerCase() : `#${tag$$1.type}`;
}

function last(arr) {
	return arr[arr.length - 1];
}

/* harmony default export */ var html_matcher_es = (html_matcher_es_parse);
// CONCATENATED MODULE: ../node_modules/@emmetio/codemirror-plugin/dist/emmet-codemirror-plugin.es.js
var emmet_codemirror_plugin_es__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };










const editorField = (index, placeholder = '') => `\${${index}${placeholder ? ':' + placeholder : ''}}`;

/**
 * Returns resolved Emmet config for `pos` location of given editor
 * @param  {CodeMirror.Editor} editor
 * @param  {CodeMirror.Position} [pos]  Point in editor where syntax should be detected.
 * Uses `editor.getCursor()` if not given
 * @param  {Object} [options] Additional options to override before config resolve
 * @return {Object}
 */
function createConfig(editor, pos, options) {
	pos = pos || editor.getCursor();
	const syntax = getSyntax(editor, pos);

	/** @type {EmmetConfig} */
	const config = config_es(emmet_codemirror_plugin_es__extends({ field: editorField }, editor.getOption('emmet'), options), { syntax });

	const mode = editor.getModeAt(pos);
	if (syntax === 'jsx') {
		config.profile = emmet_codemirror_plugin_es__extends({ selfClosingStyle: 'xml' }, config.profile);
		config.options = emmet_codemirror_plugin_es__extends({ jsx: true }, config.options);
	} else if (mode.name === 'xml') {
		config.profile = emmet_codemirror_plugin_es__extends({ selfClosingStyle: mode.configuration }, config.profile);
	}

	return config;
}

/**
 * Detect Emmet syntax from given editor’s position.
 * @param {CodeMirror.Editor} editor
 * @param {CodeMirror.Position} [pos]
 * @return {String} Returns `null` if Emmet syntax can’t be detected
 */
function getSyntax(editor, pos) {
	const rootMode = editor.getMode();
	if (rootMode.name === 'jsx' || rootMode.name === 'javascript') {
		return rootMode.name;
	}

	const mode = editor.getModeAt(pos);
	return mode.name === 'xml' ? 'html' : mode.name;
}

const LINE_END = 10; // \n

/**
 * A stream reader for CodeMirror editor
 */
let CodeMirrorStreamReader = class CodeMirrorStreamReader extends stream_reader_es {
	/**
  * @param  {CodeMirror.Editor} editor
  * @param  {CodeMirror.Position} [pos]
  * @param  {CodeMirror.Range} [limit]
  */
	constructor(editor, pos, limit) {
		super();
		const CodeMirror = editor.constructor;
		this.editor = editor;
		this.start = this.pos = pos || CodeMirror.Pos(0, 0);

		const lastLine = editor.lastLine();
		this._eof = limit ? limit.to : CodeMirror.Pos(lastLine, this._lineLength(lastLine));
		this._sof = limit ? limit.from : CodeMirror.Pos(0, 0);
	}

	/**
  * Returns true only if the stream is at the beginning of the file.
  * @returns {Boolean}
  */
	sof() {
		return comparePos(this.pos, this._sof) <= 0;
	}

	/**
  * Returns true only if the stream is at the end of the file.
  * @returns {Boolean}
  */
	eof() {
		return comparePos(this.pos, this._eof) >= 0;
	}

	/**
  * Creates a new stream instance which is limited to given `start` and `end`
  * points for underlying buffer
  * @param  {CodeMirror.Pos} start
  * @param  {CodeMirror.Pos} end
  * @return {CodeMirrorStreamReader}
  */
	limit(from, to) {
		return new this.constructor(this.editor, from, { from, to });
	}

	/**
  * Returns the next character code in the stream without advancing it.
  * Will return NaN at the end of the file.
  * @returns {Number}
  */
	peek() {
		const { line, ch } = this.pos;
		const lineStr = this.editor.getLine(line);
		return ch < lineStr.length ? lineStr.charCodeAt(ch) : LINE_END;
	}

	/**
  * Returns the next character in the stream and advances it.
  * Also returns NaN when no more characters are available.
  * @returns {Number}
  */
	next() {
		if (!this.eof()) {
			const code = this.peek();
			this.pos = emmet_codemirror_plugin_es__extends({}, this.pos, { ch: this.pos.ch + 1 });

			if (this.pos.ch >= this._lineLength(this.pos.line)) {
				this.pos.line++;
				this.pos.ch = 0;
			}

			if (this.eof()) {
				// handle edge case where position can move on next line
				// after EOF
				this.pos = emmet_codemirror_plugin_es__extends({}, this._eof);
			}

			return code;
		}

		return NaN;
	}

	/**
  * Backs up the stream n characters. Backing it up further than the
  * start of the current token will cause things to break, so be careful.
  * @param {Number} n
  */
	backUp(n) {
		const CodeMirror = this.editor.constructor;

		let { line, ch } = this.pos;
		ch -= n || 1;

		while (line >= 0 && ch < 0) {
			line--;
			ch += this._lineLength(line);
		}

		this.pos = line < 0 || ch < 0 ? CodeMirror.Pos(0, 0) : CodeMirror.Pos(line, ch);

		return this.peek();
	}

	/**
  * Get the string between the start of the current token and the
  * current stream position.
  * @returns {String}
  */
	current() {
		return this.substring(this.start, this.pos);
	}

	/**
  * Returns contents for given range
  * @param  {Point} from
  * @param  {Point} to
  * @return {String}
  */
	substring(from, to) {
		return this.editor.getRange(from, to);
	}

	/**
  * Creates error object with current stream state
  * @param {String} message
  * @return {Error}
  */
	error(message) {
		const err = new Error(`${message} at line ${this.pos.line}, column ${this.pos.ch}`);
		err.originalMessage = message;
		err.pos = this.pos;
		err.string = this.string;
		return err;
	}

	/**
  * Returns length of given line, including line ending
  * @param  {Number} line
  * @return {Number}
  */
	_lineLength(line) {
		const isLast = line === this.editor.lastLine();
		return this.editor.getLine(line).length + (isLast ? 0 : 1);
	}
};


function comparePos(a, b) {
	return a.line - b.line || a.ch - b.ch;
}

/**
 * Returns token used for single indentation in given editor
 * @param  {CodeMirror.Editor} editor
 * @return {String}
 */
function getIndentation(editor) {
	if (!editor.getOption('indentWithTabs')) {
		return repeatString(' ', editor.getOption('indentUnit'));
	}

	return '\t';
}

/**
 * Normalizes text according to given CodeMirror instance indentation
 * preferences
 * @param  {String} text
 * @param  {CodeMirror.Editor} editor
 * @param  {String} [indentation] Applies `indentText()` with given argument, if provided
 * @return {String}
 */
function normalizeText(editor, text, indentation) {
	let lines = emmet_codemirror_plugin_es_splitByLines(text);
	const indent = getIndentation(editor);

	if (indent !== '\t') {
		lines = lines.map(line => line.replace(/^\t+/, tabs => repeatString(indent, tabs.length)));
	}

	if (indentation) {
		lines = lines.map((line, i) => i ? indentation + line : line);
	}

	return lines.join('\n');
}

/**
 * Splits given text by lines
 * @param  {String} text
 * @return {String[]} Lines of text
 */
function emmet_codemirror_plugin_es_splitByLines(text) {
	return Array.isArray(text) ? text : text.split(/\r\n|\r|\n/g);
}

function repeatString(str, count) {
	let result = '';
	while (0 < count--) {
		result += str;
	}

	return result;
}

/**
 * Quick and dirty way to remove fields from given string
 * @param  {String} str
 * @return {String}
 */
function removeFields(str) {
	return field_parser_es(str).string;
}

/**
 * Check if given range contains point
 * @param  {CodeMirror.Range} range
 * @param  {CodeMirror.Position} pos
 * @param  {Boolean} [exclude] Exclude range and and start
 * @return {Boolean}
 */
function containsPos(range, pos, exclude) {
	return exclude ? comparePos$1(pos, range.from) > 0 && comparePos$1(pos, range.to) < 0 : comparePos$1(pos, range.from) >= 0 && comparePos$1(pos, range.to) <= 0;
}

function comparePos$1(a, b) {
	return a.line - b.line || a.ch - b.ch;
}

function rangeFromNode(node) {
	return {
		from: node.start,
		to: node.end
	};
}

/**
 * Narrows given `{from, to}` range to first non-whitespace characters in given 
 * editor content
 * @param {CodeMirror.Editor} editor 
 * @param {CodeMirror.Position} from 
 * @param {CodeMirror.Position} [to] 
 * @returns {Object}
 */
function narrowToNonSpace(editor, from, to) {
	const stream = new CodeMirrorStreamReader(editor, from);

	stream.eatWhile(isSpace);
	from = stream.pos;

	if (to) {
		stream.pos = to;
		stream.backUp();

		while (!stream.sof() && isSpace(stream.peek())) {
			stream.backUp();
		}

		stream.next();
		to = stream.pos;
	} else {
		to = from;
	}

	return { from, to };
}

/**
 * Returns nearest CSS property name, left to given position
 * @param {CodeMirror.Editor} editor 
 * @param {CodeMirror.Position} pos 
 * @returns {String}
 */
function getCSSPropertyName(editor, pos) {
	const line = pos.line;
	let ch = pos.ch,
	    token;

	while (ch >= 0) {
		token = editor.getTokenAt({ line, ch });
		if (token.type === 'property') {
			return token.string;
		}

		if (token.start !== ch) {
			ch = token.start;
		} else {
			break;
		}
	}
}

/**
 * Check if given position is inside CSS property value
 * @param {CodeMirror.Editor} editor 
 * @param {CodeMirror.Position} pos 
 * @return {Boolean}
 */
function isCSSPropertyValue(editor, pos) {
	const mode = editor.getModeAt(pos);
	if (mode && mode.name === 'css') {
		const token = editor.getTokenAt(pos);
		const state = token.state && token.state.localState || token.state;
		return state && state.context && state.context.type === 'prop';
	}

	return false;
}

/**
 * Context-aware abbreviation extraction from given editor.
 * Detects syntax context in `pos` editor location and, if it allows Emmet
 * abbreviation to be extracted here, returns object with extracted abbreviation,
 * its location and config.
 * @param {CodeMirror.Editor} editor
 * @param {CodeMirror.Position} pos
 */
function emmet_codemirror_plugin_es_extractAbbreviation(editor, pos, contextAware) {
	const config = createConfig(editor, pos);

	if (contextAware && !canExtract(editor, pos, config)) {
		return null;
	}

	const extracted = extract_abbreviation_es(editor.getLine(pos.line), pos.ch, {
		lookAhead: true,
		syntax: config.type,
		prefix: config.syntax === 'jsx' && editor.getOption('jsxBracket') ? '<' : ''
	});

	if (extracted) {
		const from = {
			line: pos.line,
			ch: extracted.start
		};
		const to = {
			line: pos.line,
			ch: extracted.end
		};

		if (config.type === 'stylesheet' && contextAware) {
			// In case of stylesheet syntaxes (CSS, LESS) we should narrow down
			// expand context to property value, if possible
			if (isCSSPropertyValue(editor, pos)) {
				config.options = emmet_codemirror_plugin_es__extends({ property: getCSSPropertyName(editor, pos) }, config.options);
			}
		}

		return {
			abbreviation: extracted.abbreviation,
			range: { from, to },
			config
		};
	}
}

/**
 * Check if abbreviation can be extracted from given position
 * @param {CodeMirror.Editor} editor
 * @param {CodeMirror.Position} pos
 * @param {Object} config
 * @return {Boolean}
 */
function canExtract(editor, pos, config) {
	const tokenType = editor.getTokenTypeAt(pos);

	if (config.type === 'stylesheet') {
		return tokenType !== 'comment' && tokenType !== 'string';
	}

	if (config.syntax === 'html') {
		return tokenType === null;
	}

	if (config.syntax === 'slim' || config.syntax === 'pug') {
		return tokenType === null || tokenType === 'tag' || tokenType && /attribute/.test(tokenType);
	}

	if (config.syntax === 'haml') {
		return tokenType === null || tokenType === 'attribute';
	}

	if (config.syntax === 'jsx') {
		// JSX a bit tricky, delegate it to caller
		return true;
	}

	return false;
}

/**
 * Replaces `range` in `editor` with `text` snippet. A snippet is a string containing
 * tabstops/fields like `${index:placeholder}`: this function will locate such 
 * fields and place cursor at first one.
 * Inserted snippet will be automatically matched with current editor indentation
 * @param {CodeMirror.Editor} editor 
 * @param {CodeMirror.Range} range 
 * @param {String} text
 */
function insertSnippet(editor, range, text) {
	const line = editor.getLine(range.from.line);
	const matchIndent = line.match(/^\s+/);
	let snippet = normalizeText(editor, text, matchIndent && matchIndent[0]);
	const fieldModel = field_parser_es(snippet);

	return editor.operation(() => {
		editor.replaceRange(fieldModel.string, range.from, range.to);

		// Position cursor
		const startIx = editor.indexFromPos(range.from);
		if (fieldModel.fields.length) {
			const field = fieldModel.fields[0];
			const from = editor.posFromIndex(field.location + startIx);
			const to = editor.posFromIndex(field.location + field.length + startIx);
			editor.setSelection(from, to);
		} else {
			editor.setCursor(editor.posFromIndex(startIx + fieldModel.string.length));
		}

		return true;
	});
}

const emmetMarkerClass = 'emmet-abbreviation';

/**
 * Returns parsed abbreviation from given position in `editor`, if possible.
 * @param {CodeMirror.Editor} editor
 * @param {CodeMirror.Position} pos
 * @param {Boolean} [contextAware] Use context-aware abbreviation detection
 * @returns {Abbreviation}
 */
function abbreviationFromPosition(editor, pos, contextAware) {
	// Try to find abbreviation marker from given position
	const marker = findMarker(editor, pos);
	if (marker && marker.model) {
		return marker.model;
	}

	// Try to extract abbreviation from given position
	const extracted = emmet_codemirror_plugin_es_extractAbbreviation(editor, pos, contextAware);
	if (extracted) {
		try {
			const abbr = new emmet_codemirror_plugin_es_Abbreviation(extracted.abbreviation, extracted.range, extracted.config);
			return abbr.valid(editor, contextAware) ? abbr : null;
		} catch (err) {
			// skip
			// console.warn(err);
		}
	}
}

/**
 * Returns *valid* Emmet abbreviation marker (if any) for given position of editor
 * @param  {CodeMirror.Editor} editor
 * @param  {CodeMirror.Position} [pos]
 * @return {CodeMirror.TextMarker}
 */
function findMarker(editor, pos) {
	const markers = editor.findMarksAt(pos);
	for (let i = 0, marker; i < markers.length; i++) {
		marker = markers[i];
		if (marker.className === emmetMarkerClass) {
			if (isValidMarker(editor, marker)) {
				return marker;
			}

			marker.clear();
		}
	}
}

/**
 * Removes Emmet abbreviation markers from given editor
 * @param {CodeMirror.Editor} editor
 */
function clearMarkers(editor) {
	const markers = editor.getAllMarks();
	for (let i = 0; i < markers.length; i++) {
		if (markers[i].className === emmetMarkerClass) {
			markers[i].clear();
		}
	}
}

/**
 * Marks Emmet abbreviation for given editor position, if possible
 * @param  {CodeMirror.Editor} editor Editor where abbreviation marker should be created
 * @param  {Abbreviation} model Parsed abbreviation model
 * @return {CodeMirror.TextMarker} Returns `undefined` if no valid abbreviation under caret
 */
function createMarker(editor, model) {
	const { from, to } = model.range;
	const marker = editor.markText(from, to, {
		inclusiveLeft: true,
		inclusiveRight: true,
		clearWhenEmpty: true,
		className: emmetMarkerClass
	});
	marker.model = model;
	return marker;
}

/**
 * Ensures that given editor Emmet abbreviation marker contains valid Emmet abbreviation
 * and updates abbreviation model if required
 * @param {CodeMirror} editor
 * @param {CodeMirror.TextMarket} marker
 * @return {Boolean} `true` if marker contains valid abbreviation
 */
function isValidMarker(editor, marker) {
	const range = marker.find();

	// No newlines inside abbreviation
	if (range.from.line !== range.to.line) {
		return false;
	}

	// Make sure marker contains valid abbreviation
	let text = editor.getRange(range.from, range.to);
	if (!text || /^\s|\s$/g.test(text)) {
		return false;
	}

	if (marker.model && marker.model.config.syntax === 'jsx' && text[0] === '<') {
		text = text.slice(1);
	}

	if (!marker.model || marker.model.abbreviation !== text) {
		// marker contents was updated, re-parse abbreviation
		try {
			marker.model = new emmet_codemirror_plugin_es_Abbreviation(text, range, marker.model.config);
			if (!marker.model.valid(editor, true)) {
				marker.model = null;
			}
		} catch (err) {
			console.warn(err);
			marker.model = null;
		}
	}

	return Boolean(marker.model && marker.model.snippet);
}

let emmet_codemirror_plugin_es_Abbreviation = class Abbreviation {
	/**
  * @param {String} abbreviation Abbreviation string
  * @param {CodeMirror.Range} range Abbreviation location in editor
  * @param {Object} [config]
  */
	constructor(abbreviation, range, config) {
		this.abbreviation = abbreviation;
		this.range = range;
		this.config = config;
		this.ast = parse$2(abbreviation, config);
		this.snippet = expand$2(this.ast, config);
		this.preview = removeFields(this.snippet);
	}

	/**
  * Inserts current expanded abbreviation into given `editor` by replacing
  * `range`
  * @param {CodeMirror.Editor} editor
  * @param {CodeMirror.Range} [range]
  */
	insert(editor, range) {
		return insertSnippet(editor, range || this.range, this.snippet);
	}

	/**
  * Check if parsed abbreviation is valid
  * @param {Boolean} [contextAware] Perform context-aware validation: ensure 
  * that expanded result is expected at abbreviation location
  */
	valid(editor, contextAware) {
		if (this.preview && this.abbreviation !== this.preview) {
			return contextAware && this.config.type === 'stylesheet' ? this._isValidForStylesheet(editor) : true;
		}

		return false;
	}

	_isValidForStylesheet(editor) {
		const pos = this.range.from;
		const token = editor.getTokenAt(pos);

		if (/^[#!]/.test(this.abbreviation)) {
			// Abbreviation is a property value
			return isCSSPropertyValue(editor, pos);
		}

		// All expanded nodes are properties? Properties has names, regular snippets don’t.
		const isProperty = this.ast.children.every(node => node.name);
		const state = token.state && token.state.localState || token.state;

		if (isProperty) {
			// Expanded abbreviation consists of properties: make sure we’re inside 
			// block context
			// NB: in Sass, no actual block context since it’s indetation-based
			return this.config.syntax === 'sass' || state && state.context && state.context.type === 'block';
		}

		// Expanded abbreviations are basic snippets: allow them everywhere, but forbid
		// if expanded result equals abbreviation (meaningless).
		return true;
	}
};

/**
 * Expand abbreviation command
 * @param {CodeMirror.Editor} editor
 * @param {Boolean} contextAware
 */

function expandAbbreviation(editor, contextAware) {
	if (editor.somethingSelected()) {
		return editor.constructor.Pass;
	}

	const abbr = abbreviationFromPosition(editor, editor.getCursor(), contextAware);

	if (abbr) {
		abbr.insert(editor);
		clearMarkers(editor);
		return true;
	}

	// If no abbreviation was expanded, allow editor to handle different
	// action for keyboard shortcut (Tab key mostly)
	return editor.constructor.Pass;
}

function emmetInsertLineBreak(editor) {
	const between = editor.listSelections().map(sel => betweenTags(editor, sel));

	if (!between.some(Boolean)) {
		return editor.constructor.Pass;
	}

	editor.operation(() => {
		let sels = editor.listSelections();
		const singleSep = editor.doc.lineSeparator();
		const doubleSep = singleSep + singleSep;

		// Step 1: insert newlines either single or double depending on selection
		for (let i = sels.length - 1; i >= 0; i--) {
			editor.replaceRange(between[i] ? doubleSep : singleSep, sels[i].anchor, sels[i].head, '+newline');
		}

		// Step 2: indent inserted lines
		sels = editor.listSelections();
		for (let i = 0; i < sels.length; i++) {
			editor.indentLine(sels[i].from().line, null, true);

			if (between[i]) {
				editor.indentLine(sels[i].from().line - 1, null, true);
			}
		}

		// Step 3: adjust caret positions
		editor.setSelections(editor.listSelections().map((sel, i) => {
			if (between[i]) {
				const line = sel.from().line - 1;
				const cursor = {
					line,
					ch: editor.getLine(line).length
				};
				return { anchor: cursor, head: cursor };
			}

			return sel;
		}));
	});
}

/**
 * Check if given range is a single caret between tags
 * @param {CodeMirror} editor
 * @param {CodeMirror.range} range
 */
function betweenTags(editor, range) {
	if (equalCursorPos(range.anchor, range.head)) {
		const cursor = range.anchor;
		const mode = editor.getModeAt(cursor);

		if (mode.name === 'xml') {
			const left = editor.getTokenAt(cursor);
			const right = editor.getTokenAt(emmet_codemirror_plugin_es__extends({}, cursor, { ch: cursor.ch + 1 }));

			return left.type === 'tag bracket' && left.string === '>' && right.type === 'tag bracket' && right.string === '</';
		}
	}
}

// Compare two positions, return 0 if they are the same, a negative
// number when a is less, and a positive number otherwise.
function cmp(a, b) {
	return a.line - b.line || a.ch - b.ch;
}

function equalCursorPos(a, b) {
	return a.sticky === b.sticky && cmp(a, b) === 0;
}

/**
 * Marks selected text or matched node content with abbreviation
 * @param {CodeMirror} editor 
 */
function wrapWithAbbreviation(editor) {
	const range = getWrappingContentRange(editor);

	if (range) {
		const prompt = editor.getOption('emmetPrompt') || defaultPrompt;
		const text = editor.getRange(range.from, range.to, '\n').split('\n').map(line => line.trim());

		prompt(editor, 'Enter abbreviation to wrap with:', abbr => {
			if (abbr) {
				const model = new emmet_codemirror_plugin_es_Abbreviation(abbr, range, createConfig(editor, range.from, { text }));
				model.insert(editor);
			}
		});
	} else {
		console.warn('Nothing to wrap');
	}
}

/**
 * Returns content range that should be wrapped
 * @param {CodeMirror} editor 
 */
function getWrappingContentRange(editor) {
	if (editor.somethingSelected()) {
		const sel = editor.listSelections().filter(sel => sel.anchor !== sel.head)[0];
		if (sel) {
			return comparePos$1(sel.anchor, sel.head) < 0 ? { from: sel.anchor, to: sel.head } : { from: sel.head, to: sel.anchor };
		}
	}

	// Nothing selected, find parent HTML node and return range for its content
	return getTagRangeForPos(editor, editor.getCursor());
}

/**
 * Returns either inner or outer tag range (depending on `pos` location) 
 * for given position
 * @param {CodeMirror} editor 
 * @param {Object} pos 
 * @return {Object}
 */
function getTagRangeForPos(editor, pos) {
	const model = editor.getEmmetDocumentModel();
	const tag = model && model.nodeForPoint(pos);

	if (!tag) {
		return null;
	}

	// Depending on given position, return either outer or inner tag range
	if (inRange(tag.open, pos) || inRange(tag.close, pos)) {
		// Outer range
		return rangeFromNode(tag);
	}

	// Inner range
	const from = tag.open.end;
	const to = tag.close ? tag.close.start : tag.open.end;

	return narrowToNonSpace(editor, from, to);
}

function inRange(tag, pos) {
	return tag && containsPos(rangeFromNode(tag), pos);
}

function defaultPrompt(editor, message, callback) {
	callback(window.prompt(message));
}

/**
 * Marks Emmet abbreviation for given editor position, if possible
 * @param  {CodeMirror.Editor} editor Editor where abbreviation marker should be created
 * @param  {CodeMirror.Position} pos Editor position where abbreviation marker
 * should be created. Abbreviation will be automatically extracted from given position
 * @return {CodeMirror.TextMarker} Returns `undefined` if no valid abbreviation under caret
 */
function markAbbreviation(editor, pos) {
	const marker = findMarker(editor, pos);
	if (marker) {
		// there’s active marker with valid abbreviation
		return marker;
	}

	// No active marker: remove previous markers and create new one, if possible
	clearMarkers(editor);

	const model = abbreviationFromPosition(editor, pos, true);

	if (model) {
		return createMarker(editor, model);
	}
}

/**
 * Returns available completions from given editor
 * @param  {CodeMirror.Editor} editor
 * @param  {Abbreviation} abbrModel Parsed Emmet abbreviation model for which
 * completions should be populated
 * @param  {CodeMirror.Position} abbrPos Abbreviation location in editor
 * @param  {CodeMirror.Position} [pos] Cursor position in editor
 * @return {EmmetCompletion[]}
 */
function autocompleteProvider(editor, pos) {
	pos = pos || editor.getCursor();
	let completions = [];

	// Provide two types of completions:
	// 1. Expanded abbreviation
	// 2. Snippets

	const abbreviation = abbreviationFromPosition(editor, pos, true);
	// NB: Check for edge case: expanded abbreviation equals to original
	// abbreviation (for example, `li.item` expands to `li.item` in Slim),
	// no need to provide completion for this case
	if (abbreviation && abbreviation.abbreviation !== abbreviation.snippet) {
		completions.push(expandedAbbreviationCompletion(editor, pos, abbreviation));
	}

	const config = abbreviation ? abbreviation.config : createConfig(editor, pos);

	if (config.type === 'stylesheet') {
		completions = completions.concat(getStylesheetCompletions(editor, pos, config));
	} else {
		completions = completions.concat(getMarkupCompletions(editor, pos, config));
	}

	return {
		type: config.type,
		syntax: config.syntax,
		abbreviation,
		completions: completions.filter(Boolean)
	};
}

/**
 * Returns completions for markup syntaxes (HTML, Slim, Pug etc.)
 * @param  {CodeMirror} editor
 * @param  {CodeMirror.Position} pos Cursor position in editor
 * @param  {Object} config Resolved Emmet config
 * @return {EmmetCompletion[]}
 */
function getMarkupCompletions(editor, pos, config) {
	const line = editor.getLine(pos.line).slice(0, pos.ch);
	const prefix = extractPrefix(line, /[\w:\-$@]/);

	// Make sure that current position precedes element name (e.g. not attribute,
	// class, id etc.)
	if (prefix) {
		const prefixRange = {
			from: { line: pos.line, ch: pos.ch - prefix.length },
			to: pos
		};

		return getSnippetCompletions(editor, pos, config).filter(completion => completion.key !== prefix && completion.key.indexOf(prefix) === 0).map(completion => new EmmetCompletion('snippet', editor, prefixRange, completion.key, completion.preview, completion.snippet));
	}

	return [];
}

/**
 * Returns completions for stylesheet syntaxes
 * @param  {CodeMirror} editor
 * @param  {CodeMirror.Position} pos Cursor position in editor
 * @param  {Object} config Resolved Emmet config
 * @return {EmmetCompletion[]}
 */
function getStylesheetCompletions(editor, pos, config) {
	const line = editor.getLine(pos.line).slice(0, pos.ch);
	const prefix = extractPrefix(line, /[\w-@$]/);

	if (prefix) {
		// Make sure that current position precedes element name (e.g. not attribute,
		// class, id etc.)
		const prefixRange = {
			from: { line: pos.line, ch: pos.ch - prefix.length },
			to: pos
		};

		if (config.options && config.options.property) {
			const lowerProp = config.options.property.toLowerCase();
			// Find matching CSS property snippet for keyword completions
			const completion = getSnippetCompletions(editor, pos, config).find(item => item.property && item.property === lowerProp);

			if (completion && completion.keywords.length) {
				return completion.keywords.map(kw => {
					return kw.key.indexOf(prefix) === 0 && new EmmetCompletion('value', editor, prefixRange, kw.key, kw.preview, kw.snippet);
				}).filter(Boolean);
			}
		} else {
			return getSnippetCompletions(editor, pos, config).filter(completion => completion.key !== prefix && completion.key.indexOf(prefix) === 0).map(completion => new EmmetCompletion('snippet', editor, prefixRange, completion.key, completion.preview, completion.snippet));
		}
	}

	return [];
}

/**
 * Returns all possible snippets completions for given editor context.
 * Completions are cached in editor for for re-use
 * @param  {CodeMirror.Editor} editor
 * @param  {CodeMirror.Position} pos
 * @param  {Object} config
 * @return {Array}
 */
function getSnippetCompletions(editor, pos, config) {
	const { type, syntax } = config;

	if (!editor.state.emmetCompletions) {
		editor.state.emmetCompletions = {};
	}

	const cache = editor.state.emmetCompletions;

	if (!(syntax in cache)) {
		const registry = createSnippetsRegistry(type, syntax, config.snippets);

		cache[syntax] = type === 'stylesheet' ? getStylesheetSnippets(registry, config) : getMarkupSnippets(registry, config);
	}

	return cache[syntax];
}

/**
 * Returns stylesheet snippets list
 * @param {SnippetsRegistry} registry
 * @return {Array}
 */
function getStylesheetSnippets(registry) {
	return css_snippets_resolver_es_convertToCSSSnippets(registry).map(snippet => {
		let preview = snippet.property;
		const keywords = snippet.keywords();
		if (keywords.length) {
			preview += `: ${removeFields(keywords.join(' | '))}`;
		} else if (snippet.value) {
			preview += `: ${removeFields(snippet.value)}`;
		}

		return {
			key: snippet.key,
			value: snippet.value,
			snippet: snippet.key,
			property: snippet.property,
			keywords: keywords.map(kw => {
				const m = kw.match(/^[\w-]+/);
				return m && {
					key: m[0],
					preview: removeFields(kw),
					snippet: kw
				};
			}).filter(Boolean),
			preview
		};
	});
}

/**
 * Returns markup snippets list
 * @param {SnippetsRegistry} registry
 * @param {Object} config
 * @return {Array}
 */
function getMarkupSnippets(registry, config) {
	return registry.all({ type: 'string' }).map(snippet => ({
		key: snippet.key,
		value: snippet.value,
		preview: removeFields(expand$2(snippet.value, config)),
		snippet: snippet.key
	}));
}

function expandedAbbreviationCompletion(editor, pos, abbrModel) {
	let preview = abbrModel.preview;
	if (preview.length > 500) {
		preview = preview.slice(0, 500) + '...';
	}

	return new EmmetCompletion('expanded-abbreviation', editor, abbrModel.range, 'Expand abbreviation', preview, (editor, range) => abbrModel.insert(editor, range));
}

/**
 * Extracts prefix from the end of given string that matches `match` regexp
 * @param {String} str
 * @param {RegExp} match
 * @return {String} Extracted prefix
 */
function extractPrefix(str, match) {
	let offset = str.length;

	while (offset > 0) {
		if (!match.test(str[offset - 1])) {
			break;
		}
		offset--;
	}

	return str.slice(offset);
}

let EmmetCompletion = class EmmetCompletion {
	/**
  * @param {String} type
  * @param {CodeMirror.Editor} editor
  * @param {CodeMirror.Range} range
  * @param {String} name
  * @param {String} preview
  * @param {Function} snippet
  */
	constructor(type, editor, range, name, preview, snippet) {
		this.type = type;
		this.editor = editor;
		this.range = range;
		this.name = name;
		this.preview = preview;
		this.snippet = snippet;

		this._inserted = false;
	}

	insert() {
		if (!this._inserted) {
			this._inserted = true;
			if (typeof this.snippet === 'function') {
				this.snippet(this.editor, this.range);
			} else {
				insertSnippet(this.editor, this.range, this.snippet);
			}
			clearMarkers(this.editor);
		}
	}
};

/**
 * A syntax-specific model container, used to get unified access to underlying
 * parsed document
 */

let SyntaxModel = class SyntaxModel {
	/**
  * @param  {Object} dom      Parsed document tree
  * @param  {String} type     Type of document (html, stylesheet, etc.)
  * @param  {String} [syntax] Optional document syntax like html, xhtml or xml
  */
	constructor(dom, type, syntax) {
		this.dom = dom;
		this.type = type;
		this.syntax = syntax;
	}

	/**
  * Returns best matching node for given point
  * @param  {CodeMirror.Pos}   pos
  * @param  {Boolean} [exclude] Exclude node’s start and end positions from
  *                             search
  * @return {Node}
  */
	nodeForPoint(pos, exclude) {
		let ctx = this.dom.firstChild;
		let found = null;

		while (ctx) {
			if (containsPos(rangeFromNode(ctx), pos, exclude)) {
				// Found matching tag. Try to find deeper, more accurate match
				found = ctx;
				ctx = ctx.firstChild;
			} else {
				ctx = ctx.nextSibling;
			}
		}

		return found;
	}
};

/**
 * Creates DOM-like model for given text editor
 * @param  {CodeMirror} editor
 * @param  {String}     syntax
 * @return {Node}
 */

function create(editor, syntax) {
	const stream = new CodeMirrorStreamReader(editor);
	const xml = syntax === 'xml';

	try {
		return new SyntaxModel(html_matcher_es(stream, { xml }), 'html', syntax || 'html');
	} catch (err) {
		console.warn(err);
	}
}

function getModel(editor) {
	const syntax = getSyntax$1(editor);
	return create(editor, syntax);
}

function getCachedModel(editor) {
	if (!editor.state._emmetModel) {
		editor.state._emmetModel = getModel(editor);
	}

	return editor.state._emmetModel;
}

function resetCachedModel(editor) {
	editor.state._emmetModel = null;
}

/**
 * Returns parser-supported syntax of given editor (like 'html', 'css' etc.).
 * Returns `null` if editor’s syntax is unsupported
 * @param  {CodeMirror} editor
 * @return {String}
 */
function getSyntax$1(editor) {
	const mode = editor.getMode();

	if (mode.name === 'htmlmixed') {
		return 'html';
	}

	return mode.name === 'xml' ? mode.configuration : mode.name;
}

const openTagMark = 'emmet-open-tag';
const closeTagMark = 'emmet-close-tag';

/**
 * Finds matching tag pair for given position in editor
 * @param  {CodeMirror.Editor} editor
 * @param  {CodeMirror.Position} pos
 * @return {Object}
 */
function matchTag(editor, pos) {
	pos = pos || editor.getCursor();

	// First, check if there are tag markers in editor
	const marked = getMarkedTag(editor);

	// If marks found, validate them: make sure cursor is either in open
	// or close tag
	if (marked) {
		if (containsPos(marked.open.find(), pos)) {
			// Point is inside open tag, make sure if there’s a closing tag,
			// it matches open tag content
			if (!marked.close || emmet_codemirror_plugin_es_text(editor, marked.open) === emmet_codemirror_plugin_es_text(editor, marked.close)) {
				return marked;
			}
		} else if (marked.close) {
			// There’s a close tag, make sure pointer is inside it and it matches
			// open tag
			if (containsPos(marked.close.find(), pos) && emmet_codemirror_plugin_es_text(editor, marked.open) === emmet_codemirror_plugin_es_text(editor, marked.close)) {
				return marked;
			}
		}
	}

	// Markers are not valid anymore, remove them
	clearTagMatch(editor);

	// Find new tag pair from parsed HTML model and mark them
	const node = findTagPair(editor, pos);
	if (node && node.type === 'tag') {
		return {
			open: createTagMark(editor, node.open.name, openTagMark),
			close: node.close && createTagMark(editor, node.close.name, closeTagMark)
		};
	}
}

function getMarkedTag(editor) {
	let open, close;
	editor.getAllMarks().forEach(mark => {
		if (mark.className === openTagMark) {
			open = mark;
		} else if (mark.className === closeTagMark) {
			close = mark;
		}
	});

	return open ? { open, close } : null;
}

/**
 * Removes all matched tag pair markers from editor
 * @param  {CodeMirror.Editor} editor
 */
function clearTagMatch(editor) {
	editor.getAllMarks().forEach(mark => {
		if (mark.className === openTagMark || mark.className === closeTagMark) {
			mark.clear();
		}
	});
}

/**
 * Finds tag pair (open and close, if any) form parsed HTML model of given editor
 * @param  {CodeMirror.Editor} editor
 * @param  {CodeMirror.Position} pos
 * @return {Object}
 */
function findTagPair(editor, pos) {
	const model = editor.getEmmetDocumentModel();
	return model && model.nodeForPoint(pos || editor.getCursor());
}

function createTagMark(editor, tag, className) {
	return editor.markText(tag.start, tag.end, {
		className,
		inclusiveLeft: true,
		inclusiveRight: true,
		clearWhenEmpty: false
	});
}

function emmet_codemirror_plugin_es_text(editor, mark) {
	const range = mark.find();
	return range ? editor.getRange(range.from, range.to) : '';
}

function renameTag(editor, obj) {
	const tag = getMarkedTag(editor);
	const pos = obj.from;

	if (!tag) {
		return;
	}

	if (containsPos(tag.open.find(), pos) && tag.close) {
		// Update happened inside open tag, update close tag as well
		updateTag(editor, tag.open, tag.close);
	} else if (tag.close && containsPos(tag.close.find(), pos)) {
		// Update happened inside close tag, update open tag as well
		updateTag(editor, tag.close, tag.open);
	}
}

function updateTag(editor, source, dest) {
	const name = text$1(editor, source);
	const range = dest.find();
	const m = name.match(/[\w:.-]+/);
	const newName = !name ? '' : m && m[0];

	if (newName != null) {
		if (editor.getRange(range.from, range.to) !== newName) {
			editor.replaceRange(newName, range.from, range.to);
		}
	} else {
		// User entered something that wasn’t a valid tag name.
		clearTagMatch(editor);
	}
}

function text$1(editor, mark) {
	const range = mark.find();
	return range ? editor.getRange(range.from, range.to) : '';
}

/**
 * Registers Emmet extension on given CodeMirror constructor.
 * This file is designed to be imported somehow into the app (CommonJS, ES6,
 * Rollup/Webpack/whatever). If you simply want to add a <script> into your page
 * that registers Emmet extension on global CodeMirror constructor, use
 * `browser.js` instead
 */
function registerEmmetExtension(CodeMirror) {
	// Register Emmet commands
	emmet_codemirror_plugin_es__extends(CodeMirror.commands, {
		emmetExpandAbbreviation: editor => expandAbbreviation(editor, true),
		emmetExpandAbbreviationAll: editor => expandAbbreviation(editor, false),
		emmetInsertLineBreak,
		emmetWrapWithAbbreviation: wrapWithAbbreviation
	});
	const markOnEditorChange = editor => markAbbreviation(editor, editor.getCursor());

	// Defines options that allows abbreviation marking in text editor
	CodeMirror.defineOption('markEmmetAbbreviation', true, (editor, value) => {
		if (value) {
			editor.on('change', markOnEditorChange);
		} else {
			editor.off('change', markOnEditorChange);
			clearMarkers(editor);
		}
	});

	CodeMirror.defineOption('autoRenameTags', true, (editor, value) => {
		value ? editor.on('change', renameTag) : editor.off('change', renameTag);
	});

	// Enable/disable leading angle bracket for JSX abbreviations
	CodeMirror.defineOption('jsxBracket', true);

	CodeMirror.defineOption('markTagPairs', false, (editor, value) => {
		if (value) {
			editor.on('cursorActivity', matchTag);
			editor.on('change', resetCachedModel);
		} else {
			editor.off('cursorActivity', matchTag);
			editor.off('change', resetCachedModel);
			resetCachedModel(editor);
			clearTagMatch(editor);
		}
	});

	// Emmet config: https://github.com/emmetio/config
	CodeMirror.defineOption('emmet', {});

	/**
  * Returns Emmet completions for context from `pos` position.
  * Abbreviations are calculated for marked abbreviation at given position.
  * If no parsed abbreviation marker is available and `force` argument is
  * given, tries to mark abbreviation and populate completions list again.
  * @param  {CodeMirror.Position} [pos]
  * @param  {Boolean} [force]
  * @return {EmmetCompletion[]}
  */
	CodeMirror.defineExtension('getEmmetCompletions', function (pos, force) {
		const editor = this;
		if (typeof pos === 'boolean') {
			force = pos;
			pos = null;
		}

		pos = pos || editor.getCursor();

		const autocomplete = autocompleteProvider(editor, pos);
		if (autocomplete && autocomplete.completions.length) {
			if (editor.getOption('markEmmetAbbreviation')) {
				// Ensure abbreviation marker exists
				if (!findMarker(editor, pos) && force) {
					clearMarkers(editor);
					createMarker(autocomplete.model);
				}
			}

			return {
				from: autocomplete.abbreviation.range.from,
				to: autocomplete.abbreviation.range.to,
				list: autocomplete.completions
			};
		}
	});

	/**
  * Returns valid Emmet abbreviation and its location in editor from given
  * position
  * @param  {CodeMirror.Pos} [pos] Position from which abbreviation should be
  * extracted. If not given, current cursor position is used
  * @return {Abbreviation}
  */
	CodeMirror.defineExtension('getEmmetAbbreviation', function (pos, contextAware) {
		return abbreviationFromPosition(this, pos || this.getCursor(), contextAware);
	});

	CodeMirror.defineExtension('findEmmetMarker', function (pos) {
		return findMarker(this, pos || this.getCursor());
	});

	CodeMirror.defineExtension('getEmmetDocumentModel', function () {
		const editor = this;
		return editor.getOption('markTagPairs') ? getCachedModel(editor) : getModel(editor);
	});
}

/* harmony default export */ var emmet_codemirror_plugin_es = __webpack_exports__["a"] = (registerEmmetExtension);
//# sourceMappingURL=emmet-codemirror-plugin.es.js.map

/***/ }),

/***/ "/Snk":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("E3Ci");

/***/ }),

/***/ "/wuY":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("NB7d")('keys');
var uid = __webpack_require__("X6va");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "0WCH":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "0zht":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("Z8Qa");
__webpack_require__("fOKV");
__webpack_require__("pmmJ");
__webpack_require__("WWuK");
__webpack_require__("iJoW");
__webpack_require__("jJCL");
__webpack_require__("WrsD");
__webpack_require__("y+6Q");
__webpack_require__("2z9E");
__webpack_require__("jJ+0");
__webpack_require__("YXwe");
__webpack_require__("nrvx");
__webpack_require__("dzzp");
__webpack_require__("8kVM");
__webpack_require__("nw/5");
__webpack_require__("EA4g");
__webpack_require__("5Zef");
__webpack_require__("JZf4");

module.exports = __webpack_require__("zadB").Symbol;

/***/ }),

/***/ "1+KL":
/***/ (function(module, exports, __webpack_require__) {

var classofRaw = __webpack_require__("rQTS");
var TO_STRING_TAG = __webpack_require__("95jh")('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {/* empty */}
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
  // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O)
  // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

/***/ }),

/***/ "11Ut":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("Gfzd").f;
var has = __webpack_require__("yS17");
var TAG = __webpack_require__("Ug9I")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

/***/ }),

/***/ "1ExO":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("FRpO").EventEmitter;

/***/ }),

/***/ "1Gki":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("IayR");

/***/ }),

/***/ "1JcR":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var Pos = CodeMirror.Pos;
  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }

  var nameStartChar = "A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\-\:\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var xmlTagStart = new RegExp("<(/?)([" + nameStartChar + "][" + nameChar + "]*)", "g");

  function Iter(cm, line, ch, range) {
    this.line = line;this.ch = ch;
    this.cm = cm;this.text = cm.getLine(line);
    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();
    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();
  }

  function tagAt(iter, ch) {
    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));
    return type && /\btag\b/.test(type);
  }

  function nextLine(iter) {
    if (iter.line >= iter.max) return;
    iter.ch = 0;
    iter.text = iter.cm.getLine(++iter.line);
    return true;
  }
  function prevLine(iter) {
    if (iter.line <= iter.min) return;
    iter.text = iter.cm.getLine(--iter.line);
    iter.ch = iter.text.length;
    return true;
  }

  function toTagEnd(iter) {
    for (;;) {
      var gt = iter.text.indexOf(">", iter.ch);
      if (gt == -1) {
        if (nextLine(iter)) continue;else return;
      }
      if (!tagAt(iter, gt + 1)) {
        iter.ch = gt + 1;continue;
      }
      var lastSlash = iter.text.lastIndexOf("/", gt);
      var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
      iter.ch = gt + 1;
      return selfClose ? "selfClose" : "regular";
    }
  }
  function toTagStart(iter) {
    for (;;) {
      var lt = iter.ch ? iter.text.lastIndexOf("<", iter.ch - 1) : -1;
      if (lt == -1) {
        if (prevLine(iter)) continue;else return;
      }
      if (!tagAt(iter, lt + 1)) {
        iter.ch = lt;continue;
      }
      xmlTagStart.lastIndex = lt;
      iter.ch = lt;
      var match = xmlTagStart.exec(iter.text);
      if (match && match.index == lt) return match;
    }
  }

  function toNextTag(iter) {
    for (;;) {
      xmlTagStart.lastIndex = iter.ch;
      var found = xmlTagStart.exec(iter.text);
      if (!found) {
        if (nextLine(iter)) continue;else return;
      }
      if (!tagAt(iter, found.index + 1)) {
        iter.ch = found.index + 1;continue;
      }
      iter.ch = found.index + found[0].length;
      return found;
    }
  }
  function toPrevTag(iter) {
    for (;;) {
      var gt = iter.ch ? iter.text.lastIndexOf(">", iter.ch - 1) : -1;
      if (gt == -1) {
        if (prevLine(iter)) continue;else return;
      }
      if (!tagAt(iter, gt + 1)) {
        iter.ch = gt;continue;
      }
      var lastSlash = iter.text.lastIndexOf("/", gt);
      var selfClose = lastSlash > -1 && !/\S/.test(iter.text.slice(lastSlash + 1, gt));
      iter.ch = gt + 1;
      return selfClose ? "selfClose" : "regular";
    }
  }

  function findMatchingClose(iter, tag) {
    var stack = [];
    for (;;) {
      var next = toNextTag(iter),
          end,
          startLine = iter.line,
          startCh = iter.ch - (next ? next[0].length : 0);
      if (!next || !(end = toTagEnd(iter))) return;
      if (end == "selfClose") continue;
      if (next[1]) {
        // closing tag
        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {
          stack.length = i;
          break;
        }
        if (i < 0 && (!tag || tag == next[2])) return {
          tag: next[2],
          from: Pos(startLine, startCh),
          to: Pos(iter.line, iter.ch)
        };
      } else {
        // opening tag
        stack.push(next[2]);
      }
    }
  }
  function findMatchingOpen(iter, tag) {
    var stack = [];
    for (;;) {
      var prev = toPrevTag(iter);
      if (!prev) return;
      if (prev == "selfClose") {
        toTagStart(iter);continue;
      }
      var endLine = iter.line,
          endCh = iter.ch;
      var start = toTagStart(iter);
      if (!start) return;
      if (start[1]) {
        // closing tag
        stack.push(start[2]);
      } else {
        // opening tag
        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {
          stack.length = i;
          break;
        }
        if (i < 0 && (!tag || tag == start[2])) return {
          tag: start[2],
          from: Pos(iter.line, iter.ch),
          to: Pos(endLine, endCh)
        };
      }
    }
  }

  CodeMirror.registerHelper("fold", "xml", function (cm, start) {
    var iter = new Iter(cm, start.line, 0);
    for (;;) {
      var openTag = toNextTag(iter);
      if (!openTag || iter.line != start.line) return;
      var end = toTagEnd(iter);
      if (!end) return;
      if (!openTag[1] && end != "selfClose") {
        var startPos = Pos(iter.line, iter.ch);
        var endPos = findMatchingClose(iter, openTag[2]);
        return endPos && cmp(endPos.from, startPos) > 0 ? { from: startPos, to: endPos.from } : null;
      }
    }
  });
  CodeMirror.findMatchingTag = function (cm, pos, range) {
    var iter = new Iter(cm, pos.line, pos.ch, range);
    if (iter.text.indexOf(">") == -1 && iter.text.indexOf("<") == -1) return;
    var end = toTagEnd(iter),
        to = end && Pos(iter.line, iter.ch);
    var start = end && toTagStart(iter);
    if (!end || !start || cmp(iter, pos) > 0) return;
    var here = { from: Pos(iter.line, iter.ch), to: to, tag: start[2] };
    if (end == "selfClose") return { open: here, close: null, at: "open" };

    if (start[1]) {
      // closing tag
      return { open: findMatchingOpen(iter, start[2]), close: here, at: "close" };
    } else {
      // opening tag
      iter = new Iter(cm, to.line, to.ch, range);
      return { open: here, close: findMatchingClose(iter, start[2]), at: "open" };
    }
  };

  CodeMirror.findEnclosingTag = function (cm, pos, range, tag) {
    var iter = new Iter(cm, pos.line, pos.ch, range);
    for (;;) {
      var open = findMatchingOpen(iter, tag);
      if (!open) break;
      var forward = new Iter(cm, pos.line, pos.ch, range);
      var close = findMatchingClose(forward, open.tag);
      if (close) return { open: open, close: close };
    }
  };

  // Used by addon/edit/closetag.js
  CodeMirror.scanForClosingTag = function (cm, pos, name, end) {
    var iter = new Iter(cm, pos.line, pos.ch, end ? { from: 0, to: end } : null);
    return findMatchingClose(iter, name);
  };
});

/***/ }),

/***/ "1g0E":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("xWhT");
var propertyIsEnumerableModule = __webpack_require__("2uWC");
var createPropertyDescriptor = __webpack_require__("IFQ2");
var toIndexedObject = __webpack_require__("SD9a");
var toPrimitive = __webpack_require__("i3Mv");
var has = __webpack_require__("UYRC");
var IE8_DOM_DEFINE = __webpack_require__("/7yg");
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {/* empty */}
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

/***/ }),

/***/ "1kq3":
/***/ (function(module, exports) {

module.exports = true;

/***/ }),

/***/ "1miM":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Representation a of zip file in js
 * @constructor
 */

function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if (!(this instanceof JSZip)) {
        return new JSZip();
    }

    if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function () {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = __webpack_require__("e4aZ");
JSZip.prototype.loadAsync = __webpack_require__("2/gt");
JSZip.support = __webpack_require__("untT");
JSZip.defaults = __webpack_require__("lUr3");

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.2.0";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = __webpack_require__("8JlO");
module.exports = JSZip;

/***/ }),

/***/ "2/gt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var external = __webpack_require__("8JlO");
var utf8 = __webpack_require__("Sm7/");
var utils = __webpack_require__("dvMn");
var ZipEntries = __webpack_require__("rAgE");
var Crc32Probe = __webpack_require__("gpbE");
var nodejsUtils = __webpack_require__("c5OX");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        }).on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        }).resume();
    });
}

module.exports = function (data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions: input.unixPermissions,
                dosPermissions: input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

/***/ }),

/***/ "29F7":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var Pos = CodeMirror.Pos;

  function regexpFlags(regexp) {
    var flags = regexp.flags;
    return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
  }

  function ensureFlags(regexp, flags) {
    var current = regexpFlags(regexp),
        target = current;
    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1) target += flags.charAt(i);
    return current == target ? regexp : new RegExp(regexp.source, target);
  }

  function maybeMultiline(regexp) {
    return (/\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source)
    );
  }

  function searchRegexpForward(doc, regexp, start) {
    regexp = ensureFlags(regexp, "g");
    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
      regexp.lastIndex = ch;
      var string = doc.getLine(line),
          match = regexp.exec(string);
      if (match) return { from: Pos(line, match.index),
        to: Pos(line, match.index + match[0].length),
        match: match };
    }
  }

  function searchRegexpForwardMultiline(doc, regexp, start) {
    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start);

    regexp = ensureFlags(regexp, "gm");
    var string,
        chunk = 1;
    for (var line = start.line, last = doc.lastLine(); line <= last;) {
      // This grows the search buffer in exponentially-sized chunks
      // between matches, so that nearby matches are fast and don't
      // require concatenating the whole document (in case we're
      // searching for something that has tons of matches), but at the
      // same time, the amount of retries is limited.
      for (var i = 0; i < chunk; i++) {
        if (line > last) break;
        var curLine = doc.getLine(line++);
        string = string == null ? curLine : string + "\n" + curLine;
      }
      chunk = chunk * 2;
      regexp.lastIndex = start.ch;
      var match = regexp.exec(string);
      if (match) {
        var before = string.slice(0, match.index).split("\n"),
            inside = match[0].split("\n");
        var startLine = start.line + before.length - 1,
            startCh = before[before.length - 1].length;
        return { from: Pos(startLine, startCh),
          to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
          match: match };
      }
    }
  }

  function lastMatchIn(string, regexp) {
    var cutOff = 0,
        match;
    for (;;) {
      regexp.lastIndex = cutOff;
      var newMatch = regexp.exec(string);
      if (!newMatch) return match;
      match = newMatch;
      cutOff = match.index + (match[0].length || 1);
      if (cutOff == string.length) return match;
    }
  }

  function searchRegexpBackward(doc, regexp, start) {
    regexp = ensureFlags(regexp, "g");
    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
      var string = doc.getLine(line);
      if (ch > -1) string = string.slice(0, ch);
      var match = lastMatchIn(string, regexp);
      if (match) return { from: Pos(line, match.index),
        to: Pos(line, match.index + match[0].length),
        match: match };
    }
  }

  function searchRegexpBackwardMultiline(doc, regexp, start) {
    regexp = ensureFlags(regexp, "gm");
    var string,
        chunk = 1;
    for (var line = start.line, first = doc.firstLine(); line >= first;) {
      for (var i = 0; i < chunk; i++) {
        var curLine = doc.getLine(line--);
        string = string == null ? curLine.slice(0, start.ch) : curLine + "\n" + string;
      }
      chunk *= 2;

      var match = lastMatchIn(string, regexp);
      if (match) {
        var before = string.slice(0, match.index).split("\n"),
            inside = match[0].split("\n");
        var startLine = line + before.length,
            startCh = before[before.length - 1].length;
        return { from: Pos(startLine, startCh),
          to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
          match: match };
      }
    }
  }

  var doFold, noFold;
  if (String.prototype.normalize) {
    doFold = function (str) {
      return str.normalize("NFD").toLowerCase();
    };
    noFold = function (str) {
      return str.normalize("NFD");
    };
  } else {
    doFold = function (str) {
      return str.toLowerCase();
    };
    noFold = function (str) {
      return str;
    };
  }

  // Maps a position in a case-folded line back to a position in the original line
  // (compensating for codepoints increasing in number during folding)
  function adjustPos(orig, folded, pos, foldFunc) {
    if (orig.length == folded.length) return pos;
    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
      if (min == max) return min;
      var mid = min + max >> 1;
      var len = foldFunc(orig.slice(0, mid)).length;
      if (len == pos) return mid;else if (len > pos) max = mid;else min = mid + 1;
    }
  }

  function searchStringForward(doc, query, start, caseFold) {
    // Empty string would match anything and never progress, so we
    // define it to match nothing instead.
    if (!query.length) return null;
    var fold = caseFold ? doFold : noFold;
    var lines = fold(query).split(/\r|\n\r?/);

    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
      var orig = doc.getLine(line).slice(ch),
          string = fold(orig);
      if (lines.length == 1) {
        var found = string.indexOf(lines[0]);
        if (found == -1) continue search;
        var start = adjustPos(orig, string, found, fold) + ch;
        return { from: Pos(line, adjustPos(orig, string, found, fold) + ch),
          to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch) };
      } else {
        var cutFrom = string.length - lines[0].length;
        if (string.slice(cutFrom) != lines[0]) continue search;
        for (var i = 1; i < lines.length - 1; i++) if (fold(doc.getLine(line + i)) != lines[i]) continue search;
        var end = doc.getLine(line + lines.length - 1),
            endString = fold(end),
            lastLine = lines[lines.length - 1];
        if (endString.slice(0, lastLine.length) != lastLine) continue search;
        return { from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
          to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold)) };
      }
    }
  }

  function searchStringBackward(doc, query, start, caseFold) {
    if (!query.length) return null;
    var fold = caseFold ? doFold : noFold;
    var lines = fold(query).split(/\r|\n\r?/);

    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
      var orig = doc.getLine(line);
      if (ch > -1) orig = orig.slice(0, ch);
      var string = fold(orig);
      if (lines.length == 1) {
        var found = string.lastIndexOf(lines[0]);
        if (found == -1) continue search;
        return { from: Pos(line, adjustPos(orig, string, found, fold)),
          to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold)) };
      } else {
        var lastLine = lines[lines.length - 1];
        if (string.slice(0, lastLine.length) != lastLine) continue search;
        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++) if (fold(doc.getLine(start + i)) != lines[i]) continue search;
        var top = doc.getLine(line + 1 - lines.length),
            topString = fold(top);
        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;
        return { from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
          to: Pos(line, adjustPos(orig, string, lastLine.length, fold)) };
      }
    }
  }

  function SearchCursor(doc, query, pos, options) {
    this.atOccurrence = false;
    this.doc = doc;
    pos = pos ? doc.clipPos(pos) : Pos(0, 0);
    this.pos = { from: pos, to: pos };

    var caseFold;
    if (typeof options == "object") {
      caseFold = options.caseFold;
    } else {
      // Backwards compat for when caseFold was the 4th argument
      caseFold = options;
      options = null;
    }

    if (typeof query == "string") {
      if (caseFold == null) caseFold = false;
      this.matches = function (reverse, pos) {
        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold);
      };
    } else {
      query = ensureFlags(query, "gm");
      if (!options || options.multiline !== false) this.matches = function (reverse, pos) {
        return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos);
      };else this.matches = function (reverse, pos) {
        return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos);
      };
    }
  }

  SearchCursor.prototype = {
    findNext: function () {
      return this.find(false);
    },
    findPrevious: function () {
      return this.find(true);
    },

    find: function (reverse) {
      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to));

      // Implements weird auto-growing behavior on null-matches for
      // backwards-compatiblity with the vim code (unfortunately)
      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {
        if (reverse) {
          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1);else if (result.from.line == this.doc.firstLine()) result = null;else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)));
        } else {
          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1);else if (result.to.line == this.doc.lastLine()) result = null;else result = this.matches(reverse, Pos(result.to.line + 1, 0));
        }
      }

      if (result) {
        this.pos = result;
        this.atOccurrence = true;
        return this.pos.match || true;
      } else {
        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
        this.pos = { from: end, to: end };
        return this.atOccurrence = false;
      }
    },

    from: function () {
      if (this.atOccurrence) return this.pos.from;
    },
    to: function () {
      if (this.atOccurrence) return this.pos.to;
    },

    replace: function (newText, origin) {
      if (!this.atOccurrence) return;
      var lines = CodeMirror.splitLines(newText);
      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
      this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
    }
  };

  CodeMirror.defineExtension("getSearchCursor", function (query, pos, caseFold) {
    return new SearchCursor(this.doc, query, pos, caseFold);
  });
  CodeMirror.defineDocExtension("getSearchCursor", function (query, pos, caseFold) {
    return new SearchCursor(this, query, pos, caseFold);
  });

  CodeMirror.defineExtension("selectMatches", function (query, caseFold) {
    var ranges = [];
    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
    while (cur.findNext()) {
      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
      ranges.push({ anchor: cur.from(), head: cur.to() });
    }
    if (ranges.length) this.setSelections(ranges, 0);
  });
});

/***/ }),

/***/ "2ANV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createStyles = __webpack_require__("uqKE");

var _createStyles2 = _interopRequireDefault(_createStyles);

var _ObjectValue = __webpack_require__("fHwt");

var _ObjectValue2 = _interopRequireDefault(_ObjectValue);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var DataContainer = function DataContainer(_ref, _ref2) {
  var rows = _ref.rows,
      columns = _ref.columns,
      rowsData = _ref.rowsData;
  var theme = _ref2.theme;

  var styles = (0, _createStyles2.default)('TableInspectorDataContainer', theme);
  var borderStyles = (0, _createStyles2.default)('TableInspectorLeftBorder', theme);

  return _react2.default.createElement('div', { style: styles.div }, _react2.default.createElement('table', { style: styles.table }, _react2.default.createElement('colgroup', null), _react2.default.createElement('tbody', null, rows.map(function (row, i) {
    return _react2.default.createElement('tr', { key: row, style: styles.tr }, _react2.default.createElement('td', { style: (0, _extends3.default)({}, styles.td, borderStyles.none) }, row), columns.map(function (column) {
      var rowData = rowsData[i];
      // rowData could be
      //  object -> index by key
      //    array -> index by array index
      //    null -> pass
      //  boolean -> pass
      //  string -> pass (hasOwnProperty returns true for [0..len-1])
      //  number -> pass
      //  function -> pass
      //  symbol
      //  undefined -> pass
      if ((typeof rowData === 'undefined' ? 'undefined' : (0, _typeof3.default)(rowData)) === 'object' && rowData !== null && rowData.hasOwnProperty(column)) {
        return _react2.default.createElement('td', { key: column, style: (0, _extends3.default)({}, styles.td, borderStyles.solid) }, _react2.default.createElement(_ObjectValue2.default, { object: rowData[column] }));
      } else {
        return _react2.default.createElement('td', { key: column, style: (0, _extends3.default)({}, styles.td, borderStyles.solid) });
      }
    }));
  }))));
};

DataContainer.contextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};

exports.default = DataContainer;

/***/ }),

/***/ "2O9B":
/***/ (function(module, exports, __webpack_require__) {

var definePropertyModule = __webpack_require__("uebg");
var createPropertyDescriptor = __webpack_require__("IFQ2");

module.exports = __webpack_require__("xWhT") ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "2P9T":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var ConvertWorker = __webpack_require__("yPXq");
var GenericWorker = __webpack_require__("ZKdc");
var base64 = __webpack_require__("Ps3q");
var support = __webpack_require__("untT");
var external = __webpack_require__("8JlO");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = __webpack_require__("LZfN");
    } catch (e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch (type) {
        case "blob":
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
            return base64.encode(content);
        default:
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat(type, dataArray) {
    var i,
        index = 0,
        res = null,
        totalLength = 0;
    for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch (type) {
        case "string":
            return dataArray.join("");
        case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for (i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '" + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper.on('data', function (data, meta) {
            dataArray.push(data);
            if (updateCallback) {
                updateCallback(meta);
            }
        }).on('error', function (err) {
            dataArray = [];
            reject(err);
        }).on('end', function () {
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        }).resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
            break;
        case "base64":
            internalType = "string";
            break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate: function (updateCb) {
        return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on: function (evt, fn) {
        var self = this;

        if (evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume: function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause: function () {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream: function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
    }
};

module.exports = StreamHelper;

/***/ }),

/***/ "2mwf":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("c2zY")('observable');

/***/ }),

/***/ "2u+n":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("tbG5");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

var lext = [/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];

var dbase = [/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];

var dext = [/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  //here = opts.here; /* table entry for duplication */

  var len = 0; /* a code's length in bits */
  var sym = 0; /* index of code symbols */
  var min = 0,
      max = 0; /* minimum and maximum code lengths */
  var root = 0; /* number of index bits for root table */
  var curr = 0; /* number of index bits for current table */
  var drop = 0; /* code bits to drop for sub-table */
  var left = 0; /* number of prefix codes available */
  var used = 0; /* code entries in table used */
  var huff = 0; /* Huffman code */
  var incr; /* for incrementing code, index */
  var fill; /* index for replicating entries */
  var low; /* low bits for current root entry */
  var mask; /* mask for low root bits */
  var next; /* next available space in table */
  var base = null; /* base value table to use */
  var base_index = 0;
  //  var shoextra;    /* extra bits table to use */
  var end; /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    opts.bits = 1;
    return 0; /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    } /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1; /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work; /* dummy value--not used */
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0; /* starting code */
  sym = 0; /* starting code symbol */
  len = min; /* starting code length */
  next = table_index; /* current table to fill in */
  curr = root; /* current table index bits */
  drop = 0; /* current bits to drop from code for index */
  low = -1; /* trigger new sub-table when len > root */
  used = 1 << root; /* use root table entries */
  mask = used - 1; /* mask for comparing low */

  /* check available table space */
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64; /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill; /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min; /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

/***/ }),

/***/ "2uWC":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = nativeGetOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = nativeGetOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

/***/ }),

/***/ "2z9E":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.match` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.match
__webpack_require__("KGgk")('match');

/***/ }),

/***/ "34Q3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// String encode/decode helpers


var utils = __webpack_require__("tbG5");

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}

// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};

// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};

// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) {
      utf16buf[out++] = c;continue;
    }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
    }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }

  return buf2binstring(utf16buf, out);
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) {
    return max;
  }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
};

/***/ }),

/***/ "38Wu":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__("peL6");
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "3DJC":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
__webpack_require__("KGgk")('patternMatch');

/***/ }),

/***/ "3PKL":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("dLYn");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "3tGu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__("dACh");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("jx4H");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("VOrx");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("ZKjc");

var _inherits3 = _interopRequireDefault(_inherits2);

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createStyles = __webpack_require__("uqKE");

var _createStyles2 = _interopRequireDefault(_createStyles);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var Arrow = function Arrow(_ref) {
  var expanded = _ref.expanded,
      styles = _ref.styles;
  return _react2.default.createElement('span', { style: (0, _extends3.default)({}, styles.base, expanded ? styles.expanded : styles.collapsed) }, '\u25B6');
};

var TreeNode = function (_Component) {
  (0, _inherits3.default)(TreeNode, _Component);

  function TreeNode() {
    (0, _classCallCheck3.default)(this, TreeNode);
    return (0, _possibleConstructorReturn3.default)(this, (TreeNode.__proto__ || Object.getPrototypeOf(TreeNode)).apply(this, arguments));
  }

  (0, _createClass3.default)(TreeNode, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          expanded = _props.expanded,
          onClick = _props.onClick,
          children = _props.children,
          nodeRenderer = _props.nodeRenderer,
          title = _props.title,
          shouldShowArrow = _props.shouldShowArrow,
          shouldShowPlaceholder = _props.shouldShowPlaceholder;
      var theme = this.context.theme;

      var styles = (0, _createStyles2.default)('TreeNode', theme);

      var renderedNode = (0, _react.createElement)(nodeRenderer, this.props);
      var childNodes = expanded ? children : undefined;

      return _react2.default.createElement('li', { 'aria-expanded': expanded, role: 'treeitem', style: styles.treeNodeBase, title: title }, _react2.default.createElement('div', { style: styles.treeNodePreviewContainer, onClick: onClick }, shouldShowArrow || _react.Children.count(children) > 0 ? _react2.default.createElement(Arrow, { expanded: expanded, styles: styles.treeNodeArrow }) : shouldShowPlaceholder && _react2.default.createElement('span', { style: styles.treeNodePlaceholder }, '\xA0'), renderedNode), _react2.default.createElement('ol', { role: 'group', style: styles.treeNodeChildNodesContainer }, childNodes));
    }
  }]);
  return TreeNode;
}(_react.Component);

TreeNode.propTypes = {
  name: _propTypes2.default.string,
  data: _propTypes2.default.any,

  expanded: _propTypes2.default.bool,
  shouldShowArrow: _propTypes2.default.bool,
  shouldShowPlaceholder: _propTypes2.default.bool,

  nodeRenderer: _propTypes2.default.func,

  onClick: _propTypes2.default.func
};

TreeNode.defaultProps = {
  name: undefined,
  data: undefined,
  expanded: true,

  nodeRenderer: function nodeRenderer(_ref2) {
    var name = _ref2.name;
    return _react2.default.createElement('span', null, name);
  },

  onClick: function onClick() {},

  shouldShowArrow: false,
  shouldShowPlaceholder: true
};

TreeNode.contextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};

exports.default = TreeNode;

/***/ }),

/***/ "3v7p":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("htFH");
var $Object = __webpack_require__("zKeE").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

/***/ }),

/***/ "3zRh":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("g31e");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "4Bm0":
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),

/***/ "4E2n":
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	/* istanbul ignore next */
	if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);
	/* istanbul ignore next */
	else if (typeof exports === 'object') exports["esprima"] = factory();else root["esprima"] = factory();
})(this, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};

			/******/ // The require function
			/******/function __webpack_require__(moduleId) {

				/******/ // Check if module is in cache
				/* istanbul ignore if */
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;

				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };

				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ // Flag the module as loaded
				/******/module.loaded = true;

				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}

			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;

			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;

			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";

			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			/*
     Copyright JS Foundation and other contributors, https://js.foundation/
   	  Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions are met:
   	    * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
   	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
     THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

			Object.defineProperty(exports, "__esModule", { value: true });
			var comment_handler_1 = __webpack_require__(1);
			var jsx_parser_1 = __webpack_require__(3);
			var parser_1 = __webpack_require__(8);
			var tokenizer_1 = __webpack_require__(15);
			function parse(code, options, delegate) {
				var commentHandler = null;
				var proxyDelegate = function (node, metadata) {
					if (delegate) {
						delegate(node, metadata);
					}
					if (commentHandler) {
						commentHandler.visit(node, metadata);
					}
				};
				var parserDelegate = typeof delegate === 'function' ? proxyDelegate : null;
				var collectComment = false;
				if (options) {
					collectComment = typeof options.comment === 'boolean' && options.comment;
					var attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
					if (collectComment || attachComment) {
						commentHandler = new comment_handler_1.CommentHandler();
						commentHandler.attach = attachComment;
						options.comment = true;
						parserDelegate = proxyDelegate;
					}
				}
				var isModule = false;
				if (options && typeof options.sourceType === 'string') {
					isModule = options.sourceType === 'module';
				}
				var parser;
				if (options && typeof options.jsx === 'boolean' && options.jsx) {
					parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
				} else {
					parser = new parser_1.Parser(code, options, parserDelegate);
				}
				var program = isModule ? parser.parseModule() : parser.parseScript();
				var ast = program;
				if (collectComment && commentHandler) {
					ast.comments = commentHandler.comments;
				}
				if (parser.config.tokens) {
					ast.tokens = parser.tokens;
				}
				if (parser.config.tolerant) {
					ast.errors = parser.errorHandler.errors;
				}
				return ast;
			}
			exports.parse = parse;
			function parseModule(code, options, delegate) {
				var parsingOptions = options || {};
				parsingOptions.sourceType = 'module';
				return parse(code, parsingOptions, delegate);
			}
			exports.parseModule = parseModule;
			function parseScript(code, options, delegate) {
				var parsingOptions = options || {};
				parsingOptions.sourceType = 'script';
				return parse(code, parsingOptions, delegate);
			}
			exports.parseScript = parseScript;
			function tokenize(code, options, delegate) {
				var tokenizer = new tokenizer_1.Tokenizer(code, options);
				var tokens;
				tokens = [];
				try {
					while (true) {
						var token = tokenizer.getNextToken();
						if (!token) {
							break;
						}
						if (delegate) {
							token = delegate(token);
						}
						tokens.push(token);
					}
				} catch (e) {
					tokenizer.errorHandler.tolerate(e);
				}
				if (tokenizer.errorHandler.tolerant) {
					tokens.errors = tokenizer.errors();
				}
				return tokens;
			}
			exports.tokenize = tokenize;
			var syntax_1 = __webpack_require__(2);
			exports.Syntax = syntax_1.Syntax;
			// Sync with *.json manifests.
			exports.version = '4.0.1';

			/***/
		},
		/* 1 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			var CommentHandler = function () {
				function CommentHandler() {
					this.attach = false;
					this.comments = [];
					this.stack = [];
					this.leading = [];
					this.trailing = [];
				}
				CommentHandler.prototype.insertInnerComments = function (node, metadata) {
					//  innnerComments for properties empty block
					//  `function a() {/** comments **\/}`
					if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
						var innerComments = [];
						for (var i = this.leading.length - 1; i >= 0; --i) {
							var entry = this.leading[i];
							if (metadata.end.offset >= entry.start) {
								innerComments.unshift(entry.comment);
								this.leading.splice(i, 1);
								this.trailing.splice(i, 1);
							}
						}
						if (innerComments.length) {
							node.innerComments = innerComments;
						}
					}
				};
				CommentHandler.prototype.findTrailingComments = function (metadata) {
					var trailingComments = [];
					if (this.trailing.length > 0) {
						for (var i = this.trailing.length - 1; i >= 0; --i) {
							var entry_1 = this.trailing[i];
							if (entry_1.start >= metadata.end.offset) {
								trailingComments.unshift(entry_1.comment);
							}
						}
						this.trailing.length = 0;
						return trailingComments;
					}
					var entry = this.stack[this.stack.length - 1];
					if (entry && entry.node.trailingComments) {
						var firstComment = entry.node.trailingComments[0];
						if (firstComment && firstComment.range[0] >= metadata.end.offset) {
							trailingComments = entry.node.trailingComments;
							delete entry.node.trailingComments;
						}
					}
					return trailingComments;
				};
				CommentHandler.prototype.findLeadingComments = function (metadata) {
					var leadingComments = [];
					var target;
					while (this.stack.length > 0) {
						var entry = this.stack[this.stack.length - 1];
						if (entry && entry.start >= metadata.start.offset) {
							target = entry.node;
							this.stack.pop();
						} else {
							break;
						}
					}
					if (target) {
						var count = target.leadingComments ? target.leadingComments.length : 0;
						for (var i = count - 1; i >= 0; --i) {
							var comment = target.leadingComments[i];
							if (comment.range[1] <= metadata.start.offset) {
								leadingComments.unshift(comment);
								target.leadingComments.splice(i, 1);
							}
						}
						if (target.leadingComments && target.leadingComments.length === 0) {
							delete target.leadingComments;
						}
						return leadingComments;
					}
					for (var i = this.leading.length - 1; i >= 0; --i) {
						var entry = this.leading[i];
						if (entry.start <= metadata.start.offset) {
							leadingComments.unshift(entry.comment);
							this.leading.splice(i, 1);
						}
					}
					return leadingComments;
				};
				CommentHandler.prototype.visitNode = function (node, metadata) {
					if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
						return;
					}
					this.insertInnerComments(node, metadata);
					var trailingComments = this.findTrailingComments(metadata);
					var leadingComments = this.findLeadingComments(metadata);
					if (leadingComments.length > 0) {
						node.leadingComments = leadingComments;
					}
					if (trailingComments.length > 0) {
						node.trailingComments = trailingComments;
					}
					this.stack.push({
						node: node,
						start: metadata.start.offset
					});
				};
				CommentHandler.prototype.visitComment = function (node, metadata) {
					var type = node.type[0] === 'L' ? 'Line' : 'Block';
					var comment = {
						type: type,
						value: node.value
					};
					if (node.range) {
						comment.range = node.range;
					}
					if (node.loc) {
						comment.loc = node.loc;
					}
					this.comments.push(comment);
					if (this.attach) {
						var entry = {
							comment: {
								type: type,
								value: node.value,
								range: [metadata.start.offset, metadata.end.offset]
							},
							start: metadata.start.offset
						};
						if (node.loc) {
							entry.comment.loc = node.loc;
						}
						node.type = type;
						this.leading.push(entry);
						this.trailing.push(entry);
					}
				};
				CommentHandler.prototype.visit = function (node, metadata) {
					if (node.type === 'LineComment') {
						this.visitComment(node, metadata);
					} else if (node.type === 'BlockComment') {
						this.visitComment(node, metadata);
					} else if (this.attach) {
						this.visitNode(node, metadata);
					}
				};
				return CommentHandler;
			}();
			exports.CommentHandler = CommentHandler;

			/***/
		},
		/* 2 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.Syntax = {
				AssignmentExpression: 'AssignmentExpression',
				AssignmentPattern: 'AssignmentPattern',
				ArrayExpression: 'ArrayExpression',
				ArrayPattern: 'ArrayPattern',
				ArrowFunctionExpression: 'ArrowFunctionExpression',
				AwaitExpression: 'AwaitExpression',
				BlockStatement: 'BlockStatement',
				BinaryExpression: 'BinaryExpression',
				BreakStatement: 'BreakStatement',
				CallExpression: 'CallExpression',
				CatchClause: 'CatchClause',
				ClassBody: 'ClassBody',
				ClassDeclaration: 'ClassDeclaration',
				ClassExpression: 'ClassExpression',
				ConditionalExpression: 'ConditionalExpression',
				ContinueStatement: 'ContinueStatement',
				DoWhileStatement: 'DoWhileStatement',
				DebuggerStatement: 'DebuggerStatement',
				EmptyStatement: 'EmptyStatement',
				ExportAllDeclaration: 'ExportAllDeclaration',
				ExportDefaultDeclaration: 'ExportDefaultDeclaration',
				ExportNamedDeclaration: 'ExportNamedDeclaration',
				ExportSpecifier: 'ExportSpecifier',
				ExpressionStatement: 'ExpressionStatement',
				ForStatement: 'ForStatement',
				ForOfStatement: 'ForOfStatement',
				ForInStatement: 'ForInStatement',
				FunctionDeclaration: 'FunctionDeclaration',
				FunctionExpression: 'FunctionExpression',
				Identifier: 'Identifier',
				IfStatement: 'IfStatement',
				ImportDeclaration: 'ImportDeclaration',
				ImportDefaultSpecifier: 'ImportDefaultSpecifier',
				ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
				ImportSpecifier: 'ImportSpecifier',
				Literal: 'Literal',
				LabeledStatement: 'LabeledStatement',
				LogicalExpression: 'LogicalExpression',
				MemberExpression: 'MemberExpression',
				MetaProperty: 'MetaProperty',
				MethodDefinition: 'MethodDefinition',
				NewExpression: 'NewExpression',
				ObjectExpression: 'ObjectExpression',
				ObjectPattern: 'ObjectPattern',
				Program: 'Program',
				Property: 'Property',
				RestElement: 'RestElement',
				ReturnStatement: 'ReturnStatement',
				SequenceExpression: 'SequenceExpression',
				SpreadElement: 'SpreadElement',
				Super: 'Super',
				SwitchCase: 'SwitchCase',
				SwitchStatement: 'SwitchStatement',
				TaggedTemplateExpression: 'TaggedTemplateExpression',
				TemplateElement: 'TemplateElement',
				TemplateLiteral: 'TemplateLiteral',
				ThisExpression: 'ThisExpression',
				ThrowStatement: 'ThrowStatement',
				TryStatement: 'TryStatement',
				UnaryExpression: 'UnaryExpression',
				UpdateExpression: 'UpdateExpression',
				VariableDeclaration: 'VariableDeclaration',
				VariableDeclarator: 'VariableDeclarator',
				WhileStatement: 'WhileStatement',
				WithStatement: 'WithStatement',
				YieldExpression: 'YieldExpression'
			};

			/***/
		},
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			/* istanbul ignore next */

			var __extends = this && this.__extends || function () {
				var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
					d.__proto__ = b;
				} || function (d, b) {
					for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
				};
				return function (d, b) {
					extendStatics(d, b);
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
				};
			}();
			Object.defineProperty(exports, "__esModule", { value: true });
			var character_1 = __webpack_require__(4);
			var JSXNode = __webpack_require__(5);
			var jsx_syntax_1 = __webpack_require__(6);
			var Node = __webpack_require__(7);
			var parser_1 = __webpack_require__(8);
			var token_1 = __webpack_require__(13);
			var xhtml_entities_1 = __webpack_require__(14);
			token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
			token_1.TokenName[101 /* Text */] = 'JSXText';
			// Fully qualified element name, e.g. <svg:path> returns "svg:path"
			function getQualifiedElementName(elementName) {
				var qualifiedName;
				switch (elementName.type) {
					case jsx_syntax_1.JSXSyntax.JSXIdentifier:
						var id = elementName;
						qualifiedName = id.name;
						break;
					case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
						var ns = elementName;
						qualifiedName = getQualifiedElementName(ns.namespace) + ':' + getQualifiedElementName(ns.name);
						break;
					case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
						var expr = elementName;
						qualifiedName = getQualifiedElementName(expr.object) + '.' + getQualifiedElementName(expr.property);
						break;
					/* istanbul ignore next */
					default:
						break;
				}
				return qualifiedName;
			}
			var JSXParser = function (_super) {
				__extends(JSXParser, _super);
				function JSXParser(code, options, delegate) {
					return _super.call(this, code, options, delegate) || this;
				}
				JSXParser.prototype.parsePrimaryExpression = function () {
					return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
				};
				JSXParser.prototype.startJSX = function () {
					// Unwind the scanner before the lookahead token.
					this.scanner.index = this.startMarker.index;
					this.scanner.lineNumber = this.startMarker.line;
					this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
				};
				JSXParser.prototype.finishJSX = function () {
					// Prime the next lookahead.
					this.nextToken();
				};
				JSXParser.prototype.reenterJSX = function () {
					this.startJSX();
					this.expectJSX('}');
					// Pop the closing '}' added from the lookahead.
					if (this.config.tokens) {
						this.tokens.pop();
					}
				};
				JSXParser.prototype.createJSXNode = function () {
					this.collectComments();
					return {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				};
				JSXParser.prototype.createJSXChildNode = function () {
					return {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				};
				JSXParser.prototype.scanXHTMLEntity = function (quote) {
					var result = '&';
					var valid = true;
					var terminated = false;
					var numeric = false;
					var hex = false;
					while (!this.scanner.eof() && valid && !terminated) {
						var ch = this.scanner.source[this.scanner.index];
						if (ch === quote) {
							break;
						}
						terminated = ch === ';';
						result += ch;
						++this.scanner.index;
						if (!terminated) {
							switch (result.length) {
								case 2:
									// e.g. '&#123;'
									numeric = ch === '#';
									break;
								case 3:
									if (numeric) {
										// e.g. '&#x41;'
										hex = ch === 'x';
										valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
										numeric = numeric && !hex;
									}
									break;
								default:
									valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
									valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
									break;
							}
						}
					}
					if (valid && terminated && result.length > 2) {
						// e.g. '&#x41;' becomes just '#x41'
						var str = result.substr(1, result.length - 2);
						if (numeric && str.length > 1) {
							result = String.fromCharCode(parseInt(str.substr(1), 10));
						} else if (hex && str.length > 2) {
							result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
						} else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
							result = xhtml_entities_1.XHTMLEntities[str];
						}
					}
					return result;
				};
				// Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
				JSXParser.prototype.lexJSX = function () {
					var cp = this.scanner.source.charCodeAt(this.scanner.index);
					// < > / : = { }
					if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
						var value = this.scanner.source[this.scanner.index++];
						return {
							type: 7 /* Punctuator */
							, value: value,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index - 1,
							end: this.scanner.index
						};
					}
					// " '
					if (cp === 34 || cp === 39) {
						var start = this.scanner.index;
						var quote = this.scanner.source[this.scanner.index++];
						var str = '';
						while (!this.scanner.eof()) {
							var ch = this.scanner.source[this.scanner.index++];
							if (ch === quote) {
								break;
							} else if (ch === '&') {
								str += this.scanXHTMLEntity(quote);
							} else {
								str += ch;
							}
						}
						return {
							type: 8 /* StringLiteral */
							, value: str,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					// ... or .
					if (cp === 46) {
						var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
						var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
						var value = n1 === 46 && n2 === 46 ? '...' : '.';
						var start = this.scanner.index;
						this.scanner.index += value.length;
						return {
							type: 7 /* Punctuator */
							, value: value,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					// `
					if (cp === 96) {
						// Only placeholder, since it will be rescanned as a real assignment expression.
						return {
							type: 10 /* Template */
							, value: '',
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index,
							end: this.scanner.index
						};
					}
					// Identifer can not contain backslash (char code 92).
					if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
						var start = this.scanner.index;
						++this.scanner.index;
						while (!this.scanner.eof()) {
							var ch = this.scanner.source.charCodeAt(this.scanner.index);
							if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
								++this.scanner.index;
							} else if (ch === 45) {
								// Hyphen (char code 45) can be part of an identifier.
								++this.scanner.index;
							} else {
								break;
							}
						}
						var id = this.scanner.source.slice(start, this.scanner.index);
						return {
							type: 100 /* Identifier */
							, value: id,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					return this.scanner.lex();
				};
				JSXParser.prototype.nextJSXToken = function () {
					this.collectComments();
					this.startMarker.index = this.scanner.index;
					this.startMarker.line = this.scanner.lineNumber;
					this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					var token = this.lexJSX();
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					if (this.config.tokens) {
						this.tokens.push(this.convertToken(token));
					}
					return token;
				};
				JSXParser.prototype.nextJSXText = function () {
					this.startMarker.index = this.scanner.index;
					this.startMarker.line = this.scanner.lineNumber;
					this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					var start = this.scanner.index;
					var text = '';
					while (!this.scanner.eof()) {
						var ch = this.scanner.source[this.scanner.index];
						if (ch === '{' || ch === '<') {
							break;
						}
						++this.scanner.index;
						text += ch;
						if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							++this.scanner.lineNumber;
							if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
								++this.scanner.index;
							}
							this.scanner.lineStart = this.scanner.index;
						}
					}
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					var token = {
						type: 101 /* Text */
						, value: text,
						lineNumber: this.scanner.lineNumber,
						lineStart: this.scanner.lineStart,
						start: start,
						end: this.scanner.index
					};
					if (text.length > 0 && this.config.tokens) {
						this.tokens.push(this.convertToken(token));
					}
					return token;
				};
				JSXParser.prototype.peekJSXToken = function () {
					var state = this.scanner.saveState();
					this.scanner.scanComments();
					var next = this.lexJSX();
					this.scanner.restoreState(state);
					return next;
				};
				// Expect the next JSX token to match the specified punctuator.
				// If not, an exception will be thrown.
				JSXParser.prototype.expectJSX = function (value) {
					var token = this.nextJSXToken();
					if (token.type !== 7 /* Punctuator */ || token.value !== value) {
						this.throwUnexpectedToken(token);
					}
				};
				// Return true if the next JSX token matches the specified punctuator.
				JSXParser.prototype.matchJSX = function (value) {
					var next = this.peekJSXToken();
					return next.type === 7 /* Punctuator */ && next.value === value;
				};
				JSXParser.prototype.parseJSXIdentifier = function () {
					var node = this.createJSXNode();
					var token = this.nextJSXToken();
					if (token.type !== 100 /* Identifier */) {
							this.throwUnexpectedToken(token);
						}
					return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
				};
				JSXParser.prototype.parseJSXElementName = function () {
					var node = this.createJSXNode();
					var elementName = this.parseJSXIdentifier();
					if (this.matchJSX(':')) {
						var namespace = elementName;
						this.expectJSX(':');
						var name_1 = this.parseJSXIdentifier();
						elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
					} else if (this.matchJSX('.')) {
						while (this.matchJSX('.')) {
							var object = elementName;
							this.expectJSX('.');
							var property = this.parseJSXIdentifier();
							elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
						}
					}
					return elementName;
				};
				JSXParser.prototype.parseJSXAttributeName = function () {
					var node = this.createJSXNode();
					var attributeName;
					var identifier = this.parseJSXIdentifier();
					if (this.matchJSX(':')) {
						var namespace = identifier;
						this.expectJSX(':');
						var name_2 = this.parseJSXIdentifier();
						attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
					} else {
						attributeName = identifier;
					}
					return attributeName;
				};
				JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
					var node = this.createJSXNode();
					var token = this.nextJSXToken();
					if (token.type !== 8 /* StringLiteral */) {
							this.throwUnexpectedToken(token);
						}
					var raw = this.getTokenRaw(token);
					return this.finalize(node, new Node.Literal(token.value, raw));
				};
				JSXParser.prototype.parseJSXExpressionAttribute = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					this.finishJSX();
					if (this.match('}')) {
						this.tolerateError('JSX attributes must only be assigned a non-empty expression');
					}
					var expression = this.parseAssignmentExpression();
					this.reenterJSX();
					return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
				};
				JSXParser.prototype.parseJSXAttributeValue = function () {
					return this.matchJSX('{') ? this.parseJSXExpressionAttribute() : this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
				};
				JSXParser.prototype.parseJSXNameValueAttribute = function () {
					var node = this.createJSXNode();
					var name = this.parseJSXAttributeName();
					var value = null;
					if (this.matchJSX('=')) {
						this.expectJSX('=');
						value = this.parseJSXAttributeValue();
					}
					return this.finalize(node, new JSXNode.JSXAttribute(name, value));
				};
				JSXParser.prototype.parseJSXSpreadAttribute = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					this.expectJSX('...');
					this.finishJSX();
					var argument = this.parseAssignmentExpression();
					this.reenterJSX();
					return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
				};
				JSXParser.prototype.parseJSXAttributes = function () {
					var attributes = [];
					while (!this.matchJSX('/') && !this.matchJSX('>')) {
						var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
						attributes.push(attribute);
					}
					return attributes;
				};
				JSXParser.prototype.parseJSXOpeningElement = function () {
					var node = this.createJSXNode();
					this.expectJSX('<');
					var name = this.parseJSXElementName();
					var attributes = this.parseJSXAttributes();
					var selfClosing = this.matchJSX('/');
					if (selfClosing) {
						this.expectJSX('/');
					}
					this.expectJSX('>');
					return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
				};
				JSXParser.prototype.parseJSXBoundaryElement = function () {
					var node = this.createJSXNode();
					this.expectJSX('<');
					if (this.matchJSX('/')) {
						this.expectJSX('/');
						var name_3 = this.parseJSXElementName();
						this.expectJSX('>');
						return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
					}
					var name = this.parseJSXElementName();
					var attributes = this.parseJSXAttributes();
					var selfClosing = this.matchJSX('/');
					if (selfClosing) {
						this.expectJSX('/');
					}
					this.expectJSX('>');
					return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
				};
				JSXParser.prototype.parseJSXEmptyExpression = function () {
					var node = this.createJSXChildNode();
					this.collectComments();
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					return this.finalize(node, new JSXNode.JSXEmptyExpression());
				};
				JSXParser.prototype.parseJSXExpressionContainer = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					var expression;
					if (this.matchJSX('}')) {
						expression = this.parseJSXEmptyExpression();
						this.expectJSX('}');
					} else {
						this.finishJSX();
						expression = this.parseAssignmentExpression();
						this.reenterJSX();
					}
					return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
				};
				JSXParser.prototype.parseJSXChildren = function () {
					var children = [];
					while (!this.scanner.eof()) {
						var node = this.createJSXChildNode();
						var token = this.nextJSXText();
						if (token.start < token.end) {
							var raw = this.getTokenRaw(token);
							var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
							children.push(child);
						}
						if (this.scanner.source[this.scanner.index] === '{') {
							var container = this.parseJSXExpressionContainer();
							children.push(container);
						} else {
							break;
						}
					}
					return children;
				};
				JSXParser.prototype.parseComplexJSXElement = function (el) {
					var stack = [];
					while (!this.scanner.eof()) {
						el.children = el.children.concat(this.parseJSXChildren());
						var node = this.createJSXChildNode();
						var element = this.parseJSXBoundaryElement();
						if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
							var opening = element;
							if (opening.selfClosing) {
								var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
								el.children.push(child);
							} else {
								stack.push(el);
								el = { node: node, opening: opening, closing: null, children: [] };
							}
						}
						if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
							el.closing = element;
							var open_1 = getQualifiedElementName(el.opening.name);
							var close_1 = getQualifiedElementName(el.closing.name);
							if (open_1 !== close_1) {
								this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
							}
							if (stack.length > 0) {
								var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
								el = stack[stack.length - 1];
								el.children.push(child);
								stack.pop();
							} else {
								break;
							}
						}
					}
					return el;
				};
				JSXParser.prototype.parseJSXElement = function () {
					var node = this.createJSXNode();
					var opening = this.parseJSXOpeningElement();
					var children = [];
					var closing = null;
					if (!opening.selfClosing) {
						var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
						children = el.children;
						closing = el.closing;
					}
					return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
				};
				JSXParser.prototype.parseJSXRoot = function () {
					// Pop the opening '<' added from the lookahead.
					if (this.config.tokens) {
						this.tokens.pop();
					}
					this.startJSX();
					var element = this.parseJSXElement();
					this.finishJSX();
					return element;
				};
				JSXParser.prototype.isStartOfExpression = function () {
					return _super.prototype.isStartOfExpression.call(this) || this.match('<');
				};
				return JSXParser;
			}(parser_1.Parser);
			exports.JSXParser = JSXParser;

			/***/
		},
		/* 4 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			// See also tools/generate-unicode-regex.js.
			var Regex = {
				// Unicode v8.0.0 NonAsciiIdentifierStart:
				NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
				// Unicode v8.0.0 NonAsciiIdentifierPart:
				NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
			};
			exports.Character = {
				/* tslint:disable:no-bitwise */
				fromCodePoint: function (cp) {
					return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));
				},
				// https://tc39.github.io/ecma262/#sec-white-space
				isWhiteSpace: function (cp) {
					return cp === 0x20 || cp === 0x09 || cp === 0x0B || cp === 0x0C || cp === 0xA0 || cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0;
				},
				// https://tc39.github.io/ecma262/#sec-line-terminators
				isLineTerminator: function (cp) {
					return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;
				},
				// https://tc39.github.io/ecma262/#sec-names-and-keywords
				isIdentifierStart: function (cp) {
					return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp));
				},
				isIdentifierPart: function (cp) {
					return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp >= 0x30 && cp <= 0x39 || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp));
				},
				// https://tc39.github.io/ecma262/#sec-literals-numeric-literals
				isDecimalDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x39; // 0..9
				},
				isHexDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x46 || cp >= 0x61 && cp <= 0x66; // a..f
				},
				isOctalDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x37; // 0..7
				}
			};

			/***/
		},
		/* 5 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var jsx_syntax_1 = __webpack_require__(6);
			/* tslint:disable:max-classes-per-file */
			var JSXClosingElement = function () {
				function JSXClosingElement(name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
					this.name = name;
				}
				return JSXClosingElement;
			}();
			exports.JSXClosingElement = JSXClosingElement;
			var JSXElement = function () {
				function JSXElement(openingElement, children, closingElement) {
					this.type = jsx_syntax_1.JSXSyntax.JSXElement;
					this.openingElement = openingElement;
					this.children = children;
					this.closingElement = closingElement;
				}
				return JSXElement;
			}();
			exports.JSXElement = JSXElement;
			var JSXEmptyExpression = function () {
				function JSXEmptyExpression() {
					this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
				}
				return JSXEmptyExpression;
			}();
			exports.JSXEmptyExpression = JSXEmptyExpression;
			var JSXExpressionContainer = function () {
				function JSXExpressionContainer(expression) {
					this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
					this.expression = expression;
				}
				return JSXExpressionContainer;
			}();
			exports.JSXExpressionContainer = JSXExpressionContainer;
			var JSXIdentifier = function () {
				function JSXIdentifier(name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
					this.name = name;
				}
				return JSXIdentifier;
			}();
			exports.JSXIdentifier = JSXIdentifier;
			var JSXMemberExpression = function () {
				function JSXMemberExpression(object, property) {
					this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
					this.object = object;
					this.property = property;
				}
				return JSXMemberExpression;
			}();
			exports.JSXMemberExpression = JSXMemberExpression;
			var JSXAttribute = function () {
				function JSXAttribute(name, value) {
					this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
					this.name = name;
					this.value = value;
				}
				return JSXAttribute;
			}();
			exports.JSXAttribute = JSXAttribute;
			var JSXNamespacedName = function () {
				function JSXNamespacedName(namespace, name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
					this.namespace = namespace;
					this.name = name;
				}
				return JSXNamespacedName;
			}();
			exports.JSXNamespacedName = JSXNamespacedName;
			var JSXOpeningElement = function () {
				function JSXOpeningElement(name, selfClosing, attributes) {
					this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
					this.name = name;
					this.selfClosing = selfClosing;
					this.attributes = attributes;
				}
				return JSXOpeningElement;
			}();
			exports.JSXOpeningElement = JSXOpeningElement;
			var JSXSpreadAttribute = function () {
				function JSXSpreadAttribute(argument) {
					this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
					this.argument = argument;
				}
				return JSXSpreadAttribute;
			}();
			exports.JSXSpreadAttribute = JSXSpreadAttribute;
			var JSXText = function () {
				function JSXText(value, raw) {
					this.type = jsx_syntax_1.JSXSyntax.JSXText;
					this.value = value;
					this.raw = raw;
				}
				return JSXText;
			}();
			exports.JSXText = JSXText;

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.JSXSyntax = {
				JSXAttribute: 'JSXAttribute',
				JSXClosingElement: 'JSXClosingElement',
				JSXElement: 'JSXElement',
				JSXEmptyExpression: 'JSXEmptyExpression',
				JSXExpressionContainer: 'JSXExpressionContainer',
				JSXIdentifier: 'JSXIdentifier',
				JSXMemberExpression: 'JSXMemberExpression',
				JSXNamespacedName: 'JSXNamespacedName',
				JSXOpeningElement: 'JSXOpeningElement',
				JSXSpreadAttribute: 'JSXSpreadAttribute',
				JSXText: 'JSXText'
			};

			/***/
		},
		/* 7 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			/* tslint:disable:max-classes-per-file */
			var ArrayExpression = function () {
				function ArrayExpression(elements) {
					this.type = syntax_1.Syntax.ArrayExpression;
					this.elements = elements;
				}
				return ArrayExpression;
			}();
			exports.ArrayExpression = ArrayExpression;
			var ArrayPattern = function () {
				function ArrayPattern(elements) {
					this.type = syntax_1.Syntax.ArrayPattern;
					this.elements = elements;
				}
				return ArrayPattern;
			}();
			exports.ArrayPattern = ArrayPattern;
			var ArrowFunctionExpression = function () {
				function ArrowFunctionExpression(params, body, expression) {
					this.type = syntax_1.Syntax.ArrowFunctionExpression;
					this.id = null;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = expression;
					this.async = false;
				}
				return ArrowFunctionExpression;
			}();
			exports.ArrowFunctionExpression = ArrowFunctionExpression;
			var AssignmentExpression = function () {
				function AssignmentExpression(operator, left, right) {
					this.type = syntax_1.Syntax.AssignmentExpression;
					this.operator = operator;
					this.left = left;
					this.right = right;
				}
				return AssignmentExpression;
			}();
			exports.AssignmentExpression = AssignmentExpression;
			var AssignmentPattern = function () {
				function AssignmentPattern(left, right) {
					this.type = syntax_1.Syntax.AssignmentPattern;
					this.left = left;
					this.right = right;
				}
				return AssignmentPattern;
			}();
			exports.AssignmentPattern = AssignmentPattern;
			var AsyncArrowFunctionExpression = function () {
				function AsyncArrowFunctionExpression(params, body, expression) {
					this.type = syntax_1.Syntax.ArrowFunctionExpression;
					this.id = null;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = expression;
					this.async = true;
				}
				return AsyncArrowFunctionExpression;
			}();
			exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
			var AsyncFunctionDeclaration = function () {
				function AsyncFunctionDeclaration(id, params, body) {
					this.type = syntax_1.Syntax.FunctionDeclaration;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = false;
					this.async = true;
				}
				return AsyncFunctionDeclaration;
			}();
			exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
			var AsyncFunctionExpression = function () {
				function AsyncFunctionExpression(id, params, body) {
					this.type = syntax_1.Syntax.FunctionExpression;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = false;
					this.async = true;
				}
				return AsyncFunctionExpression;
			}();
			exports.AsyncFunctionExpression = AsyncFunctionExpression;
			var AwaitExpression = function () {
				function AwaitExpression(argument) {
					this.type = syntax_1.Syntax.AwaitExpression;
					this.argument = argument;
				}
				return AwaitExpression;
			}();
			exports.AwaitExpression = AwaitExpression;
			var BinaryExpression = function () {
				function BinaryExpression(operator, left, right) {
					var logical = operator === '||' || operator === '&&';
					this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
					this.operator = operator;
					this.left = left;
					this.right = right;
				}
				return BinaryExpression;
			}();
			exports.BinaryExpression = BinaryExpression;
			var BlockStatement = function () {
				function BlockStatement(body) {
					this.type = syntax_1.Syntax.BlockStatement;
					this.body = body;
				}
				return BlockStatement;
			}();
			exports.BlockStatement = BlockStatement;
			var BreakStatement = function () {
				function BreakStatement(label) {
					this.type = syntax_1.Syntax.BreakStatement;
					this.label = label;
				}
				return BreakStatement;
			}();
			exports.BreakStatement = BreakStatement;
			var CallExpression = function () {
				function CallExpression(callee, args) {
					this.type = syntax_1.Syntax.CallExpression;
					this.callee = callee;
					this.arguments = args;
				}
				return CallExpression;
			}();
			exports.CallExpression = CallExpression;
			var CatchClause = function () {
				function CatchClause(param, body) {
					this.type = syntax_1.Syntax.CatchClause;
					this.param = param;
					this.body = body;
				}
				return CatchClause;
			}();
			exports.CatchClause = CatchClause;
			var ClassBody = function () {
				function ClassBody(body) {
					this.type = syntax_1.Syntax.ClassBody;
					this.body = body;
				}
				return ClassBody;
			}();
			exports.ClassBody = ClassBody;
			var ClassDeclaration = function () {
				function ClassDeclaration(id, superClass, body) {
					this.type = syntax_1.Syntax.ClassDeclaration;
					this.id = id;
					this.superClass = superClass;
					this.body = body;
				}
				return ClassDeclaration;
			}();
			exports.ClassDeclaration = ClassDeclaration;
			var ClassExpression = function () {
				function ClassExpression(id, superClass, body) {
					this.type = syntax_1.Syntax.ClassExpression;
					this.id = id;
					this.superClass = superClass;
					this.body = body;
				}
				return ClassExpression;
			}();
			exports.ClassExpression = ClassExpression;
			var ComputedMemberExpression = function () {
				function ComputedMemberExpression(object, property) {
					this.type = syntax_1.Syntax.MemberExpression;
					this.computed = true;
					this.object = object;
					this.property = property;
				}
				return ComputedMemberExpression;
			}();
			exports.ComputedMemberExpression = ComputedMemberExpression;
			var ConditionalExpression = function () {
				function ConditionalExpression(test, consequent, alternate) {
					this.type = syntax_1.Syntax.ConditionalExpression;
					this.test = test;
					this.consequent = consequent;
					this.alternate = alternate;
				}
				return ConditionalExpression;
			}();
			exports.ConditionalExpression = ConditionalExpression;
			var ContinueStatement = function () {
				function ContinueStatement(label) {
					this.type = syntax_1.Syntax.ContinueStatement;
					this.label = label;
				}
				return ContinueStatement;
			}();
			exports.ContinueStatement = ContinueStatement;
			var DebuggerStatement = function () {
				function DebuggerStatement() {
					this.type = syntax_1.Syntax.DebuggerStatement;
				}
				return DebuggerStatement;
			}();
			exports.DebuggerStatement = DebuggerStatement;
			var Directive = function () {
				function Directive(expression, directive) {
					this.type = syntax_1.Syntax.ExpressionStatement;
					this.expression = expression;
					this.directive = directive;
				}
				return Directive;
			}();
			exports.Directive = Directive;
			var DoWhileStatement = function () {
				function DoWhileStatement(body, test) {
					this.type = syntax_1.Syntax.DoWhileStatement;
					this.body = body;
					this.test = test;
				}
				return DoWhileStatement;
			}();
			exports.DoWhileStatement = DoWhileStatement;
			var EmptyStatement = function () {
				function EmptyStatement() {
					this.type = syntax_1.Syntax.EmptyStatement;
				}
				return EmptyStatement;
			}();
			exports.EmptyStatement = EmptyStatement;
			var ExportAllDeclaration = function () {
				function ExportAllDeclaration(source) {
					this.type = syntax_1.Syntax.ExportAllDeclaration;
					this.source = source;
				}
				return ExportAllDeclaration;
			}();
			exports.ExportAllDeclaration = ExportAllDeclaration;
			var ExportDefaultDeclaration = function () {
				function ExportDefaultDeclaration(declaration) {
					this.type = syntax_1.Syntax.ExportDefaultDeclaration;
					this.declaration = declaration;
				}
				return ExportDefaultDeclaration;
			}();
			exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
			var ExportNamedDeclaration = function () {
				function ExportNamedDeclaration(declaration, specifiers, source) {
					this.type = syntax_1.Syntax.ExportNamedDeclaration;
					this.declaration = declaration;
					this.specifiers = specifiers;
					this.source = source;
				}
				return ExportNamedDeclaration;
			}();
			exports.ExportNamedDeclaration = ExportNamedDeclaration;
			var ExportSpecifier = function () {
				function ExportSpecifier(local, exported) {
					this.type = syntax_1.Syntax.ExportSpecifier;
					this.exported = exported;
					this.local = local;
				}
				return ExportSpecifier;
			}();
			exports.ExportSpecifier = ExportSpecifier;
			var ExpressionStatement = function () {
				function ExpressionStatement(expression) {
					this.type = syntax_1.Syntax.ExpressionStatement;
					this.expression = expression;
				}
				return ExpressionStatement;
			}();
			exports.ExpressionStatement = ExpressionStatement;
			var ForInStatement = function () {
				function ForInStatement(left, right, body) {
					this.type = syntax_1.Syntax.ForInStatement;
					this.left = left;
					this.right = right;
					this.body = body;
					this.each = false;
				}
				return ForInStatement;
			}();
			exports.ForInStatement = ForInStatement;
			var ForOfStatement = function () {
				function ForOfStatement(left, right, body) {
					this.type = syntax_1.Syntax.ForOfStatement;
					this.left = left;
					this.right = right;
					this.body = body;
				}
				return ForOfStatement;
			}();
			exports.ForOfStatement = ForOfStatement;
			var ForStatement = function () {
				function ForStatement(init, test, update, body) {
					this.type = syntax_1.Syntax.ForStatement;
					this.init = init;
					this.test = test;
					this.update = update;
					this.body = body;
				}
				return ForStatement;
			}();
			exports.ForStatement = ForStatement;
			var FunctionDeclaration = function () {
				function FunctionDeclaration(id, params, body, generator) {
					this.type = syntax_1.Syntax.FunctionDeclaration;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = generator;
					this.expression = false;
					this.async = false;
				}
				return FunctionDeclaration;
			}();
			exports.FunctionDeclaration = FunctionDeclaration;
			var FunctionExpression = function () {
				function FunctionExpression(id, params, body, generator) {
					this.type = syntax_1.Syntax.FunctionExpression;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = generator;
					this.expression = false;
					this.async = false;
				}
				return FunctionExpression;
			}();
			exports.FunctionExpression = FunctionExpression;
			var Identifier = function () {
				function Identifier(name) {
					this.type = syntax_1.Syntax.Identifier;
					this.name = name;
				}
				return Identifier;
			}();
			exports.Identifier = Identifier;
			var IfStatement = function () {
				function IfStatement(test, consequent, alternate) {
					this.type = syntax_1.Syntax.IfStatement;
					this.test = test;
					this.consequent = consequent;
					this.alternate = alternate;
				}
				return IfStatement;
			}();
			exports.IfStatement = IfStatement;
			var ImportDeclaration = function () {
				function ImportDeclaration(specifiers, source) {
					this.type = syntax_1.Syntax.ImportDeclaration;
					this.specifiers = specifiers;
					this.source = source;
				}
				return ImportDeclaration;
			}();
			exports.ImportDeclaration = ImportDeclaration;
			var ImportDefaultSpecifier = function () {
				function ImportDefaultSpecifier(local) {
					this.type = syntax_1.Syntax.ImportDefaultSpecifier;
					this.local = local;
				}
				return ImportDefaultSpecifier;
			}();
			exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
			var ImportNamespaceSpecifier = function () {
				function ImportNamespaceSpecifier(local) {
					this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
					this.local = local;
				}
				return ImportNamespaceSpecifier;
			}();
			exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
			var ImportSpecifier = function () {
				function ImportSpecifier(local, imported) {
					this.type = syntax_1.Syntax.ImportSpecifier;
					this.local = local;
					this.imported = imported;
				}
				return ImportSpecifier;
			}();
			exports.ImportSpecifier = ImportSpecifier;
			var LabeledStatement = function () {
				function LabeledStatement(label, body) {
					this.type = syntax_1.Syntax.LabeledStatement;
					this.label = label;
					this.body = body;
				}
				return LabeledStatement;
			}();
			exports.LabeledStatement = LabeledStatement;
			var Literal = function () {
				function Literal(value, raw) {
					this.type = syntax_1.Syntax.Literal;
					this.value = value;
					this.raw = raw;
				}
				return Literal;
			}();
			exports.Literal = Literal;
			var MetaProperty = function () {
				function MetaProperty(meta, property) {
					this.type = syntax_1.Syntax.MetaProperty;
					this.meta = meta;
					this.property = property;
				}
				return MetaProperty;
			}();
			exports.MetaProperty = MetaProperty;
			var MethodDefinition = function () {
				function MethodDefinition(key, computed, value, kind, isStatic) {
					this.type = syntax_1.Syntax.MethodDefinition;
					this.key = key;
					this.computed = computed;
					this.value = value;
					this.kind = kind;
					this.static = isStatic;
				}
				return MethodDefinition;
			}();
			exports.MethodDefinition = MethodDefinition;
			var Module = function () {
				function Module(body) {
					this.type = syntax_1.Syntax.Program;
					this.body = body;
					this.sourceType = 'module';
				}
				return Module;
			}();
			exports.Module = Module;
			var NewExpression = function () {
				function NewExpression(callee, args) {
					this.type = syntax_1.Syntax.NewExpression;
					this.callee = callee;
					this.arguments = args;
				}
				return NewExpression;
			}();
			exports.NewExpression = NewExpression;
			var ObjectExpression = function () {
				function ObjectExpression(properties) {
					this.type = syntax_1.Syntax.ObjectExpression;
					this.properties = properties;
				}
				return ObjectExpression;
			}();
			exports.ObjectExpression = ObjectExpression;
			var ObjectPattern = function () {
				function ObjectPattern(properties) {
					this.type = syntax_1.Syntax.ObjectPattern;
					this.properties = properties;
				}
				return ObjectPattern;
			}();
			exports.ObjectPattern = ObjectPattern;
			var Property = function () {
				function Property(kind, key, computed, value, method, shorthand) {
					this.type = syntax_1.Syntax.Property;
					this.key = key;
					this.computed = computed;
					this.value = value;
					this.kind = kind;
					this.method = method;
					this.shorthand = shorthand;
				}
				return Property;
			}();
			exports.Property = Property;
			var RegexLiteral = function () {
				function RegexLiteral(value, raw, pattern, flags) {
					this.type = syntax_1.Syntax.Literal;
					this.value = value;
					this.raw = raw;
					this.regex = { pattern: pattern, flags: flags };
				}
				return RegexLiteral;
			}();
			exports.RegexLiteral = RegexLiteral;
			var RestElement = function () {
				function RestElement(argument) {
					this.type = syntax_1.Syntax.RestElement;
					this.argument = argument;
				}
				return RestElement;
			}();
			exports.RestElement = RestElement;
			var ReturnStatement = function () {
				function ReturnStatement(argument) {
					this.type = syntax_1.Syntax.ReturnStatement;
					this.argument = argument;
				}
				return ReturnStatement;
			}();
			exports.ReturnStatement = ReturnStatement;
			var Script = function () {
				function Script(body) {
					this.type = syntax_1.Syntax.Program;
					this.body = body;
					this.sourceType = 'script';
				}
				return Script;
			}();
			exports.Script = Script;
			var SequenceExpression = function () {
				function SequenceExpression(expressions) {
					this.type = syntax_1.Syntax.SequenceExpression;
					this.expressions = expressions;
				}
				return SequenceExpression;
			}();
			exports.SequenceExpression = SequenceExpression;
			var SpreadElement = function () {
				function SpreadElement(argument) {
					this.type = syntax_1.Syntax.SpreadElement;
					this.argument = argument;
				}
				return SpreadElement;
			}();
			exports.SpreadElement = SpreadElement;
			var StaticMemberExpression = function () {
				function StaticMemberExpression(object, property) {
					this.type = syntax_1.Syntax.MemberExpression;
					this.computed = false;
					this.object = object;
					this.property = property;
				}
				return StaticMemberExpression;
			}();
			exports.StaticMemberExpression = StaticMemberExpression;
			var Super = function () {
				function Super() {
					this.type = syntax_1.Syntax.Super;
				}
				return Super;
			}();
			exports.Super = Super;
			var SwitchCase = function () {
				function SwitchCase(test, consequent) {
					this.type = syntax_1.Syntax.SwitchCase;
					this.test = test;
					this.consequent = consequent;
				}
				return SwitchCase;
			}();
			exports.SwitchCase = SwitchCase;
			var SwitchStatement = function () {
				function SwitchStatement(discriminant, cases) {
					this.type = syntax_1.Syntax.SwitchStatement;
					this.discriminant = discriminant;
					this.cases = cases;
				}
				return SwitchStatement;
			}();
			exports.SwitchStatement = SwitchStatement;
			var TaggedTemplateExpression = function () {
				function TaggedTemplateExpression(tag, quasi) {
					this.type = syntax_1.Syntax.TaggedTemplateExpression;
					this.tag = tag;
					this.quasi = quasi;
				}
				return TaggedTemplateExpression;
			}();
			exports.TaggedTemplateExpression = TaggedTemplateExpression;
			var TemplateElement = function () {
				function TemplateElement(value, tail) {
					this.type = syntax_1.Syntax.TemplateElement;
					this.value = value;
					this.tail = tail;
				}
				return TemplateElement;
			}();
			exports.TemplateElement = TemplateElement;
			var TemplateLiteral = function () {
				function TemplateLiteral(quasis, expressions) {
					this.type = syntax_1.Syntax.TemplateLiteral;
					this.quasis = quasis;
					this.expressions = expressions;
				}
				return TemplateLiteral;
			}();
			exports.TemplateLiteral = TemplateLiteral;
			var ThisExpression = function () {
				function ThisExpression() {
					this.type = syntax_1.Syntax.ThisExpression;
				}
				return ThisExpression;
			}();
			exports.ThisExpression = ThisExpression;
			var ThrowStatement = function () {
				function ThrowStatement(argument) {
					this.type = syntax_1.Syntax.ThrowStatement;
					this.argument = argument;
				}
				return ThrowStatement;
			}();
			exports.ThrowStatement = ThrowStatement;
			var TryStatement = function () {
				function TryStatement(block, handler, finalizer) {
					this.type = syntax_1.Syntax.TryStatement;
					this.block = block;
					this.handler = handler;
					this.finalizer = finalizer;
				}
				return TryStatement;
			}();
			exports.TryStatement = TryStatement;
			var UnaryExpression = function () {
				function UnaryExpression(operator, argument) {
					this.type = syntax_1.Syntax.UnaryExpression;
					this.operator = operator;
					this.argument = argument;
					this.prefix = true;
				}
				return UnaryExpression;
			}();
			exports.UnaryExpression = UnaryExpression;
			var UpdateExpression = function () {
				function UpdateExpression(operator, argument, prefix) {
					this.type = syntax_1.Syntax.UpdateExpression;
					this.operator = operator;
					this.argument = argument;
					this.prefix = prefix;
				}
				return UpdateExpression;
			}();
			exports.UpdateExpression = UpdateExpression;
			var VariableDeclaration = function () {
				function VariableDeclaration(declarations, kind) {
					this.type = syntax_1.Syntax.VariableDeclaration;
					this.declarations = declarations;
					this.kind = kind;
				}
				return VariableDeclaration;
			}();
			exports.VariableDeclaration = VariableDeclaration;
			var VariableDeclarator = function () {
				function VariableDeclarator(id, init) {
					this.type = syntax_1.Syntax.VariableDeclarator;
					this.id = id;
					this.init = init;
				}
				return VariableDeclarator;
			}();
			exports.VariableDeclarator = VariableDeclarator;
			var WhileStatement = function () {
				function WhileStatement(test, body) {
					this.type = syntax_1.Syntax.WhileStatement;
					this.test = test;
					this.body = body;
				}
				return WhileStatement;
			}();
			exports.WhileStatement = WhileStatement;
			var WithStatement = function () {
				function WithStatement(object, body) {
					this.type = syntax_1.Syntax.WithStatement;
					this.object = object;
					this.body = body;
				}
				return WithStatement;
			}();
			exports.WithStatement = WithStatement;
			var YieldExpression = function () {
				function YieldExpression(argument, delegate) {
					this.type = syntax_1.Syntax.YieldExpression;
					this.argument = argument;
					this.delegate = delegate;
				}
				return YieldExpression;
			}();
			exports.YieldExpression = YieldExpression;

			/***/
		},
		/* 8 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var error_handler_1 = __webpack_require__(10);
			var messages_1 = __webpack_require__(11);
			var Node = __webpack_require__(7);
			var scanner_1 = __webpack_require__(12);
			var syntax_1 = __webpack_require__(2);
			var token_1 = __webpack_require__(13);
			var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
			var Parser = function () {
				function Parser(code, options, delegate) {
					if (options === void 0) {
						options = {};
					}
					this.config = {
						range: typeof options.range === 'boolean' && options.range,
						loc: typeof options.loc === 'boolean' && options.loc,
						source: null,
						tokens: typeof options.tokens === 'boolean' && options.tokens,
						comment: typeof options.comment === 'boolean' && options.comment,
						tolerant: typeof options.tolerant === 'boolean' && options.tolerant
					};
					if (this.config.loc && options.source && options.source !== null) {
						this.config.source = String(options.source);
					}
					this.delegate = delegate;
					this.errorHandler = new error_handler_1.ErrorHandler();
					this.errorHandler.tolerant = this.config.tolerant;
					this.scanner = new scanner_1.Scanner(code, this.errorHandler);
					this.scanner.trackComment = this.config.comment;
					this.operatorPrecedence = {
						')': 0,
						';': 0,
						',': 0,
						'=': 0,
						']': 0,
						'||': 1,
						'&&': 2,
						'|': 3,
						'^': 4,
						'&': 5,
						'==': 6,
						'!=': 6,
						'===': 6,
						'!==': 6,
						'<': 7,
						'>': 7,
						'<=': 7,
						'>=': 7,
						'<<': 8,
						'>>': 8,
						'>>>': 8,
						'+': 9,
						'-': 9,
						'*': 11,
						'/': 11,
						'%': 11
					};
					this.lookahead = {
						type: 2 /* EOF */
						, value: '',
						lineNumber: this.scanner.lineNumber,
						lineStart: 0,
						start: 0,
						end: 0
					};
					this.hasLineTerminator = false;
					this.context = {
						isModule: false,
						await: false,
						allowIn: true,
						allowStrictDirective: true,
						allowYield: true,
						firstCoverInitializedNameError: null,
						isAssignmentTarget: false,
						isBindingElement: false,
						inFunctionBody: false,
						inIteration: false,
						inSwitch: false,
						labelSet: {},
						strict: false
					};
					this.tokens = [];
					this.startMarker = {
						index: 0,
						line: this.scanner.lineNumber,
						column: 0
					};
					this.lastMarker = {
						index: 0,
						line: this.scanner.lineNumber,
						column: 0
					};
					this.nextToken();
					this.lastMarker = {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				}
				Parser.prototype.throwError = function (messageFormat) {
					var values = [];
					for (var _i = 1; _i < arguments.length; _i++) {
						values[_i - 1] = arguments[_i];
					}
					var args = Array.prototype.slice.call(arguments, 1);
					var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
						assert_1.assert(idx < args.length, 'Message reference must be in range');
						return args[idx];
					});
					var index = this.lastMarker.index;
					var line = this.lastMarker.line;
					var column = this.lastMarker.column + 1;
					throw this.errorHandler.createError(index, line, column, msg);
				};
				Parser.prototype.tolerateError = function (messageFormat) {
					var values = [];
					for (var _i = 1; _i < arguments.length; _i++) {
						values[_i - 1] = arguments[_i];
					}
					var args = Array.prototype.slice.call(arguments, 1);
					var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
						assert_1.assert(idx < args.length, 'Message reference must be in range');
						return args[idx];
					});
					var index = this.lastMarker.index;
					var line = this.scanner.lineNumber;
					var column = this.lastMarker.column + 1;
					this.errorHandler.tolerateError(index, line, column, msg);
				};
				// Throw an exception because of the token.
				Parser.prototype.unexpectedTokenError = function (token, message) {
					var msg = message || messages_1.Messages.UnexpectedToken;
					var value;
					if (token) {
						if (!message) {
							msg = token.type === 2 /* EOF */ ? messages_1.Messages.UnexpectedEOS : token.type === 3 /* Identifier */ ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 /* NumericLiteral */ ? messages_1.Messages.UnexpectedNumber : token.type === 8 /* StringLiteral */ ? messages_1.Messages.UnexpectedString : token.type === 10 /* Template */ ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
							if (token.type === 4 /* Keyword */) {
									if (this.scanner.isFutureReservedWord(token.value)) {
										msg = messages_1.Messages.UnexpectedReserved;
									} else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
										msg = messages_1.Messages.StrictReservedWord;
									}
								}
						}
						value = token.value;
					} else {
						value = 'ILLEGAL';
					}
					msg = msg.replace('%0', value);
					if (token && typeof token.lineNumber === 'number') {
						var index = token.start;
						var line = token.lineNumber;
						var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
						var column = token.start - lastMarkerLineStart + 1;
						return this.errorHandler.createError(index, line, column, msg);
					} else {
						var index = this.lastMarker.index;
						var line = this.lastMarker.line;
						var column = this.lastMarker.column + 1;
						return this.errorHandler.createError(index, line, column, msg);
					}
				};
				Parser.prototype.throwUnexpectedToken = function (token, message) {
					throw this.unexpectedTokenError(token, message);
				};
				Parser.prototype.tolerateUnexpectedToken = function (token, message) {
					this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
				};
				Parser.prototype.collectComments = function () {
					if (!this.config.comment) {
						this.scanner.scanComments();
					} else {
						var comments = this.scanner.scanComments();
						if (comments.length > 0 && this.delegate) {
							for (var i = 0; i < comments.length; ++i) {
								var e = comments[i];
								var node = void 0;
								node = {
									type: e.multiLine ? 'BlockComment' : 'LineComment',
									value: this.scanner.source.slice(e.slice[0], e.slice[1])
								};
								if (this.config.range) {
									node.range = e.range;
								}
								if (this.config.loc) {
									node.loc = e.loc;
								}
								var metadata = {
									start: {
										line: e.loc.start.line,
										column: e.loc.start.column,
										offset: e.range[0]
									},
									end: {
										line: e.loc.end.line,
										column: e.loc.end.column,
										offset: e.range[1]
									}
								};
								this.delegate(node, metadata);
							}
						}
					}
				};
				// From internal representation to an external structure
				Parser.prototype.getTokenRaw = function (token) {
					return this.scanner.source.slice(token.start, token.end);
				};
				Parser.prototype.convertToken = function (token) {
					var t = {
						type: token_1.TokenName[token.type],
						value: this.getTokenRaw(token)
					};
					if (this.config.range) {
						t.range = [token.start, token.end];
					}
					if (this.config.loc) {
						t.loc = {
							start: {
								line: this.startMarker.line,
								column: this.startMarker.column
							},
							end: {
								line: this.scanner.lineNumber,
								column: this.scanner.index - this.scanner.lineStart
							}
						};
					}
					if (token.type === 9 /* RegularExpression */) {
							var pattern = token.pattern;
							var flags = token.flags;
							t.regex = { pattern: pattern, flags: flags };
						}
					return t;
				};
				Parser.prototype.nextToken = function () {
					var token = this.lookahead;
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					this.collectComments();
					if (this.scanner.index !== this.startMarker.index) {
						this.startMarker.index = this.scanner.index;
						this.startMarker.line = this.scanner.lineNumber;
						this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					}
					var next = this.scanner.lex();
					this.hasLineTerminator = token.lineNumber !== next.lineNumber;
					if (next && this.context.strict && next.type === 3 /* Identifier */) {
							if (this.scanner.isStrictModeReservedWord(next.value)) {
								next.type = 4 /* Keyword */;
							}
						}
					this.lookahead = next;
					if (this.config.tokens && next.type !== 2 /* EOF */) {
							this.tokens.push(this.convertToken(next));
						}
					return token;
				};
				Parser.prototype.nextRegexToken = function () {
					this.collectComments();
					var token = this.scanner.scanRegExp();
					if (this.config.tokens) {
						// Pop the previous token, '/' or '/='
						// This is added from the lookahead token.
						this.tokens.pop();
						this.tokens.push(this.convertToken(token));
					}
					// Prime the next lookahead.
					this.lookahead = token;
					this.nextToken();
					return token;
				};
				Parser.prototype.createNode = function () {
					return {
						index: this.startMarker.index,
						line: this.startMarker.line,
						column: this.startMarker.column
					};
				};
				Parser.prototype.startNode = function (token, lastLineStart) {
					if (lastLineStart === void 0) {
						lastLineStart = 0;
					}
					var column = token.start - token.lineStart;
					var line = token.lineNumber;
					if (column < 0) {
						column += lastLineStart;
						line--;
					}
					return {
						index: token.start,
						line: line,
						column: column
					};
				};
				Parser.prototype.finalize = function (marker, node) {
					if (this.config.range) {
						node.range = [marker.index, this.lastMarker.index];
					}
					if (this.config.loc) {
						node.loc = {
							start: {
								line: marker.line,
								column: marker.column
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column
							}
						};
						if (this.config.source) {
							node.loc.source = this.config.source;
						}
					}
					if (this.delegate) {
						var metadata = {
							start: {
								line: marker.line,
								column: marker.column,
								offset: marker.index
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column,
								offset: this.lastMarker.index
							}
						};
						this.delegate(node, metadata);
					}
					return node;
				};
				// Expect the next token to match the specified punctuator.
				// If not, an exception will be thrown.
				Parser.prototype.expect = function (value) {
					var token = this.nextToken();
					if (token.type !== 7 /* Punctuator */ || token.value !== value) {
						this.throwUnexpectedToken(token);
					}
				};
				// Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
				Parser.prototype.expectCommaSeparator = function () {
					if (this.config.tolerant) {
						var token = this.lookahead;
						if (token.type === 7 /* Punctuator */ && token.value === ',') {
							this.nextToken();
						} else if (token.type === 7 /* Punctuator */ && token.value === ';') {
							this.nextToken();
							this.tolerateUnexpectedToken(token);
						} else {
							this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
						}
					} else {
						this.expect(',');
					}
				};
				// Expect the next token to match the specified keyword.
				// If not, an exception will be thrown.
				Parser.prototype.expectKeyword = function (keyword) {
					var token = this.nextToken();
					if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
						this.throwUnexpectedToken(token);
					}
				};
				// Return true if the next token matches the specified punctuator.
				Parser.prototype.match = function (value) {
					return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
				};
				// Return true if the next token matches the specified keyword
				Parser.prototype.matchKeyword = function (keyword) {
					return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
				};
				// Return true if the next token matches the specified contextual keyword
				// (where an identifier is sometimes a keyword depending on the context)
				Parser.prototype.matchContextualKeyword = function (keyword) {
					return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
				};
				// Return true if the next token is an assignment operator
				Parser.prototype.matchAssign = function () {
					if (this.lookahead.type !== 7 /* Punctuator */) {
							return false;
						}
					var op = this.lookahead.value;
					return op === '=' || op === '*=' || op === '**=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
				};
				// Cover grammar support.
				//
				// When an assignment expression position starts with an left parenthesis, the determination of the type
				// of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
				// or the first comma. This situation also defers the determination of all the expressions nested in the pair.
				//
				// There are three productions that can be parsed in a parentheses pair that needs to be determined
				// after the outermost pair is closed. They are:
				//
				//   1. AssignmentExpression
				//   2. BindingElements
				//   3. AssignmentTargets
				//
				// In order to avoid exponential backtracking, we use two flags to denote if the production can be
				// binding element or assignment target.
				//
				// The three productions have the relationship:
				//
				//   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
				//
				// with a single exception that CoverInitializedName when used directly in an Expression, generates
				// an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
				// first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
				//
				// isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
				// effect the current flags. This means the production the parser parses is only used as an expression. Therefore
				// the CoverInitializedName check is conducted.
				//
				// inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
				// the flags outside of the parser. This means the production the parser parses is used as a part of a potential
				// pattern. The CoverInitializedName check is deferred.
				Parser.prototype.isolateCoverGrammar = function (parseFunction) {
					var previousIsBindingElement = this.context.isBindingElement;
					var previousIsAssignmentTarget = this.context.isAssignmentTarget;
					var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
					this.context.isBindingElement = true;
					this.context.isAssignmentTarget = true;
					this.context.firstCoverInitializedNameError = null;
					var result = parseFunction.call(this);
					if (this.context.firstCoverInitializedNameError !== null) {
						this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
					}
					this.context.isBindingElement = previousIsBindingElement;
					this.context.isAssignmentTarget = previousIsAssignmentTarget;
					this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
					return result;
				};
				Parser.prototype.inheritCoverGrammar = function (parseFunction) {
					var previousIsBindingElement = this.context.isBindingElement;
					var previousIsAssignmentTarget = this.context.isAssignmentTarget;
					var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
					this.context.isBindingElement = true;
					this.context.isAssignmentTarget = true;
					this.context.firstCoverInitializedNameError = null;
					var result = parseFunction.call(this);
					this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
					this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
					this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
					return result;
				};
				Parser.prototype.consumeSemicolon = function () {
					if (this.match(';')) {
						this.nextToken();
					} else if (!this.hasLineTerminator) {
						if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
							this.throwUnexpectedToken(this.lookahead);
						}
						this.lastMarker.index = this.startMarker.index;
						this.lastMarker.line = this.startMarker.line;
						this.lastMarker.column = this.startMarker.column;
					}
				};
				// https://tc39.github.io/ecma262/#sec-primary-expression
				Parser.prototype.parsePrimaryExpression = function () {
					var node = this.createNode();
					var expr;
					var token, raw;
					switch (this.lookahead.type) {
						case 3 /* Identifier */:
							if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
								this.tolerateUnexpectedToken(this.lookahead);
							}
							expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
							break;
						case 6 /* NumericLiteral */:
						case 8 /* StringLiteral */:
							if (this.context.strict && this.lookahead.octal) {
								this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
							}
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(token.value, raw));
							break;
						case 1 /* BooleanLiteral */:
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
							break;
						case 5 /* NullLiteral */:
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(null, raw));
							break;
						case 10 /* Template */:
							expr = this.parseTemplateLiteral();
							break;
						case 7 /* Punctuator */:
							switch (this.lookahead.value) {
								case '(':
									this.context.isBindingElement = false;
									expr = this.inheritCoverGrammar(this.parseGroupExpression);
									break;
								case '[':
									expr = this.inheritCoverGrammar(this.parseArrayInitializer);
									break;
								case '{':
									expr = this.inheritCoverGrammar(this.parseObjectInitializer);
									break;
								case '/':
								case '/=':
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									this.scanner.index = this.startMarker.index;
									token = this.nextRegexToken();
									raw = this.getTokenRaw(token);
									expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
									break;
								default:
									expr = this.throwUnexpectedToken(this.nextToken());
							}
							break;
						case 4 /* Keyword */:
							if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
								expr = this.parseIdentifierName();
							} else if (!this.context.strict && this.matchKeyword('let')) {
								expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
							} else {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								if (this.matchKeyword('function')) {
									expr = this.parseFunctionExpression();
								} else if (this.matchKeyword('this')) {
									this.nextToken();
									expr = this.finalize(node, new Node.ThisExpression());
								} else if (this.matchKeyword('class')) {
									expr = this.parseClassExpression();
								} else {
									expr = this.throwUnexpectedToken(this.nextToken());
								}
							}
							break;
						default:
							expr = this.throwUnexpectedToken(this.nextToken());
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-array-initializer
				Parser.prototype.parseSpreadElement = function () {
					var node = this.createNode();
					this.expect('...');
					var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
					return this.finalize(node, new Node.SpreadElement(arg));
				};
				Parser.prototype.parseArrayInitializer = function () {
					var node = this.createNode();
					var elements = [];
					this.expect('[');
					while (!this.match(']')) {
						if (this.match(',')) {
							this.nextToken();
							elements.push(null);
						} else if (this.match('...')) {
							var element = this.parseSpreadElement();
							if (!this.match(']')) {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								this.expect(',');
							}
							elements.push(element);
						} else {
							elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
							if (!this.match(']')) {
								this.expect(',');
							}
						}
					}
					this.expect(']');
					return this.finalize(node, new Node.ArrayExpression(elements));
				};
				// https://tc39.github.io/ecma262/#sec-object-initializer
				Parser.prototype.parsePropertyMethod = function (params) {
					this.context.isAssignmentTarget = false;
					this.context.isBindingElement = false;
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = params.simple;
					var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
					if (this.context.strict && params.firstRestricted) {
						this.tolerateUnexpectedToken(params.firstRestricted, params.message);
					}
					if (this.context.strict && params.stricted) {
						this.tolerateUnexpectedToken(params.stricted, params.message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					return body;
				};
				Parser.prototype.parsePropertyMethodFunction = function () {
					var isGenerator = false;
					var node = this.createNode();
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = true;
					var params = this.parseFormalParameters();
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
				};
				Parser.prototype.parsePropertyMethodAsyncFunction = function () {
					var node = this.createNode();
					var previousAllowYield = this.context.allowYield;
					var previousAwait = this.context.await;
					this.context.allowYield = false;
					this.context.await = true;
					var params = this.parseFormalParameters();
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					this.context.await = previousAwait;
					return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
				};
				Parser.prototype.parseObjectPropertyKey = function () {
					var node = this.createNode();
					var token = this.nextToken();
					var key;
					switch (token.type) {
						case 8 /* StringLiteral */:
						case 6 /* NumericLiteral */:
							if (this.context.strict && token.octal) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
							}
							var raw = this.getTokenRaw(token);
							key = this.finalize(node, new Node.Literal(token.value, raw));
							break;
						case 3 /* Identifier */:
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 4 /* Keyword */:
							key = this.finalize(node, new Node.Identifier(token.value));
							break;
						case 7 /* Punctuator */:
							if (token.value === '[') {
								key = this.isolateCoverGrammar(this.parseAssignmentExpression);
								this.expect(']');
							} else {
								key = this.throwUnexpectedToken(token);
							}
							break;
						default:
							key = this.throwUnexpectedToken(token);
					}
					return key;
				};
				Parser.prototype.isPropertyKey = function (key, value) {
					return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
				};
				Parser.prototype.parseObjectProperty = function (hasProto) {
					var node = this.createNode();
					var token = this.lookahead;
					var kind;
					var key = null;
					var value = null;
					var computed = false;
					var method = false;
					var shorthand = false;
					var isAsync = false;
					if (token.type === 3 /* Identifier */) {
							var id = token.value;
							this.nextToken();
							computed = this.match('[');
							isAsync = !this.hasLineTerminator && id === 'async' && !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
							key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
						} else if (this.match('*')) {
						this.nextToken();
					} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
					}
					var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
					if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
						kind = 'get';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						this.context.allowYield = false;
						value = this.parseGetterMethod();
					} else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
						kind = 'set';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseSetterMethod();
					} else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
						kind = 'init';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseGeneratorMethod();
						method = true;
					} else {
						if (!key) {
							this.throwUnexpectedToken(this.lookahead);
						}
						kind = 'init';
						if (this.match(':') && !isAsync) {
							if (!computed && this.isPropertyKey(key, '__proto__')) {
								if (hasProto.value) {
									this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
								}
								hasProto.value = true;
							}
							this.nextToken();
							value = this.inheritCoverGrammar(this.parseAssignmentExpression);
						} else if (this.match('(')) {
							value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
							method = true;
						} else if (token.type === 3 /* Identifier */) {
								var id = this.finalize(node, new Node.Identifier(token.value));
								if (this.match('=')) {
									this.context.firstCoverInitializedNameError = this.lookahead;
									this.nextToken();
									shorthand = true;
									var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
									value = this.finalize(node, new Node.AssignmentPattern(id, init));
								} else {
									shorthand = true;
									value = id;
								}
							} else {
							this.throwUnexpectedToken(this.nextToken());
						}
					}
					return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
				};
				Parser.prototype.parseObjectInitializer = function () {
					var node = this.createNode();
					this.expect('{');
					var properties = [];
					var hasProto = { value: false };
					while (!this.match('}')) {
						properties.push(this.parseObjectProperty(hasProto));
						if (!this.match('}')) {
							this.expectCommaSeparator();
						}
					}
					this.expect('}');
					return this.finalize(node, new Node.ObjectExpression(properties));
				};
				// https://tc39.github.io/ecma262/#sec-template-literals
				Parser.prototype.parseTemplateHead = function () {
					assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
					var node = this.createNode();
					var token = this.nextToken();
					var raw = token.value;
					var cooked = token.cooked;
					return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
				};
				Parser.prototype.parseTemplateElement = function () {
					if (this.lookahead.type !== 10 /* Template */) {
							this.throwUnexpectedToken();
						}
					var node = this.createNode();
					var token = this.nextToken();
					var raw = token.value;
					var cooked = token.cooked;
					return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
				};
				Parser.prototype.parseTemplateLiteral = function () {
					var node = this.createNode();
					var expressions = [];
					var quasis = [];
					var quasi = this.parseTemplateHead();
					quasis.push(quasi);
					while (!quasi.tail) {
						expressions.push(this.parseExpression());
						quasi = this.parseTemplateElement();
						quasis.push(quasi);
					}
					return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
				};
				// https://tc39.github.io/ecma262/#sec-grouping-operator
				Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
					switch (expr.type) {
						case syntax_1.Syntax.Identifier:
						case syntax_1.Syntax.MemberExpression:
						case syntax_1.Syntax.RestElement:
						case syntax_1.Syntax.AssignmentPattern:
							break;
						case syntax_1.Syntax.SpreadElement:
							expr.type = syntax_1.Syntax.RestElement;
							this.reinterpretExpressionAsPattern(expr.argument);
							break;
						case syntax_1.Syntax.ArrayExpression:
							expr.type = syntax_1.Syntax.ArrayPattern;
							for (var i = 0; i < expr.elements.length; i++) {
								if (expr.elements[i] !== null) {
									this.reinterpretExpressionAsPattern(expr.elements[i]);
								}
							}
							break;
						case syntax_1.Syntax.ObjectExpression:
							expr.type = syntax_1.Syntax.ObjectPattern;
							for (var i = 0; i < expr.properties.length; i++) {
								this.reinterpretExpressionAsPattern(expr.properties[i].value);
							}
							break;
						case syntax_1.Syntax.AssignmentExpression:
							expr.type = syntax_1.Syntax.AssignmentPattern;
							delete expr.operator;
							this.reinterpretExpressionAsPattern(expr.left);
							break;
						default:
							// Allow other node type for tolerant parsing.
							break;
					}
				};
				Parser.prototype.parseGroupExpression = function () {
					var expr;
					this.expect('(');
					if (this.match(')')) {
						this.nextToken();
						if (!this.match('=>')) {
							this.expect('=>');
						}
						expr = {
							type: ArrowParameterPlaceHolder,
							params: [],
							async: false
						};
					} else {
						var startToken = this.lookahead;
						var params = [];
						if (this.match('...')) {
							expr = this.parseRestElement(params);
							this.expect(')');
							if (!this.match('=>')) {
								this.expect('=>');
							}
							expr = {
								type: ArrowParameterPlaceHolder,
								params: [expr],
								async: false
							};
						} else {
							var arrow = false;
							this.context.isBindingElement = true;
							expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
							if (this.match(',')) {
								var expressions = [];
								this.context.isAssignmentTarget = false;
								expressions.push(expr);
								while (this.lookahead.type !== 2 /* EOF */) {
									if (!this.match(',')) {
										break;
									}
									this.nextToken();
									if (this.match(')')) {
										this.nextToken();
										for (var i = 0; i < expressions.length; i++) {
											this.reinterpretExpressionAsPattern(expressions[i]);
										}
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expressions,
											async: false
										};
									} else if (this.match('...')) {
										if (!this.context.isBindingElement) {
											this.throwUnexpectedToken(this.lookahead);
										}
										expressions.push(this.parseRestElement(params));
										this.expect(')');
										if (!this.match('=>')) {
											this.expect('=>');
										}
										this.context.isBindingElement = false;
										for (var i = 0; i < expressions.length; i++) {
											this.reinterpretExpressionAsPattern(expressions[i]);
										}
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expressions,
											async: false
										};
									} else {
										expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
									}
									if (arrow) {
										break;
									}
								}
								if (!arrow) {
									expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
								}
							}
							if (!arrow) {
								this.expect(')');
								if (this.match('=>')) {
									if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: [expr],
											async: false
										};
									}
									if (!arrow) {
										if (!this.context.isBindingElement) {
											this.throwUnexpectedToken(this.lookahead);
										}
										if (expr.type === syntax_1.Syntax.SequenceExpression) {
											for (var i = 0; i < expr.expressions.length; i++) {
												this.reinterpretExpressionAsPattern(expr.expressions[i]);
											}
										} else {
											this.reinterpretExpressionAsPattern(expr);
										}
										var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
										expr = {
											type: ArrowParameterPlaceHolder,
											params: parameters,
											async: false
										};
									}
								}
								this.context.isBindingElement = false;
							}
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
				Parser.prototype.parseArguments = function () {
					this.expect('(');
					var args = [];
					if (!this.match(')')) {
						while (true) {
							var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
							args.push(expr);
							if (this.match(')')) {
								break;
							}
							this.expectCommaSeparator();
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return args;
				};
				Parser.prototype.isIdentifierName = function (token) {
					return token.type === 3 /* Identifier */ || token.type === 4 /* Keyword */ || token.type === 1 /* BooleanLiteral */ || token.type === 5 /* NullLiteral */;
				};
				Parser.prototype.parseIdentifierName = function () {
					var node = this.createNode();
					var token = this.nextToken();
					if (!this.isIdentifierName(token)) {
						this.throwUnexpectedToken(token);
					}
					return this.finalize(node, new Node.Identifier(token.value));
				};
				Parser.prototype.parseNewExpression = function () {
					var node = this.createNode();
					var id = this.parseIdentifierName();
					assert_1.assert(id.name === 'new', 'New expression must start with `new`');
					var expr;
					if (this.match('.')) {
						this.nextToken();
						if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
							var property = this.parseIdentifierName();
							expr = new Node.MetaProperty(id, property);
						} else {
							this.throwUnexpectedToken(this.lookahead);
						}
					} else {
						var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
						var args = this.match('(') ? this.parseArguments() : [];
						expr = new Node.NewExpression(callee, args);
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					}
					return this.finalize(node, expr);
				};
				Parser.prototype.parseAsyncArgument = function () {
					var arg = this.parseAssignmentExpression();
					this.context.firstCoverInitializedNameError = null;
					return arg;
				};
				Parser.prototype.parseAsyncArguments = function () {
					this.expect('(');
					var args = [];
					if (!this.match(')')) {
						while (true) {
							var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
							args.push(expr);
							if (this.match(')')) {
								break;
							}
							this.expectCommaSeparator();
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return args;
				};
				Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
					var startToken = this.lookahead;
					var maybeAsync = this.matchContextualKeyword('async');
					var previousAllowIn = this.context.allowIn;
					this.context.allowIn = true;
					var expr;
					if (this.matchKeyword('super') && this.context.inFunctionBody) {
						expr = this.createNode();
						this.nextToken();
						expr = this.finalize(expr, new Node.Super());
						if (!this.match('(') && !this.match('.') && !this.match('[')) {
							this.throwUnexpectedToken(this.lookahead);
						}
					} else {
						expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
					}
					while (true) {
						if (this.match('.')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('.');
							var property = this.parseIdentifierName();
							expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
						} else if (this.match('(')) {
							var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = false;
							var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
							expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
							if (asyncArrow && this.match('=>')) {
								for (var i = 0; i < args.length; ++i) {
									this.reinterpretExpressionAsPattern(args[i]);
								}
								expr = {
									type: ArrowParameterPlaceHolder,
									params: args,
									async: true
								};
							}
						} else if (this.match('[')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('[');
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect(']');
							expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
						} else {
							break;
						}
					}
					this.context.allowIn = previousAllowIn;
					return expr;
				};
				Parser.prototype.parseSuper = function () {
					var node = this.createNode();
					this.expectKeyword('super');
					if (!this.match('[') && !this.match('.')) {
						this.throwUnexpectedToken(this.lookahead);
					}
					return this.finalize(node, new Node.Super());
				};
				Parser.prototype.parseLeftHandSideExpression = function () {
					assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
					var node = this.startNode(this.lookahead);
					var expr = this.matchKeyword('super') && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
					while (true) {
						if (this.match('[')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('[');
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect(']');
							expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
						} else if (this.match('.')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('.');
							var property = this.parseIdentifierName();
							expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
						} else {
							break;
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-update-expressions
				Parser.prototype.parseUpdateExpression = function () {
					var expr;
					var startToken = this.lookahead;
					if (this.match('++') || this.match('--')) {
						var node = this.startNode(startToken);
						var token = this.nextToken();
						expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
							this.tolerateError(messages_1.Messages.StrictLHSPrefix);
						}
						if (!this.context.isAssignmentTarget) {
							this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
						}
						var prefix = true;
						expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					} else {
						expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
						if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
								if (this.match('++') || this.match('--')) {
									if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
										this.tolerateError(messages_1.Messages.StrictLHSPostfix);
									}
									if (!this.context.isAssignmentTarget) {
										this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
									}
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									var operator = this.nextToken().value;
									var prefix = false;
									expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
								}
							}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-unary-operators
				Parser.prototype.parseAwaitExpression = function () {
					var node = this.createNode();
					this.nextToken();
					var argument = this.parseUnaryExpression();
					return this.finalize(node, new Node.AwaitExpression(argument));
				};
				Parser.prototype.parseUnaryExpression = function () {
					var expr;
					if (this.match('+') || this.match('-') || this.match('~') || this.match('!') || this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
						var node = this.startNode(this.lookahead);
						var token = this.nextToken();
						expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
						if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
							this.tolerateError(messages_1.Messages.StrictDelete);
						}
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					} else if (this.context.await && this.matchContextualKeyword('await')) {
						expr = this.parseAwaitExpression();
					} else {
						expr = this.parseUpdateExpression();
					}
					return expr;
				};
				Parser.prototype.parseExponentiationExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
					if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
						this.nextToken();
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var left = expr;
						var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
						expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-exp-operator
				// https://tc39.github.io/ecma262/#sec-multiplicative-operators
				// https://tc39.github.io/ecma262/#sec-additive-operators
				// https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
				// https://tc39.github.io/ecma262/#sec-relational-operators
				// https://tc39.github.io/ecma262/#sec-equality-operators
				// https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
				// https://tc39.github.io/ecma262/#sec-binary-logical-operators
				Parser.prototype.binaryPrecedence = function (token) {
					var op = token.value;
					var precedence;
					if (token.type === 7 /* Punctuator */) {
							precedence = this.operatorPrecedence[op] || 0;
						} else if (token.type === 4 /* Keyword */) {
							precedence = op === 'instanceof' || this.context.allowIn && op === 'in' ? 7 : 0;
						} else {
						precedence = 0;
					}
					return precedence;
				};
				Parser.prototype.parseBinaryExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
					var token = this.lookahead;
					var prec = this.binaryPrecedence(token);
					if (prec > 0) {
						this.nextToken();
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var markers = [startToken, this.lookahead];
						var left = expr;
						var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
						var stack = [left, token.value, right];
						var precedences = [prec];
						while (true) {
							prec = this.binaryPrecedence(this.lookahead);
							if (prec <= 0) {
								break;
							}
							// Reduce: make a binary expression from the three topmost entries.
							while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
								right = stack.pop();
								var operator = stack.pop();
								precedences.pop();
								left = stack.pop();
								markers.pop();
								var node = this.startNode(markers[markers.length - 1]);
								stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
							}
							// Shift.
							stack.push(this.nextToken().value);
							precedences.push(prec);
							markers.push(this.lookahead);
							stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
						}
						// Final reduce to clean-up the stack.
						var i = stack.length - 1;
						expr = stack[i];
						var lastMarker = markers.pop();
						while (i > 1) {
							var marker = markers.pop();
							var lastLineStart = lastMarker && lastMarker.lineStart;
							var node = this.startNode(marker, lastLineStart);
							var operator = stack[i - 1];
							expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
							i -= 2;
							lastMarker = marker;
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-conditional-operator
				Parser.prototype.parseConditionalExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
					if (this.match('?')) {
						this.nextToken();
						var previousAllowIn = this.context.allowIn;
						this.context.allowIn = true;
						var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
						this.context.allowIn = previousAllowIn;
						this.expect(':');
						var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
						expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-assignment-operators
				Parser.prototype.checkPatternParam = function (options, param) {
					switch (param.type) {
						case syntax_1.Syntax.Identifier:
							this.validateParam(options, param, param.name);
							break;
						case syntax_1.Syntax.RestElement:
							this.checkPatternParam(options, param.argument);
							break;
						case syntax_1.Syntax.AssignmentPattern:
							this.checkPatternParam(options, param.left);
							break;
						case syntax_1.Syntax.ArrayPattern:
							for (var i = 0; i < param.elements.length; i++) {
								if (param.elements[i] !== null) {
									this.checkPatternParam(options, param.elements[i]);
								}
							}
							break;
						case syntax_1.Syntax.ObjectPattern:
							for (var i = 0; i < param.properties.length; i++) {
								this.checkPatternParam(options, param.properties[i].value);
							}
							break;
						default:
							break;
					}
					options.simple = options.simple && param instanceof Node.Identifier;
				};
				Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
					var params = [expr];
					var options;
					var asyncArrow = false;
					switch (expr.type) {
						case syntax_1.Syntax.Identifier:
							break;
						case ArrowParameterPlaceHolder:
							params = expr.params;
							asyncArrow = expr.async;
							break;
						default:
							return null;
					}
					options = {
						simple: true,
						paramSet: {}
					};
					for (var i = 0; i < params.length; ++i) {
						var param = params[i];
						if (param.type === syntax_1.Syntax.AssignmentPattern) {
							if (param.right.type === syntax_1.Syntax.YieldExpression) {
								if (param.right.argument) {
									this.throwUnexpectedToken(this.lookahead);
								}
								param.right.type = syntax_1.Syntax.Identifier;
								param.right.name = 'yield';
								delete param.right.argument;
								delete param.right.delegate;
							}
						} else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
							this.throwUnexpectedToken(this.lookahead);
						}
						this.checkPatternParam(options, param);
						params[i] = param;
					}
					if (this.context.strict || !this.context.allowYield) {
						for (var i = 0; i < params.length; ++i) {
							var param = params[i];
							if (param.type === syntax_1.Syntax.YieldExpression) {
								this.throwUnexpectedToken(this.lookahead);
							}
						}
					}
					if (options.message === messages_1.Messages.StrictParamDupe) {
						var token = this.context.strict ? options.stricted : options.firstRestricted;
						this.throwUnexpectedToken(token, options.message);
					}
					return {
						simple: options.simple,
						params: params,
						stricted: options.stricted,
						firstRestricted: options.firstRestricted,
						message: options.message
					};
				};
				Parser.prototype.parseAssignmentExpression = function () {
					var expr;
					if (!this.context.allowYield && this.matchKeyword('yield')) {
						expr = this.parseYieldExpression();
					} else {
						var startToken = this.lookahead;
						var token = startToken;
						expr = this.parseConditionalExpression();
						if (token.type === 3 /* Identifier */ && token.lineNumber === this.lookahead.lineNumber && token.value === 'async') {
							if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
								var arg = this.parsePrimaryExpression();
								this.reinterpretExpressionAsPattern(arg);
								expr = {
									type: ArrowParameterPlaceHolder,
									params: [arg],
									async: true
								};
							}
						}
						if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
							// https://tc39.github.io/ecma262/#sec-arrow-function-definitions
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							var isAsync = expr.async;
							var list = this.reinterpretAsCoverFormalsList(expr);
							if (list) {
								if (this.hasLineTerminator) {
									this.tolerateUnexpectedToken(this.lookahead);
								}
								this.context.firstCoverInitializedNameError = null;
								var previousStrict = this.context.strict;
								var previousAllowStrictDirective = this.context.allowStrictDirective;
								this.context.allowStrictDirective = list.simple;
								var previousAllowYield = this.context.allowYield;
								var previousAwait = this.context.await;
								this.context.allowYield = true;
								this.context.await = isAsync;
								var node = this.startNode(startToken);
								this.expect('=>');
								var body = void 0;
								if (this.match('{')) {
									var previousAllowIn = this.context.allowIn;
									this.context.allowIn = true;
									body = this.parseFunctionSourceElements();
									this.context.allowIn = previousAllowIn;
								} else {
									body = this.isolateCoverGrammar(this.parseAssignmentExpression);
								}
								var expression = body.type !== syntax_1.Syntax.BlockStatement;
								if (this.context.strict && list.firstRestricted) {
									this.throwUnexpectedToken(list.firstRestricted, list.message);
								}
								if (this.context.strict && list.stricted) {
									this.tolerateUnexpectedToken(list.stricted, list.message);
								}
								expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
								this.context.strict = previousStrict;
								this.context.allowStrictDirective = previousAllowStrictDirective;
								this.context.allowYield = previousAllowYield;
								this.context.await = previousAwait;
							}
						} else {
							if (this.matchAssign()) {
								if (!this.context.isAssignmentTarget) {
									this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
								}
								if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
									var id = expr;
									if (this.scanner.isRestrictedWord(id.name)) {
										this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
									}
									if (this.scanner.isStrictModeReservedWord(id.name)) {
										this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
									}
								}
								if (!this.match('=')) {
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
								} else {
									this.reinterpretExpressionAsPattern(expr);
								}
								token = this.nextToken();
								var operator = token.value;
								var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
								expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
								this.context.firstCoverInitializedNameError = null;
							}
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-comma-operator
				Parser.prototype.parseExpression = function () {
					var startToken = this.lookahead;
					var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
					if (this.match(',')) {
						var expressions = [];
						expressions.push(expr);
						while (this.lookahead.type !== 2 /* EOF */) {
							if (!this.match(',')) {
								break;
							}
							this.nextToken();
							expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
						}
						expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-block
				Parser.prototype.parseStatementListItem = function () {
					var statement;
					this.context.isAssignmentTarget = true;
					this.context.isBindingElement = true;
					if (this.lookahead.type === 4 /* Keyword */) {
							switch (this.lookahead.value) {
								case 'export':
									if (!this.context.isModule) {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
									}
									statement = this.parseExportDeclaration();
									break;
								case 'import':
									if (!this.context.isModule) {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
									}
									statement = this.parseImportDeclaration();
									break;
								case 'const':
									statement = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'class':
									statement = this.parseClassDeclaration();
									break;
								case 'let':
									statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
									break;
								default:
									statement = this.parseStatement();
									break;
							}
						} else {
						statement = this.parseStatement();
					}
					return statement;
				};
				Parser.prototype.parseBlock = function () {
					var node = this.createNode();
					this.expect('{');
					var block = [];
					while (true) {
						if (this.match('}')) {
							break;
						}
						block.push(this.parseStatementListItem());
					}
					this.expect('}');
					return this.finalize(node, new Node.BlockStatement(block));
				};
				// https://tc39.github.io/ecma262/#sec-let-and-const-declarations
				Parser.prototype.parseLexicalBinding = function (kind, options) {
					var node = this.createNode();
					var params = [];
					var id = this.parsePattern(params, kind);
					if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(id.name)) {
							this.tolerateError(messages_1.Messages.StrictVarName);
						}
					}
					var init = null;
					if (kind === 'const') {
						if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
							if (this.match('=')) {
								this.nextToken();
								init = this.isolateCoverGrammar(this.parseAssignmentExpression);
							} else {
								this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
							}
						}
					} else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match('=')) {
						this.expect('=');
						init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					}
					return this.finalize(node, new Node.VariableDeclarator(id, init));
				};
				Parser.prototype.parseBindingList = function (kind, options) {
					var list = [this.parseLexicalBinding(kind, options)];
					while (this.match(',')) {
						this.nextToken();
						list.push(this.parseLexicalBinding(kind, options));
					}
					return list;
				};
				Parser.prototype.isLexicalDeclaration = function () {
					var state = this.scanner.saveState();
					this.scanner.scanComments();
					var next = this.scanner.lex();
					this.scanner.restoreState(state);
					return next.type === 3 /* Identifier */ || next.type === 7 /* Punctuator */ && next.value === '[' || next.type === 7 /* Punctuator */ && next.value === '{' || next.type === 4 /* Keyword */ && next.value === 'let' || next.type === 4 /* Keyword */ && next.value === 'yield';
				};
				Parser.prototype.parseLexicalDeclaration = function (options) {
					var node = this.createNode();
					var kind = this.nextToken().value;
					assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
					var declarations = this.parseBindingList(kind, options);
					this.consumeSemicolon();
					return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
				};
				// https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
				Parser.prototype.parseBindingRestElement = function (params, kind) {
					var node = this.createNode();
					this.expect('...');
					var arg = this.parsePattern(params, kind);
					return this.finalize(node, new Node.RestElement(arg));
				};
				Parser.prototype.parseArrayPattern = function (params, kind) {
					var node = this.createNode();
					this.expect('[');
					var elements = [];
					while (!this.match(']')) {
						if (this.match(',')) {
							this.nextToken();
							elements.push(null);
						} else {
							if (this.match('...')) {
								elements.push(this.parseBindingRestElement(params, kind));
								break;
							} else {
								elements.push(this.parsePatternWithDefault(params, kind));
							}
							if (!this.match(']')) {
								this.expect(',');
							}
						}
					}
					this.expect(']');
					return this.finalize(node, new Node.ArrayPattern(elements));
				};
				Parser.prototype.parsePropertyPattern = function (params, kind) {
					var node = this.createNode();
					var computed = false;
					var shorthand = false;
					var method = false;
					var key;
					var value;
					if (this.lookahead.type === 3 /* Identifier */) {
							var keyToken = this.lookahead;
							key = this.parseVariableIdentifier();
							var init = this.finalize(node, new Node.Identifier(keyToken.value));
							if (this.match('=')) {
								params.push(keyToken);
								shorthand = true;
								this.nextToken();
								var expr = this.parseAssignmentExpression();
								value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
							} else if (!this.match(':')) {
								params.push(keyToken);
								shorthand = true;
								value = init;
							} else {
								this.expect(':');
								value = this.parsePatternWithDefault(params, kind);
							}
						} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						this.expect(':');
						value = this.parsePatternWithDefault(params, kind);
					}
					return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
				};
				Parser.prototype.parseObjectPattern = function (params, kind) {
					var node = this.createNode();
					var properties = [];
					this.expect('{');
					while (!this.match('}')) {
						properties.push(this.parsePropertyPattern(params, kind));
						if (!this.match('}')) {
							this.expect(',');
						}
					}
					this.expect('}');
					return this.finalize(node, new Node.ObjectPattern(properties));
				};
				Parser.prototype.parsePattern = function (params, kind) {
					var pattern;
					if (this.match('[')) {
						pattern = this.parseArrayPattern(params, kind);
					} else if (this.match('{')) {
						pattern = this.parseObjectPattern(params, kind);
					} else {
						if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
							this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
						}
						params.push(this.lookahead);
						pattern = this.parseVariableIdentifier(kind);
					}
					return pattern;
				};
				Parser.prototype.parsePatternWithDefault = function (params, kind) {
					var startToken = this.lookahead;
					var pattern = this.parsePattern(params, kind);
					if (this.match('=')) {
						this.nextToken();
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = true;
						var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
						this.context.allowYield = previousAllowYield;
						pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
					}
					return pattern;
				};
				// https://tc39.github.io/ecma262/#sec-variable-statement
				Parser.prototype.parseVariableIdentifier = function (kind) {
					var node = this.createNode();
					var token = this.nextToken();
					if (token.type === 4 /* Keyword */ && token.value === 'yield') {
						if (this.context.strict) {
							this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
						} else if (!this.context.allowYield) {
							this.throwUnexpectedToken(token);
						}
					} else if (token.type !== 3 /* Identifier */) {
							if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
							} else {
								if (this.context.strict || token.value !== 'let' || kind !== 'var') {
									this.throwUnexpectedToken(token);
								}
							}
						} else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
						this.tolerateUnexpectedToken(token);
					}
					return this.finalize(node, new Node.Identifier(token.value));
				};
				Parser.prototype.parseVariableDeclaration = function (options) {
					var node = this.createNode();
					var params = [];
					var id = this.parsePattern(params, 'var');
					if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(id.name)) {
							this.tolerateError(messages_1.Messages.StrictVarName);
						}
					}
					var init = null;
					if (this.match('=')) {
						this.nextToken();
						init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					} else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
						this.expect('=');
					}
					return this.finalize(node, new Node.VariableDeclarator(id, init));
				};
				Parser.prototype.parseVariableDeclarationList = function (options) {
					var opt = { inFor: options.inFor };
					var list = [];
					list.push(this.parseVariableDeclaration(opt));
					while (this.match(',')) {
						this.nextToken();
						list.push(this.parseVariableDeclaration(opt));
					}
					return list;
				};
				Parser.prototype.parseVariableStatement = function () {
					var node = this.createNode();
					this.expectKeyword('var');
					var declarations = this.parseVariableDeclarationList({ inFor: false });
					this.consumeSemicolon();
					return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
				};
				// https://tc39.github.io/ecma262/#sec-empty-statement
				Parser.prototype.parseEmptyStatement = function () {
					var node = this.createNode();
					this.expect(';');
					return this.finalize(node, new Node.EmptyStatement());
				};
				// https://tc39.github.io/ecma262/#sec-expression-statement
				Parser.prototype.parseExpressionStatement = function () {
					var node = this.createNode();
					var expr = this.parseExpression();
					this.consumeSemicolon();
					return this.finalize(node, new Node.ExpressionStatement(expr));
				};
				// https://tc39.github.io/ecma262/#sec-if-statement
				Parser.prototype.parseIfClause = function () {
					if (this.context.strict && this.matchKeyword('function')) {
						this.tolerateError(messages_1.Messages.StrictFunction);
					}
					return this.parseStatement();
				};
				Parser.prototype.parseIfStatement = function () {
					var node = this.createNode();
					var consequent;
					var alternate = null;
					this.expectKeyword('if');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						consequent = this.parseIfClause();
						if (this.matchKeyword('else')) {
							this.nextToken();
							alternate = this.parseIfClause();
						}
					}
					return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
				};
				// https://tc39.github.io/ecma262/#sec-do-while-statement
				Parser.prototype.parseDoWhileStatement = function () {
					var node = this.createNode();
					this.expectKeyword('do');
					var previousInIteration = this.context.inIteration;
					this.context.inIteration = true;
					var body = this.parseStatement();
					this.context.inIteration = previousInIteration;
					this.expectKeyword('while');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
					} else {
						this.expect(')');
						if (this.match(';')) {
							this.nextToken();
						}
					}
					return this.finalize(node, new Node.DoWhileStatement(body, test));
				};
				// https://tc39.github.io/ecma262/#sec-while-statement
				Parser.prototype.parseWhileStatement = function () {
					var node = this.createNode();
					var body;
					this.expectKeyword('while');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						body = this.parseStatement();
						this.context.inIteration = previousInIteration;
					}
					return this.finalize(node, new Node.WhileStatement(test, body));
				};
				// https://tc39.github.io/ecma262/#sec-for-statement
				// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
				Parser.prototype.parseForStatement = function () {
					var init = null;
					var test = null;
					var update = null;
					var forIn = true;
					var left, right;
					var node = this.createNode();
					this.expectKeyword('for');
					this.expect('(');
					if (this.match(';')) {
						this.nextToken();
					} else {
						if (this.matchKeyword('var')) {
							init = this.createNode();
							this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							var declarations = this.parseVariableDeclarationList({ inFor: true });
							this.context.allowIn = previousAllowIn;
							if (declarations.length === 1 && this.matchKeyword('in')) {
								var decl = declarations[0];
								if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
									this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
								}
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.nextToken();
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.expect(';');
							}
						} else if (this.matchKeyword('const') || this.matchKeyword('let')) {
							init = this.createNode();
							var kind = this.nextToken().value;
							if (!this.context.strict && this.lookahead.value === 'in') {
								init = this.finalize(init, new Node.Identifier(kind));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else {
								var previousAllowIn = this.context.allowIn;
								this.context.allowIn = false;
								var declarations = this.parseBindingList(kind, { inFor: true });
								this.context.allowIn = previousAllowIn;
								if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseExpression();
									init = null;
								} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseAssignmentExpression();
									init = null;
									forIn = false;
								} else {
									this.consumeSemicolon();
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
								}
							}
						} else {
							var initStartToken = this.lookahead;
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							init = this.inheritCoverGrammar(this.parseAssignmentExpression);
							this.context.allowIn = previousAllowIn;
							if (this.matchKeyword('in')) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
									this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
								}
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (this.matchContextualKeyword('of')) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
									this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
								}
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								if (this.match(',')) {
									var initSeq = [init];
									while (this.match(',')) {
										this.nextToken();
										initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
									}
									init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
								}
								this.expect(';');
							}
						}
					}
					if (typeof left === 'undefined') {
						if (!this.match(';')) {
							test = this.parseExpression();
						}
						this.expect(';');
						if (!this.match(')')) {
							update = this.parseExpression();
						}
					}
					var body;
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						body = this.isolateCoverGrammar(this.parseStatement);
						this.context.inIteration = previousInIteration;
					}
					return typeof left === 'undefined' ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
				};
				// https://tc39.github.io/ecma262/#sec-continue-statement
				Parser.prototype.parseContinueStatement = function () {
					var node = this.createNode();
					this.expectKeyword('continue');
					var label = null;
					if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
						var id = this.parseVariableIdentifier();
						label = id;
						var key = '$' + id.name;
						if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
					}
					this.consumeSemicolon();
					if (label === null && !this.context.inIteration) {
						this.throwError(messages_1.Messages.IllegalContinue);
					}
					return this.finalize(node, new Node.ContinueStatement(label));
				};
				// https://tc39.github.io/ecma262/#sec-break-statement
				Parser.prototype.parseBreakStatement = function () {
					var node = this.createNode();
					this.expectKeyword('break');
					var label = null;
					if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
						var id = this.parseVariableIdentifier();
						var key = '$' + id.name;
						if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
						label = id;
					}
					this.consumeSemicolon();
					if (label === null && !this.context.inIteration && !this.context.inSwitch) {
						this.throwError(messages_1.Messages.IllegalBreak);
					}
					return this.finalize(node, new Node.BreakStatement(label));
				};
				// https://tc39.github.io/ecma262/#sec-return-statement
				Parser.prototype.parseReturnStatement = function () {
					if (!this.context.inFunctionBody) {
						this.tolerateError(messages_1.Messages.IllegalReturn);
					}
					var node = this.createNode();
					this.expectKeyword('return');
					var hasArgument = !this.match(';') && !this.match('}') && !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */ || this.lookahead.type === 8 /* StringLiteral */ || this.lookahead.type === 10 /* Template */;
					var argument = hasArgument ? this.parseExpression() : null;
					this.consumeSemicolon();
					return this.finalize(node, new Node.ReturnStatement(argument));
				};
				// https://tc39.github.io/ecma262/#sec-with-statement
				Parser.prototype.parseWithStatement = function () {
					if (this.context.strict) {
						this.tolerateError(messages_1.Messages.StrictModeWith);
					}
					var node = this.createNode();
					var body;
					this.expectKeyword('with');
					this.expect('(');
					var object = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						body = this.parseStatement();
					}
					return this.finalize(node, new Node.WithStatement(object, body));
				};
				// https://tc39.github.io/ecma262/#sec-switch-statement
				Parser.prototype.parseSwitchCase = function () {
					var node = this.createNode();
					var test;
					if (this.matchKeyword('default')) {
						this.nextToken();
						test = null;
					} else {
						this.expectKeyword('case');
						test = this.parseExpression();
					}
					this.expect(':');
					var consequent = [];
					while (true) {
						if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
							break;
						}
						consequent.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.SwitchCase(test, consequent));
				};
				Parser.prototype.parseSwitchStatement = function () {
					var node = this.createNode();
					this.expectKeyword('switch');
					this.expect('(');
					var discriminant = this.parseExpression();
					this.expect(')');
					var previousInSwitch = this.context.inSwitch;
					this.context.inSwitch = true;
					var cases = [];
					var defaultFound = false;
					this.expect('{');
					while (true) {
						if (this.match('}')) {
							break;
						}
						var clause = this.parseSwitchCase();
						if (clause.test === null) {
							if (defaultFound) {
								this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
							}
							defaultFound = true;
						}
						cases.push(clause);
					}
					this.expect('}');
					this.context.inSwitch = previousInSwitch;
					return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
				};
				// https://tc39.github.io/ecma262/#sec-labelled-statements
				Parser.prototype.parseLabelledStatement = function () {
					var node = this.createNode();
					var expr = this.parseExpression();
					var statement;
					if (expr.type === syntax_1.Syntax.Identifier && this.match(':')) {
						this.nextToken();
						var id = expr;
						var key = '$' + id.name;
						if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
						}
						this.context.labelSet[key] = true;
						var body = void 0;
						if (this.matchKeyword('class')) {
							this.tolerateUnexpectedToken(this.lookahead);
							body = this.parseClassDeclaration();
						} else if (this.matchKeyword('function')) {
							var token = this.lookahead;
							var declaration = this.parseFunctionDeclaration();
							if (this.context.strict) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
							} else if (declaration.generator) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
							}
							body = declaration;
						} else {
							body = this.parseStatement();
						}
						delete this.context.labelSet[key];
						statement = new Node.LabeledStatement(id, body);
					} else {
						this.consumeSemicolon();
						statement = new Node.ExpressionStatement(expr);
					}
					return this.finalize(node, statement);
				};
				// https://tc39.github.io/ecma262/#sec-throw-statement
				Parser.prototype.parseThrowStatement = function () {
					var node = this.createNode();
					this.expectKeyword('throw');
					if (this.hasLineTerminator) {
						this.throwError(messages_1.Messages.NewlineAfterThrow);
					}
					var argument = this.parseExpression();
					this.consumeSemicolon();
					return this.finalize(node, new Node.ThrowStatement(argument));
				};
				// https://tc39.github.io/ecma262/#sec-try-statement
				Parser.prototype.parseCatchClause = function () {
					var node = this.createNode();
					this.expectKeyword('catch');
					this.expect('(');
					if (this.match(')')) {
						this.throwUnexpectedToken(this.lookahead);
					}
					var params = [];
					var param = this.parsePattern(params);
					var paramMap = {};
					for (var i = 0; i < params.length; i++) {
						var key = '$' + params[i].value;
						if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
							this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
						}
						paramMap[key] = true;
					}
					if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(param.name)) {
							this.tolerateError(messages_1.Messages.StrictCatchVariable);
						}
					}
					this.expect(')');
					var body = this.parseBlock();
					return this.finalize(node, new Node.CatchClause(param, body));
				};
				Parser.prototype.parseFinallyClause = function () {
					this.expectKeyword('finally');
					return this.parseBlock();
				};
				Parser.prototype.parseTryStatement = function () {
					var node = this.createNode();
					this.expectKeyword('try');
					var block = this.parseBlock();
					var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
					var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
					if (!handler && !finalizer) {
						this.throwError(messages_1.Messages.NoCatchOrFinally);
					}
					return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
				};
				// https://tc39.github.io/ecma262/#sec-debugger-statement
				Parser.prototype.parseDebuggerStatement = function () {
					var node = this.createNode();
					this.expectKeyword('debugger');
					this.consumeSemicolon();
					return this.finalize(node, new Node.DebuggerStatement());
				};
				// https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
				Parser.prototype.parseStatement = function () {
					var statement;
					switch (this.lookahead.type) {
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 6 /* NumericLiteral */:
						case 8 /* StringLiteral */:
						case 10 /* Template */:
						case 9 /* RegularExpression */:
							statement = this.parseExpressionStatement();
							break;
						case 7 /* Punctuator */:
							var value = this.lookahead.value;
							if (value === '{') {
								statement = this.parseBlock();
							} else if (value === '(') {
								statement = this.parseExpressionStatement();
							} else if (value === ';') {
								statement = this.parseEmptyStatement();
							} else {
								statement = this.parseExpressionStatement();
							}
							break;
						case 3 /* Identifier */:
							statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
							break;
						case 4 /* Keyword */:
							switch (this.lookahead.value) {
								case 'break':
									statement = this.parseBreakStatement();
									break;
								case 'continue':
									statement = this.parseContinueStatement();
									break;
								case 'debugger':
									statement = this.parseDebuggerStatement();
									break;
								case 'do':
									statement = this.parseDoWhileStatement();
									break;
								case 'for':
									statement = this.parseForStatement();
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'if':
									statement = this.parseIfStatement();
									break;
								case 'return':
									statement = this.parseReturnStatement();
									break;
								case 'switch':
									statement = this.parseSwitchStatement();
									break;
								case 'throw':
									statement = this.parseThrowStatement();
									break;
								case 'try':
									statement = this.parseTryStatement();
									break;
								case 'var':
									statement = this.parseVariableStatement();
									break;
								case 'while':
									statement = this.parseWhileStatement();
									break;
								case 'with':
									statement = this.parseWithStatement();
									break;
								default:
									statement = this.parseExpressionStatement();
									break;
							}
							break;
						default:
							statement = this.throwUnexpectedToken(this.lookahead);
					}
					return statement;
				};
				// https://tc39.github.io/ecma262/#sec-function-definitions
				Parser.prototype.parseFunctionSourceElements = function () {
					var node = this.createNode();
					this.expect('{');
					var body = this.parseDirectivePrologues();
					var previousLabelSet = this.context.labelSet;
					var previousInIteration = this.context.inIteration;
					var previousInSwitch = this.context.inSwitch;
					var previousInFunctionBody = this.context.inFunctionBody;
					this.context.labelSet = {};
					this.context.inIteration = false;
					this.context.inSwitch = false;
					this.context.inFunctionBody = true;
					while (this.lookahead.type !== 2 /* EOF */) {
						if (this.match('}')) {
							break;
						}
						body.push(this.parseStatementListItem());
					}
					this.expect('}');
					this.context.labelSet = previousLabelSet;
					this.context.inIteration = previousInIteration;
					this.context.inSwitch = previousInSwitch;
					this.context.inFunctionBody = previousInFunctionBody;
					return this.finalize(node, new Node.BlockStatement(body));
				};
				Parser.prototype.validateParam = function (options, param, name) {
					var key = '$' + name;
					if (this.context.strict) {
						if (this.scanner.isRestrictedWord(name)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamName;
						}
						if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamDupe;
						}
					} else if (!options.firstRestricted) {
						if (this.scanner.isRestrictedWord(name)) {
							options.firstRestricted = param;
							options.message = messages_1.Messages.StrictParamName;
						} else if (this.scanner.isStrictModeReservedWord(name)) {
							options.firstRestricted = param;
							options.message = messages_1.Messages.StrictReservedWord;
						} else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamDupe;
						}
					}
					/* istanbul ignore next */
					if (typeof Object.defineProperty === 'function') {
						Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
					} else {
						options.paramSet[key] = true;
					}
				};
				Parser.prototype.parseRestElement = function (params) {
					var node = this.createNode();
					this.expect('...');
					var arg = this.parsePattern(params);
					if (this.match('=')) {
						this.throwError(messages_1.Messages.DefaultRestParameter);
					}
					if (!this.match(')')) {
						this.throwError(messages_1.Messages.ParameterAfterRestParameter);
					}
					return this.finalize(node, new Node.RestElement(arg));
				};
				Parser.prototype.parseFormalParameter = function (options) {
					var params = [];
					var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
					for (var i = 0; i < params.length; i++) {
						this.validateParam(options, params[i], params[i].value);
					}
					options.simple = options.simple && param instanceof Node.Identifier;
					options.params.push(param);
				};
				Parser.prototype.parseFormalParameters = function (firstRestricted) {
					var options;
					options = {
						simple: true,
						params: [],
						firstRestricted: firstRestricted
					};
					this.expect('(');
					if (!this.match(')')) {
						options.paramSet = {};
						while (this.lookahead.type !== 2 /* EOF */) {
							this.parseFormalParameter(options);
							if (this.match(')')) {
								break;
							}
							this.expect(',');
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return {
						simple: options.simple,
						params: options.params,
						stricted: options.stricted,
						firstRestricted: options.firstRestricted,
						message: options.message
					};
				};
				Parser.prototype.matchAsyncFunction = function () {
					var match = this.matchContextualKeyword('async');
					if (match) {
						var state = this.scanner.saveState();
						this.scanner.scanComments();
						var next = this.scanner.lex();
						this.scanner.restoreState(state);
						match = state.lineNumber === next.lineNumber && next.type === 4 /* Keyword */ && next.value === 'function';
					}
					return match;
				};
				Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
					var node = this.createNode();
					var isAsync = this.matchContextualKeyword('async');
					if (isAsync) {
						this.nextToken();
					}
					this.expectKeyword('function');
					var isGenerator = isAsync ? false : this.match('*');
					if (isGenerator) {
						this.nextToken();
					}
					var message;
					var id = null;
					var firstRestricted = null;
					if (!identifierIsOptional || !this.match('(')) {
						var token = this.lookahead;
						id = this.parseVariableIdentifier();
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							}
						} else {
							if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
					}
					var previousAllowAwait = this.context.await;
					var previousAllowYield = this.context.allowYield;
					this.context.await = isAsync;
					this.context.allowYield = !isGenerator;
					var formalParameters = this.parseFormalParameters(firstRestricted);
					var params = formalParameters.params;
					var stricted = formalParameters.stricted;
					firstRestricted = formalParameters.firstRestricted;
					if (formalParameters.message) {
						message = formalParameters.message;
					}
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = formalParameters.simple;
					var body = this.parseFunctionSourceElements();
					if (this.context.strict && firstRestricted) {
						this.throwUnexpectedToken(firstRestricted, message);
					}
					if (this.context.strict && stricted) {
						this.tolerateUnexpectedToken(stricted, message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.await = previousAllowAwait;
					this.context.allowYield = previousAllowYield;
					return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
				};
				Parser.prototype.parseFunctionExpression = function () {
					var node = this.createNode();
					var isAsync = this.matchContextualKeyword('async');
					if (isAsync) {
						this.nextToken();
					}
					this.expectKeyword('function');
					var isGenerator = isAsync ? false : this.match('*');
					if (isGenerator) {
						this.nextToken();
					}
					var message;
					var id = null;
					var firstRestricted;
					var previousAllowAwait = this.context.await;
					var previousAllowYield = this.context.allowYield;
					this.context.await = isAsync;
					this.context.allowYield = !isGenerator;
					if (!this.match('(')) {
						var token = this.lookahead;
						id = !this.context.strict && !isGenerator && this.matchKeyword('yield') ? this.parseIdentifierName() : this.parseVariableIdentifier();
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							}
						} else {
							if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
					}
					var formalParameters = this.parseFormalParameters(firstRestricted);
					var params = formalParameters.params;
					var stricted = formalParameters.stricted;
					firstRestricted = formalParameters.firstRestricted;
					if (formalParameters.message) {
						message = formalParameters.message;
					}
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = formalParameters.simple;
					var body = this.parseFunctionSourceElements();
					if (this.context.strict && firstRestricted) {
						this.throwUnexpectedToken(firstRestricted, message);
					}
					if (this.context.strict && stricted) {
						this.tolerateUnexpectedToken(stricted, message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.await = previousAllowAwait;
					this.context.allowYield = previousAllowYield;
					return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
				};
				// https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
				Parser.prototype.parseDirective = function () {
					var token = this.lookahead;
					var node = this.createNode();
					var expr = this.parseExpression();
					var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
					this.consumeSemicolon();
					return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
				};
				Parser.prototype.parseDirectivePrologues = function () {
					var firstRestricted = null;
					var body = [];
					while (true) {
						var token = this.lookahead;
						if (token.type !== 8 /* StringLiteral */) {
								break;
							}
						var statement = this.parseDirective();
						body.push(statement);
						var directive = statement.directive;
						if (typeof directive !== 'string') {
							break;
						}
						if (directive === 'use strict') {
							this.context.strict = true;
							if (firstRestricted) {
								this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
							}
							if (!this.context.allowStrictDirective) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
							}
						} else {
							if (!firstRestricted && token.octal) {
								firstRestricted = token;
							}
						}
					}
					return body;
				};
				// https://tc39.github.io/ecma262/#sec-method-definitions
				Parser.prototype.qualifiedPropertyName = function (token) {
					switch (token.type) {
						case 3 /* Identifier */:
						case 8 /* StringLiteral */:
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 6 /* NumericLiteral */:
						case 4 /* Keyword */:
							return true;
						case 7 /* Punctuator */:
							return token.value === '[';
						default:
							break;
					}
					return false;
				};
				Parser.prototype.parseGetterMethod = function () {
					var node = this.createNode();
					var isGenerator = false;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = !isGenerator;
					var formalParameters = this.parseFormalParameters();
					if (formalParameters.params.length > 0) {
						this.tolerateError(messages_1.Messages.BadGetterArity);
					}
					var method = this.parsePropertyMethod(formalParameters);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
				};
				Parser.prototype.parseSetterMethod = function () {
					var node = this.createNode();
					var isGenerator = false;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = !isGenerator;
					var formalParameters = this.parseFormalParameters();
					if (formalParameters.params.length !== 1) {
						this.tolerateError(messages_1.Messages.BadSetterArity);
					} else if (formalParameters.params[0] instanceof Node.RestElement) {
						this.tolerateError(messages_1.Messages.BadSetterRestParameter);
					}
					var method = this.parsePropertyMethod(formalParameters);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
				};
				Parser.prototype.parseGeneratorMethod = function () {
					var node = this.createNode();
					var isGenerator = true;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = true;
					var params = this.parseFormalParameters();
					this.context.allowYield = false;
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
				};
				// https://tc39.github.io/ecma262/#sec-generator-function-definitions
				Parser.prototype.isStartOfExpression = function () {
					var start = true;
					var value = this.lookahead.value;
					switch (this.lookahead.type) {
						case 7 /* Punctuator */:
							start = value === '[' || value === '(' || value === '{' || value === '+' || value === '-' || value === '!' || value === '~' || value === '++' || value === '--' || value === '/' || value === '/='; // regular expression literal
							break;
						case 4 /* Keyword */:
							start = value === 'class' || value === 'delete' || value === 'function' || value === 'let' || value === 'new' || value === 'super' || value === 'this' || value === 'typeof' || value === 'void' || value === 'yield';
							break;
						default:
							break;
					}
					return start;
				};
				Parser.prototype.parseYieldExpression = function () {
					var node = this.createNode();
					this.expectKeyword('yield');
					var argument = null;
					var delegate = false;
					if (!this.hasLineTerminator) {
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = false;
						delegate = this.match('*');
						if (delegate) {
							this.nextToken();
							argument = this.parseAssignmentExpression();
						} else if (this.isStartOfExpression()) {
							argument = this.parseAssignmentExpression();
						}
						this.context.allowYield = previousAllowYield;
					}
					return this.finalize(node, new Node.YieldExpression(argument, delegate));
				};
				// https://tc39.github.io/ecma262/#sec-class-definitions
				Parser.prototype.parseClassElement = function (hasConstructor) {
					var token = this.lookahead;
					var node = this.createNode();
					var kind = '';
					var key = null;
					var value = null;
					var computed = false;
					var method = false;
					var isStatic = false;
					var isAsync = false;
					if (this.match('*')) {
						this.nextToken();
					} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						var id = key;
						if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
							token = this.lookahead;
							isStatic = true;
							computed = this.match('[');
							if (this.match('*')) {
								this.nextToken();
							} else {
								key = this.parseObjectPropertyKey();
							}
						}
						if (token.type === 3 /* Identifier */ && !this.hasLineTerminator && token.value === 'async') {
							var punctuator = this.lookahead.value;
							if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
								isAsync = true;
								token = this.lookahead;
								key = this.parseObjectPropertyKey();
								if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
									this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
								}
							}
						}
					}
					var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
					if (token.type === 3 /* Identifier */) {
							if (token.value === 'get' && lookaheadPropertyKey) {
								kind = 'get';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								this.context.allowYield = false;
								value = this.parseGetterMethod();
							} else if (token.value === 'set' && lookaheadPropertyKey) {
								kind = 'set';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								value = this.parseSetterMethod();
							}
						} else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
						kind = 'init';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseGeneratorMethod();
						method = true;
					}
					if (!kind && key && this.match('(')) {
						kind = 'init';
						value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
						method = true;
					}
					if (!kind) {
						this.throwUnexpectedToken(this.lookahead);
					}
					if (kind === 'init') {
						kind = 'method';
					}
					if (!computed) {
						if (isStatic && this.isPropertyKey(key, 'prototype')) {
							this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
						}
						if (!isStatic && this.isPropertyKey(key, 'constructor')) {
							if (kind !== 'method' || !method || value && value.generator) {
								this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
							}
							if (hasConstructor.value) {
								this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
							} else {
								hasConstructor.value = true;
							}
							kind = 'constructor';
						}
					}
					return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
				};
				Parser.prototype.parseClassElementList = function () {
					var body = [];
					var hasConstructor = { value: false };
					this.expect('{');
					while (!this.match('}')) {
						if (this.match(';')) {
							this.nextToken();
						} else {
							body.push(this.parseClassElement(hasConstructor));
						}
					}
					this.expect('}');
					return body;
				};
				Parser.prototype.parseClassBody = function () {
					var node = this.createNode();
					var elementList = this.parseClassElementList();
					return this.finalize(node, new Node.ClassBody(elementList));
				};
				Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
					var node = this.createNode();
					var previousStrict = this.context.strict;
					this.context.strict = true;
					this.expectKeyword('class');
					var id = identifierIsOptional && this.lookahead.type !== 3 /* Identifier */ ? null : this.parseVariableIdentifier();
					var superClass = null;
					if (this.matchKeyword('extends')) {
						this.nextToken();
						superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
					}
					var classBody = this.parseClassBody();
					this.context.strict = previousStrict;
					return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
				};
				Parser.prototype.parseClassExpression = function () {
					var node = this.createNode();
					var previousStrict = this.context.strict;
					this.context.strict = true;
					this.expectKeyword('class');
					var id = this.lookahead.type === 3 /* Identifier */ ? this.parseVariableIdentifier() : null;
					var superClass = null;
					if (this.matchKeyword('extends')) {
						this.nextToken();
						superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
					}
					var classBody = this.parseClassBody();
					this.context.strict = previousStrict;
					return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
				};
				// https://tc39.github.io/ecma262/#sec-scripts
				// https://tc39.github.io/ecma262/#sec-modules
				Parser.prototype.parseModule = function () {
					this.context.strict = true;
					this.context.isModule = true;
					this.scanner.isModule = true;
					var node = this.createNode();
					var body = this.parseDirectivePrologues();
					while (this.lookahead.type !== 2 /* EOF */) {
						body.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.Module(body));
				};
				Parser.prototype.parseScript = function () {
					var node = this.createNode();
					var body = this.parseDirectivePrologues();
					while (this.lookahead.type !== 2 /* EOF */) {
						body.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.Script(body));
				};
				// https://tc39.github.io/ecma262/#sec-imports
				Parser.prototype.parseModuleSpecifier = function () {
					var node = this.createNode();
					if (this.lookahead.type !== 8 /* StringLiteral */) {
							this.throwError(messages_1.Messages.InvalidModuleSpecifier);
						}
					var token = this.nextToken();
					var raw = this.getTokenRaw(token);
					return this.finalize(node, new Node.Literal(token.value, raw));
				};
				// import {<foo as bar>} ...;
				Parser.prototype.parseImportSpecifier = function () {
					var node = this.createNode();
					var imported;
					var local;
					if (this.lookahead.type === 3 /* Identifier */) {
							imported = this.parseVariableIdentifier();
							local = imported;
							if (this.matchContextualKeyword('as')) {
								this.nextToken();
								local = this.parseVariableIdentifier();
							}
						} else {
						imported = this.parseIdentifierName();
						local = imported;
						if (this.matchContextualKeyword('as')) {
							this.nextToken();
							local = this.parseVariableIdentifier();
						} else {
							this.throwUnexpectedToken(this.nextToken());
						}
					}
					return this.finalize(node, new Node.ImportSpecifier(local, imported));
				};
				// {foo, bar as bas}
				Parser.prototype.parseNamedImports = function () {
					this.expect('{');
					var specifiers = [];
					while (!this.match('}')) {
						specifiers.push(this.parseImportSpecifier());
						if (!this.match('}')) {
							this.expect(',');
						}
					}
					this.expect('}');
					return specifiers;
				};
				// import <foo> ...;
				Parser.prototype.parseImportDefaultSpecifier = function () {
					var node = this.createNode();
					var local = this.parseIdentifierName();
					return this.finalize(node, new Node.ImportDefaultSpecifier(local));
				};
				// import <* as foo> ...;
				Parser.prototype.parseImportNamespaceSpecifier = function () {
					var node = this.createNode();
					this.expect('*');
					if (!this.matchContextualKeyword('as')) {
						this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
					}
					this.nextToken();
					var local = this.parseIdentifierName();
					return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
				};
				Parser.prototype.parseImportDeclaration = function () {
					if (this.context.inFunctionBody) {
						this.throwError(messages_1.Messages.IllegalImportDeclaration);
					}
					var node = this.createNode();
					this.expectKeyword('import');
					var src;
					var specifiers = [];
					if (this.lookahead.type === 8 /* StringLiteral */) {
							// import 'foo';
							src = this.parseModuleSpecifier();
						} else {
						if (this.match('{')) {
							// import {bar}
							specifiers = specifiers.concat(this.parseNamedImports());
						} else if (this.match('*')) {
							// import * as foo
							specifiers.push(this.parseImportNamespaceSpecifier());
						} else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
							// import foo
							specifiers.push(this.parseImportDefaultSpecifier());
							if (this.match(',')) {
								this.nextToken();
								if (this.match('*')) {
									// import foo, * as foo
									specifiers.push(this.parseImportNamespaceSpecifier());
								} else if (this.match('{')) {
									// import foo, {bar}
									specifiers = specifiers.concat(this.parseNamedImports());
								} else {
									this.throwUnexpectedToken(this.lookahead);
								}
							}
						} else {
							this.throwUnexpectedToken(this.nextToken());
						}
						if (!this.matchContextualKeyword('from')) {
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						}
						this.nextToken();
						src = this.parseModuleSpecifier();
					}
					this.consumeSemicolon();
					return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
				};
				// https://tc39.github.io/ecma262/#sec-exports
				Parser.prototype.parseExportSpecifier = function () {
					var node = this.createNode();
					var local = this.parseIdentifierName();
					var exported = local;
					if (this.matchContextualKeyword('as')) {
						this.nextToken();
						exported = this.parseIdentifierName();
					}
					return this.finalize(node, new Node.ExportSpecifier(local, exported));
				};
				Parser.prototype.parseExportDeclaration = function () {
					if (this.context.inFunctionBody) {
						this.throwError(messages_1.Messages.IllegalExportDeclaration);
					}
					var node = this.createNode();
					this.expectKeyword('export');
					var exportDeclaration;
					if (this.matchKeyword('default')) {
						// export default ...
						this.nextToken();
						if (this.matchKeyword('function')) {
							// export default function foo () {}
							// export default function () {}
							var declaration = this.parseFunctionDeclaration(true);
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchKeyword('class')) {
							// export default class foo {}
							var declaration = this.parseClassDeclaration(true);
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchContextualKeyword('async')) {
							// export default async function f () {}
							// export default async function () {}
							// export default async x => x
							var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else {
							if (this.matchContextualKeyword('from')) {
								this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
							}
							// export default {};
							// export default [];
							// export default (1 + 2);
							var declaration = this.match('{') ? this.parseObjectInitializer() : this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
							this.consumeSemicolon();
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						}
					} else if (this.match('*')) {
						// export * from 'foo';
						this.nextToken();
						if (!this.matchContextualKeyword('from')) {
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						}
						this.nextToken();
						var src = this.parseModuleSpecifier();
						this.consumeSemicolon();
						exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
					} else if (this.lookahead.type === 4 /* Keyword */) {
							// export var f = 1;
							var declaration = void 0;
							switch (this.lookahead.value) {
								case 'let':
								case 'const':
									declaration = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'var':
								case 'class':
								case 'function':
									declaration = this.parseStatementListItem();
									break;
								default:
									this.throwUnexpectedToken(this.lookahead);
							}
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
						} else if (this.matchAsyncFunction()) {
						var declaration = this.parseFunctionDeclaration();
						exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
					} else {
						var specifiers = [];
						var source = null;
						var isExportFromIdentifier = false;
						this.expect('{');
						while (!this.match('}')) {
							isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
							specifiers.push(this.parseExportSpecifier());
							if (!this.match('}')) {
								this.expect(',');
							}
						}
						this.expect('}');
						if (this.matchContextualKeyword('from')) {
							// export {default} from 'foo';
							// export {foo} from 'foo';
							this.nextToken();
							source = this.parseModuleSpecifier();
							this.consumeSemicolon();
						} else if (isExportFromIdentifier) {
							// export {default}; // missing fromClause
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						} else {
							// export {foo};
							this.consumeSemicolon();
						}
						exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
					}
					return exportDeclaration;
				};
				return Parser;
			}();
			exports.Parser = Parser;

			/***/
		},
		/* 9 */
		/***/function (module, exports) {

			"use strict";
			// Ensure the condition is true, otherwise throw an error.
			// This is only to have a better contract semantic, i.e. another safety net
			// to catch a logic error. The condition shall be fulfilled in normal case.
			// Do NOT use this to enforce a certain condition on any user input.

			Object.defineProperty(exports, "__esModule", { value: true });
			function assert(condition, message) {
				/* istanbul ignore if */
				if (!condition) {
					throw new Error('ASSERT: ' + message);
				}
			}
			exports.assert = assert;

			/***/
		},
		/* 10 */
		/***/function (module, exports) {

			"use strict";
			/* tslint:disable:max-classes-per-file */

			Object.defineProperty(exports, "__esModule", { value: true });
			var ErrorHandler = function () {
				function ErrorHandler() {
					this.errors = [];
					this.tolerant = false;
				}
				ErrorHandler.prototype.recordError = function (error) {
					this.errors.push(error);
				};
				ErrorHandler.prototype.tolerate = function (error) {
					if (this.tolerant) {
						this.recordError(error);
					} else {
						throw error;
					}
				};
				ErrorHandler.prototype.constructError = function (msg, column) {
					var error = new Error(msg);
					try {
						throw error;
					} catch (base) {
						/* istanbul ignore else */
						if (Object.create && Object.defineProperty) {
							error = Object.create(base);
							Object.defineProperty(error, 'column', { value: column });
						}
					}
					/* istanbul ignore next */
					return error;
				};
				ErrorHandler.prototype.createError = function (index, line, col, description) {
					var msg = 'Line ' + line + ': ' + description;
					var error = this.constructError(msg, col);
					error.index = index;
					error.lineNumber = line;
					error.description = description;
					return error;
				};
				ErrorHandler.prototype.throwError = function (index, line, col, description) {
					throw this.createError(index, line, col, description);
				};
				ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
					var error = this.createError(index, line, col, description);
					if (this.tolerant) {
						this.recordError(error);
					} else {
						throw error;
					}
				};
				return ErrorHandler;
			}();
			exports.ErrorHandler = ErrorHandler;

			/***/
		},
		/* 11 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			// Error messages should be identical to V8.
			exports.Messages = {
				BadGetterArity: 'Getter must not have any formal parameters',
				BadSetterArity: 'Setter must have exactly one formal parameter',
				BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
				ConstructorIsAsync: 'Class constructor may not be an async method',
				ConstructorSpecialMethod: 'Class constructor may not be an accessor',
				DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
				DefaultRestParameter: 'Unexpected token =',
				DuplicateBinding: 'Duplicate binding %0',
				DuplicateConstructor: 'A class may only have one constructor',
				DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
				ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
				GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
				IllegalBreak: 'Illegal break statement',
				IllegalContinue: 'Illegal continue statement',
				IllegalExportDeclaration: 'Unexpected token',
				IllegalImportDeclaration: 'Unexpected token',
				IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
				IllegalReturn: 'Illegal return statement',
				InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
				InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
				InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
				InvalidLHSInForIn: 'Invalid left-hand side in for-in',
				InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
				InvalidModuleSpecifier: 'Unexpected token',
				InvalidRegExp: 'Invalid regular expression',
				LetInLexicalBinding: 'let is disallowed as a lexically bound name',
				MissingFromClause: 'Unexpected token',
				MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
				NewlineAfterThrow: 'Illegal newline after throw',
				NoAsAfterImportNamespace: 'Unexpected token',
				NoCatchOrFinally: 'Missing catch or finally after try',
				ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
				Redeclaration: '%0 \'%1\' has already been declared',
				StaticPrototype: 'Classes may not have static property named prototype',
				StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
				StrictDelete: 'Delete of an unqualified identifier in strict mode.',
				StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
				StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
				StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
				StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
				StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
				StrictModeWith: 'Strict mode code may not include a with statement',
				StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
				StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
				StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
				StrictReservedWord: 'Use of future reserved word in strict mode',
				StrictVarName: 'Variable name may not be eval or arguments in strict mode',
				TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
				UnexpectedEOS: 'Unexpected end of input',
				UnexpectedIdentifier: 'Unexpected identifier',
				UnexpectedNumber: 'Unexpected number',
				UnexpectedReserved: 'Unexpected reserved word',
				UnexpectedString: 'Unexpected string',
				UnexpectedTemplate: 'Unexpected quasi %0',
				UnexpectedToken: 'Unexpected token %0',
				UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
				UnknownLabel: 'Undefined label \'%0\'',
				UnterminatedRegExp: 'Invalid regular expression: missing /'
			};

			/***/
		},
		/* 12 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var character_1 = __webpack_require__(4);
			var messages_1 = __webpack_require__(11);
			function hexValue(ch) {
				return '0123456789abcdef'.indexOf(ch.toLowerCase());
			}
			function octalValue(ch) {
				return '01234567'.indexOf(ch);
			}
			var Scanner = function () {
				function Scanner(code, handler) {
					this.source = code;
					this.errorHandler = handler;
					this.trackComment = false;
					this.isModule = false;
					this.length = code.length;
					this.index = 0;
					this.lineNumber = code.length > 0 ? 1 : 0;
					this.lineStart = 0;
					this.curlyStack = [];
				}
				Scanner.prototype.saveState = function () {
					return {
						index: this.index,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart
					};
				};
				Scanner.prototype.restoreState = function (state) {
					this.index = state.index;
					this.lineNumber = state.lineNumber;
					this.lineStart = state.lineStart;
				};
				Scanner.prototype.eof = function () {
					return this.index >= this.length;
				};
				Scanner.prototype.throwUnexpectedToken = function (message) {
					if (message === void 0) {
						message = messages_1.Messages.UnexpectedTokenIllegal;
					}
					return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
				};
				Scanner.prototype.tolerateUnexpectedToken = function (message) {
					if (message === void 0) {
						message = messages_1.Messages.UnexpectedTokenIllegal;
					}
					this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
				};
				// https://tc39.github.io/ecma262/#sec-comments
				Scanner.prototype.skipSingleLineComment = function (offset) {
					var comments = [];
					var start, loc;
					if (this.trackComment) {
						comments = [];
						start = this.index - offset;
						loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - offset
							},
							end: {}
						};
					}
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						++this.index;
						if (character_1.Character.isLineTerminator(ch)) {
							if (this.trackComment) {
								loc.end = {
									line: this.lineNumber,
									column: this.index - this.lineStart - 1
								};
								var entry = {
									multiLine: false,
									slice: [start + offset, this.index - 1],
									range: [start, this.index - 1],
									loc: loc
								};
								comments.push(entry);
							}
							if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
								++this.index;
							}
							++this.lineNumber;
							this.lineStart = this.index;
							return comments;
						}
					}
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						var entry = {
							multiLine: false,
							slice: [start + offset, this.index],
							range: [start, this.index],
							loc: loc
						};
						comments.push(entry);
					}
					return comments;
				};
				Scanner.prototype.skipMultiLineComment = function () {
					var comments = [];
					var start, loc;
					if (this.trackComment) {
						comments = [];
						start = this.index - 2;
						loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - 2
							},
							end: {}
						};
					}
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (character_1.Character.isLineTerminator(ch)) {
							if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
								++this.index;
							}
							++this.lineNumber;
							++this.index;
							this.lineStart = this.index;
						} else if (ch === 0x2A) {
							// Block comment ends with '*/'.
							if (this.source.charCodeAt(this.index + 1) === 0x2F) {
								this.index += 2;
								if (this.trackComment) {
									loc.end = {
										line: this.lineNumber,
										column: this.index - this.lineStart
									};
									var entry = {
										multiLine: true,
										slice: [start + 2, this.index - 2],
										range: [start, this.index],
										loc: loc
									};
									comments.push(entry);
								}
								return comments;
							}
							++this.index;
						} else {
							++this.index;
						}
					}
					// Ran off the end of the file - the whole thing is a comment
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						var entry = {
							multiLine: true,
							slice: [start + 2, this.index],
							range: [start, this.index],
							loc: loc
						};
						comments.push(entry);
					}
					this.tolerateUnexpectedToken();
					return comments;
				};
				Scanner.prototype.scanComments = function () {
					var comments;
					if (this.trackComment) {
						comments = [];
					}
					var start = this.index === 0;
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (character_1.Character.isWhiteSpace(ch)) {
							++this.index;
						} else if (character_1.Character.isLineTerminator(ch)) {
							++this.index;
							if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
								++this.index;
							}
							++this.lineNumber;
							this.lineStart = this.index;
							start = true;
						} else if (ch === 0x2F) {
							ch = this.source.charCodeAt(this.index + 1);
							if (ch === 0x2F) {
								this.index += 2;
								var comment = this.skipSingleLineComment(2);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
								start = true;
							} else if (ch === 0x2A) {
								this.index += 2;
								var comment = this.skipMultiLineComment();
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else if (start && ch === 0x2D) {
							// U+003E is '>'
							if (this.source.charCodeAt(this.index + 1) === 0x2D && this.source.charCodeAt(this.index + 2) === 0x3E) {
								// '-->' is a single-line comment
								this.index += 3;
								var comment = this.skipSingleLineComment(3);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else if (ch === 0x3C && !this.isModule) {
							if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
								this.index += 4; // `<!--`
								var comment = this.skipSingleLineComment(4);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else {
							break;
						}
					}
					return comments;
				};
				// https://tc39.github.io/ecma262/#sec-future-reserved-words
				Scanner.prototype.isFutureReservedWord = function (id) {
					switch (id) {
						case 'enum':
						case 'export':
						case 'import':
						case 'super':
							return true;
						default:
							return false;
					}
				};
				Scanner.prototype.isStrictModeReservedWord = function (id) {
					switch (id) {
						case 'implements':
						case 'interface':
						case 'package':
						case 'private':
						case 'protected':
						case 'public':
						case 'static':
						case 'yield':
						case 'let':
							return true;
						default:
							return false;
					}
				};
				Scanner.prototype.isRestrictedWord = function (id) {
					return id === 'eval' || id === 'arguments';
				};
				// https://tc39.github.io/ecma262/#sec-keywords
				Scanner.prototype.isKeyword = function (id) {
					switch (id.length) {
						case 2:
							return id === 'if' || id === 'in' || id === 'do';
						case 3:
							return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
						case 4:
							return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
						case 5:
							return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
						case 6:
							return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
						case 7:
							return id === 'default' || id === 'finally' || id === 'extends';
						case 8:
							return id === 'function' || id === 'continue' || id === 'debugger';
						case 10:
							return id === 'instanceof';
						default:
							return false;
					}
				};
				Scanner.prototype.codePointAt = function (i) {
					var cp = this.source.charCodeAt(i);
					if (cp >= 0xD800 && cp <= 0xDBFF) {
						var second = this.source.charCodeAt(i + 1);
						if (second >= 0xDC00 && second <= 0xDFFF) {
							var first = cp;
							cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
						}
					}
					return cp;
				};
				Scanner.prototype.scanHexEscape = function (prefix) {
					var len = prefix === 'u' ? 4 : 2;
					var code = 0;
					for (var i = 0; i < len; ++i) {
						if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
							code = code * 16 + hexValue(this.source[this.index++]);
						} else {
							return null;
						}
					}
					return String.fromCharCode(code);
				};
				Scanner.prototype.scanUnicodeCodePointEscape = function () {
					var ch = this.source[this.index];
					var code = 0;
					// At least, one hex digit is required.
					if (ch === '}') {
						this.throwUnexpectedToken();
					}
					while (!this.eof()) {
						ch = this.source[this.index++];
						if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
							break;
						}
						code = code * 16 + hexValue(ch);
					}
					if (code > 0x10FFFF || ch !== '}') {
						this.throwUnexpectedToken();
					}
					return character_1.Character.fromCodePoint(code);
				};
				Scanner.prototype.getIdentifier = function () {
					var start = this.index++;
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (ch === 0x5C) {
							// Blackslash (U+005C) marks Unicode escape sequence.
							this.index = start;
							return this.getComplexIdentifier();
						} else if (ch >= 0xD800 && ch < 0xDFFF) {
							// Need to handle surrogate pairs.
							this.index = start;
							return this.getComplexIdentifier();
						}
						if (character_1.Character.isIdentifierPart(ch)) {
							++this.index;
						} else {
							break;
						}
					}
					return this.source.slice(start, this.index);
				};
				Scanner.prototype.getComplexIdentifier = function () {
					var cp = this.codePointAt(this.index);
					var id = character_1.Character.fromCodePoint(cp);
					this.index += id.length;
					// '\u' (U+005C, U+0075) denotes an escaped character.
					var ch;
					if (cp === 0x5C) {
						if (this.source.charCodeAt(this.index) !== 0x75) {
							this.throwUnexpectedToken();
						}
						++this.index;
						if (this.source[this.index] === '{') {
							++this.index;
							ch = this.scanUnicodeCodePointEscape();
						} else {
							ch = this.scanHexEscape('u');
							if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
								this.throwUnexpectedToken();
							}
						}
						id = ch;
					}
					while (!this.eof()) {
						cp = this.codePointAt(this.index);
						if (!character_1.Character.isIdentifierPart(cp)) {
							break;
						}
						ch = character_1.Character.fromCodePoint(cp);
						id += ch;
						this.index += ch.length;
						// '\u' (U+005C, U+0075) denotes an escaped character.
						if (cp === 0x5C) {
							id = id.substr(0, id.length - 1);
							if (this.source.charCodeAt(this.index) !== 0x75) {
								this.throwUnexpectedToken();
							}
							++this.index;
							if (this.source[this.index] === '{') {
								++this.index;
								ch = this.scanUnicodeCodePointEscape();
							} else {
								ch = this.scanHexEscape('u');
								if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
									this.throwUnexpectedToken();
								}
							}
							id += ch;
						}
					}
					return id;
				};
				Scanner.prototype.octalToDecimal = function (ch) {
					// \0 is not octal escape sequence
					var octal = ch !== '0';
					var code = octalValue(ch);
					if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
						octal = true;
						code = code * 8 + octalValue(this.source[this.index++]);
						// 3 digits are only allowed when string starts
						// with 0, 1, 2, 3
						if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							code = code * 8 + octalValue(this.source[this.index++]);
						}
					}
					return {
						code: code,
						octal: octal
					};
				};
				// https://tc39.github.io/ecma262/#sec-names-and-keywords
				Scanner.prototype.scanIdentifier = function () {
					var type;
					var start = this.index;
					// Backslash (U+005C) starts an escaped character.
					var id = this.source.charCodeAt(start) === 0x5C ? this.getComplexIdentifier() : this.getIdentifier();
					// There is no keyword or literal with only one character.
					// Thus, it must be an identifier.
					if (id.length === 1) {
						type = 3 /* Identifier */;
					} else if (this.isKeyword(id)) {
						type = 4 /* Keyword */;
					} else if (id === 'null') {
						type = 5 /* NullLiteral */;
					} else if (id === 'true' || id === 'false') {
						type = 1 /* BooleanLiteral */;
					} else {
						type = 3 /* Identifier */;
					}
					if (type !== 3 /* Identifier */ && start + id.length !== this.index) {
						var restore = this.index;
						this.index = start;
						this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
						this.index = restore;
					}
					return {
						type: type,
						value: id,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-punctuators
				Scanner.prototype.scanPunctuator = function () {
					var start = this.index;
					// Check for most common single-character punctuators.
					var str = this.source[this.index];
					switch (str) {
						case '(':
						case '{':
							if (str === '{') {
								this.curlyStack.push('{');
							}
							++this.index;
							break;
						case '.':
							++this.index;
							if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
								// Spread operator: ...
								this.index += 2;
								str = '...';
							}
							break;
						case '}':
							++this.index;
							this.curlyStack.pop();
							break;
						case ')':
						case ';':
						case ',':
						case '[':
						case ']':
						case ':':
						case '?':
						case '~':
							++this.index;
							break;
						default:
							// 4-character punctuator.
							str = this.source.substr(this.index, 4);
							if (str === '>>>=') {
								this.index += 4;
							} else {
								// 3-character punctuators.
								str = str.substr(0, 3);
								if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=' || str === '**=') {
									this.index += 3;
								} else {
									// 2-character punctuators.
									str = str.substr(0, 2);
									if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>' || str === '**') {
										this.index += 2;
									} else {
										// 1-character punctuators.
										str = this.source[this.index];
										if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
											++this.index;
										}
									}
								}
							}
					}
					if (this.index === start) {
						this.throwUnexpectedToken();
					}
					return {
						type: 7 /* Punctuator */
						, value: str,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-numeric-literals
				Scanner.prototype.scanHexLiteral = function (start) {
					var num = '';
					while (!this.eof()) {
						if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
							break;
						}
						num += this.source[this.index++];
					}
					if (num.length === 0) {
						this.throwUnexpectedToken();
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt('0x' + num, 16),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.scanBinaryLiteral = function (start) {
					var num = '';
					var ch;
					while (!this.eof()) {
						ch = this.source[this.index];
						if (ch !== '0' && ch !== '1') {
							break;
						}
						num += this.source[this.index++];
					}
					if (num.length === 0) {
						// only 0b or 0B
						this.throwUnexpectedToken();
					}
					if (!this.eof()) {
						ch = this.source.charCodeAt(this.index);
						/* istanbul ignore else */
						if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
							this.throwUnexpectedToken();
						}
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt(num, 2),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.scanOctalLiteral = function (prefix, start) {
					var num = '';
					var octal = false;
					if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
						octal = true;
						num = '0' + this.source[this.index++];
					} else {
						++this.index;
					}
					while (!this.eof()) {
						if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							break;
						}
						num += this.source[this.index++];
					}
					if (!octal && num.length === 0) {
						// only 0o or 0O
						this.throwUnexpectedToken();
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt(num, 8),
						octal: octal,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.isImplicitOctalLiteral = function () {
					// Implicit octal, unless there is a non-octal digit.
					// (Annex B.1.1 on Numeric Literals)
					for (var i = this.index + 1; i < this.length; ++i) {
						var ch = this.source[i];
						if (ch === '8' || ch === '9') {
							return false;
						}
						if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
							return true;
						}
					}
					return true;
				};
				Scanner.prototype.scanNumericLiteral = function () {
					var start = this.index;
					var ch = this.source[start];
					assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
					var num = '';
					if (ch !== '.') {
						num = this.source[this.index++];
						ch = this.source[this.index];
						// Hex number starts with '0x'.
						// Octal number starts with '0'.
						// Octal number in ES6 starts with '0o'.
						// Binary number in ES6 starts with '0b'.
						if (num === '0') {
							if (ch === 'x' || ch === 'X') {
								++this.index;
								return this.scanHexLiteral(start);
							}
							if (ch === 'b' || ch === 'B') {
								++this.index;
								return this.scanBinaryLiteral(start);
							}
							if (ch === 'o' || ch === 'O') {
								return this.scanOctalLiteral(ch, start);
							}
							if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
								if (this.isImplicitOctalLiteral()) {
									return this.scanOctalLiteral(ch, start);
								}
							}
						}
						while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							num += this.source[this.index++];
						}
						ch = this.source[this.index];
					}
					if (ch === '.') {
						num += this.source[this.index++];
						while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							num += this.source[this.index++];
						}
						ch = this.source[this.index];
					}
					if (ch === 'e' || ch === 'E') {
						num += this.source[this.index++];
						ch = this.source[this.index];
						if (ch === '+' || ch === '-') {
							num += this.source[this.index++];
						}
						if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
								num += this.source[this.index++];
							}
						} else {
							this.throwUnexpectedToken();
						}
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseFloat(num),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-string-literals
				Scanner.prototype.scanStringLiteral = function () {
					var start = this.index;
					var quote = this.source[start];
					assert_1.assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
					++this.index;
					var octal = false;
					var str = '';
					while (!this.eof()) {
						var ch = this.source[this.index++];
						if (ch === quote) {
							quote = '';
							break;
						} else if (ch === '\\') {
							ch = this.source[this.index++];
							if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								switch (ch) {
									case 'u':
										if (this.source[this.index] === '{') {
											++this.index;
											str += this.scanUnicodeCodePointEscape();
										} else {
											var unescaped_1 = this.scanHexEscape(ch);
											if (unescaped_1 === null) {
												this.throwUnexpectedToken();
											}
											str += unescaped_1;
										}
										break;
									case 'x':
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) {
											this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										}
										str += unescaped;
										break;
									case 'n':
										str += '\n';
										break;
									case 'r':
										str += '\r';
										break;
									case 't':
										str += '\t';
										break;
									case 'b':
										str += '\b';
										break;
									case 'f':
										str += '\f';
										break;
									case 'v':
										str += '\x0B';
										break;
									case '8':
									case '9':
										str += ch;
										this.tolerateUnexpectedToken();
										break;
									default:
										if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											var octToDec = this.octalToDecimal(ch);
											octal = octToDec.octal || octal;
											str += String.fromCharCode(octToDec.code);
										} else {
											str += ch;
										}
										break;
								}
							} else {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
							}
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							break;
						} else {
							str += ch;
						}
					}
					if (quote !== '') {
						this.index = start;
						this.throwUnexpectedToken();
					}
					return {
						type: 8 /* StringLiteral */
						, value: str,
						octal: octal,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
				Scanner.prototype.scanTemplate = function () {
					var cooked = '';
					var terminated = false;
					var start = this.index;
					var head = this.source[start] === '`';
					var tail = false;
					var rawOffset = 2;
					++this.index;
					while (!this.eof()) {
						var ch = this.source[this.index++];
						if (ch === '`') {
							rawOffset = 1;
							tail = true;
							terminated = true;
							break;
						} else if (ch === '$') {
							if (this.source[this.index] === '{') {
								this.curlyStack.push('${');
								++this.index;
								terminated = true;
								break;
							}
							cooked += ch;
						} else if (ch === '\\') {
							ch = this.source[this.index++];
							if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								switch (ch) {
									case 'n':
										cooked += '\n';
										break;
									case 'r':
										cooked += '\r';
										break;
									case 't':
										cooked += '\t';
										break;
									case 'u':
										if (this.source[this.index] === '{') {
											++this.index;
											cooked += this.scanUnicodeCodePointEscape();
										} else {
											var restore = this.index;
											var unescaped_2 = this.scanHexEscape(ch);
											if (unescaped_2 !== null) {
												cooked += unescaped_2;
											} else {
												this.index = restore;
												cooked += ch;
											}
										}
										break;
									case 'x':
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) {
											this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										}
										cooked += unescaped;
										break;
									case 'b':
										cooked += '\b';
										break;
									case 'f':
										cooked += '\f';
										break;
									case 'v':
										cooked += '\v';
										break;
									default:
										if (ch === '0') {
											if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
												// Illegal: \01 \02 and so on
												this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
											}
											cooked += '\0';
										} else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											// Illegal: \1 \2
											this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
										} else {
											cooked += ch;
										}
										break;
								}
							} else {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
							}
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							++this.lineNumber;
							if (ch === '\r' && this.source[this.index] === '\n') {
								++this.index;
							}
							this.lineStart = this.index;
							cooked += '\n';
						} else {
							cooked += ch;
						}
					}
					if (!terminated) {
						this.throwUnexpectedToken();
					}
					if (!head) {
						this.curlyStack.pop();
					}
					return {
						type: 10 /* Template */
						, value: this.source.slice(start + 1, this.index - rawOffset),
						cooked: cooked,
						head: head,
						tail: tail,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
				Scanner.prototype.testRegExp = function (pattern, flags) {
					// The BMP character to use as a replacement for astral symbols when
					// translating an ES6 "u"-flagged pattern to an ES5-compatible
					// approximation.
					// Note: replacing with '\uFFFF' enables false positives in unlikely
					// scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
					// pattern that would not be detected by this substitution.
					var astralSubstitute = '\uFFFF';
					var tmp = pattern;
					var self = this;
					if (flags.indexOf('u') >= 0) {
						tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
							var codePoint = parseInt($1 || $2, 16);
							if (codePoint > 0x10FFFF) {
								self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
							}
							if (codePoint <= 0xFFFF) {
								return String.fromCharCode(codePoint);
							}
							return astralSubstitute;
						}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
					}
					// First, detect invalid regular expressions.
					try {
						RegExp(tmp);
					} catch (e) {
						this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
					}
					// Return a regular expression object for this pattern-flag pair, or
					// `null` in case the current environment doesn't support the flags it
					// uses.
					try {
						return new RegExp(pattern, flags);
					} catch (exception) {
						/* istanbul ignore next */
						return null;
					}
				};
				Scanner.prototype.scanRegExpBody = function () {
					var ch = this.source[this.index];
					assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
					var str = this.source[this.index++];
					var classMarker = false;
					var terminated = false;
					while (!this.eof()) {
						ch = this.source[this.index++];
						str += ch;
						if (ch === '\\') {
							ch = this.source[this.index++];
							// https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
							if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
							}
							str += ch;
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
						} else if (classMarker) {
							if (ch === ']') {
								classMarker = false;
							}
						} else {
							if (ch === '/') {
								terminated = true;
								break;
							} else if (ch === '[') {
								classMarker = true;
							}
						}
					}
					if (!terminated) {
						this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
					}
					// Exclude leading and trailing slash.
					return str.substr(1, str.length - 2);
				};
				Scanner.prototype.scanRegExpFlags = function () {
					var str = '';
					var flags = '';
					while (!this.eof()) {
						var ch = this.source[this.index];
						if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
							break;
						}
						++this.index;
						if (ch === '\\' && !this.eof()) {
							ch = this.source[this.index];
							if (ch === 'u') {
								++this.index;
								var restore = this.index;
								var char = this.scanHexEscape('u');
								if (char !== null) {
									flags += char;
									for (str += '\\u'; restore < this.index; ++restore) {
										str += this.source[restore];
									}
								} else {
									this.index = restore;
									flags += 'u';
									str += '\\u';
								}
								this.tolerateUnexpectedToken();
							} else {
								str += '\\';
								this.tolerateUnexpectedToken();
							}
						} else {
							flags += ch;
							str += ch;
						}
					}
					return flags;
				};
				Scanner.prototype.scanRegExp = function () {
					var start = this.index;
					var pattern = this.scanRegExpBody();
					var flags = this.scanRegExpFlags();
					var value = this.testRegExp(pattern, flags);
					return {
						type: 9 /* RegularExpression */
						, value: '',
						pattern: pattern,
						flags: flags,
						regex: value,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.lex = function () {
					if (this.eof()) {
						return {
							type: 2 /* EOF */
							, value: '',
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: this.index,
							end: this.index
						};
					}
					var cp = this.source.charCodeAt(this.index);
					if (character_1.Character.isIdentifierStart(cp)) {
						return this.scanIdentifier();
					}
					// Very common: ( and ) and ;
					if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
						return this.scanPunctuator();
					}
					// String literal starts with single quote (U+0027) or double quote (U+0022).
					if (cp === 0x27 || cp === 0x22) {
						return this.scanStringLiteral();
					}
					// Dot (.) U+002E can also start a floating-point number, hence the need
					// to check the next character.
					if (cp === 0x2E) {
						if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
							return this.scanNumericLiteral();
						}
						return this.scanPunctuator();
					}
					if (character_1.Character.isDecimalDigit(cp)) {
						return this.scanNumericLiteral();
					}
					// Template literals start with ` (U+0060) for template head
					// or } (U+007D) for template middle or template tail.
					if (cp === 0x60 || cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${') {
						return this.scanTemplate();
					}
					// Possible identifier start in a surrogate pair.
					if (cp >= 0xD800 && cp < 0xDFFF) {
						if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
							return this.scanIdentifier();
						}
					}
					return this.scanPunctuator();
				};
				return Scanner;
			}();
			exports.Scanner = Scanner;

			/***/
		},
		/* 13 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.TokenName = {};
			exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
			exports.TokenName[2 /* EOF */] = '<end>';
			exports.TokenName[3 /* Identifier */] = 'Identifier';
			exports.TokenName[4 /* Keyword */] = 'Keyword';
			exports.TokenName[5 /* NullLiteral */] = 'Null';
			exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
			exports.TokenName[7 /* Punctuator */] = 'Punctuator';
			exports.TokenName[8 /* StringLiteral */] = 'String';
			exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
			exports.TokenName[10 /* Template */] = 'Template';

			/***/
		},
		/* 14 */
		/***/function (module, exports) {

			"use strict";
			// Generated by generate-xhtml-entities.js. DO NOT MODIFY!

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.XHTMLEntities = {
				quot: '\u0022',
				amp: '\u0026',
				apos: '\u0027',
				gt: '\u003E',
				nbsp: '\u00A0',
				iexcl: '\u00A1',
				cent: '\u00A2',
				pound: '\u00A3',
				curren: '\u00A4',
				yen: '\u00A5',
				brvbar: '\u00A6',
				sect: '\u00A7',
				uml: '\u00A8',
				copy: '\u00A9',
				ordf: '\u00AA',
				laquo: '\u00AB',
				not: '\u00AC',
				shy: '\u00AD',
				reg: '\u00AE',
				macr: '\u00AF',
				deg: '\u00B0',
				plusmn: '\u00B1',
				sup2: '\u00B2',
				sup3: '\u00B3',
				acute: '\u00B4',
				micro: '\u00B5',
				para: '\u00B6',
				middot: '\u00B7',
				cedil: '\u00B8',
				sup1: '\u00B9',
				ordm: '\u00BA',
				raquo: '\u00BB',
				frac14: '\u00BC',
				frac12: '\u00BD',
				frac34: '\u00BE',
				iquest: '\u00BF',
				Agrave: '\u00C0',
				Aacute: '\u00C1',
				Acirc: '\u00C2',
				Atilde: '\u00C3',
				Auml: '\u00C4',
				Aring: '\u00C5',
				AElig: '\u00C6',
				Ccedil: '\u00C7',
				Egrave: '\u00C8',
				Eacute: '\u00C9',
				Ecirc: '\u00CA',
				Euml: '\u00CB',
				Igrave: '\u00CC',
				Iacute: '\u00CD',
				Icirc: '\u00CE',
				Iuml: '\u00CF',
				ETH: '\u00D0',
				Ntilde: '\u00D1',
				Ograve: '\u00D2',
				Oacute: '\u00D3',
				Ocirc: '\u00D4',
				Otilde: '\u00D5',
				Ouml: '\u00D6',
				times: '\u00D7',
				Oslash: '\u00D8',
				Ugrave: '\u00D9',
				Uacute: '\u00DA',
				Ucirc: '\u00DB',
				Uuml: '\u00DC',
				Yacute: '\u00DD',
				THORN: '\u00DE',
				szlig: '\u00DF',
				agrave: '\u00E0',
				aacute: '\u00E1',
				acirc: '\u00E2',
				atilde: '\u00E3',
				auml: '\u00E4',
				aring: '\u00E5',
				aelig: '\u00E6',
				ccedil: '\u00E7',
				egrave: '\u00E8',
				eacute: '\u00E9',
				ecirc: '\u00EA',
				euml: '\u00EB',
				igrave: '\u00EC',
				iacute: '\u00ED',
				icirc: '\u00EE',
				iuml: '\u00EF',
				eth: '\u00F0',
				ntilde: '\u00F1',
				ograve: '\u00F2',
				oacute: '\u00F3',
				ocirc: '\u00F4',
				otilde: '\u00F5',
				ouml: '\u00F6',
				divide: '\u00F7',
				oslash: '\u00F8',
				ugrave: '\u00F9',
				uacute: '\u00FA',
				ucirc: '\u00FB',
				uuml: '\u00FC',
				yacute: '\u00FD',
				thorn: '\u00FE',
				yuml: '\u00FF',
				OElig: '\u0152',
				oelig: '\u0153',
				Scaron: '\u0160',
				scaron: '\u0161',
				Yuml: '\u0178',
				fnof: '\u0192',
				circ: '\u02C6',
				tilde: '\u02DC',
				Alpha: '\u0391',
				Beta: '\u0392',
				Gamma: '\u0393',
				Delta: '\u0394',
				Epsilon: '\u0395',
				Zeta: '\u0396',
				Eta: '\u0397',
				Theta: '\u0398',
				Iota: '\u0399',
				Kappa: '\u039A',
				Lambda: '\u039B',
				Mu: '\u039C',
				Nu: '\u039D',
				Xi: '\u039E',
				Omicron: '\u039F',
				Pi: '\u03A0',
				Rho: '\u03A1',
				Sigma: '\u03A3',
				Tau: '\u03A4',
				Upsilon: '\u03A5',
				Phi: '\u03A6',
				Chi: '\u03A7',
				Psi: '\u03A8',
				Omega: '\u03A9',
				alpha: '\u03B1',
				beta: '\u03B2',
				gamma: '\u03B3',
				delta: '\u03B4',
				epsilon: '\u03B5',
				zeta: '\u03B6',
				eta: '\u03B7',
				theta: '\u03B8',
				iota: '\u03B9',
				kappa: '\u03BA',
				lambda: '\u03BB',
				mu: '\u03BC',
				nu: '\u03BD',
				xi: '\u03BE',
				omicron: '\u03BF',
				pi: '\u03C0',
				rho: '\u03C1',
				sigmaf: '\u03C2',
				sigma: '\u03C3',
				tau: '\u03C4',
				upsilon: '\u03C5',
				phi: '\u03C6',
				chi: '\u03C7',
				psi: '\u03C8',
				omega: '\u03C9',
				thetasym: '\u03D1',
				upsih: '\u03D2',
				piv: '\u03D6',
				ensp: '\u2002',
				emsp: '\u2003',
				thinsp: '\u2009',
				zwnj: '\u200C',
				zwj: '\u200D',
				lrm: '\u200E',
				rlm: '\u200F',
				ndash: '\u2013',
				mdash: '\u2014',
				lsquo: '\u2018',
				rsquo: '\u2019',
				sbquo: '\u201A',
				ldquo: '\u201C',
				rdquo: '\u201D',
				bdquo: '\u201E',
				dagger: '\u2020',
				Dagger: '\u2021',
				bull: '\u2022',
				hellip: '\u2026',
				permil: '\u2030',
				prime: '\u2032',
				Prime: '\u2033',
				lsaquo: '\u2039',
				rsaquo: '\u203A',
				oline: '\u203E',
				frasl: '\u2044',
				euro: '\u20AC',
				image: '\u2111',
				weierp: '\u2118',
				real: '\u211C',
				trade: '\u2122',
				alefsym: '\u2135',
				larr: '\u2190',
				uarr: '\u2191',
				rarr: '\u2192',
				darr: '\u2193',
				harr: '\u2194',
				crarr: '\u21B5',
				lArr: '\u21D0',
				uArr: '\u21D1',
				rArr: '\u21D2',
				dArr: '\u21D3',
				hArr: '\u21D4',
				forall: '\u2200',
				part: '\u2202',
				exist: '\u2203',
				empty: '\u2205',
				nabla: '\u2207',
				isin: '\u2208',
				notin: '\u2209',
				ni: '\u220B',
				prod: '\u220F',
				sum: '\u2211',
				minus: '\u2212',
				lowast: '\u2217',
				radic: '\u221A',
				prop: '\u221D',
				infin: '\u221E',
				ang: '\u2220',
				and: '\u2227',
				or: '\u2228',
				cap: '\u2229',
				cup: '\u222A',
				int: '\u222B',
				there4: '\u2234',
				sim: '\u223C',
				cong: '\u2245',
				asymp: '\u2248',
				ne: '\u2260',
				equiv: '\u2261',
				le: '\u2264',
				ge: '\u2265',
				sub: '\u2282',
				sup: '\u2283',
				nsub: '\u2284',
				sube: '\u2286',
				supe: '\u2287',
				oplus: '\u2295',
				otimes: '\u2297',
				perp: '\u22A5',
				sdot: '\u22C5',
				lceil: '\u2308',
				rceil: '\u2309',
				lfloor: '\u230A',
				rfloor: '\u230B',
				loz: '\u25CA',
				spades: '\u2660',
				clubs: '\u2663',
				hearts: '\u2665',
				diams: '\u2666',
				lang: '\u27E8',
				rang: '\u27E9'
			};

			/***/
		},
		/* 15 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var error_handler_1 = __webpack_require__(10);
			var scanner_1 = __webpack_require__(12);
			var token_1 = __webpack_require__(13);
			var Reader = function () {
				function Reader() {
					this.values = [];
					this.curly = this.paren = -1;
				}
				// A function following one of those tokens is an expression.
				Reader.prototype.beforeFunctionExpression = function (t) {
					return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',
					// assignment operators
					'=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',
					// binary/unary operators
					'+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
				};
				// Determine if forward slash (/) is an operator or part of a regular expression
				// https://github.com/mozilla/sweet.js/wiki/design
				Reader.prototype.isRegexStart = function () {
					var previous = this.values[this.values.length - 1];
					var regex = previous !== null;
					switch (previous) {
						case 'this':
						case ']':
							regex = false;
							break;
						case ')':
							var keyword = this.values[this.paren - 1];
							regex = keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with';
							break;
						case '}':
							// Dividing a function by anything makes little sense,
							// but we have to check for that.
							regex = false;
							if (this.values[this.curly - 3] === 'function') {
								// Anonymous function, e.g. function(){} /42
								var check = this.values[this.curly - 4];
								regex = check ? !this.beforeFunctionExpression(check) : false;
							} else if (this.values[this.curly - 4] === 'function') {
								// Named function, e.g. function f(){} /42/
								var check = this.values[this.curly - 5];
								regex = check ? !this.beforeFunctionExpression(check) : true;
							}
							break;
						default:
							break;
					}
					return regex;
				};
				Reader.prototype.push = function (token) {
					if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
							if (token.value === '{') {
								this.curly = this.values.length;
							} else if (token.value === '(') {
								this.paren = this.values.length;
							}
							this.values.push(token.value);
						} else {
						this.values.push(null);
					}
				};
				return Reader;
			}();
			var Tokenizer = function () {
				function Tokenizer(code, config) {
					this.errorHandler = new error_handler_1.ErrorHandler();
					this.errorHandler.tolerant = config ? typeof config.tolerant === 'boolean' && config.tolerant : false;
					this.scanner = new scanner_1.Scanner(code, this.errorHandler);
					this.scanner.trackComment = config ? typeof config.comment === 'boolean' && config.comment : false;
					this.trackRange = config ? typeof config.range === 'boolean' && config.range : false;
					this.trackLoc = config ? typeof config.loc === 'boolean' && config.loc : false;
					this.buffer = [];
					this.reader = new Reader();
				}
				Tokenizer.prototype.errors = function () {
					return this.errorHandler.errors;
				};
				Tokenizer.prototype.getNextToken = function () {
					if (this.buffer.length === 0) {
						var comments = this.scanner.scanComments();
						if (this.scanner.trackComment) {
							for (var i = 0; i < comments.length; ++i) {
								var e = comments[i];
								var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
								var comment = {
									type: e.multiLine ? 'BlockComment' : 'LineComment',
									value: value
								};
								if (this.trackRange) {
									comment.range = e.range;
								}
								if (this.trackLoc) {
									comment.loc = e.loc;
								}
								this.buffer.push(comment);
							}
						}
						if (!this.scanner.eof()) {
							var loc = void 0;
							if (this.trackLoc) {
								loc = {
									start: {
										line: this.scanner.lineNumber,
										column: this.scanner.index - this.scanner.lineStart
									},
									end: {}
								};
							}
							var startRegex = this.scanner.source[this.scanner.index] === '/' && this.reader.isRegexStart();
							var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
							this.reader.push(token);
							var entry = {
								type: token_1.TokenName[token.type],
								value: this.scanner.source.slice(token.start, token.end)
							};
							if (this.trackRange) {
								entry.range = [token.start, token.end];
							}
							if (this.trackLoc) {
								loc.end = {
									line: this.scanner.lineNumber,
									column: this.scanner.index - this.scanner.lineStart
								};
								entry.loc = loc;
							}
							if (token.type === 9 /* RegularExpression */) {
									var pattern = token.pattern;
									var flags = token.flags;
									entry.regex = { pattern: pattern, flags: flags };
								}
							this.buffer.push(entry);
						}
					}
					return this.buffer.shift();
				};
				return Tokenizer;
			}();
			exports.Tokenizer = Tokenizer;

			/***/
		}
		/******/])
	);
});
;

/***/ }),

/***/ "4KuB":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("sa2S");

/***/ }),

/***/ "4Z/U":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IteratorPrototype = __webpack_require__("j68S").IteratorPrototype;
var create = __webpack_require__("M3NV");
var createPropertyDescriptor = __webpack_require__("IFQ2");
var setToStringTag = __webpack_require__("xyxa");
var Iterators = __webpack_require__("Gzjq");

var returnThis = function () {
  return this;
};

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};

/***/ }),

/***/ "4e7A":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Open simple dialogs on top of an editor. Relies on dialog.css.

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  function dialogDiv(cm, template, bottom) {
    var wrap = cm.getWrapperElement();
    var dialog;
    dialog = wrap.appendChild(document.createElement("div"));
    if (bottom) dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";else dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";

    if (typeof template == "string") {
      dialog.innerHTML = template;
    } else {
      // Assuming it's a detached DOM element.
      dialog.appendChild(template);
    }
    CodeMirror.addClass(wrap, 'dialog-opened');
    return dialog;
  }

  function closeNotification(cm, newVal) {
    if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();
    cm.state.currentNotificationClose = newVal;
  }

  CodeMirror.defineExtension("openDialog", function (template, callback, options) {
    if (!options) options = {};

    closeNotification(this, null);

    var dialog = dialogDiv(this, template, options.bottom);
    var closed = false,
        me = this;
    function close(newVal) {
      if (typeof newVal == 'string') {
        inp.value = newVal;
      } else {
        if (closed) return;
        closed = true;
        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
        dialog.parentNode.removeChild(dialog);
        me.focus();

        if (options.onClose) options.onClose(dialog);
      }
    }

    var inp = dialog.getElementsByTagName("input")[0],
        button;
    if (inp) {
      inp.focus();

      if (options.value) {
        inp.value = options.value;
        if (options.selectValueOnOpen !== false) {
          inp.select();
        }
      }

      if (options.onInput) CodeMirror.on(inp, "input", function (e) {
        options.onInput(e, inp.value, close);
      });
      if (options.onKeyUp) CodeMirror.on(inp, "keyup", function (e) {
        options.onKeyUp(e, inp.value, close);
      });

      CodeMirror.on(inp, "keydown", function (e) {
        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {
          return;
        }
        if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {
          inp.blur();
          CodeMirror.e_stop(e);
          close();
        }
        if (e.keyCode == 13) callback(inp.value, e);
      });

      if (options.closeOnBlur !== false) CodeMirror.on(inp, "blur", close);
    } else if (button = dialog.getElementsByTagName("button")[0]) {
      CodeMirror.on(button, "click", function () {
        close();
        me.focus();
      });

      if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);

      button.focus();
    }
    return close;
  });

  CodeMirror.defineExtension("openConfirm", function (template, callbacks, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var buttons = dialog.getElementsByTagName("button");
    var closed = false,
        me = this,
        blurring = 1;
    function close() {
      if (closed) return;
      closed = true;
      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
      dialog.parentNode.removeChild(dialog);
      me.focus();
    }
    buttons[0].focus();
    for (var i = 0; i < buttons.length; ++i) {
      var b = buttons[i];
      (function (callback) {
        CodeMirror.on(b, "click", function (e) {
          CodeMirror.e_preventDefault(e);
          close();
          if (callback) callback(me);
        });
      })(callbacks[i]);
      CodeMirror.on(b, "blur", function () {
        --blurring;
        setTimeout(function () {
          if (blurring <= 0) close();
        }, 200);
      });
      CodeMirror.on(b, "focus", function () {
        ++blurring;
      });
    }
  });

  /*
   * openNotification
   * Opens a notification, that can be closed with an optional timer
   * (default 5000ms timer) and always closes on click.
   *
   * If a notification is opened while another is opened, it will close the
   * currently opened one and open the new one immediately.
   */
  CodeMirror.defineExtension("openNotification", function (template, options) {
    closeNotification(this, close);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var closed = false,
        doneTimer;
    var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;

    function close() {
      if (closed) return;
      closed = true;
      clearTimeout(doneTimer);
      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
      dialog.parentNode.removeChild(dialog);
    }

    CodeMirror.on(dialog, 'click', function (e) {
      CodeMirror.e_preventDefault(e);
      close();
    });

    if (duration) doneTimer = setTimeout(close, duration);

    return close;
  });
});

/***/ }),

/***/ "5++D":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __webpack_require__("dACh");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("jx4H");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("VOrx");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("ZKjc");

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _ThemeProvider = __webpack_require__("ZQr7");

var _ThemeProvider2 = _interopRequireDefault(_ThemeProvider);

var _createStyles = __webpack_require__("uqKE");

var _createStyles2 = _interopRequireDefault(_createStyles);

var _getHeaders2 = __webpack_require__("gYye");

var _getHeaders3 = _interopRequireDefault(_getHeaders2);

var _DataContainer = __webpack_require__("2ANV");

var _DataContainer2 = _interopRequireDefault(_DataContainer);

var _HeaderContainer = __webpack_require__("fz1y");

var _HeaderContainer2 = _interopRequireDefault(_HeaderContainer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var TableInspector = function (_Component) {
  (0, _inherits3.default)(TableInspector, _Component);

  function TableInspector(props) {
    (0, _classCallCheck3.default)(this, TableInspector);

    var _this = (0, _possibleConstructorReturn3.default)(this, (TableInspector.__proto__ || Object.getPrototypeOf(TableInspector)).call(this, props));

    _this.state = {
      sorted: false, // has user ever clicked the <th> tag to sort?
      sortIndexColumn: false, // is index column sorted?
      sortColumn: undefined, // which column is sorted?
      sortAscending: false // is sorting ascending or descending?
    };
    return _this;
  }

  (0, _createClass3.default)(TableInspector, [{
    key: 'handleIndexTHClick',
    value: function handleIndexTHClick() {
      this.setState(function (_ref) {
        var sortIndexColumn = _ref.sortIndexColumn,
            sortAscending = _ref.sortAscending;
        return {
          sorted: true,
          sortIndexColumn: true,
          sortColumn: undefined,
          // when changed to a new column, default to asending
          sortAscending: sortIndexColumn ? !sortAscending : true
        };
      });
    }
  }, {
    key: 'handleTHClick',
    value: function handleTHClick(col) {
      this.setState(function (_ref2) {
        var sortColumn = _ref2.sortColumn,
            sortAscending = _ref2.sortAscending;
        return {
          sorted: true,
          sortIndexColumn: false,
          // update sort column
          sortColumn: col,
          // when changed to a new column, default to asending
          sortAscending: col === sortColumn ? !sortAscending : true
        };
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var data = this.props.data;
      var columns = this.props.columns;

      var theme = this.props.theme;

      var styles = (0, _createStyles2.default)('TableInspector', theme);

      if ((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) !== 'object' || data === null) {
        return _react2.default.createElement('div', null);
      }

      var _getHeaders = (0, _getHeaders3.default)(data),
          rowHeaders = _getHeaders.rowHeaders,
          colHeaders = _getHeaders.colHeaders;

      // columns to be displayed are specified
      // NOTE: there's some space for optimization here


      if (columns !== undefined) {
        colHeaders = columns;
      }

      var rowsData = rowHeaders.map(function (rowHeader) {
        return data[rowHeader];
      });

      var sortIndexColumn = this.state.sortIndexColumn,
          sortColumn = this.state.sortColumn,
          sortAscending = this.state.sortAscending;

      var columnDataWithRowIndexes = void 0; /* row indexes are [0..nRows-1] */
      // TODO: refactor
      if (sortColumn !== undefined) {
        // the column to be sorted (rowsData, column) => [[columnData, rowIndex]]
        columnDataWithRowIndexes = rowsData.map(function (rowData, index) {
          // normalize rowData
          if ((typeof rowData === 'undefined' ? 'undefined' : (0, _typeof3.default)(rowData)) === 'object' && rowData !== null /*&& rowData.hasOwnProperty(sortColumn)*/
          ) {
              var columnData = rowData[sortColumn];
              return [columnData, index];
            }
          return [undefined, index];
        });
      } else {
        if (sortIndexColumn) {
          columnDataWithRowIndexes = rowHeaders.map(function (rowData, index) {
            var columnData = rowHeaders[index];
            return [columnData, index];
          });
        }
      }
      if (columnDataWithRowIndexes !== undefined) {
        // apply a mapper before sorting (because we need to access inside a container)
        var comparator = function comparator(mapper, ascending) {
          return function (a, b) {
            var v1 = mapper(a); // the datum
            var v2 = mapper(b);
            var type1 = typeof v1 === 'undefined' ? 'undefined' : (0, _typeof3.default)(v1);
            var type2 = typeof v2 === 'undefined' ? 'undefined' : (0, _typeof3.default)(v2);
            // use '<' operator to compare same type of values or compare type precedence order #
            var lt = function lt(v1, v2) {
              if (v1 < v2) {
                return -1;
              } else if (v1 > v2) {
                return 1;
              } else {
                return 0;
              }
            };
            var result = void 0;
            if (type1 === type2) {
              result = lt(v1, v2);
            } else {
              // order of different types
              var order = {
                string: 0,
                number: 1,
                object: 2,
                symbol: 3,
                boolean: 4,
                undefined: 5,
                function: 6
              };
              result = lt(order[type1], order[type2]);
            }
            // reverse result if descending
            if (!ascending) result = -result;
            return result;
          };
        };
        var sortedRowIndexes = columnDataWithRowIndexes.sort(comparator(function (item) {
          return item[0];
        }, sortAscending)).map(function (item) {
          return item[1];
        }); // sorted row indexes
        rowHeaders = sortedRowIndexes.map(function (i) {
          return rowHeaders[i];
        });
        rowsData = sortedRowIndexes.map(function (i) {
          return rowsData[i];
        });
      }

      return _react2.default.createElement(_ThemeProvider2.default, { theme: this.props.theme }, _react2.default.createElement('div', { style: styles.base }, _react2.default.createElement(_HeaderContainer2.default, {
        columns: colHeaders
        /* for sorting */
        , sorted: this.state.sorted,
        sortIndexColumn: this.state.sortIndexColumn,
        sortColumn: this.state.sortColumn,
        sortAscending: this.state.sortAscending,
        onTHClick: this.handleTHClick.bind(this),
        onIndexTHClick: this.handleIndexTHClick.bind(this)
      }), _react2.default.createElement(_DataContainer2.default, { rows: rowHeaders, columns: colHeaders, rowsData: rowsData })));
    }
  }]);
  return TableInspector;
}(_react.Component); /**
                      * Specs:
                      * https://developer.chrome.com/devtools/docs/commandline-api#tabledata-columns
                      * https://developer.mozilla.org/en-US/docs/Web/API/Console/table
                      */

exports.default = TableInspector;

TableInspector.propTypes = {
  /**
   * the Javascript object you would like to inspect, either an array or an object
   */
  data: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object]),
  /**
   * An array of the names of the columns you'd like to display in the table
   */
  columns: _propTypes2.default.array
};

TableInspector.defaultProps = {
  data: undefined,
  columns: undefined,
  theme: 'chromeLight'
};

/***/ }),

/***/ "58xA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var tslib_1 = __webpack_require__("vCxL");

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
var CONSTANTS = {
    /**
     * @define {boolean} Whether this is the client Node.js SDK.
     */
    NODE_CLIENT: false,
    /**
     * @define {boolean} Whether this is the Admin Node.js SDK.
     */
    NODE_ADMIN: false,
    /**
     * Firebase SDK Version
     */
    SDK_VERSION: '${JSCORE_VERSION}'
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Throws an error if the provided assertion is falsy
 * @param {*} assertion The assertion to be tested for falsiness
 * @param {!string} message The message to display if the check fails
 */
var assert = function (assertion, message) {
    if (!assertion) {
        throw assertionError(message);
    }
};
/**
 * Returns an Error object suitable for throwing.
 * @param {string} message
 * @return {!Error}
 */
var assertionError = function (message) {
    return new Error('Firebase Database (' + CONSTANTS.SDK_VERSION + ') INTERNAL ASSERT FAILED: ' + message);
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var stringToByteArray = function (str) {
    // TODO(user): Use native implementations if/when available
    var out = [],
        p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
            out[p++] = c;
        } else if (c < 2048) {
            out[p++] = c >> 6 | 192;
            out[p++] = c & 63 | 128;
        } else if ((c & 0xfc00) == 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) == 0xdc00) {
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = c >> 18 | 240;
            out[p++] = c >> 12 & 63 | 128;
            out[p++] = c >> 6 & 63 | 128;
            out[p++] = c & 63 | 128;
        } else {
            out[p++] = c >> 12 | 224;
            out[p++] = c >> 6 & 63 | 128;
            out[p++] = c & 63 | 128;
        }
    }
    return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {Array<number>} bytes Array of numbers representing characters.
 * @return {string} Stringification of the array.
 */
var byteArrayToString = function (bytes) {
    // TODO(user): Use native implementations if/when available
    var out = [],
        pos = 0,
        c = 0;
    while (pos < bytes.length) {
        var c1 = bytes[pos++];
        if (c1 < 128) {
            out[c++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
            var c2 = bytes[pos++];
            out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
            // Surrogate Pair
            var c2 = bytes[pos++];
            var c3 = bytes[pos++];
            var c4 = bytes[pos++];
            var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
        } else {
            var c2 = bytes[pos++];
            var c3 = bytes[pos++];
            out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
    }
    return out.join('');
};
// Static lookup maps, lazily populated by init_()
var base64 = {
    /**
     * Maps bytes to characters.
     * @type {Object}
     * @private
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @type {Object}
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     * @type {string}
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     * @type {string}
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     * @type {string}
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     * @type {boolean}
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param {Array<number>|Uint8Array} input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param {boolean=} opt_webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeByteArray: function (input, opt_webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        var byteToCharMap = opt_webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
            var byte1 = input[i];
            var haveByte2 = i + 1 < input.length;
            var byte2 = haveByte2 ? input[i + 1] : 0;
            var haveByte3 = i + 2 < input.length;
            var byte3 = haveByte3 ? input[i + 2] : 0;
            var outByte1 = byte1 >> 2;
            var outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;
            var outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;
            var outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param {string} input A string to encode.
     * @param {boolean=} opt_webSafe If true, we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeString: function (input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray(input), opt_webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param {string} input to decode.
     * @param {boolean=} opt_webSafe True if we should use the
     *     alternative alphabet.
     * @return {string} string representing the decoded value.
     */
    decodeString: function (input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param {string} input Input to decode.
     * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.
     * @return {!Array<number>} bytes representing the decoded value.
     */
    decodeStringToByteArray: function (input, opt_webSafe) {
        this.init_();
        var charToByteMap = opt_webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length;) {
            var byte1 = charToByteMap[input.charAt(i++)];
            var haveByte2 = i < input.length;
            var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            var haveByte3 = i < input.length;
            var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            var haveByte4 = i < input.length;
            var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw Error();
            }
            var outByte1 = byte1 << 2 | byte2 >> 4;
            output.push(outByte1);
            if (byte3 != 64) {
                var outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;
                output.push(outByte2);
                if (byte4 != 64) {
                    var outByte3 = byte3 << 6 & 0xc0 | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_: function () {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (var i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * URL-safe base64 encoding
 * @param {!string} str
 * @return {!string}
 */
var base64Encode = function (str) {
    var utf8Bytes = stringToByteArray(str);
    return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param {string} str To be decoded
 * @return {?string} Decoded result, if possible
 */
var base64Decode = function (str) {
    try {
        return base64.decodeString(str, true);
    } catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            var dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (var prop in source) {
        if (!source.hasOwnProperty(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
// TODO: Really needed (for JSCompiler type checking)?
function patchProperty(obj, prop, value) {
    obj[prop] = value;
}

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Deferred = /** @class */function () {
    function Deferred() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} callback
     * @return {!function(?(Error), ?=)}
     */
    Deferred.prototype.wrapCallback = function (callback) {
        var _this = this;
        return function (error, value) {
            if (error) {
                _this.reject(error);
            } else {
                _this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                _this.promise.catch(function () {});
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                } else {
                    callback(error, value);
                }
            }
        };
    };
    return Deferred;
}();

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return {string} user agent string
 */
var getUA = function () {
    if (typeof navigator !== 'undefined' && typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    } else {
        return '';
    }
};
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap in the Ripple emulator) nor
 * Cordova `onDeviceReady`, which would normally wait for a callback.
 *
 * @return {boolean} isMobileCordova
 */
var isMobileCordova = function () {
    return typeof window !== 'undefined' && !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
};
/**
 * Detect React Native.
 *
 * @return {boolean} True if ReactNative environment is detected.
 */
var isReactNative = function () {
    return typeof navigator === 'object' && navigator['product'] === 'ReactNative';
};
/**
 * Detect Node.js.
 *
 * @return {boolean} True if Node.js environment is detected.
 */
var isNodeSdk = function () {
    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ERROR_NAME = 'FirebaseError';
// Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
var FirebaseError = /** @class */function (_super) {
    tslib_1.__extends(FirebaseError, _super);
    function FirebaseError(code, message) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.name = ERROR_NAME;
        // Fix For ES5
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, FirebaseError.prototype);
        // Maintains proper stack trace for where our error was thrown.
        // Only available on V8.
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, ErrorFactory.prototype.create);
        }
        return _this;
    }
    return FirebaseError;
}(Error);
var ErrorFactory = /** @class */function () {
    function ErrorFactory(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
    }
    ErrorFactory.prototype.create = function (code, data) {
        if (data === void 0) {
            data = {};
        }
        var fullCode = this.service + "/" + code;
        var template = this.errors[code];
        var message = template ? replaceTemplate(template, data) : 'Error';
        // Service Name: Error message (service/code).
        var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
        var error = new FirebaseError(fullCode, fullMessage);
        // Keys with an underscore at the end of their name are not included in
        // error.data for some reason.
        // TODO: Replace with Object.entries when lib is updated to es2017.
        for (var _i = 0, _a = Object.keys(data); _i < _a.length; _i++) {
            var key = _a[_i];
            if (key.slice(-1) !== '_') {
                if (key in error) {
                    console.warn("Overwriting FirebaseError base field \"" + key + "\" can cause unexpected behavior.");
                }
                error[key] = data[key];
            }
        }
        return error;
    };
    return ErrorFactory;
}();
function replaceTemplate(template, data) {
    return template.replace(PATTERN, function (_, key) {
        var value = data[key];
        return value != null ? value.toString() : "<" + key + "?>";
    });
}
var PATTERN = /\{\$([^}]+)}/g;

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
    return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
    return JSON.stringify(data);
}

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {{header: *, claims: *, data: *, signature: string}}
 */
var decode = function (token) {
    var header = {},
        claims = {},
        data = {},
        signature = '';
    try {
        var parts = token.split('.');
        header = jsonEval(base64Decode(parts[0]) || '');
        claims = jsonEval(base64Decode(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    } catch (e) {}
    return {
        header: header,
        claims: claims,
        data: data,
        signature: signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isValidTimestamp = function (token) {
    var claims = decode(token).claims,
        now = Math.floor(new Date().getTime() / 1000),
        validSince,
        validUntil;
    if (typeof claims === 'object') {
        if (claims.hasOwnProperty('nbf')) {
            validSince = claims['nbf'];
        } else if (claims.hasOwnProperty('iat')) {
            validSince = claims['iat'];
        }
        if (claims.hasOwnProperty('exp')) {
            validUntil = claims['exp'];
        } else {
            // token will expire after 24h by default
            validUntil = validSince + 86400;
        }
    }
    return now && validSince && validUntil && now >= validSince && now <= validUntil;
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {?number}
 */
var issuedAtTime = function (token) {
    var claims = decode(token).claims;
    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
        return claims['iat'];
    }
    return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isValidFormat = function (token) {
    var decoded = decode(token),
        claims = decoded.claims;
    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isAdmin = function (token) {
    var claims = decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// See http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/
var contains = function (obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var safeGet = function (obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) return obj[key];
    // else return undefined.
};
/**
 * Enumerates the keys/values in an object, excluding keys defined on the prototype.
 *
 * @param {?Object.<K,V>} obj Object to enumerate.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
var forEach = function (obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn(key, obj[key]);
        }
    }
};
/**
 * Copies all the (own) properties from one object to another.
 * @param {!Object} objTo
 * @param {!Object} objFrom
 * @return {!Object} objTo
 */
var extend = function (objTo, objFrom) {
    forEach(objFrom, function (key, value) {
        objTo[key] = value;
    });
    return objTo;
};
/**
 * Returns a clone of the specified object.
 * @param {!Object} obj
 * @return {!Object} cloned obj.
 */
var clone = function (obj) {
    return extend({}, obj);
};
/**
 * Returns true if obj has typeof "object" and is not null.  Unlike goog.isObject(), does not return true
 * for functions.
 *
 * @param obj {*} A potential object.
 * @returns {boolean} True if it's an object.
 */
var isNonNullObject = function (obj) {
    return typeof obj === 'object' && obj !== null;
};
var isEmpty = function (obj) {
    for (var key in obj) {
        return false;
    }
    return true;
};
var getCount = function (obj) {
    var rv = 0;
    for (var key in obj) {
        rv++;
    }
    return rv;
};
var map = function (obj, f, opt_obj) {
    var res = {};
    for (var key in obj) {
        res[key] = f.call(opt_obj, obj[key], key, obj);
    }
    return res;
};
var findKey = function (obj, fn, opt_this) {
    for (var key in obj) {
        if (fn.call(opt_this, obj[key], key, obj)) {
            return key;
        }
    }
    return undefined;
};
var findValue = function (obj, fn, opt_this) {
    var key = findKey(obj, fn, opt_this);
    return key && obj[key];
};
var getAnyKey = function (obj) {
    for (var key in obj) {
        return key;
    }
};
var getValues = function (obj) {
    var res = [];
    var i = 0;
    for (var key in obj) {
        res[i++] = obj[key];
    }
    return res;
};
/**
 * Tests whether every key/value pair in an object pass the test implemented
 * by the provided function
 *
 * @param {?Object.<K,V>} obj Object to test.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
var every = function (obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (!fn(key, obj[key])) {
                return false;
            }
        }
    }
    return true;
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a params
 * object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 *
 * @param {!Object} querystringParams
 * @return {string}
 */
var querystring = function (querystringParams) {
    var params = [];
    forEach(querystringParams, function (key, value) {
        if (Array.isArray(value)) {
            value.forEach(function (arrayVal) {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        } else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    });
    return params.length ? '&' + params.join('&') : '';
};
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object (e.g. {arg: 'val', arg2: 'val2'})
 *
 * @param {string} querystring
 * @return {!Object}
 */
var querystringDecode = function (querystring) {
    var obj = {};
    var tokens = querystring.replace(/^\?/, '').split('&');
    tokens.forEach(function (token) {
        if (token) {
            var key = token.split('=');
            obj[key[0]] = key[1];
        }
    });
    return obj;
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @final
 * @struct
 */
var Sha1 = /** @class */function () {
    function Sha1() {
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @type {!Array<number>}
         * @private
         */
        this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @type {!Array<number>}
         * @private
         */
        this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @type {!Array<number>}
         * @private
         */
        this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @type {!Array<number>}
         * @private
         */
        this.pad_ = [];
        /**
         * @private {number}
         */
        this.inbuf_ = 0;
        /**
         * @private {number}
         */
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (var i = 1; i < this.blockSize; ++i) {
            this.pad_[i] = 0;
        }
        this.reset();
    }
    Sha1.prototype.reset = function () {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    };
    /**
     * Internal compress helper function.
     * @param {!Array<number>|!Uint8Array|string} buf Block to compress.
     * @param {number=} opt_offset Offset of the block in the buffer.
     * @private
     */
    Sha1.prototype.compress_ = function (buf, opt_offset) {
        if (!opt_offset) {
            opt_offset = 0;
        }
        var W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (var i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] = buf.charCodeAt(opt_offset) << 24 | buf.charCodeAt(opt_offset + 1) << 16 | buf.charCodeAt(opt_offset + 2) << 8 | buf.charCodeAt(opt_offset + 3);
                opt_offset += 4;
            }
        } else {
            for (var i = 0; i < 16; i++) {
                W[i] = buf[opt_offset] << 24 | buf[opt_offset + 1] << 16 | buf[opt_offset + 2] << 8 | buf[opt_offset + 3];
                opt_offset += 4;
            }
        }
        // expand to 80 words
        for (var i = 16; i < 80; i++) {
            var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = (t << 1 | t >>> 31) & 0xffffffff;
        }
        var a = this.chain_[0];
        var b = this.chain_[1];
        var c = this.chain_[2];
        var d = this.chain_[3];
        var e = this.chain_[4];
        var f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (var i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ b & (c ^ d);
                    k = 0x5a827999;
                } else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            } else {
                if (i < 60) {
                    f = b & c | d & (b | c);
                    k = 0x8f1bbcdc;
                } else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = this.chain_[0] + a & 0xffffffff;
        this.chain_[1] = this.chain_[1] + b & 0xffffffff;
        this.chain_[2] = this.chain_[2] + c & 0xffffffff;
        this.chain_[3] = this.chain_[3] + d & 0xffffffff;
        this.chain_[4] = this.chain_[4] + e & 0xffffffff;
    };
    Sha1.prototype.update = function (bytes, opt_length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (opt_length === undefined) {
            opt_length = bytes.length;
        }
        var lengthMinusBlock = opt_length - this.blockSize;
        var n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        var buf = this.buf_;
        var inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < opt_length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf == 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < opt_length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            } else {
                while (n < opt_length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += opt_length;
    };
    /** @override */
    Sha1.prototype.digest = function () {
        var digest = [];
        var totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        } else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (var i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        var n = 0;
        for (var i = 0; i < 5; i++) {
            for (var j = 24; j >= 0; j -= 8) {
                digest[n] = this.chain_[i] >> j & 255;
                ++n;
            }
        }
        return digest;
    };
    return Sha1;
}();

/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
function createSubscribe(executor, onNoObservers) {
    var proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
}
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
var ObserverProxy = /** @class */function () {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    function ObserverProxy(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task.then(function () {
            executor(_this);
        }).catch(function (e) {
            _this.error(e);
        });
    }
    ObserverProxy.prototype.next = function (value) {
        this.forEachObserver(function (observer) {
            observer.next(value);
        });
    };
    ObserverProxy.prototype.error = function (error) {
        this.forEachObserver(function (observer) {
            observer.error(error);
        });
        this.close(error);
    };
    ObserverProxy.prototype.complete = function () {
        this.forEachObserver(function (observer) {
            observer.complete();
        });
        this.close();
    };
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {
        var _this = this;
        var observer;
        if (nextOrObserver === undefined && error === undefined && complete === undefined) {
            throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {
            observer = nextOrObserver;
        } else {
            observer = {
                next: nextOrObserver,
                error: error,
                complete: complete
            };
        }
        if (observer.next === undefined) {
            observer.next = noop;
        }
        if (observer.error === undefined) {
            observer.error = noop;
        }
        if (observer.complete === undefined) {
            observer.complete = noop;
        }
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
            this.task.then(function () {
                try {
                    if (_this.finalError) {
                        observer.error(_this.finalError);
                    } else {
                        observer.complete();
                    }
                } catch (e) {
                    // nothing
                }
                return;
            });
        }
        this.observers.push(observer);
        return unsub;
    };
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    ObserverProxy.prototype.unsubscribeOne = function (i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
            return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
            this.onNoObservers(this);
        }
    };
    ObserverProxy.prototype.forEachObserver = function (fn) {
        if (this.finalized) {
            // Already closed by previous event....just eat the additional values.
            return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (var i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    };
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    ObserverProxy.prototype.sendOne = function (i, fn) {
        var _this = this;
        // Execute the callback asynchronously
        this.task.then(function () {
            if (_this.observers !== undefined && _this.observers[i] !== undefined) {
                try {
                    fn(_this.observers[i]);
                } catch (e) {
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) {
                        console.error(e);
                    }
                }
            }
        });
    };
    ObserverProxy.prototype.close = function (err) {
        var _this = this;
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        this.task.then(function () {
            _this.observers = undefined;
            _this.onNoObservers = undefined;
        });
    };
    return ObserverProxy;
}();
/** Turn synchronous function into one called asynchronously. */
function async(fn, onError) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        Promise.resolve(true).then(function () {
            fn.apply(void 0, args);
        }).catch(function (error) {
            if (onError) {
                onError(error);
            }
        });
    };
}
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === 'function') {
            return true;
        }
    }
    return false;
}
function noop() {}
// do nothing


/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param {!string} fnName The function name
 * @param {!number} minCount The minimum number of arguments to allow for the function call
 * @param {!number} maxCount The maximum number of argument to allow for the function call
 * @param {!number} argCount The actual number of arguments provided.
 */
var validateArgCount = function (fnName, minCount, maxCount, argCount) {
    var argError;
    if (argCount < minCount) {
        argError = 'at least ' + minCount;
    } else if (argCount > maxCount) {
        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
    }
    if (argError) {
        var error = fnName + ' failed: Was called with ' + argCount + (argCount === 1 ? ' argument.' : ' arguments.') + ' Expects ' + argError + '.';
        throw new Error(error);
    }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param {!string} fnName The function name
 * @param {!number} argumentNumber The index of the argument
 * @param {boolean} optional Whether or not the argument is optional
 * @return {!string} The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argumentNumber, optional) {
    var argName = '';
    switch (argumentNumber) {
        case 1:
            argName = optional ? 'first' : 'First';
            break;
        case 2:
            argName = optional ? 'second' : 'Second';
            break;
        case 3:
            argName = optional ? 'third' : 'Third';
            break;
        case 4:
            argName = optional ? 'fourth' : 'Fourth';
            break;
        default:
            throw new Error('errorPrefix called with argumentNumber > 4.  Need to update it?');
    }
    var error = fnName + ' failed: ';
    error += argName + ' argument ';
    return error;
}
/**
 * @param {!string} fnName
 * @param {!number} argumentNumber
 * @param {!string} namespace
 * @param {boolean} optional
 */
function validateNamespace(fnName, argumentNumber, namespace, optional) {
    if (optional && !namespace) return;
    if (typeof namespace !== 'string') {
        //TODO: I should do more validation here. We only allow certain chars in namespaces.
        throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid firebase namespace.');
    }
}
function validateCallback(fnName, argumentNumber, callback, optional) {
    if (optional && !callback) return;
    if (typeof callback !== 'function') throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid function.');
}
function validateContextObject(fnName, argumentNumber, context, optional) {
    if (optional && !context) return;
    if (typeof context !== 'object' || context === null) throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid context object.');
}

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
var stringToByteArray$1 = function (str) {
    var out = [],
        p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            var high = c - 0xd800; // the high 10 bits.
            i++;
            assert(i < str.length, 'Surrogate pair missing trail surrogate.');
            var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        } else if (c < 2048) {
            out[p++] = c >> 6 | 192;
            out[p++] = c & 63 | 128;
        } else if (c < 65536) {
            out[p++] = c >> 12 | 224;
            out[p++] = c >> 6 & 63 | 128;
            out[p++] = c & 63 | 128;
        } else {
            out[p++] = c >> 18 | 240;
            out[p++] = c >> 12 & 63 | 128;
            out[p++] = c >> 6 & 63 | 128;
            out[p++] = c & 63 | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
var stringLength = function (str) {
    var p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        } else if (c < 2048) {
            p += 2;
        } else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        } else {
            p += 3;
        }
    }
    return p;
};

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.CONSTANTS = CONSTANTS;
exports.Deferred = Deferred;
exports.ErrorFactory = ErrorFactory;
exports.FirebaseError = FirebaseError;
exports.Sha1 = Sha1;
exports.assert = assert;
exports.assertionError = assertionError;
exports.async = async;
exports.base64 = base64;
exports.base64Decode = base64Decode;
exports.base64Encode = base64Encode;
exports.clone = clone;
exports.contains = contains;
exports.createSubscribe = createSubscribe;
exports.decode = decode;
exports.deepCopy = deepCopy;
exports.deepExtend = deepExtend;
exports.errorPrefix = errorPrefix;
exports.every = every;
exports.extend = extend;
exports.findKey = findKey;
exports.findValue = findValue;
exports.forEach = forEach;
exports.getAnyKey = getAnyKey;
exports.getCount = getCount;
exports.getUA = getUA;
exports.getValues = getValues;
exports.isAdmin = isAdmin;
exports.isEmpty = isEmpty;
exports.isMobileCordova = isMobileCordova;
exports.isNodeSdk = isNodeSdk;
exports.isNonNullObject = isNonNullObject;
exports.isReactNative = isReactNative;
exports.isValidFormat = isValidFormat;
exports.isValidTimestamp = isValidTimestamp;
exports.issuedAtTime = issuedAtTime;
exports.jsonEval = jsonEval;
exports.map = map;
exports.patchProperty = patchProperty;
exports.querystring = querystring;
exports.querystringDecode = querystringDecode;
exports.safeGet = safeGet;
exports.stringLength = stringLength;
exports.stringToByteArray = stringToByteArray$1;
exports.stringify = stringify;
exports.validateArgCount = validateArgCount;
exports.validateCallback = validateCallback;
exports.validateContextObject = validateContextObject;
exports.validateNamespace = validateNamespace;
//# sourceMappingURL=index.cjs.js.map

/***/ }),

/***/ "59Aw":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("zkJf");

/***/ }),

/***/ "5D9O":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) {
  var ReactIs = require('react-is');

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("wVGV")();
}

/***/ }),

/***/ "5XDi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasChildNodes = hasChildNodes;
var DEFAULT_ROOT_PATH = exports.DEFAULT_ROOT_PATH = '$';

var WILDCARD = '*';

function hasChildNodes(data, dataIterator) {
  return !dataIterator(data).next().done;
}

var wildcardPathsFromLevel = exports.wildcardPathsFromLevel = function wildcardPathsFromLevel(level) {
  // i is depth
  return Array.from({ length: level }, function (_, i) {
    return [DEFAULT_ROOT_PATH].concat(Array.from({ length: i }, function () {
      return '*';
    })).join('.');
  });
};

var getExpandedPaths = exports.getExpandedPaths = function getExpandedPaths(data, dataIterator, expandPaths, expandLevel) {
  var initialState = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var wildcardPaths = [].concat(wildcardPathsFromLevel(expandLevel)).concat(expandPaths).filter(function (path) {
    return typeof path === 'string';
  }); // could be undefined

  var expandedPaths = [];
  wildcardPaths.forEach(function (wildcardPath) {
    var keyPaths = wildcardPath.split('.');
    var populatePaths = function populatePaths(curData, curPath, depth) {
      if (depth === keyPaths.length) {
        expandedPaths.push(curPath);
        return;
      }
      var key = keyPaths[depth];
      if (depth === 0) {
        if (hasChildNodes(curData, dataIterator) && (key === DEFAULT_ROOT_PATH || key === WILDCARD)) {
          populatePaths(curData, DEFAULT_ROOT_PATH, depth + 1);
        }
      } else {
        if (key === WILDCARD) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = dataIterator(curData)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _ref2 = _step.value;
              var name = _ref2.name,
                  _data = _ref2.data;

              if (hasChildNodes(_data, dataIterator)) {
                populatePaths(_data, curPath + '.' + name, depth + 1);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else {
          var value = curData[key];
          if (hasChildNodes(value, dataIterator)) {
            populatePaths(value, curPath + '.' + key, depth + 1);
          }
        }
      }
    };

    populatePaths(data, '', 0);
  });

  return expandedPaths.reduce(function (obj, path) {
    obj[path] = true;
    return obj;
  }, initialState);
};

/***/ }),

/***/ "5Zef":
/***/ (function(module, exports, __webpack_require__) {

// Math[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
__webpack_require__("xyxa")(Math, 'Math', true);

/***/ }),

/***/ "5gBI":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  function lineIndent(cm, lineNo) {
    var text = cm.getLine(lineNo);
    var spaceTo = text.search(/\S/);
    if (spaceTo == -1 || /\bcomment\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1)))) return -1;
    return CodeMirror.countColumn(text, null, cm.getOption("tabSize"));
  }

  CodeMirror.registerHelper("fold", "indent", function (cm, start) {
    var myIndent = lineIndent(cm, start.line);
    if (myIndent < 0) return;
    var lastLineInFold = null;

    // Go through lines until we find a line that definitely doesn't belong in
    // the block we're folding, or to the end.
    for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {
      var indent = lineIndent(cm, i);
      if (indent == -1) {} else if (indent > myIndent) {
        // Lines with a greater indent are considered part of the block.
        lastLineInFold = i;
      } else {
        // If this line has non-space, non-comment content, and is
        // indented less or equal to the start line, it is the start of
        // another block.
        break;
      }
    }
    if (lastLineInFold) return {
      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),
      to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)
    };
  });
});

/***/ }),

/***/ "6DLj":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("SD9a");
var toLength = __webpack_require__("qub/");
var toAbsoluteIndex = __webpack_require__("nIol");

// `Array.prototype.{ indexOf, includes }` methods implementation
// false -> Array#indexOf
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
// true  -> Array#includes
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "6Ks4":
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__("bien");
var requireObjectCoercible = __webpack_require__("Vhc8");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) {
    throw TypeError('String.prototype.' + NAME + " doesn't accept regex");
  }return String(requireObjectCoercible(that));
};

/***/ }),

/***/ "6MLN":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("wLcK")(function () {
  return Object.defineProperty({}, 'a', { get: function () {
      return 7;
    } }).a != 7;
});

/***/ }),

/***/ "6n5Z":
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + postfix).toString(36));
};

/***/ }),

/***/ "6r0S":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  var Pos = CodeMirror.Pos;

  function forEach(arr, f) {
    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);
  }

  function arrayContains(arr, item) {
    if (!Array.prototype.indexOf) {
      var i = arr.length;
      while (i--) {
        if (arr[i] === item) {
          return true;
        }
      }
      return false;
    }
    return arr.indexOf(item) != -1;
  }

  function scriptHint(editor, keywords, getToken, options) {
    // Find the token at the cursor
    var cur = editor.getCursor(),
        token = getToken(editor, cur);
    if (/\b(?:string|comment)\b/.test(token.type)) return;
    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);
    if (innerMode.mode.helperType === "json") return;
    token.state = innerMode.state;

    // If it's not a 'word-style' token, ignore the token.
    if (!/^[\w$_]*$/.test(token.string)) {
      token = { start: cur.ch, end: cur.ch, string: "", state: token.state,
        type: token.string == "." ? "property" : null };
    } else if (token.end > cur.ch) {
      token.end = cur.ch;
      token.string = token.string.slice(0, cur.ch - token.start);
    }

    var tprop = token;
    // If it is a property, find out what it is a property of.
    while (tprop.type == "property") {
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if (tprop.string != ".") return;
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if (!context) var context = [];
      context.push(tprop);
    }
    return { list: getCompletions(token, context, keywords, options),
      from: Pos(cur.line, token.start),
      to: Pos(cur.line, token.end) };
  }

  function javascriptHint(editor, options) {
    return scriptHint(editor, javascriptKeywords, function (e, cur) {
      return e.getTokenAt(cur);
    }, options);
  };
  CodeMirror.registerHelper("hint", "javascript", javascriptHint);

  function getCoffeeScriptToken(editor, cur) {
    // This getToken, it is for coffeescript, imitates the behavior of
    // getTokenAt method in javascript.js, that is, returning "property"
    // type and treat "." as indepenent token.
    var token = editor.getTokenAt(cur);
    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {
      token.end = token.start;
      token.string = '.';
      token.type = "property";
    } else if (/^\.[\w$_]*$/.test(token.string)) {
      token.type = "property";
      token.start++;
      token.string = token.string.replace(/\./, '');
    }
    return token;
  }

  function coffeescriptHint(editor, options) {
    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);
  }
  CodeMirror.registerHelper("hint", "coffeescript", coffeescriptHint);

  var stringProps = ("charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight " + "toUpperCase toLowerCase split concat match replace search").split(" ");
  var arrayProps = ("length concat join splice push pop shift unshift slice reverse sort indexOf " + "lastIndexOf every some filter forEach map reduce reduceRight ").split(" ");
  var funcProps = "prototype apply call bind".split(" ");
  var javascriptKeywords = ("break case catch class const continue debugger default delete do else export extends false finally for function " + "if in import instanceof new null return super switch this throw true try typeof var void while with yield").split(" ");
  var coffeescriptKeywords = ("and break catch class continue delete do else extends false finally for " + "if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes").split(" ");

  function forAllProps(obj, callback) {
    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {
      for (var name in obj) callback(name);
    } else {
      for (var o = obj; o; o = Object.getPrototypeOf(o)) Object.getOwnPropertyNames(o).forEach(callback);
    }
  }

  function getCompletions(token, context, keywords, options) {
    var found = [],
        start = token.string,
        global = options && options.globalScope || window;
    function maybeAdd(str) {
      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);
    }
    function gatherCompletions(obj) {
      if (typeof obj == "string") forEach(stringProps, maybeAdd);else if (obj instanceof Array) forEach(arrayProps, maybeAdd);else if (obj instanceof Function) forEach(funcProps, maybeAdd);
      forAllProps(obj, maybeAdd);
    }

    if (context && context.length) {
      // If this is a property, see if it belongs to some object we can
      // find in the current environment.
      var obj = context.pop(),
          base;
      if (obj.type && obj.type.indexOf("variable") === 0) {
        if (options && options.additionalContext) base = options.additionalContext[obj.string];
        if (!options || options.useGlobalScope !== false) base = base || global[obj.string];
      } else if (obj.type == "string") {
        base = "";
      } else if (obj.type == "atom") {
        base = 1;
      } else if (obj.type == "function") {
        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') && typeof global.jQuery == 'function') base = global.jQuery();else if (global._ != null && obj.string == '_' && typeof global._ == 'function') base = global._();
      }
      while (base != null && context.length) base = base[context.pop().string];
      if (base != null) gatherCompletions(base);
    } else {
      // If not, just look in the global object and any local scope
      // (reading into JS mode internals to get at the local and global variables)
      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);
      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);
      if (!options || options.useGlobalScope !== false) gatherCompletions(global);
      forEach(keywords, maybeAdd);
    }
    return found;
  }
});

/***/ }),

/***/ "6t7t":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("nFDa"), __esModule: true };

/***/ }),

/***/ "7AqT":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("ZHvQ");
var ITERATOR = __webpack_require__("Ug9I")('iterator');
var Iterators = __webpack_require__("dhak");
module.exports = __webpack_require__("zKeE").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "7T8+":
/***/ (function(module, exports, __webpack_require__) {

var objectKeys = __webpack_require__("cjyi");
var getOwnPropertySymbolsModule = __webpack_require__("Mve8");
var propertyIsEnumerableModule = __webpack_require__("2uWC");

// all enumerable object keys, includes symbols
module.exports = function (it) {
  var result = objectKeys(it);
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  if (getOwnPropertySymbols) {
    var symbols = getOwnPropertySymbols(it);
    var propertyIsEnumerable = propertyIsEnumerableModule.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (propertyIsEnumerable.call(it, key = symbols[i++])) result.push(key);
  }return result;
};

/***/ }),

/***/ "7qSu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var internalFindIndex = __webpack_require__("W8pO")(6);
var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
  SKIPS_HOLES = false;
});

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
__webpack_require__("c+Wn")({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return internalFindIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
__webpack_require__("dqyN")(FIND_INDEX);

/***/ }),

/***/ "7tlB":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__("Hba+");

/*<replacement>*/
var util = __webpack_require__("Q14w");
util.inherits = __webpack_require__("4Bm0");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "7vHL":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_firestore__ = __webpack_require__("eA7g");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_firestore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__firebase_firestore__);


/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//# sourceMappingURL=index.esm.js.map

/***/ }),

/***/ "87T5":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.modeInfo = [{ name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] }, { name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"] }, { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] }, { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i }, { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] }, { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"] }, { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] }, { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"] }, { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"] }, { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"] }, { name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"] }, { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] }, { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/ }, { name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] }, { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] }, { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] }, { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] }, { name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"] }, { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] }, { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] }, { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] }, { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] }, { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] }, { name: "Django", mime: "text/x-django", mode: "django" }, { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ }, { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] }, { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] }, { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" }, { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] }, { name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"] }, { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] }, { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] }, { name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] }, { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] }, { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] }, { name: "Esper", mime: "text/x-esper", mode: "sql" }, { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] }, { name: "FCL", mime: "text/x-fcl", mode: "fcl" }, { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] }, { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"] }, { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] }, { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] }, { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] }, { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i }, { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] }, { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/ }, { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] }, { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] }, { name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"] }, { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] }, { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] }, { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] }, { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"] }, { name: "HTTP", mime: "message/http", mode: "http" }, { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] }, { name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"] }, { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] }, { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] }, { name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
    mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"] }, { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] }, { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] }, { name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"] }, { name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"] }, { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"] }, { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] }, { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] }, { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] }, { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] }, { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] }, { name: "mIRC", mime: "text/mirc", mode: "mirc" }, { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" }, { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"] }, { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] }, { name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"] }, { name: "MS SQL", mime: "text/x-mssql", mode: "sql" }, { name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"] }, { name: "MySQL", mime: "text/x-mysql", mode: "sql" }, { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i }, { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] }, { name: "NTriples", mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
    mode: "ntriples", ext: ["nt", "nq"] }, { name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"], alias: ["objective-c", "objc"] }, { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] }, { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] }, { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] }, { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] }, { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] }, { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] }, { name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"] }, { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] }, { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] }, { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] }, { name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql" }, { name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"] }, { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] }, { name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"] }, { name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/ }, { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] }, { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] }, { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"] }, { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] }, { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" }, { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] }, { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] }, { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] }, { name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"] }, { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] }, { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] }, { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] }, { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] }, { name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ }, { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] }, { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] }, { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] }, { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] }, { name: "Solr", mime: "text/x-solr", mode: "solr" }, { name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"] }, { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] }, { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] }, { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] }, { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] }, { name: "SQLite", mime: "text/x-sqlite", mode: "sql" }, { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] }, { name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"] }, { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] }, { name: "sTeX", mime: "text/x-stex", mode: "stex" }, { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"] }, { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"] }, { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] }, { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] }, { name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki" }, { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" }, { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] }, { name: "Tornado", mime: "text/x-tornado", mode: "tornado" }, { name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] }, { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] }, { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] }, { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] }, { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] }, { name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"] }, { name: "Twig", mime: "text/x-twig", mode: "twig" }, { name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"] }, { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] }, { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] }, { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] }, { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] }, { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] }, { name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"] }, { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"] }, { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] }, { name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"] }, { name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] }, { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] }, { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] }, { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] }, { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] }];
  // Ensure all modes have a mime property for backwards compatibility
  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.mimes) info.mime = info.mimes[0];
  }

  CodeMirror.findModeByMIME = function (mime) {
    mime = mime.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.mime == mime) return info;
      if (info.mimes) for (var j = 0; j < info.mimes.length; j++) if (info.mimes[j] == mime) return info;
    }
    if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml");
    if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json");
  };

  CodeMirror.findModeByExtension = function (ext) {
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.ext) for (var j = 0; j < info.ext.length; j++) if (info.ext[j] == ext) return info;
    }
  };

  CodeMirror.findModeByFileName = function (filename) {
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.file && info.file.test(filename)) return info;
    }
    var dot = filename.lastIndexOf(".");
    var ext = dot > -1 && filename.substring(dot + 1, filename.length);
    if (ext) return CodeMirror.findModeByExtension(ext);
  };

  CodeMirror.findModeByName = function (name) {
    name = name.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.name.toLowerCase() == name) return info;
      if (info.alias) for (var j = 0; j < info.alias.length; j++) if (info.alias[j].toLowerCase() == name) return info;
    }
  };
});

/***/ }),

/***/ "89El":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

var ReactIs = __webpack_require__("H1RQ");
var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};

var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};

var TYPE_STATICS = {};
TYPE_STATICS[ReactIs.ForwardRef] = FORWARD_REF_STATICS;

function getStatics(component) {
    if (ReactIs.isMemo(component)) {
        return MEMO_STATICS;
    }
    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),

/***/ "8FtN":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("eOjq"), __esModule: true };

/***/ }),

/***/ "8JlO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global Promise */


// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)

var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = __webpack_require__("xz3w");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

/***/ }),

/***/ "8h5B":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("b3E9");
var SPECIES = __webpack_require__("95jh")('species');

module.exports = function (METHOD_NAME) {
  return !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

/***/ }),

/***/ "8kVM":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.toPrimitive` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.toprimitive
__webpack_require__("KGgk")('toPrimitive');

/***/ }),

/***/ "95jh":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("JE34")('wks');
var uid = __webpack_require__("6n5Z");
var Symbol = __webpack_require__("wJQ+").Symbol;
var NATIVE_SYMBOL = __webpack_require__("CXjr");

module.exports = function (name) {
  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name] || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

/***/ }),

/***/ "9Uuy":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var support = __webpack_require__("untT");
var ArrayReader = __webpack_require__("TCoK");
var StringReader = __webpack_require__("wOgZ");
var NodeBufferReader = __webpack_require__("daDe");
var Uint8ArrayReader = __webpack_require__("nR4t");

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

/***/ }),

/***/ "9aRM":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var theme = {
  BASE_FONT_FAMILY: 'Menlo, monospace',
  BASE_FONT_SIZE: '11px',
  BASE_LINE_HEIGHT: '14px',

  BASE_BACKGROUND_COLOR: 'white',
  BASE_COLOR: 'black',

  OBJECT_NAME_COLOR: 'rgb(136, 19, 145)',
  OBJECT_VALUE_NULL_COLOR: 'rgb(128, 128, 128)',
  OBJECT_VALUE_UNDEFINED_COLOR: 'rgb(128, 128, 128)',
  OBJECT_VALUE_REGEXP_COLOR: 'rgb(196, 26, 22)',
  OBJECT_VALUE_STRING_COLOR: 'rgb(196, 26, 22)',
  OBJECT_VALUE_SYMBOL_COLOR: 'rgb(196, 26, 22)',
  OBJECT_VALUE_NUMBER_COLOR: 'rgb(28, 0, 207)',
  OBJECT_VALUE_BOOLEAN_COLOR: 'rgb(28, 0, 207)',
  OBJECT_VALUE_FUNCTION_KEYWORD_COLOR: 'rgb(170, 13, 145)',

  HTML_TAG_COLOR: 'rgb(168, 148, 166)',
  HTML_TAGNAME_COLOR: 'rgb(136, 18, 128)',
  HTML_TAGNAME_TEXT_TRANSFORM: 'lowercase',
  HTML_ATTRIBUTE_NAME_COLOR: 'rgb(153, 69, 0)',
  HTML_ATTRIBUTE_VALUE_COLOR: 'rgb(26, 26, 166)',
  HTML_COMMENT_COLOR: 'rgb(35, 110, 37)',
  HTML_DOCTYPE_COLOR: 'rgb(192, 192, 192)',

  ARROW_COLOR: '#6e6e6e',
  ARROW_MARGIN_RIGHT: 3,
  ARROW_FONT_SIZE: 12,

  TREENODE_FONT_FAMILY: 'Menlo, monospace',
  TREENODE_FONT_SIZE: '11px',
  TREENODE_LINE_HEIGHT: '14px',
  TREENODE_PADDING_LEFT: 12,

  TABLE_BORDER_COLOR: '#aaa',
  TABLE_TH_BACKGROUND_COLOR: '#eee',
  TABLE_TH_HOVER_COLOR: 'hsla(0, 0%, 90%, 1)',
  TABLE_SORT_ICON_COLOR: '#6e6e6e',
  TABLE_DATA_BACKGROUND_IMAGE: 'linear-gradient(to bottom, white, white 50%, rgb(234, 243, 255) 50%, rgb(234, 243, 255))',
  TABLE_DATA_BACKGROUND_SIZE: '128px 32px'
};

exports.default = theme;

/***/ }),

/***/ "9kxq":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("BxvP");
var document = __webpack_require__("i1Q6").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "A9/K":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("tzeh").Transform;

/***/ }),

/***/ "ABU1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var GenericWorker = __webpack_require__("ZKdc");

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if (!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function () {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function () {

    if (this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null,
        nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch (this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
                break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
                break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
                break;
        }
        this.index = nextIndex;
        return this.push({
            data: data,
            meta: {
                percent: this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

/***/ }),

/***/ "AIXc":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("HeB0"), __webpack_require__("qqFR"), __webpack_require__("ggoL"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var defaultTags = {
    script: [["lang", /(javascript|babel)/i, "javascript"], ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"], ["type", /./, "text/plain"], [null, null, "javascript"]],
    style: [["lang", /^css$/i, "css"], ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"], ["type", /./, "text/plain"], [null, null, "css"]]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(),
        close = cur.search(pat);
    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }

  var attrRegexpCache = {};
  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr));
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : "";
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];
      for (var i = source.length - 1; i >= 0; i--) dest.unshift(source[i]);
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
    });

    var tags = {};
    var configTags = parserConfig && parserConfig.tags,
        configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--) tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState),
          tag = /\btag\b/.test(style),
          tagName;
      if (tag && !/[<>\s\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " ";
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag);
        state.inTag = null;
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
        var mode = CodeMirror.getMode(config, modeSpec);
        var endTagA = getTagRegexp(inTag[1], true),
            endTag = getTagRegexp(inTag[1], false);
        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }
          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };
        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
      } else if (state.inTag) {
        state.inTag += stream.current();
        if (stream.eol()) state.inTag += " ";
      }
      return style;
    };

    return {
      startState: function () {
        var state = CodeMirror.startState(htmlMode);
        return { token: html, inTag: null, localMode: null, localState: null, htmlState: state };
      },

      copyState: function (state) {
        var local;
        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }
        return { token: state.token, inTag: state.inTag,
          localMode: state.localMode, localState: local,
          htmlState: CodeMirror.copyState(htmlMode, state.htmlState) };
      },

      token: function (stream, state) {
        return state.token(stream, state);
      },

      indent: function (state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter)) return htmlMode.indent(state.htmlState, textAfter, line);else if (state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line);else return CodeMirror.Pass;
      },

      innerMode: function (state) {
        return { state: state.localState || state.htmlState, mode: state.localMode || htmlMode };
      }
    };
  }, "xml", "javascript", "css");

  CodeMirror.defineMIME("text/html", "htmlmixed");
});

/***/ }),

/***/ "ALBP":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("wJQ+");
var bind = __webpack_require__("3PKL");
var call = Function.call;

module.exports = function (CONSTRUCTOR, METHOD, length) {
  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);
};

/***/ }),

/***/ "AP0c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)

var objectKeys = __webpack_require__("cjyi");
var getOwnPropertySymbolsModule = __webpack_require__("Mve8");
var propertyIsEnumerableModule = __webpack_require__("2uWC");
var toObject = __webpack_require__("yocI");
var IndexedObject = __webpack_require__("u1qH");
var nativeAssign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !nativeAssign || __webpack_require__("b3E9")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (propertyIsEnumerable.call(S, key = keys[j++])) T[key] = S[key];
  }return T;
} : nativeAssign;

/***/ }),

/***/ "AS82":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("xWhT");
var definePropertyModule = __webpack_require__("uebg");
var anObject = __webpack_require__("hrV0");
var objectKeys = __webpack_require__("cjyi");

module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var key;
  while (length > i) definePropertyModule.f(O, key = keys[i++], Properties[key]);
  return O;
};

/***/ }),

/***/ "Aa2f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim

var global = __webpack_require__("i1Q6");
var has = __webpack_require__("yS17");
var DESCRIPTORS = __webpack_require__("6MLN");
var $export = __webpack_require__("vSO4");
var redefine = __webpack_require__("gojl");
var META = __webpack_require__("e8vu").KEY;
var $fails = __webpack_require__("wLcK");
var shared = __webpack_require__("NB7d");
var setToStringTag = __webpack_require__("11Ut");
var uid = __webpack_require__("X6va");
var wks = __webpack_require__("Ug9I");
var wksExt = __webpack_require__("ZxII");
var wksDefine = __webpack_require__("c2zY");
var enumKeys = __webpack_require__("ycyv");
var isArray = __webpack_require__("ayXv");
var anObject = __webpack_require__("zotD");
var isObject = __webpack_require__("BxvP");
var toObject = __webpack_require__("mbLO");
var toIObject = __webpack_require__("Wyka");
var toPrimitive = __webpack_require__("EKwp");
var createDesc = __webpack_require__("0WCH");
var _create = __webpack_require__("TNJq");
var gOPNExt = __webpack_require__("rMkZ");
var $GOPD = __webpack_require__("sxPs");
var $GOPS = __webpack_require__("Ocr3");
var $DP = __webpack_require__("Gfzd");
var $keys = __webpack_require__("knrM");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () {
      return dP(this, 'a', { value: 7 }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    }return setSymbolDesc(it, key, D);
  }return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("Ni5N").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("z7R8").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("1kq3")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols =
// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () {
    setter = true;
  },
  useSimple: function () {
    setter = false;
  }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () {
  $GOPS.f(1);
});

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("akPY")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "AeFI":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _ObjectValue = __webpack_require__("fHwt");

var _ObjectValue2 = _interopRequireDefault(_ObjectValue);

var _ObjectName = __webpack_require__("bY9t");

var _ObjectName2 = _interopRequireDefault(_ObjectName);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/* NOTE: Chrome console.log is italic */
var styles = {
  preview: {
    fontStyle: 'italic'
  }
};

/* intersperse arr with separator */
function intersperse(arr, sep) {
  if (arr.length === 0) {
    return [];
  }

  return arr.slice(1).reduce(function (xs, x) {
    return xs.concat([sep, x]);
  }, [arr[0]]);
}

/**
 * A preview of the object
 */
var ObjectPreview = function ObjectPreview(_ref) {
  var data = _ref.data,
      maxProperties = _ref.maxProperties;

  var object = data;

  if ((typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) !== 'object' || object === null || object instanceof Date || object instanceof RegExp) {
    return _react2.default.createElement(_ObjectValue2.default, { object: object });
  }

  if (Array.isArray(object)) {
    return _react2.default.createElement('span', { style: styles.preview }, '[', intersperse(object.map(function (element, index) {
      return _react2.default.createElement(_ObjectValue2.default, { key: index, object: element });
    }), ', '), ']');
  } else {
    var propertyNodes = [];
    for (var propertyName in object) {
      var propertyValue = object[propertyName];
      if (object.hasOwnProperty(propertyName)) {
        var ellipsis = void 0;
        if (propertyNodes.length === maxProperties - 1 && Object.keys(object).length > maxProperties) {
          ellipsis = _react2.default.createElement('span', { key: 'ellipsis' }, '\u2026');
        }
        propertyNodes.push(_react2.default.createElement('span', { key: propertyName }, _react2.default.createElement(_ObjectName2.default, { name: propertyName || '""' }), ':\xA0', _react2.default.createElement(_ObjectValue2.default, { object: propertyValue }), ellipsis));
        if (ellipsis) break;
      }
    }

    return _react2.default.createElement('span', { style: styles.preview }, object.constructor.name + ' {', intersperse(propertyNodes, ', '), '}');
  }
};

ObjectPreview.propTypes = {
  /**
   * max number of properties shown in the property view
   */
  maxProperties: _propTypes2.default.number
};
ObjectPreview.defaultProps = {
  maxProperties: 5
};

exports.default = ObjectPreview;

/***/ }),

/***/ "AhD2":
/***/ (function(module, exports) {

/*
Based on Joel Besada's lovely experiment
https://twitter.com/JoelBesada/status/670343885655293952
 */

;(function () {
	var shakeTime = 0,
	    shakeTimeMax = 0,
	    shakeIntensity = 5,
	    lastTime = 0,
	    particles = [],
	    particlePointer = 0,
	    MAX_PARTICLES = 100,
	    PARTICLE_NUM_RANGE = { min: 2, max: 7 },
	    PARTICLE_GRAVITY = 0.08,
	    PARTICLE_ALPHA_FADEOUT = 0.96,
	    PARTICLE_VELOCITY_RANGE = {
		x: [-1, 1],
		y: [-3.5, -1.5]
	},
	    w = window.innerWidth,
	    h = window.innerHeight,
	    effect,
	    isActive = false;

	var codemirrors = [],
	    cmNode;
	var canvas, ctx;
	var current_time, dt, magnitude, shakeX, shakeY; // loop vars
	var throttledShake = throttle(shake, 100);
	var throttledSpawnParticles = throttle(spawnParticles, 100);

	function getRGBComponents(node) {
		var color = getComputedStyle(node).color;
		if (color) {
			try {
				return color.match(/(\d+), (\d+), (\d+)/).slice(1);
			} catch (e) {
				return [255, 255, 255];
			}
		} else {
			return [255, 255, 255];
		}
	}

	function spawnParticles(cm, type) {
		var cursorPos = cm.getCursor();
		var pos = cm.cursorCoords();
		var node = document.elementFromPoint(pos.left - 5, pos.top + 5);
		type = cm.getTokenAt(cursorPos);
		if (type) {
			type = type.type;
		};
		var numParticles = random(PARTICLE_NUM_RANGE.min, PARTICLE_NUM_RANGE.max);
		var color = getRGBComponents(node);
		for (var i = numParticles; i--;) {
			particles[particlePointer] = createParticle(pos.left + 10, pos.top, color);
			particlePointer = (particlePointer + 1) % MAX_PARTICLES;
		}
	}

	function createParticle(x, y, color) {
		var p = {
			x: x,
			y: y + 10,
			alpha: 1,
			color: color
		};
		if (effect === 1) {
			p.size = random(2, 4);
			p.vx = PARTICLE_VELOCITY_RANGE.x[0] + Math.random() * (PARTICLE_VELOCITY_RANGE.x[1] - PARTICLE_VELOCITY_RANGE.x[0]);
			p.vy = PARTICLE_VELOCITY_RANGE.y[0] + Math.random() * (PARTICLE_VELOCITY_RANGE.y[1] - PARTICLE_VELOCITY_RANGE.y[0]);
		} else if (effect === 2) {
			p.size = random(2, 8);
			p.drag = 0.92;
			p.vx = random(-3, 3);
			p.vy = random(-3, 3);
			p.wander = 0.15;
			p.theta = random(0, 360) * Math.PI / 180;
		}
		return p;
	}

	function effect1(particle) {
		particle.vy += PARTICLE_GRAVITY;
		particle.x += particle.vx;
		particle.y += particle.vy;

		particle.alpha *= PARTICLE_ALPHA_FADEOUT;

		ctx.fillStyle = 'rgba(' + particle.color[0] + ',' + particle.color[1] + ',' + particle.color[2] + ',' + particle.alpha + ')';
		ctx.fillRect(Math.round(particle.x - 1), Math.round(particle.y - 1), particle.size, particle.size);
	}

	// Effect based on Soulwire's demo: http://codepen.io/soulwire/pen/foktm
	function effect2(particle) {
		particle.x += particle.vx;
		particle.y += particle.vy;
		particle.vx *= particle.drag;
		particle.vy *= particle.drag;
		particle.theta += random(-0.5, 0.5);
		particle.vx += Math.sin(particle.theta) * 0.1;
		particle.vy += Math.cos(particle.theta) * 0.1;
		particle.size *= 0.96;

		ctx.fillStyle = 'rgba(' + particle.color[0] + ',' + particle.color[1] + ',' + particle.color[2] + ',' + particle.alpha + ')';
		ctx.beginPath();
		ctx.arc(Math.round(particle.x - 1), Math.round(particle.y - 1), particle.size, 0, 2 * Math.PI);
		ctx.fill();
	}

	function drawParticles(timeDelta) {
		var particle;
		for (var i = particles.length; i--;) {
			particle = particles[i];
			if (!particle || particle.alpha < 0.01 || particle.size <= 0.5) {
				continue;
			}

			if (effect === 1) {
				effect1(particle);
			} else if (effect === 2) {
				effect2(particle);
			}
		}
	}

	function shake(editor, time) {
		cmNode = editor.getWrapperElement();
		shakeTime = shakeTimeMax = time;
	}

	function random(min, max) {
		if (!max) {
			max = min;min = 0;
		}
		return min + ~~(Math.random() * (max - min + 1));
	}

	function throttle(callback, limit) {
		var wait = false;
		return function () {
			if (!wait) {
				callback.apply(this, arguments);
				wait = true;
				setTimeout(function () {
					wait = false;
				}, limit);
			}
		};
	}

	function loop() {
		if (!isActive) {
			return;
		}

		ctx.clearRect(0, 0, w, h);

		// get the time past the previous frame
		current_time = new Date().getTime();
		if (!lastTime) lastTime = current_time;
		dt = (current_time - lastTime) / 1000;
		lastTime = current_time;

		if (shakeTime > 0) {
			shakeTime -= dt;
			magnitude = shakeTime / shakeTimeMax * shakeIntensity;
			shakeX = random(-magnitude, magnitude);
			shakeY = random(-magnitude, magnitude);
			cmNode.style.transform = 'translate(' + shakeX + 'px,' + shakeY + 'px)';
		}
		drawParticles();
		requestAnimationFrame(loop);
	}

	function onCodeMirrorChange(editor, change) {
		if (change.origin !== '+input' && change.origin !== '+delete') {
			return;
		}

		if (editor.getOption('blastCode') === true || editor.getOption('blastCode').shake === undefined) {
			throttledShake(editor, 0.3);
		}
		throttledSpawnParticles(editor);
	}

	function init(editor) {
		isActive = true;

		if (!canvas) {
			canvas = document.createElement('canvas');
			ctx = canvas.getContext('2d'), canvas.id = 'code-blast-canvas';
			canvas.style.position = 'absolute';
			canvas.style.top = 0;
			canvas.style.left = 0;
			canvas.style.zIndex = 1;
			canvas.style.pointerEvents = 'none';
			canvas.width = w;
			canvas.height = h;

			document.body.appendChild(canvas);
			loop();
		}

		editor.on("change", onCodeMirrorChange);
	}

	function destroy(editor) {
		editor.off('change', onCodeMirrorChange);
		codemirrors.splice(codemirrors.indexOf(editor), 1);
		if (!codemirrors.length) {
			isActive = false;
			if (canvas) {
				canvas.remove();
				canvas = null;
			}
		}
	}

	CodeMirror.defineOption('blastCode', false, function (editor, val, old) {
		if (val) {
			codemirrors.push(editor);
			effect = val.effect || 2;
			init(editor);
		} else {
			destroy(editor);
		}
	});
})();

/***/ }),

/***/ "Aq8W":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("dXs8"), __esModule: true };

/***/ }),

/***/ "AsaI":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var GenericWorker = __webpack_require__("ZKdc");

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function (chunk) {
        self.push({
            data: chunk,
            meta: {
                percent: 0
            }
        });
    }).on("error", function (e) {
        if (self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    }).on("end", function () {
        if (self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if (!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

/***/ }),

/***/ "Asjh":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),

/***/ "B9Lq":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("yS17");
var toIObject = __webpack_require__("Wyka");
var arrayIndexOf = __webpack_require__("LNnS")(false);
var IE_PROTO = __webpack_require__("/wuY")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),

/***/ "BVSg":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Tag-closer extension for CodeMirror.
 *
 * This extension adds an "autoCloseTags" option that can be set to
 * either true to get the default behavior, or an object to further
 * configure its behavior.
 *
 * These are supported options:
 *
 * `whenClosing` (default true)
 *   Whether to autoclose when the '/' of a closing tag is typed.
 * `whenOpening` (default true)
 *   Whether to autoclose the tag when the final '>' of an opening
 *   tag is typed.
 * `dontCloseTags` (default is empty tags for HTML, none for XML)
 *   An array of tag names that should not be autoclosed.
 * `indentTags` (default is block tags for HTML, none for XML)
 *   An array of tag names that should, when opened, cause a
 *   blank line to be added inside the tag, and the blank line and
 *   closing line to be indented.
 * `emptyTags` (default is none)
 *   An array of XML tag names that should be autoclosed with '/>'.
 *
 * See demos/closetag.html for a usage example.
 */

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("1JcR"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../fold/xml-fold"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  CodeMirror.defineOption("autoCloseTags", false, function (cm, val, old) {
    if (old != CodeMirror.Init && old) cm.removeKeyMap("autoCloseTags");
    if (!val) return;
    var map = { name: "autoCloseTags" };
    if (typeof val != "object" || val.whenClosing) map["'/'"] = function (cm) {
      return autoCloseSlash(cm);
    };
    if (typeof val != "object" || val.whenOpening) map["'>'"] = function (cm) {
      return autoCloseGT(cm);
    };
    cm.addKeyMap(map);
  });

  var htmlDontClose = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
  var htmlIndent = ["applet", "blockquote", "body", "button", "div", "dl", "fieldset", "form", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "html", "iframe", "layer", "legend", "object", "ol", "p", "select", "table", "ul"];

  function autoCloseGT(cm) {
    if (cm.getOption("disableInput")) return CodeMirror.Pass;
    var ranges = cm.listSelections(),
        replacements = [];
    var opt = cm.getOption("autoCloseTags");
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var pos = ranges[i].head,
          tok = cm.getTokenAt(pos);
      var inner = CodeMirror.innerMode(cm.getMode(), tok.state),
          state = inner.state;
      if (inner.mode.name != "xml" || !state.tagName) return CodeMirror.Pass;

      var html = inner.mode.configuration == "html";
      var dontCloseTags = typeof opt == "object" && opt.dontCloseTags || html && htmlDontClose;
      var indentTags = typeof opt == "object" && opt.indentTags || html && htmlIndent;

      var tagName = state.tagName;
      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);
      var lowerTagName = tagName.toLowerCase();
      // Don't process the '>' at the end of an end-tag or self-closing tag
      if (!tagName || tok.type == "string" && (tok.end != pos.ch || !/[\"\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) || tok.type == "tag" && state.type == "closeTag" || tok.string.indexOf("/") == tok.string.length - 1 || // match something like <someTagName />
      dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 || closingTagExists(cm, tagName, pos, state, true)) return CodeMirror.Pass;

      var emptyTags = typeof opt == "object" && opt.emptyTags;
      if (emptyTags && indexOf(emptyTags, tagName) > -1) {
        replacements[i] = { text: "/>", newPos: CodeMirror.Pos(pos.line, pos.ch + 2) };
        continue;
      }

      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;
      replacements[i] = { indent: indent,
        text: ">" + (indent ? "\n\n" : "") + "</" + tagName + ">",
        newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1) };
    }

    var dontIndentOnAutoClose = typeof opt == "object" && opt.dontIndentOnAutoClose;
    for (var i = ranges.length - 1; i >= 0; i--) {
      var info = replacements[i];
      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, "+insert");
      var sel = cm.listSelections().slice(0);
      sel[i] = { head: info.newPos, anchor: info.newPos };
      cm.setSelections(sel);
      if (!dontIndentOnAutoClose && info.indent) {
        cm.indentLine(info.newPos.line, null, true);
        cm.indentLine(info.newPos.line + 1, null, true);
      }
    }
  }

  function autoCloseCurrent(cm, typingSlash) {
    var ranges = cm.listSelections(),
        replacements = [];
    var head = typingSlash ? "/" : "</";
    var opt = cm.getOption("autoCloseTags");
    var dontIndentOnAutoClose = typeof opt == "object" && opt.dontIndentOnSlash;
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var pos = ranges[i].head,
          tok = cm.getTokenAt(pos);
      var inner = CodeMirror.innerMode(cm.getMode(), tok.state),
          state = inner.state;
      if (typingSlash && (tok.type == "string" || tok.string.charAt(0) != "<" || tok.start != pos.ch - 1)) return CodeMirror.Pass;
      // Kludge to get around the fact that we are not in XML mode
      // when completing in JS/CSS snippet in htmlmixed mode. Does not
      // work for other XML embedded languages (there is no general
      // way to go from a mixed mode to its current XML state).
      var replacement;
      if (inner.mode.name != "xml") {
        if (cm.getMode().name == "htmlmixed" && inner.mode.name == "javascript") replacement = head + "script";else if (cm.getMode().name == "htmlmixed" && inner.mode.name == "css") replacement = head + "style";else return CodeMirror.Pass;
      } else {
        if (!state.context || !state.context.tagName || closingTagExists(cm, state.context.tagName, pos, state)) return CodeMirror.Pass;
        replacement = head + state.context.tagName;
      }
      if (cm.getLine(pos.line).charAt(tok.end) != ">") replacement += ">";
      replacements[i] = replacement;
    }
    cm.replaceSelections(replacements);
    ranges = cm.listSelections();
    if (!dontIndentOnAutoClose) {
      for (var i = 0; i < ranges.length; i++) if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line) cm.indentLine(ranges[i].head.line);
    }
  }

  function autoCloseSlash(cm) {
    if (cm.getOption("disableInput")) return CodeMirror.Pass;
    return autoCloseCurrent(cm, true);
  }

  CodeMirror.commands.closeTag = function (cm) {
    return autoCloseCurrent(cm);
  };

  function indexOf(collection, elt) {
    if (collection.indexOf) return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i) if (collection[i] == elt) return i;
    return -1;
  }

  // If xml-fold is loaded, we use its functionality to try and verify
  // whether a given tag is actually unclosed.
  function closingTagExists(cm, tagName, pos, state, newTag) {
    if (!CodeMirror.scanForClosingTag) return false;
    var end = Math.min(cm.lastLine() + 1, pos.line + 500);
    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);
    if (!nextClose || nextClose.tag != tagName) return false;
    var cx = state.context;
    // If the immediate wrapping context contains onCx instances of
    // the same tag, a closing tag only exists if there are at least
    // that many closing tags of that type following.
    for (var onCx = newTag ? 1 : 0; cx && cx.tagName == tagName; cx = cx.prev) ++onCx;
    pos = nextClose.to;
    for (var i = 1; i < onCx; i++) {
      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);
      if (!next || next.tag != tagName) return false;
      pos = next.to;
    }
    return true;
  }
});

/***/ }),

/***/ "BX4+":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("ky2m"), __esModule: true };

/***/ }),

/***/ "BiiT":
/***/ (function(module, exports, __webpack_require__) {

var nativeFunctionToString = __webpack_require__("mv67");
var WeakMap = __webpack_require__("wJQ+").WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));

/***/ }),

/***/ "BtHH":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__("mbLO");
var $getPrototypeOf = __webpack_require__("HHE0");

__webpack_require__("cOHw")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "BxvP":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "By4a":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("ZHvQ");
var ITERATOR = __webpack_require__("Ug9I")('iterator');
var Iterators = __webpack_require__("dhak");
module.exports = __webpack_require__("zKeE").isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined || '@@iterator' in O
  // eslint-disable-next-line no-prototype-builtins
  || Iterators.hasOwnProperty(classof(O));
};

/***/ }),

/***/ "C6nS":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("tzeh").PassThrough;

/***/ }),

/***/ "CAJ1":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("UYRC");
var ownKeys = __webpack_require__("veA5");
var getOwnPropertyDescriptorModule = __webpack_require__("1g0E");
var definePropertyModule = __webpack_require__("uebg");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

/***/ }),

/***/ "CGvP":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__("1+KL");
var TO_STRING_TAG = __webpack_require__("95jh")('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = String(test) !== '[object z]' ? function toString() {
  return '[object ' + classof(this) + ']';
} : test.toString;

/***/ }),

/***/ "COf8":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("OYXR");
var global = __webpack_require__("i1Q6");
var hide = __webpack_require__("akPY");
var Iterators = __webpack_require__("dhak");
var TO_STRING_TAG = __webpack_require__("Ug9I")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),

/***/ "CXjr":
/***/ (function(module, exports, __webpack_require__) {

// Chrome 38 Symbol has incorrect toString conversion
module.exports = !__webpack_require__("b3E9")(function () {
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

/***/ }),

/***/ "CnGL":
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var validateSetPrototypeOfArguments = __webpack_require__("FMmW");

module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var correctSetter = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    correctSetter = test instanceof Array;
  } catch (error) {/* empty */}
  return function setPrototypeOf(O, proto) {
    validateSetPrototypeOfArguments(O, proto);
    if (correctSetter) setter.call(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

/***/ }),

/***/ "Ctqd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

/***/ }),

/***/ "DHrQ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__("Yj0v");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__("REa7");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__("FRpO").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__("1ExO");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__("38Wu").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__("Q14w");
util.inherits = __webpack_require__("4Bm0");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(0);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__("wl+m");
var destroyImpl = __webpack_require__("GRUB");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__("Hba+");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__("z0rv").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__("Hba+");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__("z0rv").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("h6ac")))

/***/ }),

/***/ "DoY4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toIndexedObject = __webpack_require__("SD9a");
var addToUnscopables = __webpack_require__("dqyN");
var Iterators = __webpack_require__("Gzjq");
var InternalStateModule = __webpack_require__("q/RK");
var defineIterator = __webpack_require__("GHga");
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0, // next index
    kind: kind // kind
  });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "Dylg":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("UYRC");
var toObject = __webpack_require__("yocI");
var IE_PROTO = __webpack_require__("YYE9")('IE_PROTO');
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("Fjti");
var ObjectPrototype = Object.prototype;

module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectPrototype : null;
};

/***/ }),

/***/ "E3Ci":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("Kfn2");

module.exports = __webpack_require__("ALBP")('String', 'startsWith');

/***/ }),

/***/ "E5Ce":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("ShN9");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "EA4g":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.unscopables` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.unscopables
__webpack_require__("KGgk")('unscopables');

/***/ }),

/***/ "EKwp":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("BxvP");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "ERJL":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chromeLight = exports.chromeDark = undefined;

var _chromeDark2 = __webpack_require__("dGHV");

var _chromeDark3 = _interopRequireDefault(_chromeDark2);

var _chromeLight2 = __webpack_require__("9aRM");

var _chromeLight3 = _interopRequireDefault(_chromeLight2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.chromeDark = _chromeDark3.default;
exports.chromeLight = _chromeLight3.default;

/***/ }),

/***/ "EkFk":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_app__ = __webpack_require__("dP58");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_app___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__firebase_app__);
(function () {
  var h,
      aa = aa || {},
      l = this;function m(a) {
    return "string" == typeof a;
  }function ba(a) {
    return "boolean" == typeof a;
  }var ca = /^[\w+/_-]+[=]{0,2}$/,
      ea = null;function fa() {}
  function ha(a) {
    var b = typeof a;if ("object" == b) {
      if (a) {
        if (a instanceof Array) return "array";if (a instanceof Object) return b;var c = Object.prototype.toString.call(a);if ("[object Window]" == c) return "object";if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
      } else return "null";
    } else if ("function" == b && "undefined" == typeof a.call) return "object";return b;
  }function ia(a) {
    return null === a;
  }function ja(a) {
    return "array" == ha(a);
  }function ka(a) {
    var b = ha(a);return "array" == b || "object" == b && "number" == typeof a.length;
  }function q(a) {
    return "function" == ha(a);
  }function r(a) {
    var b = typeof a;return "object" == b && null != a || "function" == b;
  }var la = "closure_uid_" + (1E9 * Math.random() >>> 0),
      ma = 0;function na(a, b, c) {
    return a.call.apply(a.bind, arguments);
  }
  function oa(a, b, c) {
    if (!a) throw Error();if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);return function () {
        var e = Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(e, d);return a.apply(b, e);
      };
    }return function () {
      return a.apply(b, arguments);
    };
  }function t(a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? t = na : t = oa;return t.apply(null, arguments);
  }
  function pa(a, b) {
    var c = Array.prototype.slice.call(arguments, 1);return function () {
      var d = c.slice();d.push.apply(d, arguments);return a.apply(this, d);
    };
  }var qa = Date.now || function () {
    return +new Date();
  };function u(a, b) {
    function c() {}c.prototype = b.prototype;a.pb = b.prototype;a.prototype = new c();a.prototype.constructor = a;a.gd = function (d, e, f) {
      for (var g = Array(arguments.length - 2), k = 2; k < arguments.length; k++) g[k - 2] = arguments[k];return b.prototype[e].apply(d, g);
    };
  };function ra(a) {
    if (!a) return !1;try {
      return !!a.$goog_Thenable;
    } catch (b) {
      return !1;
    }
  };function v(a) {
    if (Error.captureStackTrace) Error.captureStackTrace(this, v);else {
      var b = Error().stack;b && (this.stack = b);
    }a && (this.message = String(a));
  }u(v, Error);v.prototype.name = "CustomError";function sa(a, b) {
    a = a.split("%s");for (var c = "", d = a.length - 1, e = 0; e < d; e++) c += a[e] + (e < b.length ? b[e] : "%s");v.call(this, c + a[d]);
  }u(sa, v);sa.prototype.name = "AssertionError";function ta(a, b) {
    throw new sa("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
  };function ua(a, b) {
    this.c = a;this.f = b;this.b = 0;this.a = null;
  }ua.prototype.get = function () {
    if (0 < this.b) {
      this.b--;var a = this.a;this.a = a.next;a.next = null;
    } else a = this.c();return a;
  };function va(a, b) {
    a.f(b);100 > a.b && (a.b++, b.next = a.a, a.a = b);
  };function wa() {
    this.b = this.a = null;
  }var ya = new ua(function () {
    return new xa();
  }, function (a) {
    a.reset();
  });wa.prototype.add = function (a, b) {
    var c = ya.get();c.set(a, b);this.b ? this.b.next = c : this.a = c;this.b = c;
  };function za() {
    var a = Aa,
        b = null;a.a && (b = a.a, a.a = a.a.next, a.a || (a.b = null), b.next = null);return b;
  }function xa() {
    this.next = this.b = this.a = null;
  }xa.prototype.set = function (a, b) {
    this.a = a;this.b = b;this.next = null;
  };xa.prototype.reset = function () {
    this.next = this.b = this.a = null;
  };var Ba = Array.prototype.indexOf ? function (a, b) {
    return Array.prototype.indexOf.call(a, b, void 0);
  } : function (a, b) {
    if (m(a)) return m(b) && 1 == b.length ? a.indexOf(b, 0) : -1;for (var c = 0; c < a.length; c++) if (c in a && a[c] === b) return c;return -1;
  },
      w = Array.prototype.forEach ? function (a, b, c) {
    Array.prototype.forEach.call(a, b, c);
  } : function (a, b, c) {
    for (var d = a.length, e = m(a) ? a.split("") : a, f = 0; f < d; f++) f in e && b.call(c, e[f], f, a);
  };function Ca(a, b) {
    for (var c = m(a) ? a.split("") : a, d = a.length - 1; 0 <= d; --d) d in c && b.call(void 0, c[d], d, a);
  }
  var Da = Array.prototype.map ? function (a, b) {
    return Array.prototype.map.call(a, b, void 0);
  } : function (a, b) {
    for (var c = a.length, d = Array(c), e = m(a) ? a.split("") : a, f = 0; f < c; f++) f in e && (d[f] = b.call(void 0, e[f], f, a));return d;
  },
      Ea = Array.prototype.some ? function (a, b) {
    return Array.prototype.some.call(a, b, void 0);
  } : function (a, b) {
    for (var c = a.length, d = m(a) ? a.split("") : a, e = 0; e < c; e++) if (e in d && b.call(void 0, d[e], e, a)) return !0;return !1;
  };
  function Fa(a) {
    a: {
      var b = Ga;for (var c = a.length, d = m(a) ? a.split("") : a, e = 0; e < c; e++) if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;break a;
      }b = -1;
    }return 0 > b ? null : m(a) ? a.charAt(b) : a[b];
  }function Ha(a, b) {
    return 0 <= Ba(a, b);
  }function Ia(a, b) {
    b = Ba(a, b);var c;(c = 0 <= b) && Array.prototype.splice.call(a, b, 1);return c;
  }function x(a, b) {
    var c = 0;Ca(a, function (d, e) {
      b.call(void 0, d, e, a) && 1 == Array.prototype.splice.call(a, e, 1).length && c++;
    });
  }function Ja(a) {
    return Array.prototype.concat.apply([], arguments);
  }
  function Ka(a) {
    var b = a.length;if (0 < b) {
      for (var c = Array(b), d = 0; d < b; d++) c[d] = a[d];return c;
    }return [];
  };var La = String.prototype.trim ? function (a) {
    return a.trim();
  } : function (a) {
    return (/^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]
    );
  },
      Ma = /&/g,
      Na = /</g,
      Oa = />/g,
      Pa = /"/g,
      Qa = /'/g,
      Ra = /\x00/g,
      Sa = /[\x00&<>"']/;function y(a, b) {
    return -1 != a.indexOf(b);
  }function Ta(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  };var Ua;a: {
    var Va = l.navigator;if (Va) {
      var Wa = Va.userAgent;if (Wa) {
        Ua = Wa;break a;
      }
    }Ua = "";
  }function B(a) {
    return y(Ua, a);
  };function Xa(a, b) {
    for (var c in a) b.call(void 0, a[c], c, a);
  }function Ya(a) {
    for (var b in a) return !1;return !0;
  }function Za(a) {
    var b = {},
        c;for (c in a) b[c] = a[c];return b;
  }var $a = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function ab(a, b) {
    for (var c, d, e = 1; e < arguments.length; e++) {
      d = arguments[e];for (c in d) a[c] = d[c];for (var f = 0; f < $a.length; f++) c = $a[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
    }
  };function bb(a, b) {
    for (var c = a.split("%s"), d = "", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length;) d += c.shift() + e.shift();return d + c.join("%s");
  }function cb(a) {
    Sa.test(a) && (-1 != a.indexOf("&") && (a = a.replace(Ma, "&amp;")), -1 != a.indexOf("<") && (a = a.replace(Na, "&lt;")), -1 != a.indexOf(">") && (a = a.replace(Oa, "&gt;")), -1 != a.indexOf('"') && (a = a.replace(Pa, "&quot;")), -1 != a.indexOf("'") && (a = a.replace(Qa, "&#39;")), -1 != a.indexOf("\x00") && (a = a.replace(Ra, "&#0;")));return a;
  };function db(a) {
    l.setTimeout(function () {
      throw a;
    }, 0);
  }var eb;
  function fb() {
    var a = l.MessageChannel;"undefined" === typeof a && "undefined" !== typeof window && window.postMessage && window.addEventListener && !B("Presto") && (a = function () {
      var e = document.createElement("IFRAME");e.style.display = "none";e.src = "";document.documentElement.appendChild(e);var f = e.contentWindow;e = f.document;e.open();e.write("");e.close();var g = "callImmediate" + Math.random(),
          k = "file:" == f.location.protocol ? "*" : f.location.protocol + "//" + f.location.host;e = t(function (n) {
        if (("*" == k || n.origin == k) && n.data == g) this.port1.onmessage();
      }, this);f.addEventListener("message", e, !1);this.port1 = {};this.port2 = { postMessage: function () {
          f.postMessage(g, k);
        } };
    });if ("undefined" !== typeof a && !B("Trident") && !B("MSIE")) {
      var b = new a(),
          c = {},
          d = c;b.port1.onmessage = function () {
        if (void 0 !== c.next) {
          c = c.next;var e = c.xb;c.xb = null;e();
        }
      };return function (e) {
        d.next = { xb: e };d = d.next;b.port2.postMessage(0);
      };
    }return "undefined" !== typeof document && "onreadystatechange" in document.createElement("SCRIPT") ? function (e) {
      var f = document.createElement("SCRIPT");
      f.onreadystatechange = function () {
        f.onreadystatechange = null;f.parentNode.removeChild(f);f = null;e();e = null;
      };document.documentElement.appendChild(f);
    } : function (e) {
      l.setTimeout(e, 0);
    };
  };function gb(a, b) {
    hb || ib();jb || (hb(), jb = !0);Aa.add(a, b);
  }var hb;function ib() {
    if (l.Promise && l.Promise.resolve) {
      var a = l.Promise.resolve(void 0);hb = function () {
        a.then(kb);
      };
    } else hb = function () {
      var b = kb;!q(l.setImmediate) || l.Window && l.Window.prototype && !B("Edge") && l.Window.prototype.setImmediate == l.setImmediate ? (eb || (eb = fb()), eb(b)) : l.setImmediate(b);
    };
  }var jb = !1,
      Aa = new wa();function kb() {
    for (var a; a = za();) {
      try {
        a.a.call(a.b);
      } catch (b) {
        db(b);
      }va(ya, a);
    }jb = !1;
  };function C(a, b) {
    this.a = lb;this.i = void 0;this.f = this.b = this.c = null;this.g = this.h = !1;if (a != fa) try {
      var c = this;a.call(b, function (d) {
        mb(c, nb, d);
      }, function (d) {
        if (!(d instanceof ob)) try {
          if (d instanceof Error) throw d;throw Error("Promise rejected.");
        } catch (e) {}mb(c, pb, d);
      });
    } catch (d) {
      mb(this, pb, d);
    }
  }var lb = 0,
      nb = 2,
      pb = 3;function qb() {
    this.next = this.f = this.b = this.g = this.a = null;this.c = !1;
  }qb.prototype.reset = function () {
    this.f = this.b = this.g = this.a = null;this.c = !1;
  };var rb = new ua(function () {
    return new qb();
  }, function (a) {
    a.reset();
  });
  function sb(a, b, c) {
    var d = rb.get();d.g = a;d.b = b;d.f = c;return d;
  }function D(a) {
    if (a instanceof C) return a;var b = new C(fa);mb(b, nb, a);return b;
  }function E(a) {
    return new C(function (b, c) {
      c(a);
    });
  }function tb(a, b, c) {
    ub(a, b, c, null) || gb(pa(b, a));
  }function vb(a) {
    return new C(function (b, c) {
      var d = a.length,
          e = [];if (d) for (var f = function (p, z) {
        d--;e[p] = z;0 == d && b(e);
      }, g = function (p) {
        c(p);
      }, k = 0, n; k < a.length; k++) n = a[k], tb(n, pa(f, k), g);else b(e);
    });
  }
  function wb(a) {
    return new C(function (b) {
      var c = a.length,
          d = [];if (c) for (var e = function (k, n, p) {
        c--;d[k] = n ? { Eb: !0, value: p } : { Eb: !1, reason: p };0 == c && b(d);
      }, f = 0, g; f < a.length; f++) g = a[f], tb(g, pa(e, f, !0), pa(e, f, !1));else b(d);
    });
  }C.prototype.then = function (a, b, c) {
    return xb(this, q(a) ? a : null, q(b) ? b : null, c);
  };C.prototype.$goog_Thenable = !0;h = C.prototype;h.ia = function (a, b) {
    a = sb(a, a, b);a.c = !0;yb(this, a);return this;
  };h.s = function (a, b) {
    return xb(this, null, a, b);
  };
  h.cancel = function (a) {
    this.a == lb && gb(function () {
      var b = new ob(a);zb(this, b);
    }, this);
  };function zb(a, b) {
    if (a.a == lb) if (a.c) {
      var c = a.c;if (c.b) {
        for (var d = 0, e = null, f = null, g = c.b; g && (g.c || (d++, g.a == a && (e = g), !(e && 1 < d))); g = g.next) e || (f = g);e && (c.a == lb && 1 == d ? zb(c, b) : (f ? (d = f, d.next == c.f && (c.f = d), d.next = d.next.next) : Ab(c), Bb(c, e, pb, b)));
      }a.c = null;
    } else mb(a, pb, b);
  }function yb(a, b) {
    a.b || a.a != nb && a.a != pb || Cb(a);a.f ? a.f.next = b : a.b = b;a.f = b;
  }
  function xb(a, b, c, d) {
    var e = sb(null, null, null);e.a = new C(function (f, g) {
      e.g = b ? function (k) {
        try {
          var n = b.call(d, k);f(n);
        } catch (p) {
          g(p);
        }
      } : f;e.b = c ? function (k) {
        try {
          var n = c.call(d, k);void 0 === n && k instanceof ob ? g(k) : f(n);
        } catch (p) {
          g(p);
        }
      } : g;
    });e.a.c = a;yb(a, e);return e.a;
  }h.Pc = function (a) {
    this.a = lb;mb(this, nb, a);
  };h.Qc = function (a) {
    this.a = lb;mb(this, pb, a);
  };
  function mb(a, b, c) {
    a.a == lb && (a === c && (b = pb, c = new TypeError("Promise cannot resolve to itself")), a.a = 1, ub(c, a.Pc, a.Qc, a) || (a.i = c, a.a = b, a.c = null, Cb(a), b != pb || c instanceof ob || Db(a, c)));
  }function ub(a, b, c, d) {
    if (a instanceof C) return yb(a, sb(b || fa, c || null, d)), !0;if (ra(a)) return a.then(b, c, d), !0;if (r(a)) try {
      var e = a.then;if (q(e)) return Eb(a, e, b, c, d), !0;
    } catch (f) {
      return c.call(d, f), !0;
    }return !1;
  }
  function Eb(a, b, c, d, e) {
    function f(n) {
      k || (k = !0, d.call(e, n));
    }function g(n) {
      k || (k = !0, c.call(e, n));
    }var k = !1;try {
      b.call(a, g, f);
    } catch (n) {
      f(n);
    }
  }function Cb(a) {
    a.h || (a.h = !0, gb(a.Yb, a));
  }function Ab(a) {
    var b = null;a.b && (b = a.b, a.b = b.next, b.next = null);a.b || (a.f = null);return b;
  }h.Yb = function () {
    for (var a; a = Ab(this);) Bb(this, a, this.a, this.i);this.h = !1;
  };
  function Bb(a, b, c, d) {
    if (c == pb && b.b && !b.c) for (; a && a.g; a = a.c) a.g = !1;if (b.a) b.a.c = null, Fb(b, c, d);else try {
      b.c ? b.g.call(b.f) : Fb(b, c, d);
    } catch (e) {
      Gb.call(null, e);
    }va(rb, b);
  }function Fb(a, b, c) {
    b == nb ? a.g.call(a.f, c) : a.b && a.b.call(a.f, c);
  }function Db(a, b) {
    a.g = !0;gb(function () {
      a.g && Gb.call(null, b);
    });
  }var Gb = db;function ob(a) {
    v.call(this, a);
  }u(ob, v);ob.prototype.name = "cancel";function Hb() {
    0 != Ib && (Jb[this[la] || (this[la] = ++ma)] = this);this.qa = this.qa;this.ja = this.ja;
  }var Ib = 0,
      Jb = {};Hb.prototype.qa = !1;function Kb(a) {
    if (!a.qa && (a.qa = !0, a.va(), 0 != Ib)) {
      var b = a[la] || (a[la] = ++ma);if (0 != Ib && a.ja && 0 < a.ja.length) throw Error(a + " did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.");delete Jb[b];
    }
  }Hb.prototype.va = function () {
    if (this.ja) for (; this.ja.length;) this.ja.shift()();
  };function Lb(a) {
    Lb[" "](a);return a;
  }Lb[" "] = fa;function Mb(a, b) {
    var c = Nb;return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b(a);
  };var Ob = B("Opera"),
      Pb = B("Trident") || B("MSIE"),
      Qb = B("Edge"),
      Rb = Qb || Pb,
      Sb = B("Gecko") && !(y(Ua.toLowerCase(), "webkit") && !B("Edge")) && !(B("Trident") || B("MSIE")) && !B("Edge"),
      Tb = y(Ua.toLowerCase(), "webkit") && !B("Edge");function Ub() {
    var a = l.document;return a ? a.documentMode : void 0;
  }var Vb;
  a: {
    var Wb = "",
        Xb = function () {
      var a = Ua;if (Sb) return (/rv:([^\);]+)(\)|;)/.exec(a)
      );if (Qb) return (/Edge\/([\d\.]+)/.exec(a)
      );if (Pb) return (/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a)
      );if (Tb) return (/WebKit\/(\S+)/.exec(a)
      );if (Ob) return (/(?:Version)[ \/]?(\S+)/.exec(a)
      );
    }();Xb && (Wb = Xb ? Xb[1] : "");if (Pb) {
      var Yb = Ub();if (null != Yb && Yb > parseFloat(Wb)) {
        Vb = String(Yb);break a;
      }
    }Vb = Wb;
  }var Nb = {};
  function Zb(a) {
    return Mb(a, function () {
      for (var b = 0, c = La(String(Vb)).split("."), d = La(String(a)).split("."), e = Math.max(c.length, d.length), f = 0; 0 == b && f < e; f++) {
        var g = c[f] || "",
            k = d[f] || "";do {
          g = /(\d*)(\D*)(.*)/.exec(g) || ["", "", "", ""];k = /(\d*)(\D*)(.*)/.exec(k) || ["", "", "", ""];if (0 == g[0].length && 0 == k[0].length) break;b = Ta(0 == g[1].length ? 0 : parseInt(g[1], 10), 0 == k[1].length ? 0 : parseInt(k[1], 10)) || Ta(0 == g[2].length, 0 == k[2].length) || Ta(g[2], k[2]);g = g[3];k = k[3];
        } while (0 == b);
      }return 0 <= b;
    });
  }var $b;var ac = l.document;
  $b = ac && Pb ? Ub() || ("CSS1Compat" == ac.compatMode ? parseInt(Vb, 10) : 5) : void 0;var bc = Object.freeze || function (a) {
    return a;
  };var cc = !Pb || 9 <= Number($b),
      dc = Pb && !Zb("9"),
      ec = function () {
    if (!l.addEventListener || !Object.defineProperty) return !1;var a = !1,
        b = Object.defineProperty({}, "passive", { get: function () {
        a = !0;
      } });try {
      l.addEventListener("test", fa, b), l.removeEventListener("test", fa, b);
    } catch (c) {}return a;
  }();function F(a, b) {
    this.type = a;this.b = this.target = b;this.Kb = !0;
  }F.prototype.preventDefault = function () {
    this.Kb = !1;
  };function hc(a, b) {
    F.call(this, a ? a.type : "");this.relatedTarget = this.b = this.target = null;this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;this.key = "";this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;this.pointerId = 0;this.pointerType = "";this.a = null;if (a) {
      var c = this.type = a.type,
          d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;this.target = a.target || a.srcElement;this.b = b;if (b = a.relatedTarget) {
        if (Sb) {
          a: {
            try {
              Lb(b.nodeName);var e = !0;break a;
            } catch (f) {}e = !1;
          }e || (b = null);
        }
      } else "mouseover" == c ? b = a.fromElement : "mouseout" == c && (b = a.toElement);this.relatedTarget = b;d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);this.button = a.button;this.key = a.key || "";this.ctrlKey = a.ctrlKey;this.altKey = a.altKey;this.shiftKey = a.shiftKey;this.metaKey = a.metaKey;this.pointerId = a.pointerId || 0;this.pointerType = m(a.pointerType) ? a.pointerType : ic[a.pointerType] || "";this.a = a;a.defaultPrevented && this.preventDefault();
    }
  }u(hc, F);var ic = bc({ 2: "touch", 3: "pen", 4: "mouse" });hc.prototype.preventDefault = function () {
    hc.pb.preventDefault.call(this);var a = this.a;if (a.preventDefault) a.preventDefault();else if (a.returnValue = !1, dc) try {
      if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) a.keyCode = -1;
    } catch (b) {}
  };hc.prototype.f = function () {
    return this.a;
  };var jc = "closure_listenable_" + (1E6 * Math.random() | 0),
      kc = 0;function lc(a, b, c, d, e) {
    this.listener = a;this.proxy = null;this.src = b;this.type = c;this.capture = !!d;this.Ma = e;this.key = ++kc;this.oa = this.Ia = !1;
  }function mc(a) {
    a.oa = !0;a.listener = null;a.proxy = null;a.src = null;a.Ma = null;
  };function nc(a) {
    this.src = a;this.a = {};this.b = 0;
  }nc.prototype.add = function (a, b, c, d, e) {
    var f = a.toString();a = this.a[f];a || (a = this.a[f] = [], this.b++);var g = oc(a, b, d, e);-1 < g ? (b = a[g], c || (b.Ia = !1)) : (b = new lc(b, this.src, f, !!d, e), b.Ia = c, a.push(b));return b;
  };function pc(a, b) {
    var c = b.type;c in a.a && Ia(a.a[c], b) && (mc(b), 0 == a.a[c].length && (delete a.a[c], a.b--));
  }function oc(a, b, c, d) {
    for (var e = 0; e < a.length; ++e) {
      var f = a[e];if (!f.oa && f.listener == b && f.capture == !!c && f.Ma == d) return e;
    }return -1;
  };var qc = "closure_lm_" + (1E6 * Math.random() | 0),
      rc = {},
      sc = 0;function tc(a, b, c, d, e) {
    if (d && d.once) uc(a, b, c, d, e);else if (ja(b)) for (var f = 0; f < b.length; f++) tc(a, b[f], c, d, e);else c = vc(c), a && a[jc] ? wc(a, b, c, r(d) ? !!d.capture : !!d, e) : xc(a, b, c, !1, d, e);
  }
  function xc(a, b, c, d, e, f) {
    if (!b) throw Error("Invalid event type");var g = r(e) ? !!e.capture : !!e,
        k = yc(a);k || (a[qc] = k = new nc(a));c = k.add(b, c, d, g, f);if (!c.proxy) {
      d = zc();c.proxy = d;d.src = a;d.listener = c;if (a.addEventListener) ec || (e = g), void 0 === e && (e = !1), a.addEventListener(b.toString(), d, e);else if (a.attachEvent) a.attachEvent(Ac(b.toString()), d);else if (a.addListener && a.removeListener) a.addListener(d);else throw Error("addEventListener and attachEvent are unavailable.");sc++;
    }
  }
  function zc() {
    var a = Bc,
        b = cc ? function (c) {
      return a.call(b.src, b.listener, c);
    } : function (c) {
      c = a.call(b.src, b.listener, c);if (!c) return c;
    };return b;
  }function uc(a, b, c, d, e) {
    if (ja(b)) for (var f = 0; f < b.length; f++) uc(a, b[f], c, d, e);else c = vc(c), a && a[jc] ? Cc(a, b, c, r(d) ? !!d.capture : !!d, e) : xc(a, b, c, !0, d, e);
  }
  function G(a, b, c, d, e) {
    if (ja(b)) for (var f = 0; f < b.length; f++) G(a, b[f], c, d, e);else (d = r(d) ? !!d.capture : !!d, c = vc(c), a && a[jc]) ? (a = a.o, b = String(b).toString(), b in a.a && (f = a.a[b], c = oc(f, c, d, e), -1 < c && (mc(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b], a.b--)))) : a && (a = yc(a)) && (b = a.a[b.toString()], a = -1, b && (a = oc(b, c, d, e)), (c = -1 < a ? b[a] : null) && Dc(c));
  }
  function Dc(a) {
    if ("number" != typeof a && a && !a.oa) {
      var b = a.src;if (b && b[jc]) pc(b.o, a);else {
        var c = a.type,
            d = a.proxy;b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(Ac(c), d) : b.addListener && b.removeListener && b.removeListener(d);sc--;(c = yc(b)) ? (pc(c, a), 0 == c.b && (c.src = null, b[qc] = null)) : mc(a);
      }
    }
  }function Ac(a) {
    return a in rc ? rc[a] : rc[a] = "on" + a;
  }
  function Ec(a, b, c, d) {
    var e = !0;if (a = yc(a)) if (b = a.a[b.toString()]) for (b = b.concat(), a = 0; a < b.length; a++) {
      var f = b[a];f && f.capture == c && !f.oa && (f = Fc(f, d), e = e && !1 !== f);
    }return e;
  }function Fc(a, b) {
    var c = a.listener,
        d = a.Ma || a.src;a.Ia && Dc(a);return c.call(d, b);
  }
  function Bc(a, b) {
    if (a.oa) return !0;if (!cc) {
      if (!b) a: {
        b = ["window", "event"];for (var c = l, d = 0; d < b.length; d++) if (c = c[b[d]], null == c) {
          b = null;break a;
        }b = c;
      }d = b;b = new hc(d, this);c = !0;if (!(0 > d.keyCode || void 0 != d.returnValue)) {
        a: {
          var e = !1;if (0 == d.keyCode) try {
            d.keyCode = -1;break a;
          } catch (g) {
            e = !0;
          }if (e || void 0 == d.returnValue) d.returnValue = !0;
        }d = [];for (e = b.b; e; e = e.parentNode) d.push(e);a = a.type;for (e = d.length - 1; 0 <= e; e--) {
          b.b = d[e];var f = Ec(d[e], a, !0, b);c = c && f;
        }for (e = 0; e < d.length; e++) b.b = d[e], f = Ec(d[e], a, !1, b), c = c && f;
      }return c;
    }return Fc(a, new hc(b, this));
  }function yc(a) {
    a = a[qc];return a instanceof nc ? a : null;
  }var Gc = "__closure_events_fn_" + (1E9 * Math.random() >>> 0);function vc(a) {
    if (q(a)) return a;a[Gc] || (a[Gc] = function (b) {
      return a.handleEvent(b);
    });return a[Gc];
  };function H() {
    Hb.call(this);this.o = new nc(this);this.Rb = this;this.Wa = null;
  }u(H, Hb);H.prototype[jc] = !0;H.prototype.addEventListener = function (a, b, c, d) {
    tc(this, a, b, c, d);
  };H.prototype.removeEventListener = function (a, b, c, d) {
    G(this, a, b, c, d);
  };
  H.prototype.dispatchEvent = function (a) {
    var b,
        c = this.Wa;if (c) for (b = []; c; c = c.Wa) b.push(c);c = this.Rb;var d = a.type || a;if (m(a)) a = new F(a, c);else if (a instanceof F) a.target = a.target || c;else {
      var e = a;a = new F(d, c);ab(a, e);
    }e = !0;if (b) for (var f = b.length - 1; 0 <= f; f--) {
      var g = a.b = b[f];e = Hc(g, d, !0, a) && e;
    }g = a.b = c;e = Hc(g, d, !0, a) && e;e = Hc(g, d, !1, a) && e;if (b) for (f = 0; f < b.length; f++) g = a.b = b[f], e = Hc(g, d, !1, a) && e;return e;
  };
  H.prototype.va = function () {
    H.pb.va.call(this);if (this.o) {
      var a = this.o,
          b = 0,
          c;for (c in a.a) {
        for (var d = a.a[c], e = 0; e < d.length; e++) ++b, mc(d[e]);delete a.a[c];a.b--;
      }
    }this.Wa = null;
  };function wc(a, b, c, d, e) {
    a.o.add(String(b), c, !1, d, e);
  }function Cc(a, b, c, d, e) {
    a.o.add(String(b), c, !0, d, e);
  }
  function Hc(a, b, c, d) {
    b = a.o.a[String(b)];if (!b) return !0;b = b.concat();for (var e = !0, f = 0; f < b.length; ++f) {
      var g = b[f];if (g && !g.oa && g.capture == c) {
        var k = g.listener,
            n = g.Ma || g.src;g.Ia && pc(a.o, g);e = !1 !== k.call(n, d) && e;
      }
    }return e && 0 != d.Kb;
  };function Ic(a, b, c) {
    if (q(a)) c && (a = t(a, c));else if (a && "function" == typeof a.handleEvent) a = t(a.handleEvent, a);else throw Error("Invalid listener argument");return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
  }function Jc(a) {
    var b = null;return new C(function (c, d) {
      b = Ic(function () {
        c(void 0);
      }, a);-1 == b && d(Error("Failed to schedule timer."));
    }).s(function (c) {
      l.clearTimeout(b);throw c;
    });
  };function Kc(a) {
    if (a.S && "function" == typeof a.S) return a.S();if (m(a)) return a.split("");if (ka(a)) {
      for (var b = [], c = a.length, d = 0; d < c; d++) b.push(a[d]);return b;
    }b = [];c = 0;for (d in a) b[c++] = a[d];return b;
  }function Lc(a) {
    if (a.U && "function" == typeof a.U) return a.U();if (!a.S || "function" != typeof a.S) {
      if (ka(a) || m(a)) {
        var b = [];a = a.length;for (var c = 0; c < a; c++) b.push(c);return b;
      }b = [];c = 0;for (var d in a) b[c++] = d;return b;
    }
  }
  function Mc(a, b) {
    if (a.forEach && "function" == typeof a.forEach) a.forEach(b, void 0);else if (ka(a) || m(a)) w(a, b, void 0);else for (var c = Lc(a), d = Kc(a), e = d.length, f = 0; f < e; f++) b.call(void 0, d[f], c && c[f], a);
  };function Nc(a, b) {
    this.b = {};this.a = [];this.c = 0;var c = arguments.length;if (1 < c) {
      if (c % 2) throw Error("Uneven number of arguments");for (var d = 0; d < c; d += 2) this.set(arguments[d], arguments[d + 1]);
    } else if (a) if (a instanceof Nc) for (c = a.U(), d = 0; d < c.length; d++) this.set(c[d], a.get(c[d]));else for (d in a) this.set(d, a[d]);
  }h = Nc.prototype;h.S = function () {
    Oc(this);for (var a = [], b = 0; b < this.a.length; b++) a.push(this.b[this.a[b]]);return a;
  };h.U = function () {
    Oc(this);return this.a.concat();
  };
  h.clear = function () {
    this.b = {};this.c = this.a.length = 0;
  };function Oc(a) {
    if (a.c != a.a.length) {
      for (var b = 0, c = 0; b < a.a.length;) {
        var d = a.a[b];Pc(a.b, d) && (a.a[c++] = d);b++;
      }a.a.length = c;
    }if (a.c != a.a.length) {
      var e = {};for (c = b = 0; b < a.a.length;) d = a.a[b], Pc(e, d) || (a.a[c++] = d, e[d] = 1), b++;a.a.length = c;
    }
  }h.get = function (a, b) {
    return Pc(this.b, a) ? this.b[a] : b;
  };h.set = function (a, b) {
    Pc(this.b, a) || (this.c++, this.a.push(a));this.b[a] = b;
  };
  h.forEach = function (a, b) {
    for (var c = this.U(), d = 0; d < c.length; d++) {
      var e = c[d],
          f = this.get(e);a.call(b, f, e, this);
    }
  };function Pc(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  };var Qc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;function Rc(a, b) {
    if (a) {
      a = a.split("&");for (var c = 0; c < a.length; c++) {
        var d = a[c].indexOf("="),
            e = null;if (0 <= d) {
          var f = a[c].substring(0, d);e = a[c].substring(d + 1);
        } else f = a[c];b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
      }
    }
  };function Sc(a, b) {
    this.b = this.o = this.c = "";this.i = null;this.h = this.g = "";this.f = !1;if (a instanceof Sc) {
      this.f = void 0 !== b ? b : a.f;Tc(this, a.c);this.o = a.o;this.b = a.b;Uc(this, a.i);this.g = a.g;b = a.a;var c = new Vc();c.c = b.c;b.a && (c.a = new Nc(b.a), c.b = b.b);Wc(this, c);this.h = a.h;
    } else a && (c = String(a).match(Qc)) ? (this.f = !!b, Tc(this, c[1] || "", !0), this.o = Xc(c[2] || ""), this.b = Xc(c[3] || "", !0), Uc(this, c[4]), this.g = Xc(c[5] || "", !0), Wc(this, c[6] || "", !0), this.h = Xc(c[7] || "")) : (this.f = !!b, this.a = new Vc(null, this.f));
  }
  Sc.prototype.toString = function () {
    var a = [],
        b = this.c;b && a.push(Yc(b, Zc, !0), ":");var c = this.b;if (c || "file" == b) a.push("//"), (b = this.o) && a.push(Yc(b, Zc, !0), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.i, null != c && a.push(":", String(c));if (c = this.g) this.b && "/" != c.charAt(0) && a.push("/"), a.push(Yc(c, "/" == c.charAt(0) ? $c : ad, !0));(c = this.a.toString()) && a.push("?", c);(c = this.h) && a.push("#", Yc(c, bd));return a.join("");
  };
  function Tc(a, b, c) {
    a.c = c ? Xc(b, !0) : b;a.c && (a.c = a.c.replace(/:$/, ""));
  }function Uc(a, b) {
    if (b) {
      b = Number(b);if (isNaN(b) || 0 > b) throw Error("Bad port number " + b);a.i = b;
    } else a.i = null;
  }function Wc(a, b, c) {
    b instanceof Vc ? (a.a = b, cd(a.a, a.f)) : (c || (b = Yc(b, dd)), a.a = new Vc(b, a.f));
  }function I(a, b, c) {
    a.a.set(b, c);
  }function ed(a, b) {
    return a.a.get(b);
  }function fd(a) {
    return a instanceof Sc ? new Sc(a) : new Sc(a, void 0);
  }function gd(a, b) {
    var c = new Sc(null, void 0);Tc(c, "https");a && (c.b = a);b && (c.g = b);return c;
  }
  function Xc(a, b) {
    return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
  }function Yc(a, b, c) {
    return m(a) ? (a = encodeURI(a).replace(b, hd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
  }function hd(a) {
    a = a.charCodeAt(0);return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
  }var Zc = /[#\/\?@]/g,
      ad = /[#\?:]/g,
      $c = /[#\?]/g,
      dd = /[#\?@]/g,
      bd = /#/g;function Vc(a, b) {
    this.b = this.a = null;this.c = a || null;this.f = !!b;
  }
  function id(a) {
    a.a || (a.a = new Nc(), a.b = 0, a.c && Rc(a.c, function (b, c) {
      a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
    }));
  }function jd(a) {
    var b = Lc(a);if ("undefined" == typeof b) throw Error("Keys are undefined");var c = new Vc(null, void 0);a = Kc(a);for (var d = 0; d < b.length; d++) {
      var e = b[d],
          f = a[d];ja(f) ? kd(c, e, f) : c.add(e, f);
    }return c;
  }h = Vc.prototype;h.add = function (a, b) {
    id(this);this.c = null;a = ld(this, a);var c = this.a.get(a);c || this.a.set(a, c = []);c.push(b);this.b += 1;return this;
  };
  function md(a, b) {
    id(a);b = ld(a, b);Pc(a.a.b, b) && (a.c = null, a.b -= a.a.get(b).length, a = a.a, Pc(a.b, b) && (delete a.b[b], a.c--, a.a.length > 2 * a.c && Oc(a)));
  }h.clear = function () {
    this.a = this.c = null;this.b = 0;
  };function nd(a, b) {
    id(a);b = ld(a, b);return Pc(a.a.b, b);
  }h.forEach = function (a, b) {
    id(this);this.a.forEach(function (c, d) {
      w(c, function (e) {
        a.call(b, e, d, this);
      }, this);
    }, this);
  };h.U = function () {
    id(this);for (var a = this.a.S(), b = this.a.U(), c = [], d = 0; d < b.length; d++) for (var e = a[d], f = 0; f < e.length; f++) c.push(b[d]);return c;
  };
  h.S = function (a) {
    id(this);var b = [];if (m(a)) nd(this, a) && (b = Ja(b, this.a.get(ld(this, a))));else {
      a = this.a.S();for (var c = 0; c < a.length; c++) b = Ja(b, a[c]);
    }return b;
  };h.set = function (a, b) {
    id(this);this.c = null;a = ld(this, a);nd(this, a) && (this.b -= this.a.get(a).length);this.a.set(a, [b]);this.b += 1;return this;
  };h.get = function (a, b) {
    if (!a) return b;a = this.S(a);return 0 < a.length ? String(a[0]) : b;
  };function kd(a, b, c) {
    md(a, b);0 < c.length && (a.c = null, a.a.set(ld(a, b), Ka(c)), a.b += c.length);
  }
  h.toString = function () {
    if (this.c) return this.c;if (!this.a) return "";for (var a = [], b = this.a.U(), c = 0; c < b.length; c++) {
      var d = b[c],
          e = encodeURIComponent(String(d));d = this.S(d);for (var f = 0; f < d.length; f++) {
        var g = e;"" !== d[f] && (g += "=" + encodeURIComponent(String(d[f])));a.push(g);
      }
    }return this.c = a.join("&");
  };function ld(a, b) {
    b = String(b);a.f && (b = b.toLowerCase());return b;
  }function cd(a, b) {
    b && !a.f && (id(a), a.c = null, a.a.forEach(function (c, d) {
      var e = d.toLowerCase();d != e && (md(this, d), kd(this, e, c));
    }, a));a.f = b;
  };var od = !Pb || 9 <= Number($b);function pd(a, b) {
    this.a = a === qd && b || "";this.b = rd;
  }pd.prototype.na = !0;pd.prototype.ma = function () {
    return this.a;
  };pd.prototype.toString = function () {
    return "Const{" + this.a + "}";
  };function sd(a) {
    if (a instanceof pd && a.constructor === pd && a.b === rd) return a.a;ta("expected object of type Const, got '" + a + "'");return "type_error:Const";
  }var rd = {},
      qd = {};function td() {
    this.a = "";this.b = ud;
  }td.prototype.na = !0;td.prototype.ma = function () {
    return this.a.toString();
  };td.prototype.toString = function () {
    return "TrustedResourceUrl{" + this.a + "}";
  };function vd(a) {
    if (a instanceof td && a.constructor === td && a.b === ud) return a.a;ta("expected object of type TrustedResourceUrl, got '" + a + "' of type " + ha(a));return "type_error:TrustedResourceUrl";
  }
  function wd(a, b) {
    var c = sd(a);if (!xd.test(c)) throw Error("Invalid TrustedResourceUrl format: " + c);a = c.replace(yd, function (d, e) {
      if (!Object.prototype.hasOwnProperty.call(b, e)) throw Error('Found marker, "' + e + '", in format string, "' + c + '", but no valid label mapping found in args: ' + JSON.stringify(b));d = b[e];return d instanceof pd ? sd(d) : encodeURIComponent(String(d));
    });return zd(a);
  }var yd = /%{(\w+)}/g,
      xd = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i,
      ud = {};
  function zd(a) {
    var b = new td();b.a = a;return b;
  };function Ad() {
    this.a = "";this.b = Bd;
  }Ad.prototype.na = !0;Ad.prototype.ma = function () {
    return this.a.toString();
  };Ad.prototype.toString = function () {
    return "SafeUrl{" + this.a + "}";
  };function Cd(a) {
    if (a instanceof Ad && a.constructor === Ad && a.b === Bd) return a.a;ta("expected object of type SafeUrl, got '" + a + "' of type " + ha(a));return "type_error:SafeUrl";
  }var Dd = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
  function Ed(a) {
    if (a instanceof Ad) return a;a = "object" == typeof a && a.na ? a.ma() : String(a);Dd.test(a) || (a = "about:invalid#zClosurez");return Fd(a);
  }var Bd = {};function Fd(a) {
    var b = new Ad();b.a = a;return b;
  }Fd("about:blank");function Gd() {
    this.a = "";this.b = Hd;
  }Gd.prototype.na = !0;Gd.prototype.ma = function () {
    return this.a.toString();
  };Gd.prototype.toString = function () {
    return "SafeHtml{" + this.a + "}";
  };function Id(a) {
    if (a instanceof Gd && a.constructor === Gd && a.b === Hd) return a.a;ta("expected object of type SafeHtml, got '" + a + "' of type " + ha(a));return "type_error:SafeHtml";
  }var Hd = {};function Jd(a) {
    var b = new Gd();b.a = a;return b;
  }Jd("<!DOCTYPE html>");Jd("");Jd("<br>");function Kd(a, b) {
    a.src = vd(b);if (null === ea) b: {
      b = l.document;if ((b = b.querySelector && b.querySelector("script[nonce]")) && (b = b.nonce || b.getAttribute("nonce")) && ca.test(b)) {
        ea = b;break b;
      }ea = "";
    }b = ea;b && a.setAttribute("nonce", b);
  };function Ld(a) {
    var b = document;return m(a) ? b.getElementById(a) : a;
  }function Md(a, b) {
    Xa(b, function (c, d) {
      c && "object" == typeof c && c.na && (c = c.ma());"style" == d ? a.style.cssText = c : "class" == d ? a.className = c : "for" == d ? a.htmlFor = c : Nd.hasOwnProperty(d) ? a.setAttribute(Nd[d], c) : 0 == d.lastIndexOf("aria-", 0) || 0 == d.lastIndexOf("data-", 0) ? a.setAttribute(d, c) : a[d] = c;
    });
  }
  var Nd = { cellpadding: "cellPadding", cellspacing: "cellSpacing", colspan: "colSpan", frameborder: "frameBorder", height: "height", maxlength: "maxLength", nonce: "nonce", role: "role", rowspan: "rowSpan", type: "type", usemap: "useMap", valign: "vAlign", width: "width" };
  function Od(a, b, c) {
    var d = arguments,
        e = document,
        f = String(d[0]),
        g = d[1];if (!od && g && (g.name || g.type)) {
      f = ["<", f];g.name && f.push(' name="', cb(g.name), '"');if (g.type) {
        f.push(' type="', cb(g.type), '"');var k = {};ab(k, g);delete k.type;g = k;
      }f.push(">");f = f.join("");
    }f = e.createElement(f);g && (m(g) ? f.className = g : ja(g) ? f.className = g.join(" ") : Md(f, g));2 < d.length && Pd(e, f, d);return f;
  }
  function Pd(a, b, c) {
    function d(g) {
      g && b.appendChild(m(g) ? a.createTextNode(g) : g);
    }for (var e = 2; e < c.length; e++) {
      var f = c[e];!ka(f) || r(f) && 0 < f.nodeType ? d(f) : w(Qd(f) ? Ka(f) : f, d);
    }
  }function Qd(a) {
    if (a && "number" == typeof a.length) {
      if (r(a)) return "function" == typeof a.item || "string" == typeof a.item;if (q(a)) return "function" == typeof a.item;
    }return !1;
  };function Rd(a) {
    var b = [];Sd(new Td(), a, b);return b.join("");
  }function Td() {}
  function Sd(a, b, c) {
    if (null == b) c.push("null");else {
      if ("object" == typeof b) {
        if (ja(b)) {
          var d = b;b = d.length;c.push("[");for (var e = "", f = 0; f < b; f++) c.push(e), Sd(a, d[f], c), e = ",";c.push("]");return;
        }if (b instanceof String || b instanceof Number || b instanceof Boolean) b = b.valueOf();else {
          c.push("{");e = "";for (d in b) Object.prototype.hasOwnProperty.call(b, d) && (f = b[d], "function" != typeof f && (c.push(e), Ud(d, c), c.push(":"), Sd(a, f, c), e = ","));c.push("}");return;
        }
      }switch (typeof b) {case "string":
          Ud(b, c);break;case "number":
          c.push(isFinite(b) && !isNaN(b) ? String(b) : "null");break;case "boolean":
          c.push(String(b));break;case "function":
          c.push("null");break;default:
          throw Error("Unknown type: " + typeof b);}
    }
  }var Vd = { '"': '\\"', "\\": "\\\\", "/": "\\/", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "\t": "\\t", "\x0B": "\\u000b" },
      Wd = /\uffff/.test("\uffff") ? /[\\"\x00-\x1f\x7f-\uffff]/g : /[\\"\x00-\x1f\x7f-\xff]/g;
  function Ud(a, b) {
    b.push('"', a.replace(Wd, function (c) {
      var d = Vd[c];d || (d = "\\u" + (c.charCodeAt(0) | 65536).toString(16).substr(1), Vd[c] = d);return d;
    }), '"');
  }; /*
     Copyright 2017 Google Inc.
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
     */
  function Xd() {
    var a = J();return Pb && !!$b && 11 == $b || /Edge\/\d+/.test(a);
  }function Yd() {
    return l.window && l.window.location.href || self && self.location && self.location.href || "";
  }function Zd(a, b) {
    b = b || l.window;var c = "about:blank";a && (c = Cd(Ed(a)).toString());b.location.href = c;
  }function $d(a, b) {
    var c = [],
        d;for (d in a) d in b ? typeof a[d] != typeof b[d] ? c.push(d) : "object" == typeof a[d] && null != a[d] && null != b[d] ? 0 < $d(a[d], b[d]).length && c.push(d) : a[d] !== b[d] && c.push(d) : c.push(d);for (d in b) d in a || c.push(d);return c;
  }
  function ae() {
    var a = J();a = be(a) != ce ? null : (a = a.match(/\sChrome\/(\d+)/i)) && 2 == a.length ? parseInt(a[1], 10) : null;return a && 30 > a ? !1 : !Pb || !$b || 9 < $b;
  }function de(a) {
    a = (a || J()).toLowerCase();return a.match(/android/) || a.match(/webos/) || a.match(/iphone|ipad|ipod/) || a.match(/blackberry/) || a.match(/windows phone/) || a.match(/iemobile/) ? !0 : !1;
  }function ee(a) {
    a = a || l.window;try {
      a.close();
    } catch (b) {}
  }
  function fe(a, b, c) {
    var d = Math.floor(1E9 * Math.random()).toString();b = b || 500;c = c || 600;var e = (window.screen.availHeight - c) / 2,
        f = (window.screen.availWidth - b) / 2;b = { width: b, height: c, top: 0 < e ? e : 0, left: 0 < f ? f : 0, location: !0, resizable: !0, statusbar: !0, toolbar: !1 };c = J().toLowerCase();d && (b.target = d, y(c, "crios/") && (b.target = "_blank"));be(J()) == ge && (a = a || "http://localhost", b.scrollbars = !0);c = a || "";(a = b) || (a = {});d = window;b = c instanceof Ad ? c : Ed("undefined" != typeof c.href ? c.href : String(c));c = a.target || c.target;e = [];
    for (g in a) switch (g) {case "width":case "height":case "top":case "left":
        e.push(g + "=" + a[g]);break;case "target":case "noopener":case "noreferrer":
        break;default:
        e.push(g + "=" + (a[g] ? 1 : 0));}var g = e.join(",");(B("iPhone") && !B("iPod") && !B("iPad") || B("iPad") || B("iPod")) && d.navigator && d.navigator.standalone && c && "_self" != c ? (g = d.document.createElement("A"), b instanceof Ad || b instanceof Ad || (b = "object" == typeof b && b.na ? b.ma() : String(b), Dd.test(b) || (b = "about:invalid#zClosurez"), b = Fd(b)), g.href = Cd(b), g.setAttribute("target", c), a.noreferrer && g.setAttribute("rel", "noreferrer"), a = document.createEvent("MouseEvent"), a.initMouseEvent("click", !0, !0, d, 1), g.dispatchEvent(a), g = {}) : a.noreferrer ? (g = d.open("", c, g), a = Cd(b).toString(), g && (Rb && y(a, ";") && (a = "'" + a.replace(/'/g, "%27") + "'"), g.opener = null, a = Jd('<meta name="referrer" content="no-referrer"><meta http-equiv="refresh" content="0; url=' + cb(a) + '">'), g.document.write(Id(a)), g.document.close())) : (g = d.open(Cd(b).toString(), c, g)) && a.noopener && (g.opener = null);if (g) try {
      g.focus();
    } catch (k) {}return g;
  }
  function he(a) {
    return new C(function (b) {
      function c() {
        Jc(2E3).then(function () {
          if (!a || a.closed) b();else return c();
        });
      }return c();
    });
  }var ie = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
      je = /^[^@]+@[^@]+$/;function ke() {
    var a = null;return new C(function (b) {
      "complete" == l.document.readyState ? b() : (a = function () {
        b();
      }, uc(window, "load", a));
    }).s(function (b) {
      G(window, "load", a);throw b;
    });
  }
  function le() {
    return me(void 0) ? ke().then(function () {
      return new C(function (a, b) {
        var c = l.document,
            d = setTimeout(function () {
          b(Error("Cordova framework is not ready."));
        }, 1E3);c.addEventListener("deviceready", function () {
          clearTimeout(d);a();
        }, !1);
      });
    }) : E(Error("Cordova must run in an Android or iOS file scheme."));
  }function me(a) {
    a = a || J();return !("file:" !== ne() || !a.toLowerCase().match(/iphone|ipad|ipod|android/));
  }function oe() {
    var a = l.window;try {
      return !(!a || a == a.top);
    } catch (b) {
      return !1;
    }
  }
  function pe() {
    return "undefined" !== typeof l.WorkerGlobalScope && "function" === typeof l.importScripts;
  }function qe() {
    return __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.hasOwnProperty("reactNative") ? "ReactNative" : __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.hasOwnProperty("node") ? "Node" : pe() ? "Worker" : "Browser";
  }function re() {
    var a = qe();return "ReactNative" === a || "Node" === a;
  }function se() {
    for (var a = 50, b = []; 0 < a;) b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), a--;return b.join("");
  }
  var ge = "Firefox",
      ce = "Chrome";
  function be(a) {
    var b = a.toLowerCase();if (y(b, "opera/") || y(b, "opr/") || y(b, "opios/")) return "Opera";if (y(b, "iemobile")) return "IEMobile";if (y(b, "msie") || y(b, "trident/")) return "IE";if (y(b, "edge/")) return "Edge";if (y(b, "firefox/")) return ge;if (y(b, "silk/")) return "Silk";if (y(b, "blackberry")) return "Blackberry";if (y(b, "webos")) return "Webos";if (!y(b, "safari/") || y(b, "chrome/") || y(b, "crios/") || y(b, "android")) {
      if (!y(b, "chrome/") && !y(b, "crios/") || y(b, "edge/")) {
        if (y(b, "android")) return "Android";if ((a = a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/)) && 2 == a.length) return a[1];
      } else return ce;
    } else return "Safari";return "Other";
  }var te = { Wc: "FirebaseCore-web", Yc: "FirebaseUI-web" };function ue(a, b) {
    b = b || [];var c = [],
        d = {},
        e;for (e in te) d[te[e]] = !0;for (e = 0; e < b.length; e++) "undefined" !== typeof d[b[e]] && (delete d[b[e]], c.push(b[e]));c.sort();b = c;b.length || (b = ["FirebaseCore-web"]);c = qe();"Browser" === c ? (d = J(), c = be(d)) : "Worker" === c && (d = J(), c = be(d) + "-" + c);return c + "/JsCore/" + a + "/" + b.join(",");
  }function J() {
    return l.navigator && l.navigator.userAgent || "";
  }
  function K(a, b) {
    a = a.split(".");b = b || l;for (var c = 0; c < a.length && "object" == typeof b && null != b; c++) b = b[a[c]];c != a.length && (b = void 0);return b;
  }function ve() {
    try {
      var a = l.localStorage,
          b = we();if (a) return a.setItem(b, "1"), a.removeItem(b), Xd() ? !!l.indexedDB : !0;
    } catch (c) {
      return pe() && !!l.indexedDB;
    }return !1;
  }function xe() {
    return (ye() || "chrome-extension:" === ne() || me()) && !re() && ve() && !pe();
  }function ye() {
    return "http:" === ne() || "https:" === ne();
  }function ne() {
    return l.location && l.location.protocol || null;
  }
  function ze(a) {
    a = a || J();return de(a) || be(a) == ge ? !1 : !0;
  }function Ae(a) {
    return "undefined" === typeof a ? null : Rd(a);
  }function Be(a) {
    var b = {},
        c;for (c in a) a.hasOwnProperty(c) && null !== a[c] && void 0 !== a[c] && (b[c] = a[c]);return b;
  }function Ce(a) {
    if (null !== a) return JSON.parse(a);
  }function we(a) {
    return a ? a : Math.floor(1E9 * Math.random()).toString();
  }function De(a) {
    a = a || J();return "Safari" == be(a) || a.toLowerCase().match(/iphone|ipad|ipod/) ? !1 : !0;
  }
  function Ee() {
    var a = l.___jsl;if (a && a.H) for (var b in a.H) if (a.H[b].r = a.H[b].r || [], a.H[b].L = a.H[b].L || [], a.H[b].r = a.H[b].L.concat(), a.CP) for (var c = 0; c < a.CP.length; c++) a.CP[c] = null;
  }function Fe(a, b) {
    if (a > b) throw Error("Short delay should be less than long delay!");this.a = a;this.c = b;a = J();b = qe();this.b = de(a) || "ReactNative" === b;
  }
  Fe.prototype.get = function () {
    var a = l.navigator;return (a && "boolean" === typeof a.onLine && (ye() || "chrome-extension:" === ne() || "undefined" !== typeof a.connection) ? a.onLine : 1) ? this.b ? this.c : this.a : Math.min(5E3, this.a);
  };function Ge() {
    var a = l.document;return a && "undefined" !== typeof a.visibilityState ? "visible" == a.visibilityState : !0;
  }
  function He() {
    var a = l.document,
        b = null;return Ge() || !a ? D() : new C(function (c) {
      b = function () {
        Ge() && (a.removeEventListener("visibilitychange", b, !1), c());
      };a.addEventListener("visibilitychange", b, !1);
    }).s(function (c) {
      a.removeEventListener("visibilitychange", b, !1);throw c;
    });
  }function Ie(a) {
    try {
      var b = new Date(parseInt(a, 10));if (!isNaN(b.getTime()) && !/[^0-9]/.test(a)) return b.toUTCString();
    } catch (c) {}return null;
  }function Je() {
    return !(!K("fireauth.oauthhelper", l) && !K("fireauth.iframe", l));
  }
  function Ke() {
    var a = l.navigator;return a && a.serviceWorker && a.serviceWorker.controller || null;
  }function Le() {
    var a = l.navigator;return a && a.serviceWorker ? D().then(function () {
      return a.serviceWorker.ready;
    }).then(function (b) {
      return b.active || null;
    }).s(function () {
      return null;
    }) : D(null);
  };var Me = {};function Ne(a) {
    Me[a] || (Me[a] = !0, "undefined" !== typeof console && "function" === typeof console.warn && console.warn(a));
  };var Oe;try {
    var Pe = {};Object.defineProperty(Pe, "abcd", { configurable: !0, enumerable: !0, value: 1 });Object.defineProperty(Pe, "abcd", { configurable: !0, enumerable: !0, value: 2 });Oe = 2 == Pe.abcd;
  } catch (a) {
    Oe = !1;
  }function L(a, b, c) {
    Oe ? Object.defineProperty(a, b, { configurable: !0, enumerable: !0, value: c }) : a[b] = c;
  }function M(a, b) {
    if (b) for (var c in b) b.hasOwnProperty(c) && L(a, c, b[c]);
  }function Qe(a) {
    var b = {};M(b, a);return b;
  }function Re(a) {
    var b = {},
        c;for (c in a) a.hasOwnProperty(c) && (b[c] = a[c]);return b;
  }
  function Se(a, b) {
    if (!b || !b.length) return !0;if (!a) return !1;for (var c = 0; c < b.length; c++) {
      var d = a[b[c]];if (void 0 === d || null === d || "" === d) return !1;
    }return !0;
  }function Te(a) {
    var b = a;if ("object" == typeof a && null != a) {
      b = "length" in a ? [] : {};for (var c in a) L(b, c, Te(a[c]));
    }return b;
  };function Ue(a) {
    var b = {},
        c = a[Ve],
        d = a[We];a = a[Xe];if (!a || a != Ye && !c) throw Error("Invalid provider user info!");b[Ze] = d || null;b[$e] = c || null;L(this, af, a);L(this, bf, Te(b));
  }var Ye = "EMAIL_SIGNIN",
      Ve = "email",
      We = "newEmail",
      Xe = "requestType",
      $e = "email",
      Ze = "fromEmail",
      bf = "data",
      af = "operation";function N(a, b) {
    this.code = cf + a;this.message = b || df[a] || "";
  }u(N, Error);N.prototype.w = function () {
    return { code: this.code, message: this.message };
  };N.prototype.toJSON = function () {
    return this.w();
  };function ef(a) {
    var b = a && a.code;return b ? new N(b.substring(cf.length), a.message) : null;
  }
  var cf = "auth/",
      df = { "admin-restricted-operation": "This operation is restricted to administrators only.", "argument-error": "", "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.", "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
    "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.", "code-expired": "The SMS code has expired. Please re-send the verification code to try again.", "cordova-not-ready": "Cordova framework is not ready.", "cors-unsupported": "This browser is not supported.", "credential-already-in-use": "This credential is already associated with a different user account.", "custom-token-mismatch": "The custom token corresponds to a different audience.",
    "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.", "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.", "email-already-in-use": "The email address is already in use by another account.", "expired-action-code": "The action code has expired. ", "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.",
    "internal-error": "An internal error has occurred.", "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.", "invalid-app-id": "The mobile app identifier is not registed for the current project.", "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.", "invalid-auth-event": "An internal error has occurred.",
    "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure use the verification code provided by the user.", "invalid-continue-uri": "The continue URL provided in the request is invalid.", "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
    "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.", "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.", "invalid-email": "The email address is badly formatted.", "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.", "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.", "invalid-credential": "The supplied auth credential is malformed or has expired.",
    "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.", "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.", "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.", "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
    "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.", "wrong-password": "The password is invalid or the user does not have a password.", "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.", "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
    "invalid-provider-id": "The specified provider ID is invalid.", "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.", "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.", "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.", "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.",
    "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.", "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.", "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.", "missing-continue-uri": "A continue URL must be provided in the request.", "missing-iframe-start": "An internal error has occurred.",
    "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.", "missing-or-invalid-nonce": "The OIDC ID token requires a valid unhashed nonce.", "missing-phone-number": "To send verification codes, provide a phone number for the recipient.", "missing-verification-id": "The phone auth credential was created with an empty verification ID.", "app-deleted": "This instance of FirebaseApp has been deleted.", "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
    "network-request-failed": "A network error (such as timeout, interrupted connection or unreachable host) has occurred.", "no-auth-event": "An internal error has occurred.", "no-such-provider": "User was not linked to an account with the given provider.", "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.", "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
    "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.', "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.", "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.", "provider-already-linked": "User can only be linked to one identity for the given provider.",
    "quota-exceeded": "The project's quota for this operation has been exceeded.", "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.", "redirect-operation-pending": "A redirect sign-in operation is already pending.", "rejected-credential": "The request contains malformed or mismatching credentials.", timeout: "The operation has timed out.", "user-token-expired": "The user's credential is no longer valid. The user must sign in again.", "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.",
    "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.", "unsupported-persistence-type": "The current environment does not support the specified persistence type.", "user-cancelled": "User did not grant your application the permissions it requested.", "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.", "user-disabled": "The user account has been disabled by an administrator.",
    "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.", "user-signed-out": "", "weak-password": "The password must be 6 characters long or more.", "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled." };function ff(a) {
    var b = a[gf];if ("undefined" === typeof b) throw new N("missing-continue-uri");if ("string" !== typeof b || "string" === typeof b && !b.length) throw new N("invalid-continue-uri");this.h = b;this.b = this.a = null;this.g = !1;var c = a[hf];if (c && "object" === typeof c) {
      b = c[jf];var d = c[kf];c = c[lf];if ("string" === typeof b && b.length) {
        this.a = b;if ("undefined" !== typeof d && "boolean" !== typeof d) throw new N("argument-error", kf + " property must be a boolean when specified.");this.g = !!d;if ("undefined" !== typeof c && ("string" !== typeof c || "string" === typeof c && !c.length)) throw new N("argument-error", lf + " property must be a non empty string when specified.");this.b = c || null;
      } else {
        if ("undefined" !== typeof b) throw new N("argument-error", jf + " property must be a non empty string when specified.");if ("undefined" !== typeof d || "undefined" !== typeof c) throw new N("missing-android-pkg-name");
      }
    } else if ("undefined" !== typeof c) throw new N("argument-error", hf + " property must be a non null object when specified.");this.f = null;if ((b = a[mf]) && "object" === typeof b) {
      if (b = b[nf], "string" === typeof b && b.length) this.f = b;else {
        if ("undefined" !== typeof b) throw new N("argument-error", nf + " property must be a non empty string when specified.");
      }
    } else if ("undefined" !== typeof b) throw new N("argument-error", mf + " property must be a non null object when specified.");b = a[of];if ("undefined" !== typeof b && "boolean" !== typeof b) throw new N("argument-error", of + " property must be a boolean when specified.");this.c = !!b;a = a[pf];if ("undefined" !== typeof a && ("string" !== typeof a || "string" === typeof a && !a.length)) throw new N("argument-error", pf + " property must be a non empty string when specified.");this.i = a || null;
  }var hf = "android",
      pf = "dynamicLinkDomain",
      of = "handleCodeInApp",
      mf = "iOS",
      gf = "url",
      kf = "installApp",
      lf = "minimumVersion",
      jf = "packageName",
      nf = "bundleId";
  function qf(a) {
    var b = {};b.continueUrl = a.h;b.canHandleCodeInApp = a.c;if (b.androidPackageName = a.a) b.androidMinimumVersion = a.b, b.androidInstallApp = a.g;b.iOSBundleId = a.f;b.dynamicLinkDomain = a.i;for (var c in b) null === b[c] && delete b[c];return b;
  };function rf(a) {
    return Da(a, function (b) {
      b = b.toString(16);return 1 < b.length ? b : "0" + b;
    }).join("");
  };var sf = null,
      tf = null;function uf(a) {
    var b = "";vf(a, function (c) {
      b += String.fromCharCode(c);
    });return b;
  }function vf(a, b) {
    function c(n) {
      for (; d < a.length;) {
        var p = a.charAt(d++),
            z = tf[p];if (null != z) return z;if (!/^[\s\xa0]*$/.test(p)) throw Error("Unknown base64 encoding at char: " + p);
      }return n;
    }wf();for (var d = 0;;) {
      var e = c(-1),
          f = c(0),
          g = c(64),
          k = c(64);if (64 === k && -1 === e) break;b(e << 2 | f >> 4);64 != g && (b(f << 4 & 240 | g >> 2), 64 != k && b(g << 6 & 192 | k));
    }
  }
  function wf() {
    if (!sf) {
      sf = {};tf = {};for (var a = 0; 65 > a; a++) sf[a] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a), tf[sf[a]] = a, 62 <= a && (tf["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a)] = a);
    }
  };function xf(a) {
    this.c = a.sub;qa();this.a = a.provider_id || a.firebase && a.firebase.sign_in_provider || null;this.b = !!a.is_anonymous || "anonymous" == this.a;
  }xf.prototype.f = function () {
    return this.b;
  };function yf(a) {
    return (a = zf(a)) && a.sub && a.iss && a.aud && a.exp ? new xf(a) : null;
  }function zf(a) {
    if (!a) return null;a = a.split(".");if (3 != a.length) return null;a = a[1];for (var b = (4 - a.length % 4) % 4, c = 0; c < b; c++) a += ".";try {
      return JSON.parse(uf(a));
    } catch (d) {}return null;
  };var Af = { bd: { bb: "https://www.googleapis.com/identitytoolkit/v3/relyingparty/", jb: "https://securetoken.googleapis.com/v1/token", id: "p" }, dd: { bb: "https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/", jb: "https://staging-securetoken.sandbox.googleapis.com/v1/token", id: "s" }, ed: { bb: "https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/", jb: "https://test-securetoken.sandbox.googleapis.com/v1/token", id: "t" } };
  function Bf(a) {
    for (var b in Af) if (Af[b].id === a) return a = Af[b], { firebaseEndpoint: a.bb, secureTokenEndpoint: a.jb };return null;
  }var Cf;Cf = Bf("__EID__") ? "__EID__" : void 0;var Df = "oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version".split(" "),
      Ef = ["client_id", "response_type", "scope", "redirect_uri", "state"],
      Ff = { Xc: { Na: "locale", Ba: 500, Aa: 600, Oa: "facebook.com", ib: Ef }, Zc: { Na: null, Ba: 500, Aa: 620, Oa: "github.com", ib: Ef }, $c: { Na: "hl", Ba: 515, Aa: 680, Oa: "google.com", ib: Ef }, fd: { Na: "lang", Ba: 485, Aa: 705, Oa: "twitter.com", ib: Df } };function Gf(a) {
    for (var b in Ff) if (Ff[b].Oa == a) return Ff[b];return null;
  };function Hf(a) {
    var b = {};b["facebook.com"] = If;b["google.com"] = Jf;b["github.com"] = Kf;b["twitter.com"] = Lf;var c = a && a[Mf];try {
      if (c) return b[c] ? new b[c](a) : new Nf(a);if ("undefined" !== typeof a[Of]) return new Pf(a);
    } catch (d) {}return null;
  }var Of = "idToken",
      Mf = "providerId";
  function Pf(a) {
    var b = a[Mf];if (!b && a[Of]) {
      var c = yf(a[Of]);c && c.a && (b = c.a);
    }if (!b) throw Error("Invalid additional user info!");if ("anonymous" == b || "custom" == b) b = null;c = !1;"undefined" !== typeof a.isNewUser ? c = !!a.isNewUser : "identitytoolkit#SignupNewUserResponse" === a.kind && (c = !0);L(this, "providerId", b);L(this, "isNewUser", c);
  }function Nf(a) {
    Pf.call(this, a);a = Ce(a.rawUserInfo || "{}");L(this, "profile", Te(a || {}));
  }u(Nf, Pf);
  function If(a) {
    Nf.call(this, a);if ("facebook.com" != this.providerId) throw Error("Invalid provider ID!");
  }u(If, Nf);function Kf(a) {
    Nf.call(this, a);if ("github.com" != this.providerId) throw Error("Invalid provider ID!");L(this, "username", this.profile && this.profile.login || null);
  }u(Kf, Nf);function Jf(a) {
    Nf.call(this, a);if ("google.com" != this.providerId) throw Error("Invalid provider ID!");
  }u(Jf, Nf);
  function Lf(a) {
    Nf.call(this, a);if ("twitter.com" != this.providerId) throw Error("Invalid provider ID!");L(this, "username", a.screenName || null);
  }u(Lf, Nf);function Qf(a) {
    this.a = fd(a);
  };function Rf(a) {
    var b = fd(a),
        c = ed(b, "link"),
        d = ed(fd(c), "link");b = ed(b, "deep_link_id");return ed(fd(b), "link") || b || d || c || a;
  };function Sf() {}function Tf(a, b) {
    return a.then(function (c) {
      if (c[Uf]) {
        var d = yf(c[Uf]);if (!d || b != d.c) throw new N("user-mismatch");return c;
      }throw new N("user-mismatch");
    }).s(function (c) {
      throw c && c.code && c.code == cf + "user-not-found" ? new N("user-mismatch") : c;
    });
  }function Vf(a, b) {
    if (b) this.a = b;else throw new N("internal-error", "failed to construct a credential");L(this, "providerId", a);L(this, "signInMethod", a);
  }Vf.prototype.la = function (a) {
    return Wf(a, Xf(this));
  };
  Vf.prototype.b = function (a, b) {
    var c = Xf(this);c.idToken = b;return Yf(a, c);
  };Vf.prototype.f = function (a, b) {
    return Tf(Zf(a, Xf(this)), b);
  };function Xf(a) {
    return { pendingToken: a.a, requestUri: "http://localhost" };
  }Vf.prototype.w = function () {
    return { providerId: this.providerId, signInMethod: this.signInMethod, pendingToken: this.a };
  };function $f(a) {
    if (a && a.providerId && a.signInMethod && 0 == a.providerId.indexOf("saml.") && a.pendingToken) try {
      return new Vf(a.providerId, a.pendingToken);
    } catch (b) {}return null;
  }
  function ag(a, b, c) {
    this.a = null;if (b.idToken || b.accessToken) b.idToken && L(this, "idToken", b.idToken), b.accessToken && L(this, "accessToken", b.accessToken), b.nonce && !b.pendingToken && L(this, "nonce", b.nonce), b.pendingToken && (this.a = b.pendingToken);else if (b.oauthToken && b.oauthTokenSecret) L(this, "accessToken", b.oauthToken), L(this, "secret", b.oauthTokenSecret);else throw new N("internal-error", "failed to construct a credential");L(this, "providerId", a);L(this, "signInMethod", c);
  }
  ag.prototype.la = function (a) {
    return Wf(a, bg(this));
  };ag.prototype.b = function (a, b) {
    var c = bg(this);c.idToken = b;return Yf(a, c);
  };ag.prototype.f = function (a, b) {
    var c = bg(this);return Tf(Zf(a, c), b);
  };
  function bg(a) {
    var b = {};a.idToken && (b.id_token = a.idToken);a.accessToken && (b.access_token = a.accessToken);a.secret && (b.oauth_token_secret = a.secret);b.providerId = a.providerId;a.nonce && !a.a && (b.nonce = a.nonce);b = { postBody: jd(b).toString(), requestUri: "http://localhost" };a.a && (delete b.postBody, b.pendingToken = a.a);return b;
  }
  ag.prototype.w = function () {
    var a = { providerId: this.providerId, signInMethod: this.signInMethod };this.idToken && (a.oauthIdToken = this.idToken);this.accessToken && (a.oauthAccessToken = this.accessToken);this.secret && (a.oauthTokenSecret = this.secret);this.nonce && (a.nonce = this.nonce);this.a && (a.pendingToken = this.a);return a;
  };
  function cg(a) {
    if (a && a.providerId && a.signInMethod) {
      var b = { idToken: a.oauthIdToken, accessToken: a.oauthTokenSecret ? null : a.oauthAccessToken, oauthTokenSecret: a.oauthTokenSecret, oauthToken: a.oauthTokenSecret && a.oauthAccessToken, nonce: a.nonce, pendingToken: a.pendingToken };try {
        return new ag(a.providerId, b, a.signInMethod);
      } catch (c) {}
    }return null;
  }function dg(a, b) {
    this.Fc = b || [];M(this, { providerId: a, isOAuthProvider: !0 });this.zb = {};this.eb = (Gf(a) || {}).Na || null;this.ab = null;
  }
  dg.prototype.Da = function (a) {
    this.zb = Za(a);return this;
  };function eg(a) {
    if ("string" !== typeof a || 0 != a.indexOf("saml.")) throw new N("argument-error", 'SAML provider IDs must be prefixed with "saml."');dg.call(this, a, []);
  }u(eg, dg);function O(a) {
    dg.call(this, a, Ef);this.a = [];
  }u(O, dg);O.prototype.ua = function (a) {
    Ha(this.a, a) || this.a.push(a);return this;
  };O.prototype.Fb = function () {
    return Ka(this.a);
  };
  O.prototype.credential = function (a, b) {
    var c;r(a) ? c = { idToken: a.idToken || null, accessToken: a.accessToken || null, nonce: a.rawNonce || null } : c = { idToken: a || null, accessToken: b || null };if (!c.idToken && !c.accessToken) throw new N("argument-error", "credential failed: must provide the ID token and/or the access token.");return new ag(this.providerId, c, this.providerId);
  };function fg() {
    O.call(this, "facebook.com");
  }u(fg, O);L(fg, "PROVIDER_ID", "facebook.com");L(fg, "FACEBOOK_SIGN_IN_METHOD", "facebook.com");
  function gg(a) {
    if (!a) throw new N("argument-error", "credential failed: expected 1 argument (the OAuth access token).");var b = a;r(a) && (b = a.accessToken);return new fg().credential({ accessToken: b });
  }function hg() {
    O.call(this, "github.com");
  }u(hg, O);L(hg, "PROVIDER_ID", "github.com");L(hg, "GITHUB_SIGN_IN_METHOD", "github.com");
  function ig(a) {
    if (!a) throw new N("argument-error", "credential failed: expected 1 argument (the OAuth access token).");var b = a;r(a) && (b = a.accessToken);return new hg().credential({ accessToken: b });
  }function jg() {
    O.call(this, "google.com");this.ua("profile");
  }u(jg, O);L(jg, "PROVIDER_ID", "google.com");L(jg, "GOOGLE_SIGN_IN_METHOD", "google.com");function kg(a, b) {
    var c = a;r(a) && (c = a.idToken, b = a.accessToken);return new jg().credential({ idToken: c, accessToken: b });
  }function lg() {
    dg.call(this, "twitter.com", Df);
  }u(lg, dg);
  L(lg, "PROVIDER_ID", "twitter.com");L(lg, "TWITTER_SIGN_IN_METHOD", "twitter.com");function mg(a, b) {
    var c = a;r(c) || (c = { oauthToken: a, oauthTokenSecret: b });if (!c.oauthToken || !c.oauthTokenSecret) throw new N("argument-error", "credential failed: expected 2 arguments (the OAuth access token and secret).");return new ag("twitter.com", c, "twitter.com");
  }
  function ng(a, b, c) {
    this.a = a;this.c = b;L(this, "providerId", "password");L(this, "signInMethod", c === og.EMAIL_LINK_SIGN_IN_METHOD ? og.EMAIL_LINK_SIGN_IN_METHOD : og.EMAIL_PASSWORD_SIGN_IN_METHOD);
  }ng.prototype.la = function (a) {
    return this.signInMethod == og.EMAIL_LINK_SIGN_IN_METHOD ? P(a, pg, { email: this.a, oobCode: this.c }) : P(a, qg, { email: this.a, password: this.c });
  };
  ng.prototype.b = function (a, b) {
    return this.signInMethod == og.EMAIL_LINK_SIGN_IN_METHOD ? P(a, rg, { idToken: b, email: this.a, oobCode: this.c }) : P(a, sg, { idToken: b, email: this.a, password: this.c });
  };ng.prototype.f = function (a, b) {
    return Tf(this.la(a), b);
  };ng.prototype.w = function () {
    return { email: this.a, password: this.c, signInMethod: this.signInMethod };
  };function tg(a) {
    return a && a.email && a.password ? new ng(a.email, a.password, a.signInMethod) : null;
  }function og() {
    M(this, { providerId: "password", isOAuthProvider: !1 });
  }
  function ug(a, b) {
    b = vg(b);if (!b) throw new N("argument-error", "Invalid email link!");return new ng(a, b, og.EMAIL_LINK_SIGN_IN_METHOD);
  }function vg(a) {
    a = Rf(a);a = new Qf(a);var b = ed(a.a, "oobCode") || null;return "signIn" === (ed(a.a, "mode") || null) && b ? b : null;
  }M(og, { PROVIDER_ID: "password" });M(og, { EMAIL_LINK_SIGN_IN_METHOD: "emailLink" });M(og, { EMAIL_PASSWORD_SIGN_IN_METHOD: "password" });
  function wg(a) {
    if (!(a.Ua && a.Ta || a.Fa && a.$)) throw new N("internal-error");this.a = a;L(this, "providerId", "phone");L(this, "signInMethod", "phone");
  }wg.prototype.la = function (a) {
    return a.Va(xg(this));
  };wg.prototype.b = function (a, b) {
    var c = xg(this);c.idToken = b;return P(a, yg, c);
  };wg.prototype.f = function (a, b) {
    var c = xg(this);c.operation = "REAUTH";a = P(a, zg, c);return Tf(a, b);
  };
  wg.prototype.w = function () {
    var a = { providerId: "phone" };this.a.Ua && (a.verificationId = this.a.Ua);this.a.Ta && (a.verificationCode = this.a.Ta);this.a.Fa && (a.temporaryProof = this.a.Fa);this.a.$ && (a.phoneNumber = this.a.$);return a;
  };function Ag(a) {
    if (a && "phone" === a.providerId && (a.verificationId && a.verificationCode || a.temporaryProof && a.phoneNumber)) {
      var b = {};w(["verificationId", "verificationCode", "temporaryProof", "phoneNumber"], function (c) {
        a[c] && (b[c] = a[c]);
      });return new wg(b);
    }return null;
  }
  function xg(a) {
    return a.a.Fa && a.a.$ ? { temporaryProof: a.a.Fa, phoneNumber: a.a.$ } : { sessionInfo: a.a.Ua, code: a.a.Ta };
  }function Bg(a) {
    try {
      this.a = a || __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.auth();
    } catch (b) {
      throw new N("argument-error", "Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().");
    }M(this, { providerId: "phone", isOAuthProvider: !1 });
  }
  Bg.prototype.Va = function (a, b) {
    var c = this.a.b;return D(b.verify()).then(function (d) {
      if (!m(d)) throw new N("argument-error", "An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.");switch (b.type) {case "recaptcha":
          return Cg(c, { phoneNumber: a, recaptchaToken: d }).then(function (e) {
            "function" === typeof b.reset && b.reset();return e;
          }, function (e) {
            "function" === typeof b.reset && b.reset();throw e;
          });default:
          throw new N("argument-error", 'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');}
    });
  };function Dg(a, b) {
    if (!a) throw new N("missing-verification-id");if (!b) throw new N("missing-verification-code");return new wg({ Ua: a, Ta: b });
  }M(Bg, { PROVIDER_ID: "phone" });M(Bg, { PHONE_SIGN_IN_METHOD: "phone" });
  function Eg(a) {
    if (a.temporaryProof && a.phoneNumber) return new wg({ Fa: a.temporaryProof, $: a.phoneNumber });var b = a && a.providerId;if (!b || "password" === b) return null;var c = a && a.oauthAccessToken,
        d = a && a.oauthTokenSecret,
        e = a && a.nonce,
        f = a && a.oauthIdToken,
        g = a && a.pendingToken;try {
      switch (b) {case "google.com":
          return kg(f, c);case "facebook.com":
          return gg(c);case "github.com":
          return ig(c);case "twitter.com":
          return mg(c, d);default:
          return c || d || f || g ? g ? 0 == b.indexOf("saml.") ? new Vf(b, g) : new ag(b, { pendingToken: g, idToken: a.oauthIdToken,
            accessToken: a.oauthAccessToken }, b) : new O(b).credential({ idToken: f, accessToken: c, rawNonce: e }) : null;}
    } catch (k) {
      return null;
    }
  }function Fg(a) {
    if (!a.isOAuthProvider) throw new N("invalid-oauth-provider");
  };function Gg(a, b, c, d, e, f) {
    this.c = a;this.b = b || null;this.g = c || null;this.f = d || null;this.h = f || null;this.a = e || null;if (this.g || this.a) {
      if (this.g && this.a) throw new N("invalid-auth-event");if (this.g && !this.f) throw new N("invalid-auth-event");
    } else throw new N("invalid-auth-event");
  }Gg.prototype.getUid = function () {
    var a = [];a.push(this.c);this.b && a.push(this.b);this.f && a.push(this.f);this.i && a.push(this.i);return a.join("-");
  };
  Gg.prototype.w = function () {
    return { type: this.c, eventId: this.b, urlResponse: this.g, sessionId: this.f, postBody: this.h, error: this.a && this.a.w() };
  };function Hg(a) {
    a = a || {};return a.type ? new Gg(a.type, a.eventId, a.urlResponse, a.sessionId, a.error && ef(a.error), a.postBody) : null;
  }; /*
     Copyright 2018 Google Inc.
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
     */
  function Ig() {
    this.b = null;this.a = [];
  }var Jg = null;Ig.prototype.subscribe = function (a) {
    var b = this;this.a.push(a);this.b || (this.b = function (c) {
      for (var d = 0; d < b.a.length; d++) b.a[d](c);
    }, a = K("universalLinks.subscribe", l), "function" === typeof a && a(null, this.b));
  };Ig.prototype.unsubscribe = function (a) {
    x(this.a, function (b) {
      return b == a;
    });
  };function Kg(a) {
    var b = "unauthorized-domain",
        c = void 0,
        d = fd(a);a = d.b;d = d.c;"chrome-extension" == d ? c = bb("This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : "http" == d || "https" == d ? c = bb("This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : b = "operation-not-supported-in-this-environment";
    N.call(this, b, c);
  }u(Kg, N);function Lg(a, b, c) {
    N.call(this, a, c);a = b || {};a.Ab && L(this, "email", a.Ab);a.$ && L(this, "phoneNumber", a.$);a.credential && L(this, "credential", a.credential);
  }u(Lg, N);Lg.prototype.w = function () {
    var a = { code: this.code, message: this.message };this.email && (a.email = this.email);this.phoneNumber && (a.phoneNumber = this.phoneNumber);var b = this.credential && this.credential.w();b && ab(a, b);return a;
  };Lg.prototype.toJSON = function () {
    return this.w();
  };
  function Mg(a) {
    if (a.code) {
      var b = a.code || "";0 == b.indexOf(cf) && (b = b.substring(cf.length));var c = { credential: Eg(a) };if (a.email) c.Ab = a.email;else if (a.phoneNumber) c.$ = a.phoneNumber;else if (!c.credential) return new N(b, a.message || void 0);return new Lg(b, c, a.message);
    }return null;
  };function Ng() {}Ng.prototype.c = null;function Og(a) {
    return a.c || (a.c = a.b());
  };var Pg;function Qg() {}u(Qg, Ng);Qg.prototype.a = function () {
    var a = Rg(this);return a ? new ActiveXObject(a) : new XMLHttpRequest();
  };Qg.prototype.b = function () {
    var a = {};Rg(this) && (a[0] = !0, a[1] = !0);return a;
  };
  function Rg(a) {
    if (!a.f && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
      for (var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0; c < b.length; c++) {
        var d = b[c];try {
          return new ActiveXObject(d), a.f = d;
        } catch (e) {}
      }throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
    }return a.f;
  }Pg = new Qg();function Sg() {}u(Sg, Ng);Sg.prototype.a = function () {
    var a = new XMLHttpRequest();if ("withCredentials" in a) return a;if ("undefined" != typeof XDomainRequest) return new Tg();throw Error("Unsupported browser");
  };Sg.prototype.b = function () {
    return {};
  };
  function Tg() {
    this.a = new XDomainRequest();this.readyState = 0;this.onreadystatechange = null;this.responseType = this.responseText = this.response = "";this.status = -1;this.statusText = "";this.a.onload = t(this.fc, this);this.a.onerror = t(this.Gb, this);this.a.onprogress = t(this.gc, this);this.a.ontimeout = t(this.kc, this);
  }h = Tg.prototype;h.open = function (a, b, c) {
    if (null != c && !c) throw Error("Only async requests are supported.");this.a.open(a, b);
  };
  h.send = function (a) {
    if (a) {
      if ("string" == typeof a) this.a.send(a);else throw Error("Only string data is supported");
    } else this.a.send();
  };h.abort = function () {
    this.a.abort();
  };h.setRequestHeader = function () {};h.getResponseHeader = function (a) {
    return "content-type" == a.toLowerCase() ? this.a.contentType : "";
  };h.fc = function () {
    this.status = 200;this.response = this.responseText = this.a.responseText;Ug(this, 4);
  };h.Gb = function () {
    this.status = 500;this.response = this.responseText = "";Ug(this, 4);
  };h.kc = function () {
    this.Gb();
  };
  h.gc = function () {
    this.status = 200;Ug(this, 1);
  };function Ug(a, b) {
    a.readyState = b;if (a.onreadystatechange) a.onreadystatechange();
  }h.getAllResponseHeaders = function () {
    return "content-type: " + this.a.contentType;
  };function Vg(a, b, c) {
    this.reset(a, b, c, void 0, void 0);
  }Vg.prototype.a = null;var Wg = 0;Vg.prototype.reset = function (a, b, c, d, e) {
    "number" == typeof e || Wg++;d || qa();delete this.a;
  };function Xg(a) {
    this.f = a;this.b = this.c = this.a = null;
  }function Yg(a, b) {
    this.name = a;this.value = b;
  }Yg.prototype.toString = function () {
    return this.name;
  };var Zg = new Yg("SEVERE", 1E3),
      $g = new Yg("WARNING", 900),
      ah = new Yg("CONFIG", 700),
      bh = new Yg("FINE", 500);function ch(a) {
    if (a.c) return a.c;if (a.a) return ch(a.a);ta("Root logger has no level set.");return null;
  }Xg.prototype.log = function (a, b, c) {
    if (a.value >= ch(this).value) for (q(b) && (b = b()), a = new Vg(a, String(b), this.f), c && (a.a = c), c = this; c;) c = c.a;
  };var dh = {},
      eh = null;
  function fh(a) {
    eh || (eh = new Xg(""), dh[""] = eh, eh.c = ah);var b;if (!(b = dh[a])) {
      b = new Xg(a);var c = a.lastIndexOf("."),
          d = a.substr(c + 1);c = fh(a.substr(0, c));c.b || (c.b = {});c.b[d] = b;b.a = c;dh[a] = b;
    }return b;
  };function gh(a, b) {
    a && a.log(bh, b, void 0);
  };function hh(a) {
    this.f = a;
  }u(hh, Ng);hh.prototype.a = function () {
    return new ih(this.f);
  };hh.prototype.b = function (a) {
    return function () {
      return a;
    };
  }({});function ih(a) {
    H.call(this);this.u = a;this.readyState = jh;this.status = 0;this.responseType = this.responseText = this.response = this.statusText = "";this.onreadystatechange = null;this.i = new Headers();this.b = null;this.m = "GET";this.g = "";this.a = !1;this.h = fh("goog.net.FetchXmlHttp");this.l = this.c = this.f = null;
  }u(ih, H);var jh = 0;h = ih.prototype;
  h.open = function (a, b) {
    if (this.readyState != jh) throw this.abort(), Error("Error reopening a connection");this.m = a;this.g = b;this.readyState = 1;kh(this);
  };h.send = function (a) {
    if (1 != this.readyState) throw this.abort(), Error("need to call open() first. ");this.a = !0;var b = { headers: this.i, method: this.m, credentials: void 0, cache: void 0 };a && (b.body = a);this.u.fetch(new Request(this.g, b)).then(this.jc.bind(this), this.La.bind(this));
  };
  h.abort = function () {
    this.response = this.responseText = "";this.i = new Headers();this.status = 0;this.c && this.c.cancel("Request was aborted.");1 <= this.readyState && this.a && 4 != this.readyState && (this.a = !1, lh(this, !1));this.readyState = jh;
  };
  h.jc = function (a) {
    this.a && (this.f = a, this.b || (this.b = a.headers, this.readyState = 2, kh(this)), this.a && (this.readyState = 3, kh(this), this.a && ("arraybuffer" === this.responseType ? a.arrayBuffer().then(this.hc.bind(this), this.La.bind(this)) : "undefined" !== typeof l.ReadableStream && "body" in a ? (this.response = this.responseText = "", this.c = a.body.getReader(), this.l = new TextDecoder(), mh(this)) : a.text().then(this.ic.bind(this), this.La.bind(this)))));
  };function mh(a) {
    a.c.read().then(a.ec.bind(a)).catch(a.La.bind(a));
  }
  h.ec = function (a) {
    if (this.a) {
      var b = this.l.decode(a.value ? a.value : new Uint8Array(0), { stream: !a.done });b && (this.response = this.responseText += b);a.done ? lh(this, !0) : kh(this);3 == this.readyState && mh(this);
    }
  };h.ic = function (a) {
    this.a && (this.response = this.responseText = a, lh(this, !0));
  };h.hc = function (a) {
    this.a && (this.response = a, lh(this, !0));
  };h.La = function (a) {
    var b = this.h;b && b.log($g, "Failed to fetch url " + this.g, a instanceof Error ? a : Error(a));this.a && lh(this, !0);
  };
  function lh(a, b) {
    b && a.f && (a.status = a.f.status, a.statusText = a.f.statusText);a.readyState = 4;a.f = null;a.c = null;a.l = null;kh(a);
  }h.setRequestHeader = function (a, b) {
    this.i.append(a, b);
  };h.getResponseHeader = function (a) {
    return this.b ? this.b.get(a.toLowerCase()) || "" : ((a = this.h) && a.log($g, "Attempting to get response header but no headers have been received for url: " + this.g, void 0), "");
  };
  h.getAllResponseHeaders = function () {
    if (!this.b) {
      var a = this.h;a && a.log($g, "Attempting to get all response headers but no headers have been received for url: " + this.g, void 0);return "";
    }a = [];for (var b = this.b.entries(), c = b.next(); !c.done;) c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();return a.join("\r\n");
  };function kh(a) {
    a.onreadystatechange && a.onreadystatechange.call(a);
  };function nh(a) {
    H.call(this);this.headers = new Nc();this.D = a || null;this.c = !1;this.A = this.a = null;this.h = this.N = this.l = "";this.f = this.I = this.i = this.G = !1;this.g = 0;this.u = null;this.m = oh;this.v = this.O = !1;
  }u(nh, H);var oh = "";nh.prototype.b = fh("goog.net.XhrIo");var ph = /^https?$/i,
      qh = ["POST", "PUT"];
  function rh(a, b, c, d, e) {
    if (a.a) throw Error("[goog.net.XhrIo] Object is active with another request=" + a.l + "; newUri=" + b);c = c ? c.toUpperCase() : "GET";a.l = b;a.h = "";a.N = c;a.G = !1;a.c = !0;a.a = a.D ? a.D.a() : Pg.a();a.A = a.D ? Og(a.D) : Og(Pg);a.a.onreadystatechange = t(a.Jb, a);try {
      gh(a.b, sh(a, "Opening Xhr")), a.I = !0, a.a.open(c, String(b), !0), a.I = !1;
    } catch (g) {
      gh(a.b, sh(a, "Error opening Xhr: " + g.message));th(a, g);return;
    }b = d || "";var f = new Nc(a.headers);e && Mc(e, function (g, k) {
      f.set(k, g);
    });e = Fa(f.U());d = l.FormData && b instanceof l.FormData;!Ha(qh, c) || e || d || f.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");f.forEach(function (g, k) {
      this.a.setRequestHeader(k, g);
    }, a);a.m && (a.a.responseType = a.m);"withCredentials" in a.a && a.a.withCredentials !== a.O && (a.a.withCredentials = a.O);try {
      uh(a), 0 < a.g && (a.v = vh(a.a), gh(a.b, sh(a, "Will abort after " + a.g + "ms if incomplete, xhr2 " + a.v)), a.v ? (a.a.timeout = a.g, a.a.ontimeout = t(a.Ga, a)) : a.u = Ic(a.Ga, a.g, a)), gh(a.b, sh(a, "Sending request")), a.i = !0, a.a.send(b), a.i = !1;
    } catch (g) {
      gh(a.b, sh(a, "Send error: " + g.message)), th(a, g);
    }
  }function vh(a) {
    return Pb && Zb(9) && "number" == typeof a.timeout && void 0 !== a.ontimeout;
  }function Ga(a) {
    return "content-type" == a.toLowerCase();
  }h = nh.prototype;h.Ga = function () {
    "undefined" != typeof aa && this.a && (this.h = "Timed out after " + this.g + "ms, aborting", gh(this.b, sh(this, this.h)), this.dispatchEvent("timeout"), this.abort(8));
  };function th(a, b) {
    a.c = !1;a.a && (a.f = !0, a.a.abort(), a.f = !1);a.h = b;wh(a);xh(a);
  }
  function wh(a) {
    a.G || (a.G = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"));
  }h.abort = function () {
    this.a && this.c && (gh(this.b, sh(this, "Aborting")), this.c = !1, this.f = !0, this.a.abort(), this.f = !1, this.dispatchEvent("complete"), this.dispatchEvent("abort"), xh(this));
  };h.va = function () {
    this.a && (this.c && (this.c = !1, this.f = !0, this.a.abort(), this.f = !1), xh(this, !0));nh.pb.va.call(this);
  };h.Jb = function () {
    this.qa || (this.I || this.i || this.f ? yh(this) : this.yc());
  };h.yc = function () {
    yh(this);
  };
  function yh(a) {
    if (a.c && "undefined" != typeof aa) if (a.A[1] && 4 == zh(a) && 2 == Ah(a)) gh(a.b, sh(a, "Local request error detected and ignored"));else if (a.i && 4 == zh(a)) Ic(a.Jb, 0, a);else if (a.dispatchEvent("readystatechange"), 4 == zh(a)) {
      gh(a.b, sh(a, "Request complete"));a.c = !1;try {
        var b = Ah(a);a: switch (b) {case 200:case 201:case 202:case 204:case 206:case 304:case 1223:
            var c = !0;break a;default:
            c = !1;}var d;if (!(d = c)) {
          var e;if (e = 0 === b) {
            var f = String(a.l).match(Qc)[1] || null;if (!f && l.self && l.self.location) {
              var g = l.self.location.protocol;
              f = g.substr(0, g.length - 1);
            }e = !ph.test(f ? f.toLowerCase() : "");
          }d = e;
        }if (d) a.dispatchEvent("complete"), a.dispatchEvent("success");else {
          try {
            var k = 2 < zh(a) ? a.a.statusText : "";
          } catch (n) {
            gh(a.b, "Can not get status: " + n.message), k = "";
          }a.h = k + " [" + Ah(a) + "]";wh(a);
        }
      } finally {
        xh(a);
      }
    }
  }function xh(a, b) {
    if (a.a) {
      uh(a);var c = a.a,
          d = a.A[0] ? fa : null;a.a = null;a.A = null;b || a.dispatchEvent("ready");try {
        c.onreadystatechange = d;
      } catch (e) {
        (a = a.b) && a.log(Zg, "Problem encountered resetting onreadystatechange: " + e.message, void 0);
      }
    }
  }
  function uh(a) {
    a.a && a.v && (a.a.ontimeout = null);a.u && (l.clearTimeout(a.u), a.u = null);
  }function zh(a) {
    return a.a ? a.a.readyState : 0;
  }function Ah(a) {
    try {
      return 2 < zh(a) ? a.a.status : -1;
    } catch (b) {
      return -1;
    }
  }function Bh(a) {
    try {
      return a.a ? a.a.responseText : "";
    } catch (b) {
      return gh(a.b, "Can not get responseText: " + b.message), "";
    }
  }
  h.getResponse = function () {
    try {
      if (!this.a) return null;if ("response" in this.a) return this.a.response;switch (this.m) {case oh:case "text":
          return this.a.responseText;case "arraybuffer":
          if ("mozResponseArrayBuffer" in this.a) return this.a.mozResponseArrayBuffer;}var a = this.b;a && a.log(Zg, "Response type " + this.m + " is not supported on this browser", void 0);return null;
    } catch (b) {
      return gh(this.b, "Can not get response: " + b.message), null;
    }
  };function sh(a, b) {
    return b + " [" + a.N + " " + a.l + " " + Ah(a) + "]";
  }; /*
     Portions of this code are from MochiKit, received by
     The Closure Authors under the MIT license. All other code is Copyright
     2005-2009 The Closure Authors. All Rights Reserved.
     */
  function Ch(a) {
    var b = Dh;this.g = [];this.v = b;this.u = a || null;this.f = this.a = !1;this.c = void 0;this.l = this.A = this.i = !1;this.h = 0;this.b = null;this.o = 0;
  }Ch.prototype.cancel = function (a) {
    if (this.a) this.c instanceof Ch && this.c.cancel();else {
      if (this.b) {
        var b = this.b;delete this.b;a ? b.cancel(a) : (b.o--, 0 >= b.o && b.cancel());
      }this.v ? this.v.call(this.u, this) : this.l = !0;this.a || (a = new Eh(this), Fh(this), Gh(this, !1, a));
    }
  };Ch.prototype.m = function (a, b) {
    this.i = !1;Gh(this, a, b);
  };function Gh(a, b, c) {
    a.a = !0;a.c = c;a.f = !b;Hh(a);
  }
  function Fh(a) {
    if (a.a) {
      if (!a.l) throw new Ih(a);a.l = !1;
    }
  }function Jh(a, b) {
    Kh(a, null, b, void 0);
  }function Kh(a, b, c, d) {
    a.g.push([b, c, d]);a.a && Hh(a);
  }Ch.prototype.then = function (a, b, c) {
    var d,
        e,
        f = new C(function (g, k) {
      d = g;e = k;
    });Kh(this, d, function (g) {
      g instanceof Eh ? f.cancel() : e(g);
    });return f.then(a, b, c);
  };Ch.prototype.$goog_Thenable = !0;function Lh(a) {
    return Ea(a.g, function (b) {
      return q(b[1]);
    });
  }
  function Hh(a) {
    if (a.h && a.a && Lh(a)) {
      var b = a.h,
          c = Mh[b];c && (l.clearTimeout(c.a), delete Mh[b]);a.h = 0;
    }a.b && (a.b.o--, delete a.b);b = a.c;for (var d = c = !1; a.g.length && !a.i;) {
      var e = a.g.shift(),
          f = e[0],
          g = e[1];e = e[2];if (f = a.f ? g : f) try {
        var k = f.call(e || a.u, b);void 0 !== k && (a.f = a.f && (k == b || k instanceof Error), a.c = b = k);if (ra(b) || "function" === typeof l.Promise && b instanceof l.Promise) d = !0, a.i = !0;
      } catch (n) {
        b = n, a.f = !0, Lh(a) || (c = !0);
      }
    }a.c = b;d && (k = t(a.m, a, !0), d = t(a.m, a, !1), b instanceof Ch ? (Kh(b, k, d), b.A = !0) : b.then(k, d));c && (b = new Nh(b), Mh[b.a] = b, a.h = b.a);
  }function Ih() {
    v.call(this);
  }u(Ih, v);Ih.prototype.message = "Deferred has already fired";Ih.prototype.name = "AlreadyCalledError";function Eh() {
    v.call(this);
  }u(Eh, v);Eh.prototype.message = "Deferred was canceled";Eh.prototype.name = "CanceledError";function Nh(a) {
    this.a = l.setTimeout(t(this.c, this), 0);this.b = a;
  }Nh.prototype.c = function () {
    delete Mh[this.a];throw this.b;
  };var Mh = {};function Oh(a) {
    var b = {},
        c = b.document || document,
        d = vd(a).toString(),
        e = document.createElement("SCRIPT"),
        f = { Lb: e, Ga: void 0 },
        g = new Ch(f),
        k = null,
        n = null != b.timeout ? b.timeout : 5E3;0 < n && (k = window.setTimeout(function () {
      Ph(e, !0);var p = new Qh(Rh, "Timeout reached for loading script " + d);Fh(g);Gh(g, !1, p);
    }, n), f.Ga = k);e.onload = e.onreadystatechange = function () {
      e.readyState && "loaded" != e.readyState && "complete" != e.readyState || (Ph(e, b.hd || !1, k), Fh(g), Gh(g, !0, null));
    };e.onerror = function () {
      Ph(e, !0, k);var p = new Qh(Sh, "Error while loading script " + d);Fh(g);Gh(g, !1, p);
    };f = b.attributes || {};ab(f, { type: "text/javascript", charset: "UTF-8" });Md(e, f);Kd(e, a);Th(c).appendChild(e);return g;
  }function Th(a) {
    var b;return (b = (a || document).getElementsByTagName("HEAD")) && 0 != b.length ? b[0] : a.documentElement;
  }function Dh() {
    if (this && this.Lb) {
      var a = this.Lb;a && "SCRIPT" == a.tagName && Ph(a, !0, this.Ga);
    }
  }
  function Ph(a, b, c) {
    null != c && l.clearTimeout(c);a.onload = fa;a.onerror = fa;a.onreadystatechange = fa;b && window.setTimeout(function () {
      a && a.parentNode && a.parentNode.removeChild(a);
    }, 0);
  }var Sh = 0,
      Rh = 1;function Qh(a, b) {
    var c = "Jsloader error (code #" + a + ")";b && (c += ": " + b);v.call(this, c);this.code = a;
  }u(Qh, v);function Uh(a) {
    this.f = a;
  }u(Uh, Ng);Uh.prototype.a = function () {
    return new this.f();
  };Uh.prototype.b = function () {
    return {};
  };
  function Vh(a, b, c) {
    this.b = a;a = b || {};this.i = a.secureTokenEndpoint || "https://securetoken.googleapis.com/v1/token";this.o = a.secureTokenTimeout || Wh;this.f = Za(a.secureTokenHeaders || Xh);this.g = a.firebaseEndpoint || "https://www.googleapis.com/identitytoolkit/v3/relyingparty/";this.h = a.firebaseTimeout || Yh;this.a = Za(a.firebaseHeaders || Zh);c && (this.a["X-Client-Version"] = c, this.f["X-Client-Version"] = c);c = "Node" == qe();c = l.XMLHttpRequest || c && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.node && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.node.XMLHttpRequest;if (!c && !pe()) throw new N("internal-error", "The XMLHttpRequest compatibility library was not found.");this.c = void 0;pe() ? this.c = new hh(self) : re() ? this.c = new Uh(c) : this.c = new Sg();
  }var $h,
      Uf = "idToken",
      Wh = new Fe(3E4, 6E4),
      Xh = { "Content-Type": "application/x-www-form-urlencoded" },
      Yh = new Fe(3E4, 6E4),
      Zh = { "Content-Type": "application/json" };function ai(a, b) {
    b ? a.a["X-Firebase-Locale"] = b : delete a.a["X-Firebase-Locale"];
  }
  function bi(a, b) {
    b ? (a.a["X-Client-Version"] = b, a.f["X-Client-Version"] = b) : (delete a.a["X-Client-Version"], delete a.f["X-Client-Version"]);
  }function ci(a, b, c, d, e, f, g) {
    ae() || pe() ? a = t(a.m, a) : ($h || ($h = new C(function (k, n) {
      di(k, n);
    })), a = t(a.l, a));a(b, c, d, e, f, g);
  }
  Vh.prototype.m = function (a, b, c, d, e, f) {
    if (pe() && ("undefined" === typeof l.fetch || "undefined" === typeof l.Headers || "undefined" === typeof l.Request)) throw new N("operation-not-supported-in-this-environment", "fetch, Headers and Request native APIs or equivalent Polyfills must be available to support HTTP requests from a Worker environment.");var g = new nh(this.c);if (f) {
      g.g = Math.max(0, f);var k = setTimeout(function () {
        g.dispatchEvent("timeout");
      }, f);
    }wc(g, "complete", function () {
      k && clearTimeout(k);var n = null;try {
        n = JSON.parse(Bh(this)) || null;
      } catch (p) {
        n = null;
      }b && b(n);
    });Cc(g, "ready", function () {
      k && clearTimeout(k);Kb(this);
    });Cc(g, "timeout", function () {
      k && clearTimeout(k);Kb(this);b && b(null);
    });rh(g, a, c, d, e);
  };var ei = new pd(qd, "https://apis.google.com/js/client.js?onload=%{onload}"),
      fi = "__fcb" + Math.floor(1E6 * Math.random()).toString();
  function di(a, b) {
    if (((window.gapi || {}).client || {}).request) a();else {
      l[fi] = function () {
        ((window.gapi || {}).client || {}).request ? a() : b(Error("CORS_UNSUPPORTED"));
      };var c = wd(ei, { onload: fi });Jh(Oh(c), function () {
        b(Error("CORS_UNSUPPORTED"));
      });
    }
  }
  Vh.prototype.l = function (a, b, c, d, e) {
    var f = this;$h.then(function () {
      window.gapi.client.setApiKey(f.b);var g = window.gapi.auth.getToken();window.gapi.auth.setToken(null);window.gapi.client.request({ path: a, method: c, body: d, headers: e, authType: "none", callback: function (k) {
          window.gapi.auth.setToken(g);b && b(k);
        } });
    }).s(function (g) {
      b && b({ error: { message: g && g.message || "CORS_UNSUPPORTED" } });
    });
  };
  function gi(a, b) {
    return new C(function (c, d) {
      "refresh_token" == b.grant_type && b.refresh_token || "authorization_code" == b.grant_type && b.code ? ci(a, a.i + "?key=" + encodeURIComponent(a.b), function (e) {
        e ? e.error ? d(hi(e)) : e.access_token && e.refresh_token ? c(e) : d(new N("internal-error")) : d(new N("network-request-failed"));
      }, "POST", jd(b).toString(), a.f, a.o.get()) : d(new N("internal-error"));
    });
  }
  function ii(a, b, c, d, e, f) {
    var g = fd(a.g + b);I(g, "key", a.b);f && I(g, "cb", qa().toString());var k = "GET" == c;if (k) for (var n in d) d.hasOwnProperty(n) && I(g, n, d[n]);return new C(function (p, z) {
      ci(a, g.toString(), function (A) {
        A ? A.error ? z(hi(A, e || {})) : p(A) : z(new N("network-request-failed"));
      }, c, k ? void 0 : Rd(Be(d)), a.a, a.h.get());
    });
  }function ji(a) {
    a = a.email;if (!m(a) || !je.test(a)) throw new N("invalid-email");
  }function ki(a) {
    "email" in a && ji(a);
  }
  function li(a, b) {
    return P(a, mi, { identifier: b, continueUri: ye() ? Yd() : "http://localhost" }).then(function (c) {
      return c.allProviders || [];
    });
  }function ni(a, b) {
    return P(a, mi, { identifier: b, continueUri: ye() ? Yd() : "http://localhost" }).then(function (c) {
      return c.signinMethods || [];
    });
  }function oi(a) {
    return P(a, pi, {}).then(function (b) {
      return b.authorizedDomains || [];
    });
  }function qi(a) {
    if (!a[Uf]) throw new N("internal-error");
  }
  function ri(a) {
    if (a.phoneNumber || a.temporaryProof) {
      if (!a.phoneNumber || !a.temporaryProof) throw new N("internal-error");
    } else {
      if (!a.sessionInfo) throw new N("missing-verification-id");if (!a.code) throw new N("missing-verification-code");
    }
  }Vh.prototype.Ra = function () {
    return P(this, si, {});
  };Vh.prototype.qb = function (a, b) {
    return P(this, ti, { idToken: a, email: b });
  };Vh.prototype.rb = function (a, b) {
    return P(this, sg, { idToken: a, password: b });
  };var ui = { displayName: "DISPLAY_NAME", photoUrl: "PHOTO_URL" };h = Vh.prototype;
  h.sb = function (a, b) {
    var c = { idToken: a },
        d = [];Xa(ui, function (e, f) {
      var g = b[f];null === g ? d.push(e) : f in b && (c[f] = g);
    });d.length && (c.deleteAttribute = d);return P(this, ti, c);
  };h.lb = function (a, b) {
    a = { requestType: "PASSWORD_RESET", email: a };ab(a, b);return P(this, vi, a);
  };h.mb = function (a, b) {
    a = { requestType: "EMAIL_SIGNIN", email: a };ab(a, b);return P(this, wi, a);
  };h.kb = function (a, b) {
    a = { requestType: "VERIFY_EMAIL", idToken: a };ab(a, b);return P(this, xi, a);
  };function Cg(a, b) {
    return P(a, yi, b);
  }h.Va = function (a) {
    return P(this, zi, a);
  };
  function Ai(a, b, c) {
    return P(a, Bi, { idToken: b, deleteProvider: c });
  }function Ci(a) {
    if (!a.requestUri || !a.sessionId && !a.postBody && !a.pendingToken) throw new N("internal-error");
  }function Di(a, b) {
    b.oauthIdToken && b.providerId && 0 == b.providerId.indexOf("oidc.") && !b.pendingToken && (a.sessionId ? b.nonce = a.sessionId : a.postBody && (a = new Vc(a.postBody), nd(a, "nonce") && (b.nonce = a.get("nonce"))));return b;
  }
  function Ei(a) {
    var b = null;a.needConfirmation ? (a.code = "account-exists-with-different-credential", b = Mg(a)) : "FEDERATED_USER_ID_ALREADY_LINKED" == a.errorMessage ? (a.code = "credential-already-in-use", b = Mg(a)) : "EMAIL_EXISTS" == a.errorMessage ? (a.code = "email-already-in-use", b = Mg(a)) : a.errorMessage && (b = Fi(a.errorMessage));if (b) throw b;if (!a[Uf]) throw new N("internal-error");
  }function Wf(a, b) {
    b.returnIdpCredential = !0;return P(a, Gi, b);
  }function Yf(a, b) {
    b.returnIdpCredential = !0;return P(a, Hi, b);
  }
  function Zf(a, b) {
    b.returnIdpCredential = !0;b.autoCreate = !1;return P(a, Ii, b);
  }function Ji(a) {
    if (!a.oobCode) throw new N("invalid-action-code");
  }h.$a = function (a, b) {
    return P(this, Ki, { oobCode: a, newPassword: b });
  };h.Ja = function (a) {
    return P(this, Li, { oobCode: a });
  };h.Xa = function (a) {
    return P(this, Mi, { oobCode: a });
  };
  var Mi = { endpoint: "setAccountInfo", C: Ji, da: "email" },
      Li = { endpoint: "resetPassword", C: Ji, J: function (a) {
      var b = a.requestType;if (!b || !a.email && "EMAIL_SIGNIN" != b) throw new N("internal-error");
    } },
      Ni = { endpoint: "signupNewUser", C: function (a) {
      ji(a);if (!a.password) throw new N("weak-password");
    }, J: qi, R: !0 },
      mi = { endpoint: "createAuthUri" },
      Oi = { endpoint: "deleteAccount", T: ["idToken"] },
      Bi = { endpoint: "setAccountInfo", T: ["idToken", "deleteProvider"], C: function (a) {
      if (!ja(a.deleteProvider)) throw new N("internal-error");
    } },
      pg = { endpoint: "emailLinkSignin", T: ["email", "oobCode"], C: ji, J: qi, R: !0 },
      rg = { endpoint: "emailLinkSignin", T: ["idToken", "email", "oobCode"], C: ji, J: qi, R: !0 },
      Pi = { endpoint: "getAccountInfo" },
      wi = { endpoint: "getOobConfirmationCode", T: ["requestType"], C: function (a) {
      if ("EMAIL_SIGNIN" != a.requestType) throw new N("internal-error");ji(a);
    }, da: "email" },
      xi = { endpoint: "getOobConfirmationCode", T: ["idToken", "requestType"], C: function (a) {
      if ("VERIFY_EMAIL" != a.requestType) throw new N("internal-error");
    }, da: "email" },
      vi = { endpoint: "getOobConfirmationCode",
    T: ["requestType"], C: function (a) {
      if ("PASSWORD_RESET" != a.requestType) throw new N("internal-error");ji(a);
    }, da: "email" },
      pi = { vb: !0, endpoint: "getProjectConfig", Ib: "GET" },
      Qi = { vb: !0, endpoint: "getRecaptchaParam", Ib: "GET", J: function (a) {
      if (!a.recaptchaSiteKey) throw new N("internal-error");
    } },
      Ki = { endpoint: "resetPassword", C: Ji, da: "email" },
      yi = { endpoint: "sendVerificationCode", T: ["phoneNumber", "recaptchaToken"], da: "sessionInfo" },
      ti = { endpoint: "setAccountInfo", T: ["idToken"], C: ki, R: !0 },
      sg = { endpoint: "setAccountInfo",
    T: ["idToken"], C: function (a) {
      ki(a);if (!a.password) throw new N("weak-password");
    }, J: qi, R: !0 },
      si = { endpoint: "signupNewUser", J: qi, R: !0 },
      Gi = { endpoint: "verifyAssertion", C: Ci, Pa: Di, J: Ei, R: !0 },
      Ii = { endpoint: "verifyAssertion", C: Ci, Pa: Di, J: function (a) {
      if (a.errorMessage && "USER_NOT_FOUND" == a.errorMessage) throw new N("user-not-found");if (a.errorMessage) throw Fi(a.errorMessage);if (!a[Uf]) throw new N("internal-error");
    }, R: !0 },
      Hi = { endpoint: "verifyAssertion", C: function (a) {
      Ci(a);if (!a.idToken) throw new N("internal-error");
    }, Pa: Di, J: Ei, R: !0 },
      Ri = { endpoint: "verifyCustomToken", C: function (a) {
      if (!a.token) throw new N("invalid-custom-token");
    }, J: qi, R: !0 },
      qg = { endpoint: "verifyPassword", C: function (a) {
      ji(a);if (!a.password) throw new N("wrong-password");
    }, J: qi, R: !0 },
      zi = { endpoint: "verifyPhoneNumber", C: ri, J: qi },
      yg = { endpoint: "verifyPhoneNumber", C: function (a) {
      if (!a.idToken) throw new N("internal-error");ri(a);
    }, J: function (a) {
      if (a.temporaryProof) throw a.code = "credential-already-in-use", Mg(a);qi(a);
    } },
      zg = { Xb: { USER_NOT_FOUND: "user-not-found" },
    endpoint: "verifyPhoneNumber", C: ri, J: qi };function P(a, b, c) {
    if (!Se(c, b.T)) return E(new N("internal-error"));var d = b.Ib || "POST",
        e;return D(c).then(b.C).then(function () {
      b.R && (c.returnSecureToken = !0);return ii(a, b.endpoint, d, c, b.Xb, b.vb || !1);
    }).then(function (f) {
      e = f;return b.Pa ? b.Pa(c, e) : e;
    }).then(b.J).then(function () {
      if (!b.da) return e;if (!(b.da in e)) throw new N("internal-error");return e[b.da];
    });
  }function Fi(a) {
    return hi({ error: { errors: [{ message: a }], code: 400, message: a } });
  }
  function hi(a, b) {
    var c = (a.error && a.error.errors && a.error.errors[0] || {}).reason || "";var d = { keyInvalid: "invalid-api-key", ipRefererBlocked: "app-not-authorized" };if (c = d[c] ? new N(d[c]) : null) return c;c = a.error && a.error.message || "";d = { INVALID_CUSTOM_TOKEN: "invalid-custom-token", CREDENTIAL_MISMATCH: "custom-token-mismatch", MISSING_CUSTOM_TOKEN: "internal-error", INVALID_IDENTIFIER: "invalid-email", MISSING_CONTINUE_URI: "internal-error", INVALID_EMAIL: "invalid-email", INVALID_PASSWORD: "wrong-password", USER_DISABLED: "user-disabled",
      MISSING_PASSWORD: "internal-error", EMAIL_EXISTS: "email-already-in-use", PASSWORD_LOGIN_DISABLED: "operation-not-allowed", INVALID_IDP_RESPONSE: "invalid-credential", INVALID_PENDING_TOKEN: "invalid-credential", FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use", MISSING_OR_INVALID_NONCE: "missing-or-invalid-nonce", INVALID_MESSAGE_PAYLOAD: "invalid-message-payload", INVALID_RECIPIENT_EMAIL: "invalid-recipient-email", INVALID_SENDER: "invalid-sender", EMAIL_NOT_FOUND: "user-not-found", RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
      EXPIRED_OOB_CODE: "expired-action-code", INVALID_OOB_CODE: "invalid-action-code", MISSING_OOB_CODE: "internal-error", INVALID_PROVIDER_ID: "invalid-provider-id", CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login", INVALID_ID_TOKEN: "invalid-user-token", TOKEN_EXPIRED: "user-token-expired", USER_NOT_FOUND: "user-token-expired", CORS_UNSUPPORTED: "cors-unsupported", DYNAMIC_LINK_NOT_ACTIVATED: "dynamic-link-not-activated", INVALID_APP_ID: "invalid-app-id", TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests", WEAK_PASSWORD: "weak-password",
      OPERATION_NOT_ALLOWED: "operation-not-allowed", USER_CANCELLED: "user-cancelled", CAPTCHA_CHECK_FAILED: "captcha-check-failed", INVALID_APP_CREDENTIAL: "invalid-app-credential", INVALID_CODE: "invalid-verification-code", INVALID_PHONE_NUMBER: "invalid-phone-number", INVALID_SESSION_INFO: "invalid-verification-id", INVALID_TEMPORARY_PROOF: "invalid-credential", MISSING_APP_CREDENTIAL: "missing-app-credential", MISSING_CODE: "missing-verification-code", MISSING_PHONE_NUMBER: "missing-phone-number", MISSING_SESSION_INFO: "missing-verification-id",
      QUOTA_EXCEEDED: "quota-exceeded", SESSION_EXPIRED: "code-expired", REJECTED_CREDENTIAL: "rejected-credential", INVALID_CONTINUE_URI: "invalid-continue-uri", MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name", MISSING_IOS_BUNDLE_ID: "missing-ios-bundle-id", UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri", INVALID_DYNAMIC_LINK_DOMAIN: "invalid-dynamic-link-domain", INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id", INVALID_CERT_HASH: "invalid-cert-hash", ADMIN_ONLY_OPERATION: "admin-restricted-operation" };ab(d, b || {});b = (b = c.match(/^[^\s]+\s*:\s*(.*)$/)) && 1 < b.length ? b[1] : void 0;for (var e in d) if (0 === c.indexOf(e)) return new N(d[e], b);!b && a && (b = Ae(a));return new N("internal-error", b);
  };function Si(a) {
    this.b = a;this.a = null;this.gb = Ti(this);
  }
  function Ti(a) {
    return Ui().then(function () {
      return new C(function (b, c) {
        K("gapi.iframes.getContext")().open({ where: document.body, url: a.b, messageHandlersFilter: K("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"), attributes: { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" } }, dontclear: !0 }, function (d) {
          function e() {
            clearTimeout(f);b();
          }a.a = d;a.a.restyle({ setHideOnLeave: !1 });var f = setTimeout(function () {
            c(Error("Network Error"));
          }, Vi.get());d.ping(e).then(e, function () {
            c(Error("Network Error"));
          });
        });
      });
    });
  }
  function Wi(a, b) {
    return a.gb.then(function () {
      return new C(function (c) {
        a.a.send(b.type, b, c, K("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
      });
    });
  }function Xi(a, b) {
    a.gb.then(function () {
      a.a.register("authEvent", b, K("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
    });
  }var Yi = new pd(qd, "https://apis.google.com/js/api.js?onload=%{onload}"),
      Zi = new Fe(3E4, 6E4),
      Vi = new Fe(5E3, 15E3),
      $i = null;
  function Ui() {
    return $i ? $i : $i = new C(function (a, b) {
      function c() {
        Ee();K("gapi.load")("gapi.iframes", { callback: a, ontimeout: function () {
            Ee();b(Error("Network Error"));
          }, timeout: Zi.get() });
      }if (K("gapi.iframes.Iframe")) a();else if (K("gapi.load")) c();else {
        var d = "__iframefcb" + Math.floor(1E6 * Math.random()).toString();l[d] = function () {
          K("gapi.load") ? c() : b(Error("Network Error"));
        };d = wd(Yi, { onload: d });D(Oh(d)).s(function () {
          b(Error("Network Error"));
        });
      }
    }).s(function (a) {
      $i = null;throw a;
    });
  };function aj(a, b, c) {
    this.i = a;this.g = b;this.h = c;this.f = null;this.a = gd(this.i, "/__/auth/iframe");I(this.a, "apiKey", this.g);I(this.a, "appName", this.h);this.b = null;this.c = [];
  }aj.prototype.toString = function () {
    this.f ? I(this.a, "v", this.f) : md(this.a.a, "v");this.b ? I(this.a, "eid", this.b) : md(this.a.a, "eid");this.c.length ? I(this.a, "fw", this.c.join(",")) : md(this.a.a, "fw");return this.a.toString();
  };function bj(a, b, c, d, e) {
    this.m = a;this.l = b;this.c = c;this.o = d;this.h = this.g = this.i = null;this.a = e;this.f = null;
  }
  bj.prototype.toString = function () {
    var a = gd(this.m, "/__/auth/handler");I(a, "apiKey", this.l);I(a, "appName", this.c);I(a, "authType", this.o);if (this.a.isOAuthProvider) {
      var b = this.a;try {
        var c = __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.app(this.c).auth().ea();
      } catch (k) {
        c = null;
      }b.ab = c;I(a, "providerId", this.a.providerId);b = this.a;c = Be(b.zb);for (var d in c) c[d] = c[d].toString();d = b.Fc;c = Za(c);for (var e = 0; e < d.length; e++) {
        var f = d[e];f in c && delete c[f];
      }b.eb && b.ab && !c[b.eb] && (c[b.eb] = b.ab);Ya(c) || I(a, "customParameters", Ae(c));
    }"function" === typeof this.a.Fb && (b = this.a.Fb(), b.length && I(a, "scopes", b.join(",")));this.i ? I(a, "redirectUrl", this.i) : md(a.a, "redirectUrl");this.g ? I(a, "eventId", this.g) : md(a.a, "eventId");this.h ? I(a, "v", this.h) : md(a.a, "v");if (this.b) for (var g in this.b) this.b.hasOwnProperty(g) && !ed(a, g) && I(a, g, this.b[g]);this.f ? I(a, "eid", this.f) : md(a.a, "eid");g = cj(this.c);g.length && I(a, "fw", g.join(","));return a.toString();
  };function cj(a) {
    try {
      return __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.app(a).auth().ya();
    } catch (b) {
      return [];
    }
  }
  function dj(a, b, c, d, e) {
    this.l = a;this.f = b;this.b = c;this.c = d || null;this.h = e || null;this.m = this.u = this.v = null;this.g = [];this.o = this.a = null;
  }
  function ej(a) {
    var b = Yd();return oi(a).then(function (c) {
      a: {
        var d = fd(b),
            e = d.c;d = d.b;for (var f = 0; f < c.length; f++) {
          var g = c[f];var k = d;var n = e;0 == g.indexOf("chrome-extension://") ? k = fd(g).b == k && "chrome-extension" == n : "http" != n && "https" != n ? k = !1 : ie.test(g) ? k = k == g : (g = g.split(".").join("\\."), k = new RegExp("^(.+\\." + g + "|" + g + ")$", "i").test(k));if (k) {
            c = !0;break a;
          }
        }c = !1;
      }if (!c) throw new Kg(Yd());
    });
  }
  function fj(a) {
    if (a.o) return a.o;a.o = ke().then(function () {
      if (!a.u) {
        var b = a.c,
            c = a.h,
            d = cj(a.b),
            e = new aj(a.l, a.f, a.b);e.f = b;e.b = c;e.c = Ka(d || []);a.u = e.toString();
      }a.i = new Si(a.u);gj(a);
    });return a.o;
  }h = dj.prototype;h.Ea = function (a, b, c) {
    var d = new N("popup-closed-by-user"),
        e = new N("web-storage-unsupported"),
        f = this,
        g = !1;return this.ga().then(function () {
      hj(f).then(function (k) {
        k || (a && ee(a), b(e), g = !0);
      });
    }).s(function () {}).then(function () {
      if (!g) return he(a);
    }).then(function () {
      if (!g) return Jc(c).then(function () {
        b(d);
      });
    });
  };
  h.Mb = function () {
    var a = J();return !ze(a) && !De(a);
  };h.Hb = function () {
    return !1;
  };
  h.Db = function (a, b, c, d, e, f, g) {
    if (!a) return E(new N("popup-blocked"));if (g && !ze()) return this.ga().s(function (n) {
      ee(a);e(n);
    }), d(), D();this.a || (this.a = ej(ij(this)));var k = this;return this.a.then(function () {
      var n = k.ga().s(function (p) {
        ee(a);e(p);throw p;
      });d();return n;
    }).then(function () {
      Fg(c);if (!g) {
        var n = jj(k.l, k.f, k.b, b, c, null, f, k.c, void 0, k.h);Zd(n, a);
      }
    }).s(function (n) {
      "auth/network-request-failed" == n.code && (k.a = null);throw n;
    });
  };
  function ij(a) {
    a.m || (a.v = a.c ? ue(a.c, cj(a.b)) : null, a.m = new Vh(a.f, Bf(a.h), a.v));return a.m;
  }h.Ca = function (a, b, c) {
    this.a || (this.a = ej(ij(this)));var d = this;return this.a.then(function () {
      Fg(b);var e = jj(d.l, d.f, d.b, a, b, Yd(), c, d.c, void 0, d.h);Zd(e);
    }).s(function (e) {
      "auth/network-request-failed" == e.code && (d.a = null);throw e;
    });
  };h.ga = function () {
    var a = this;return fj(this).then(function () {
      return a.i.gb;
    }).s(function () {
      a.a = null;throw new N("network-request-failed");
    });
  };h.Qb = function () {
    return !0;
  };
  function jj(a, b, c, d, e, f, g, k, n, p) {
    a = new bj(a, b, c, d, e);a.i = f;a.g = g;a.h = k;a.b = Za(n || null);a.f = p;return a.toString();
  }function gj(a) {
    if (!a.i) throw Error("IfcHandler must be initialized!");Xi(a.i, function (b) {
      var c = {};if (b && b.authEvent) {
        var d = !1;b = Hg(b.authEvent);for (c = 0; c < a.g.length; c++) d = a.g[c](b) || d;c = {};c.status = d ? "ACK" : "ERROR";return D(c);
      }c.status = "ERROR";return D(c);
    });
  }
  function hj(a) {
    var b = { type: "webStorageSupport" };return fj(a).then(function () {
      return Wi(a.i, b);
    }).then(function (c) {
      if (c && c.length && "undefined" !== typeof c[0].webStorageSupport) return c[0].webStorageSupport;throw Error();
    });
  }h.wa = function (a) {
    this.g.push(a);
  };h.Ka = function (a) {
    x(this.g, function (b) {
      return b == a;
    });
  };function kj(a) {
    this.a = a || __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.reactNative && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.reactNative.AsyncStorage;if (!this.a) throw new N("internal-error", "The React Native compatibility library was not found.");this.type = "asyncStorage";
  }h = kj.prototype;h.get = function (a) {
    return D(this.a.getItem(a)).then(function (b) {
      return b && Ce(b);
    });
  };h.set = function (a, b) {
    return D(this.a.setItem(a, Ae(b)));
  };h.P = function (a) {
    return D(this.a.removeItem(a));
  };h.Y = function () {};h.ca = function () {};function lj(a) {
    this.b = a;this.a = {};this.c = t(this.f, this);
  }var mj = [];function nj() {
    var a = pe() ? self : null;w(mj, function (c) {
      c.b == a && (b = c);
    });if (!b) {
      var b = new lj(a);mj.push(b);
    }return b;
  }
  lj.prototype.f = function (a) {
    var b = a.data.eventType,
        c = a.data.eventId,
        d = this.a[b];if (d && 0 < d.length) {
      a.ports[0].postMessage({ status: "ack", eventId: c, eventType: b, response: null });var e = [];w(d, function (f) {
        e.push(D().then(function () {
          return f(a.origin, a.data.data);
        }));
      });wb(e).then(function (f) {
        var g = [];w(f, function (k) {
          g.push({ fulfilled: k.Eb, value: k.value, reason: k.reason ? k.reason.message : void 0 });
        });w(g, function (k) {
          for (var n in k) "undefined" === typeof k[n] && delete k[n];
        });a.ports[0].postMessage({ status: "done", eventId: c,
          eventType: b, response: g });
      });
    }
  };lj.prototype.subscribe = function (a, b) {
    Ya(this.a) && this.b.addEventListener("message", this.c);"undefined" === typeof this.a[a] && (this.a[a] = []);this.a[a].push(b);
  };lj.prototype.unsubscribe = function (a, b) {
    "undefined" !== typeof this.a[a] && b ? (x(this.a[a], function (c) {
      return c == b;
    }), 0 == this.a[a].length && delete this.a[a]) : b || delete this.a[a];Ya(this.a) && this.b.removeEventListener("message", this.c);
  };function oj(a) {
    this.a = a;
  }oj.prototype.postMessage = function (a, b) {
    this.a.postMessage(a, b);
  };function pj(a) {
    this.c = a;this.b = !1;this.a = [];
  }
  function qj(a, b, c, d) {
    var e,
        f = c || {},
        g,
        k,
        n,
        p = null;if (a.b) return E(Error("connection_unavailable"));var z = d ? 800 : 50,
        A = "undefined" !== typeof MessageChannel ? new MessageChannel() : null;return new C(function (da, fc) {
      A ? (e = Math.floor(Math.random() * Math.pow(10, 20)).toString(), A.port1.start(), k = setTimeout(function () {
        fc(Error("unsupported_event"));
      }, z), g = function (gc) {
        gc.data.eventId === e && ("ack" === gc.data.status ? (clearTimeout(k), n = setTimeout(function () {
          fc(Error("timeout"));
        }, 3E3)) : "done" === gc.data.status ? (clearTimeout(n), "undefined" !== typeof gc.data.response ? da(gc.data.response) : fc(Error("unknown_error"))) : (clearTimeout(k), clearTimeout(n), fc(Error("invalid_response"))));
      }, p = { messageChannel: A, onMessage: g }, a.a.push(p), A.port1.addEventListener("message", g), a.c.postMessage({ eventType: b, eventId: e, data: f }, [A.port2])) : fc(Error("connection_unavailable"));
    }).then(function (da) {
      rj(a, p);return da;
    }).s(function (da) {
      rj(a, p);throw da;
    });
  }
  function rj(a, b) {
    if (b) {
      var c = b.messageChannel,
          d = b.onMessage;c && (c.port1.removeEventListener("message", d), c.port1.close());x(a.a, function (e) {
        return e == b;
      });
    }
  }pj.prototype.close = function () {
    for (; 0 < this.a.length;) rj(this, this.a[0]);this.b = !0;
  };function sj() {
    if (!tj()) throw new N("web-storage-unsupported");this.c = {};this.a = [];this.b = 0;this.l = l.indexedDB;this.type = "indexedDB";this.g = this.o = this.f = this.i = null;this.u = !1;this.h = null;var a = this;pe() && self ? (this.o = nj(), this.o.subscribe("keyChanged", function (b, c) {
      return uj(a).then(function (d) {
        0 < d.length && w(a.a, function (e) {
          e(d);
        });return { keyProcessed: Ha(d, c.key) };
      });
    }), this.o.subscribe("ping", function () {
      return D(["keyChanged"]);
    })) : Le().then(function (b) {
      if (a.h = b) a.g = new pj(new oj(b)), qj(a.g, "ping", null, !0).then(function (c) {
        c[0].fulfilled && Ha(c[0].value, "keyChanged") && (a.u = !0);
      }).s(function () {});
    });
  }var vj;function wj(a) {
    return new C(function (b, c) {
      var d = a.l.deleteDatabase("firebaseLocalStorageDb");d.onsuccess = function () {
        b();
      };d.onerror = function (e) {
        c(Error(e.target.error));
      };
    });
  }
  function xj(a) {
    return new C(function (b, c) {
      var d = a.l.open("firebaseLocalStorageDb", 1);d.onerror = function (e) {
        try {
          e.preventDefault();
        } catch (f) {}c(Error(e.target.error));
      };d.onupgradeneeded = function (e) {
        e = e.target.result;try {
          e.createObjectStore("firebaseLocalStorage", { keyPath: "fbase_key" });
        } catch (f) {
          c(f);
        }
      };d.onsuccess = function (e) {
        e = e.target.result;e.objectStoreNames.contains("firebaseLocalStorage") ? b(e) : wj(a).then(function () {
          return xj(a);
        }).then(function (f) {
          b(f);
        }).s(function (f) {
          c(f);
        });
      };
    });
  }
  function yj(a) {
    a.m || (a.m = xj(a));return a.m;
  }function tj() {
    try {
      return !!l.indexedDB;
    } catch (a) {
      return !1;
    }
  }function zj(a) {
    return a.objectStore("firebaseLocalStorage");
  }function Aj(a, b) {
    return a.transaction(["firebaseLocalStorage"], b ? "readwrite" : "readonly");
  }function Bj(a) {
    return new C(function (b, c) {
      a.onsuccess = function (d) {
        d && d.target ? b(d.target.result) : b();
      };a.onerror = function (d) {
        c(d.target.error);
      };
    });
  }h = sj.prototype;
  h.set = function (a, b) {
    var c = !1,
        d,
        e = this;return yj(this).then(function (f) {
      d = f;f = zj(Aj(d, !0));return Bj(f.get(a));
    }).then(function (f) {
      var g = zj(Aj(d, !0));if (f) return f.value = b, Bj(g.put(f));e.b++;c = !0;f = {};f.fbase_key = a;f.value = b;return Bj(g.add(f));
    }).then(function () {
      e.c[a] = b;return Cj(e, a);
    }).ia(function () {
      c && e.b--;
    });
  };function Cj(a, b) {
    return a.g && a.h && Ke() === a.h ? qj(a.g, "keyChanged", { key: b }, a.u).then(function () {}).s(function () {}) : D();
  }
  h.get = function (a) {
    return yj(this).then(function (b) {
      return Bj(zj(Aj(b, !1)).get(a));
    }).then(function (b) {
      return b && b.value;
    });
  };h.P = function (a) {
    var b = !1,
        c = this;return yj(this).then(function (d) {
      b = !0;c.b++;return Bj(zj(Aj(d, !0))["delete"](a));
    }).then(function () {
      delete c.c[a];return Cj(c, a);
    }).ia(function () {
      b && c.b--;
    });
  };
  function uj(a) {
    return yj(a).then(function (b) {
      var c = zj(Aj(b, !1));return c.getAll ? Bj(c.getAll()) : new C(function (d, e) {
        var f = [],
            g = c.openCursor();g.onsuccess = function (k) {
          (k = k.target.result) ? (f.push(k.value), k["continue"]()) : d(f);
        };g.onerror = function (k) {
          e(k.target.error);
        };
      });
    }).then(function (b) {
      var c = {},
          d = [];if (0 == a.b) {
        for (d = 0; d < b.length; d++) c[b[d].fbase_key] = b[d].value;d = $d(a.c, c);a.c = c;
      }return d;
    });
  }h.Y = function (a) {
    0 == this.a.length && Dj(this);this.a.push(a);
  };
  h.ca = function (a) {
    x(this.a, function (b) {
      return b == a;
    });0 == this.a.length && Ej(this);
  };function Dj(a) {
    function b() {
      a.f = setTimeout(function () {
        a.i = uj(a).then(function (c) {
          0 < c.length && w(a.a, function (d) {
            d(c);
          });
        }).then(function () {
          b();
        }).s(function (c) {
          "STOP_EVENT" != c.message && b();
        });
      }, 800);
    }Ej(a);b();
  }function Ej(a) {
    a.i && a.i.cancel("STOP_EVENT");a.f && (clearTimeout(a.f), a.f = null);
  };function Fj(a) {
    var b = this,
        c = null;this.a = [];this.type = "indexedDB";this.c = a;this.b = D().then(function () {
      if (tj()) {
        var d = we(),
            e = "__sak" + d;vj || (vj = new sj());c = vj;return c.set(e, d).then(function () {
          return c.get(e);
        }).then(function (f) {
          if (f !== d) throw Error("indexedDB not supported!");return c.P(e);
        }).then(function () {
          return c;
        }).s(function () {
          return b.c;
        });
      }return b.c;
    }).then(function (d) {
      b.type = d.type;d.Y(function (e) {
        w(b.a, function (f) {
          f(e);
        });
      });return d;
    });
  }h = Fj.prototype;h.get = function (a) {
    return this.b.then(function (b) {
      return b.get(a);
    });
  };
  h.set = function (a, b) {
    return this.b.then(function (c) {
      return c.set(a, b);
    });
  };h.P = function (a) {
    return this.b.then(function (b) {
      return b.P(a);
    });
  };h.Y = function (a) {
    this.a.push(a);
  };h.ca = function (a) {
    x(this.a, function (b) {
      return b == a;
    });
  };function Gj() {
    this.a = {};this.type = "inMemory";
  }h = Gj.prototype;h.get = function (a) {
    return D(this.a[a]);
  };h.set = function (a, b) {
    this.a[a] = b;return D();
  };h.P = function (a) {
    delete this.a[a];return D();
  };h.Y = function () {};h.ca = function () {};function Hj() {
    if (!Ij()) {
      if ("Node" == qe()) throw new N("internal-error", "The LocalStorage compatibility library was not found.");throw new N("web-storage-unsupported");
    }this.a = Jj() || __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.node.localStorage;this.type = "localStorage";
  }function Jj() {
    try {
      var a = l.localStorage,
          b = we();a && (a.setItem(b, "1"), a.removeItem(b));return a;
    } catch (c) {
      return null;
    }
  }
  function Ij() {
    var a = "Node" == qe();a = Jj() || a && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.node && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.node.localStorage;if (!a) return !1;try {
      return a.setItem("__sak", "1"), a.removeItem("__sak"), !0;
    } catch (b) {
      return !1;
    }
  }h = Hj.prototype;h.get = function (a) {
    var b = this;return D().then(function () {
      var c = b.a.getItem(a);return Ce(c);
    });
  };h.set = function (a, b) {
    var c = this;return D().then(function () {
      var d = Ae(b);null === d ? c.P(a) : c.a.setItem(a, d);
    });
  };h.P = function (a) {
    var b = this;return D().then(function () {
      b.a.removeItem(a);
    });
  };
  h.Y = function (a) {
    l.window && tc(l.window, "storage", a);
  };h.ca = function (a) {
    l.window && G(l.window, "storage", a);
  };function Kj() {
    this.type = "nullStorage";
  }h = Kj.prototype;h.get = function () {
    return D(null);
  };h.set = function () {
    return D();
  };h.P = function () {
    return D();
  };h.Y = function () {};h.ca = function () {};function Lj() {
    if (!Mj()) {
      if ("Node" == qe()) throw new N("internal-error", "The SessionStorage compatibility library was not found.");throw new N("web-storage-unsupported");
    }this.a = Nj() || __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.node.sessionStorage;this.type = "sessionStorage";
  }function Nj() {
    try {
      var a = l.sessionStorage,
          b = we();a && (a.setItem(b, "1"), a.removeItem(b));return a;
    } catch (c) {
      return null;
    }
  }
  function Mj() {
    var a = "Node" == qe();a = Nj() || a && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.node && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.node.sessionStorage;if (!a) return !1;try {
      return a.setItem("__sak", "1"), a.removeItem("__sak"), !0;
    } catch (b) {
      return !1;
    }
  }h = Lj.prototype;h.get = function (a) {
    var b = this;return D().then(function () {
      var c = b.a.getItem(a);return Ce(c);
    });
  };h.set = function (a, b) {
    var c = this;return D().then(function () {
      var d = Ae(b);null === d ? c.P(a) : c.a.setItem(a, d);
    });
  };h.P = function (a) {
    var b = this;return D().then(function () {
      b.a.removeItem(a);
    });
  };h.Y = function () {};
  h.ca = function () {};function Oj() {
    var a = {};a.Browser = Pj;a.Node = Qj;a.ReactNative = Rj;a.Worker = Sj;this.a = a[qe()];
  }var Tj,
      Pj = { B: Hj, Sa: Lj },
      Qj = { B: Hj, Sa: Lj },
      Rj = { B: kj, Sa: Kj },
      Sj = { B: Hj, Sa: Kj };var Uj = { ad: "local", NONE: "none", cd: "session" };function Vj(a) {
    var b = new N("invalid-persistence-type"),
        c = new N("unsupported-persistence-type");a: {
      for (d in Uj) if (Uj[d] == a) {
        var d = !0;break a;
      }d = !1;
    }if (!d || "string" !== typeof a) throw b;switch (qe()) {case "ReactNative":
        if ("session" === a) throw c;break;case "Node":
        if ("none" !== a) throw c;break;default:
        if (!ve() && "none" !== a) throw c;}
  }
  function Wj() {
    var a = !De(J()) && oe() ? !0 : !1,
        b = ze(),
        c = ve();this.m = a;this.h = b;this.o = c;this.a = {};Tj || (Tj = new Oj());a = Tj;try {
      this.g = !Xd() && Je() || !l.indexedDB ? new a.a.B() : new Fj(pe() ? new Gj() : new a.a.B());
    } catch (d) {
      this.g = new Gj(), this.h = !0;
    }try {
      this.i = new a.a.Sa();
    } catch (d) {
      this.i = new Gj();
    }this.l = new Gj();this.f = t(this.Pb, this);this.b = {};
  }var Xj;function Yj() {
    Xj || (Xj = new Wj());return Xj;
  }function Zj(a, b) {
    switch (b) {case "session":
        return a.i;case "none":
        return a.l;default:
        return a.g;}
  }
  function ak(a, b) {
    return "firebase:" + a.name + (b ? ":" + b : "");
  }function bk(a, b, c) {
    var d = ak(b, c),
        e = Zj(a, b.B);return a.get(b, c).then(function (f) {
      var g = null;try {
        g = Ce(l.localStorage.getItem(d));
      } catch (k) {}if (g && !f) return l.localStorage.removeItem(d), a.set(b, g, c);g && f && "localStorage" != e.type && l.localStorage.removeItem(d);
    });
  }h = Wj.prototype;h.get = function (a, b) {
    return Zj(this, a.B).get(ak(a, b));
  };function ck(a, b, c) {
    c = ak(b, c);"local" == b.B && (a.b[c] = null);return Zj(a, b.B).P(c);
  }
  h.set = function (a, b, c) {
    var d = ak(a, c),
        e = this,
        f = Zj(this, a.B);return f.set(d, b).then(function () {
      return f.get(d);
    }).then(function (g) {
      "local" == a.B && (e.b[d] = g);
    });
  };h.addListener = function (a, b, c) {
    a = ak(a, b);this.o && (this.b[a] = l.localStorage.getItem(a));Ya(this.a) && (Zj(this, "local").Y(this.f), this.h || (Xd() || !Je()) && l.indexedDB || !this.o || dk(this));this.a[a] || (this.a[a] = []);this.a[a].push(c);
  };
  h.removeListener = function (a, b, c) {
    a = ak(a, b);this.a[a] && (x(this.a[a], function (d) {
      return d == c;
    }), 0 == this.a[a].length && delete this.a[a]);Ya(this.a) && (Zj(this, "local").ca(this.f), ek(this));
  };function dk(a) {
    ek(a);a.c = setInterval(function () {
      for (var b in a.a) {
        var c = l.localStorage.getItem(b),
            d = a.b[b];c != d && (a.b[b] = c, c = new hc({ type: "storage", key: b, target: window, oldValue: d, newValue: c, a: !0 }), a.Pb(c));
      }
    }, 1E3);
  }function ek(a) {
    a.c && (clearInterval(a.c), a.c = null);
  }
  h.Pb = function (a) {
    if (a && a.f) {
      var b = a.a.key;if (null == b) for (var c in this.a) {
        var d = this.b[c];"undefined" === typeof d && (d = null);var e = l.localStorage.getItem(c);e !== d && (this.b[c] = e, this.Ya(c));
      } else if (0 == b.indexOf("firebase:") && this.a[b]) {
        "undefined" !== typeof a.a.a ? Zj(this, "local").ca(this.f) : ek(this);if (this.m) if (c = l.localStorage.getItem(b), d = a.a.newValue, d !== c) null !== d ? l.localStorage.setItem(b, d) : l.localStorage.removeItem(b);else if (this.b[b] === d && "undefined" === typeof a.a.a) return;var f = this;c = function () {
          if ("undefined" !== typeof a.a.a || f.b[b] !== l.localStorage.getItem(b)) f.b[b] = l.localStorage.getItem(b), f.Ya(b);
        };Pb && $b && 10 == $b && l.localStorage.getItem(b) !== a.a.newValue && a.a.newValue !== a.a.oldValue ? setTimeout(c, 10) : c();
      }
    } else w(a, t(this.Ya, this));
  };h.Ya = function (a) {
    this.a[a] && w(this.a[a], function (b) {
      b();
    });
  };function fk(a) {
    this.a = a;this.b = Yj();
  }var gk = { name: "authEvent", B: "local" };function hk(a) {
    return a.b.get(gk, a.a).then(function (b) {
      return Hg(b);
    });
  };function ik() {
    this.a = Yj();
  };function jk() {
    this.b = -1;
  };function kk(a, b) {
    this.b = lk;this.f = l.Uint8Array ? new Uint8Array(this.b) : Array(this.b);this.g = this.c = 0;this.a = [];this.i = a;this.h = b;this.o = l.Int32Array ? new Int32Array(64) : Array(64);void 0 !== mk || (l.Int32Array ? mk = new Int32Array(nk) : mk = nk);this.reset();
  }var mk;u(kk, jk);for (var lk = 64, ok = lk - 1, pk = [], qk = 0; qk < ok; qk++) pk[qk] = 0;var rk = Ja(128, pk);kk.prototype.reset = function () {
    this.g = this.c = 0;this.a = l.Int32Array ? new Int32Array(this.h) : Ka(this.h);
  };
  function sk(a) {
    for (var b = a.f, c = a.o, d = 0, e = 0; e < b.length;) c[d++] = b[e] << 24 | b[e + 1] << 16 | b[e + 2] << 8 | b[e + 3], e = 4 * d;for (b = 16; 64 > b; b++) {
      e = c[b - 15] | 0;d = c[b - 2] | 0;var f = (c[b - 16] | 0) + ((e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3) | 0,
          g = (c[b - 7] | 0) + ((d >>> 17 | d << 15) ^ (d >>> 19 | d << 13) ^ d >>> 10) | 0;c[b] = f + g | 0;
    }d = a.a[0] | 0;e = a.a[1] | 0;var k = a.a[2] | 0,
        n = a.a[3] | 0,
        p = a.a[4] | 0,
        z = a.a[5] | 0,
        A = a.a[6] | 0;f = a.a[7] | 0;for (b = 0; 64 > b; b++) {
      var da = ((d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10)) + (d & e ^ d & k ^ e & k) | 0;g = p & z ^ ~p & A;f = f + ((p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) | 0;g = g + (mk[b] | 0) | 0;g = f + (g + (c[b] | 0) | 0) | 0;f = A;A = z;z = p;p = n + g | 0;n = k;k = e;e = d;d = g + da | 0;
    }a.a[0] = a.a[0] + d | 0;a.a[1] = a.a[1] + e | 0;a.a[2] = a.a[2] + k | 0;a.a[3] = a.a[3] + n | 0;a.a[4] = a.a[4] + p | 0;a.a[5] = a.a[5] + z | 0;a.a[6] = a.a[6] + A | 0;a.a[7] = a.a[7] + f | 0;
  }
  function tk(a, b, c) {
    void 0 === c && (c = b.length);var d = 0,
        e = a.c;if (m(b)) for (; d < c;) a.f[e++] = b.charCodeAt(d++), e == a.b && (sk(a), e = 0);else if (ka(b)) for (; d < c;) {
      var f = b[d++];if (!("number" == typeof f && 0 <= f && 255 >= f && f == (f | 0))) throw Error("message must be a byte array");a.f[e++] = f;e == a.b && (sk(a), e = 0);
    } else throw Error("message must be string or array");a.c = e;a.g += c;
  }
  var nk = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];function uk() {
    kk.call(this, 8, vk);
  }u(uk, kk);var vk = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];function wk(a, b, c, d, e) {
    this.l = a;this.i = b;this.o = c;this.m = d || null;this.u = e || null;this.h = b + ":" + c;this.v = new ik();this.g = new fk(this.h);this.f = null;this.b = [];this.a = this.c = null;
  }function xk(a) {
    return new N("invalid-cordova-configuration", a);
  }h = wk.prototype;
  h.ga = function () {
    return this.za ? this.za : this.za = le().then(function () {
      if ("function" !== typeof K("universalLinks.subscribe", l)) throw xk("cordova-universal-links-plugin-fix is not installed");if ("undefined" === typeof K("BuildInfo.packageName", l)) throw xk("cordova-plugin-buildinfo is not installed");if ("function" !== typeof K("cordova.plugins.browsertab.openUrl", l)) throw xk("cordova-plugin-browsertab is not installed");if ("function" !== typeof K("cordova.InAppBrowser.open", l)) throw xk("cordova-plugin-inappbrowser is not installed");
    }, function () {
      throw new N("cordova-not-ready");
    });
  };function yk() {
    for (var a = 20, b = []; 0 < a;) b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), a--;return b.join("");
  }function zk(a) {
    var b = new uk();tk(b, a);a = [];var c = 8 * b.g;56 > b.c ? tk(b, rk, 56 - b.c) : tk(b, rk, b.b - (b.c - 56));for (var d = 63; 56 <= d; d--) b.f[d] = c & 255, c /= 256;sk(b);for (d = c = 0; d < b.i; d++) for (var e = 24; 0 <= e; e -= 8) a[c++] = b.a[d] >> e & 255;return rf(a);
  }
  h.Ea = function (a, b) {
    b(new N("operation-not-supported-in-this-environment"));return D();
  };h.Db = function () {
    return E(new N("operation-not-supported-in-this-environment"));
  };h.Qb = function () {
    return !1;
  };h.Mb = function () {
    return !0;
  };h.Hb = function () {
    return !0;
  };
  h.Ca = function (a, b, c) {
    if (this.c) return E(new N("redirect-operation-pending"));var d = this,
        e = l.document,
        f = null,
        g = null,
        k = null,
        n = null;return this.c = D().then(function () {
      Fg(b);return Ak(d);
    }).then(function () {
      return Bk(d, a, b, c);
    }).then(function () {
      return new C(function (p, z) {
        g = function () {
          var A = K("cordova.plugins.browsertab.close", l);p();"function" === typeof A && A();d.a && "function" === typeof d.a.close && (d.a.close(), d.a = null);return !1;
        };d.wa(g);k = function () {
          f || (f = Jc(2E3).then(function () {
            z(new N("redirect-cancelled-by-user"));
          }));
        };
        n = function () {
          Ge() && k();
        };e.addEventListener("resume", k, !1);J().toLowerCase().match(/android/) || e.addEventListener("visibilitychange", n, !1);
      }).s(function (p) {
        return Ck(d).then(function () {
          throw p;
        });
      });
    }).ia(function () {
      k && e.removeEventListener("resume", k, !1);n && e.removeEventListener("visibilitychange", n, !1);f && f.cancel();g && d.Ka(g);d.c = null;
    });
  };
  function Bk(a, b, c, d) {
    var e = yk(),
        f = new Gg(b, d, null, e, new N("no-auth-event")),
        g = K("BuildInfo.packageName", l);if ("string" !== typeof g) throw new N("invalid-cordova-configuration");var k = K("BuildInfo.displayName", l),
        n = {};if (J().toLowerCase().match(/iphone|ipad|ipod/)) n.ibi = g;else if (J().toLowerCase().match(/android/)) n.apn = g;else return E(new N("operation-not-supported-in-this-environment"));k && (n.appDisplayName = k);e = zk(e);n.sessionId = e;var p = jj(a.l, a.i, a.o, b, c, null, d, a.m, n, a.u);return a.ga().then(function () {
      var z = a.h;return a.v.a.set(gk, f.w(), z);
    }).then(function () {
      var z = K("cordova.plugins.browsertab.isAvailable", l);if ("function" !== typeof z) throw new N("invalid-cordova-configuration");var A = null;z(function (da) {
        if (da) {
          A = K("cordova.plugins.browsertab.openUrl", l);if ("function" !== typeof A) throw new N("invalid-cordova-configuration");A(p);
        } else {
          A = K("cordova.InAppBrowser.open", l);if ("function" !== typeof A) throw new N("invalid-cordova-configuration");da = J();a.a = A(p, da.match(/(iPad|iPhone|iPod).*OS 7_\d/i) || da.match(/(iPad|iPhone|iPod).*OS 8_\d/i) ? "_blank" : "_system", "location=yes");
        }
      });
    });
  }function Dk(a, b) {
    for (var c = 0; c < a.b.length; c++) try {
      a.b[c](b);
    } catch (d) {}
  }function Ak(a) {
    a.f || (a.f = a.ga().then(function () {
      return new C(function (b) {
        function c(d) {
          b(d);a.Ka(c);return !1;
        }a.wa(c);Ek(a);
      });
    }));return a.f;
  }function Ck(a) {
    var b = null;return hk(a.g).then(function (c) {
      b = c;c = a.g;return ck(c.b, gk, c.a);
    }).then(function () {
      return b;
    });
  }
  function Ek(a) {
    function b(g) {
      d = !0;e && e.cancel();Ck(a).then(function (k) {
        var n = c;if (k && g && g.url) {
          var p = null;n = Rf(g.url);-1 != n.indexOf("/__/auth/callback") && (p = fd(n), p = Ce(ed(p, "firebaseError") || null), p = (p = "object" === typeof p ? ef(p) : null) ? new Gg(k.c, k.b, null, null, p) : new Gg(k.c, k.b, n, k.f));n = p || c;
        }Dk(a, n);
      });
    }var c = new Gg("unknown", null, null, null, new N("no-auth-event")),
        d = !1,
        e = Jc(500).then(function () {
      return Ck(a).then(function () {
        d || Dk(a, c);
      });
    }),
        f = l.handleOpenURL;l.handleOpenURL = function (g) {
      0 == g.toLowerCase().indexOf(K("BuildInfo.packageName", l).toLowerCase() + "://") && b({ url: g });if ("function" === typeof f) try {
        f(g);
      } catch (k) {
        console.error(k);
      }
    };Jg || (Jg = new Ig());Jg.subscribe(b);
  }h.wa = function (a) {
    this.b.push(a);Ak(this).s(function (b) {
      "auth/invalid-cordova-configuration" === b.code && (b = new Gg("unknown", null, null, null, new N("no-auth-event")), a(b));
    });
  };h.Ka = function (a) {
    x(this.b, function (b) {
      return b == a;
    });
  };function Fk(a) {
    this.a = a;this.b = Yj();
  }var Gk = { name: "pendingRedirect", B: "session" };function Hk(a) {
    return a.b.set(Gk, "pending", a.a);
  }function Ik(a) {
    return ck(a.b, Gk, a.a);
  }function Jk(a) {
    return a.b.get(Gk, a.a).then(function (b) {
      return "pending" == b;
    });
  };function Kk(a, b, c) {
    this.i = {};this.u = 0;this.A = a;this.l = b;this.m = c;this.h = [];this.f = !1;this.o = t(this.cb, this);this.b = new Lk();this.v = new Mk();this.g = new Fk(this.l + ":" + this.m);this.c = {};this.c.unknown = this.b;this.c.signInViaRedirect = this.b;this.c.linkViaRedirect = this.b;this.c.reauthViaRedirect = this.b;this.c.signInViaPopup = this.v;this.c.linkViaPopup = this.v;this.c.reauthViaPopup = this.v;this.a = Nk(this.A, this.l, this.m, Cf);
  }
  function Nk(a, b, c, d) {
    var e = __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION || null;return me() ? new wk(a, b, c, e, d) : new dj(a, b, c, e, d);
  }h = Kk.prototype;h.reset = function () {
    this.f = !1;this.a.Ka(this.o);this.a = Nk(this.A, this.l, this.m);this.i = {};
  };h.Za = function () {
    this.b.Za();
  };function Ok(a) {
    a.f || (a.f = !0, a.a.wa(a.o));var b = a.a;return a.a.ga().s(function (c) {
      a.a == b && a.reset();throw c;
    });
  }
  function Pk(a) {
    a.a.Mb() && Ok(a).s(function (b) {
      var c = new Gg("unknown", null, null, null, new N("operation-not-supported-in-this-environment"));Qk(b) && a.cb(c);
    });a.a.Hb() || Rk(a.b);
  }h.subscribe = function (a) {
    Ha(this.h, a) || this.h.push(a);if (!this.f) {
      var b = this;Jk(this.g).then(function (c) {
        c ? Ik(b.g).then(function () {
          Ok(b).s(function (d) {
            var e = new Gg("unknown", null, null, null, new N("operation-not-supported-in-this-environment"));Qk(d) && b.cb(e);
          });
        }) : Pk(b);
      }).s(function () {
        Pk(b);
      });
    }
  };
  h.unsubscribe = function (a) {
    x(this.h, function (b) {
      return b == a;
    });
  };h.cb = function (a) {
    if (!a) throw new N("invalid-auth-event");6E5 <= qa() - this.u && (this.i = {}, this.u = 0);if (a && a.getUid() && this.i.hasOwnProperty(a.getUid())) return !1;for (var b = !1, c = 0; c < this.h.length; c++) {
      var d = this.h[c];if (d.wb(a.c, a.b)) {
        if (b = this.c[a.c]) b.h(a, d), a && (a.f || a.b) && (this.i[a.getUid()] = !0, this.u = qa());b = !0;break;
      }
    }Rk(this.b);return b;
  };var Sk = new Fe(2E3, 1E4),
      Tk = new Fe(3E4, 6E4);Kk.prototype.fa = function () {
    return this.b.fa();
  };
  function Uk(a, b, c, d, e, f) {
    return a.a.Db(b, c, d, function () {
      a.f || (a.f = !0, a.a.wa(a.o));
    }, function () {
      a.reset();
    }, e, f);
  }function Qk(a) {
    return a && "auth/cordova-not-ready" == a.code ? !0 : !1;
  }Kk.prototype.Ca = function (a, b, c) {
    var d = this,
        e;return Hk(this.g).then(function () {
      return d.a.Ca(a, b, c).s(function (f) {
        if (Qk(f)) throw new N("operation-not-supported-in-this-environment");e = f;return Ik(d.g).then(function () {
          throw e;
        });
      }).then(function () {
        return d.a.Qb() ? new C(function () {}) : Ik(d.g).then(function () {
          return d.fa();
        }).then(function () {}).s(function () {});
      });
    });
  };
  Kk.prototype.Ea = function (a, b, c, d) {
    return this.a.Ea(c, function (e) {
      a.ha(b, null, e, d);
    }, Sk.get());
  };var Vk = {};function Wk(a, b, c) {
    var d = b + ":" + c;Vk[d] || (Vk[d] = new Kk(a, b, c));return Vk[d];
  }function Lk() {
    this.b = null;this.f = [];this.c = [];this.a = null;this.i = this.g = !1;
  }Lk.prototype.reset = function () {
    this.b = null;this.a && (this.a.cancel(), this.a = null);
  };
  Lk.prototype.h = function (a, b) {
    if (a) {
      this.reset();this.g = !0;var c = a.c,
          d = a.b,
          e = a.a && "auth/web-storage-unsupported" == a.a.code,
          f = a.a && "auth/operation-not-supported-in-this-environment" == a.a.code;this.i = !(!e && !f);"unknown" != c || e || f ? a.a ? (Xk(this, !0, null, a.a), D()) : b.xa(c, d) ? Yk(this, a, b) : E(new N("invalid-auth-event")) : (Xk(this, !1, null, null), D());
    } else E(new N("invalid-auth-event"));
  };function Rk(a) {
    a.g || (a.g = !0, Xk(a, !1, null, null));
  }Lk.prototype.Za = function () {
    this.g && !this.i && Xk(this, !1, null, null);
  };
  function Yk(a, b, c) {
    c = c.xa(b.c, b.b);var d = b.g,
        e = b.f,
        f = b.h,
        g = !!b.c.match(/Redirect$/);c(d, e, f).then(function (k) {
      Xk(a, g, k, null);
    }).s(function (k) {
      Xk(a, g, null, k);
    });
  }function Zk(a, b) {
    a.b = function () {
      return E(b);
    };if (a.c.length) for (var c = 0; c < a.c.length; c++) a.c[c](b);
  }function $k(a, b) {
    a.b = function () {
      return D(b);
    };if (a.f.length) for (var c = 0; c < a.f.length; c++) a.f[c](b);
  }function Xk(a, b, c, d) {
    b ? d ? Zk(a, d) : $k(a, c) : $k(a, { user: null });a.f = [];a.c = [];
  }
  Lk.prototype.fa = function () {
    var a = this;return new C(function (b, c) {
      a.b ? a.b().then(b, c) : (a.f.push(b), a.c.push(c), al(a));
    });
  };function al(a) {
    var b = new N("timeout");a.a && a.a.cancel();a.a = Jc(Tk.get()).then(function () {
      a.b || (a.g = !0, Xk(a, !0, null, b));
    });
  }function Mk() {}Mk.prototype.h = function (a, b) {
    if (a) {
      var c = a.c,
          d = a.b;a.a ? (b.ha(a.c, null, a.a, a.b), D()) : b.xa(c, d) ? bl(a, b) : E(new N("invalid-auth-event"));
    } else E(new N("invalid-auth-event"));
  };
  function bl(a, b) {
    var c = a.b,
        d = a.c;b.xa(d, c)(a.g, a.f, a.h).then(function (e) {
      b.ha(d, e, null, c);
    }).s(function (e) {
      b.ha(d, null, e, c);
    });
  };function cl() {
    this.tb = !1;Object.defineProperty(this, "appVerificationDisabled", { get: function () {
        return this.tb;
      }, set: function (a) {
        this.tb = a;
      }, enumerable: !1 });
  };function dl(a, b) {
    this.a = b;L(this, "verificationId", a);
  }dl.prototype.confirm = function (a) {
    a = Dg(this.verificationId, a);return this.a(a);
  };function el(a, b, c, d) {
    return new Bg(a).Va(b, c).then(function (e) {
      return new dl(e, d);
    });
  };function fl(a) {
    var b = zf(a);if (!(b && b.exp && b.auth_time && b.iat)) throw new N("internal-error", "An internal error occurred. The token obtained by Firebase appears to be malformed. Please retry the operation.");M(this, { token: a, expirationTime: Ie(1E3 * b.exp), authTime: Ie(1E3 * b.auth_time), issuedAtTime: Ie(1E3 * b.iat), signInProvider: b.firebase && b.firebase.sign_in_provider ? b.firebase.sign_in_provider : null, claims: b });
  };function gl(a, b, c) {
    this.h = a;this.i = b;this.g = c;this.c = 3E4;this.f = 96E4;this.b = null;this.a = this.c;if (this.f < this.c) throw Error("Proactive refresh lower bound greater than upper bound!");
  }gl.prototype.start = function () {
    this.a = this.c;hl(this, !0);
  };function il(a, b) {
    if (b) return a.a = a.c, a.g();b = a.a;a.a *= 2;a.a > a.f && (a.a = a.f);return b;
  }function hl(a, b) {
    a.stop();a.b = Jc(il(a, b)).then(function () {
      return He();
    }).then(function () {
      return a.h();
    }).then(function () {
      hl(a, !0);
    }).s(function (c) {
      a.i(c) && hl(a, !1);
    });
  }
  gl.prototype.stop = function () {
    this.b && (this.b.cancel(), this.b = null);
  };function jl(a) {
    this.f = a;this.b = this.a = null;this.c = 0;
  }jl.prototype.w = function () {
    return { apiKey: this.f.b, refreshToken: this.a, accessToken: this.b, expirationTime: this.c };
  };function kl(a, b) {
    var c = b[Uf],
        d = b.refreshToken;b = ll(b.expiresIn);a.b = c;a.c = b;a.a = d;
  }function ml(a, b) {
    a.b = b.b;a.a = b.a;a.c = b.c;
  }function ll(a) {
    return qa() + 1E3 * parseInt(a, 10);
  }
  function nl(a, b) {
    return gi(a.f, b).then(function (c) {
      a.b = c.access_token;a.c = ll(c.expires_in);a.a = c.refresh_token;return { accessToken: a.b, expirationTime: a.c, refreshToken: a.a };
    }).s(function (c) {
      "auth/user-token-expired" == c.code && (a.a = null);throw c;
    });
  }jl.prototype.getToken = function (a) {
    a = !!a;return this.b && !this.a ? E(new N("user-token-expired")) : a || !this.b || qa() > this.c - 3E4 ? this.a ? nl(this, { grant_type: "refresh_token", refresh_token: this.a }) : D(null) : D({ accessToken: this.b, expirationTime: this.c, refreshToken: this.a });
  };function ol(a, b) {
    this.a = a || null;this.b = b || null;M(this, { lastSignInTime: Ie(b || null), creationTime: Ie(a || null) });
  }function pl(a) {
    return new ol(a.a, a.b);
  }ol.prototype.w = function () {
    return { lastLoginAt: this.b, createdAt: this.a };
  };function ql(a, b, c, d, e, f) {
    M(this, { uid: a, displayName: d || null, photoURL: e || null, email: c || null, phoneNumber: f || null, providerId: b });
  }function rl(a, b) {
    F.call(this, a);for (var c in b) this[c] = b[c];
  }u(rl, F);
  function Q(a, b, c) {
    this.G = [];this.l = a.apiKey;this.m = a.appName;this.u = a.authDomain || null;a = __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION ? ue(__WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION) : null;this.b = new Vh(this.l, Bf(Cf), a);this.h = new jl(this.b);sl(this, b[Uf]);kl(this.h, b);L(this, "refreshToken", this.h.a);tl(this, c || {});H.call(this);this.I = !1;this.u && xe() && (this.a = Wk(this.u, this.l, this.m));this.N = [];this.i = null;this.A = ul(this);this.V = t(this.Ha, this);var d = this;this.ka = null;this.ta = function (e) {
      d.pa(e.g);
    };this.X = null;this.O = [];this.sa = function (e) {
      vl(d, e.c);
    };this.W = null;
  }u(Q, H);Q.prototype.pa = function (a) {
    this.ka = a;ai(this.b, a);
  };Q.prototype.ea = function () {
    return this.ka;
  };function wl(a, b) {
    a.X && G(a.X, "languageCodeChanged", a.ta);(a.X = b) && tc(b, "languageCodeChanged", a.ta);
  }function vl(a, b) {
    a.O = b;bi(a.b, __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION ? ue(__WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION, a.O) : null);
  }Q.prototype.ya = function () {
    return Ka(this.O);
  };function xl(a, b) {
    a.W && G(a.W, "frameworkChanged", a.sa);(a.W = b) && tc(b, "frameworkChanged", a.sa);
  }Q.prototype.Ha = function () {
    this.A.b && (this.A.stop(), this.A.start());
  };
  function yl(a) {
    try {
      return __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.app(a.m).auth();
    } catch (b) {
      throw new N("internal-error", "No firebase.auth.Auth instance is available for the Firebase App '" + a.m + "'!");
    }
  }function ul(a) {
    return new gl(function () {
      return a.F(!0);
    }, function (b) {
      return b && "auth/network-request-failed" == b.code ? !0 : !1;
    }, function () {
      var b = a.h.c - qa() - 3E5;return 0 < b ? b : 0;
    });
  }function zl(a) {
    a.D || a.A.b || (a.A.start(), G(a, "tokenChanged", a.V), tc(a, "tokenChanged", a.V));
  }function Al(a) {
    G(a, "tokenChanged", a.V);a.A.stop();
  }
  function sl(a, b) {
    a.ra = b;L(a, "_lat", b);
  }function Bl(a, b) {
    x(a.N, function (c) {
      return c == b;
    });
  }function Cl(a) {
    for (var b = [], c = 0; c < a.N.length; c++) b.push(a.N[c](a));return wb(b).then(function () {
      return a;
    });
  }function Dl(a) {
    a.a && !a.I && (a.I = !0, a.a.subscribe(a));
  }
  function tl(a, b) {
    M(a, { uid: b.uid, displayName: b.displayName || null, photoURL: b.photoURL || null, email: b.email || null, emailVerified: b.emailVerified || !1, phoneNumber: b.phoneNumber || null, isAnonymous: b.isAnonymous || !1, metadata: new ol(b.createdAt, b.lastLoginAt), providerData: [] });
  }L(Q.prototype, "providerId", "firebase");function El() {}function Fl(a) {
    return D().then(function () {
      if (a.D) throw new N("app-deleted");
    });
  }function Gl(a) {
    return Da(a.providerData, function (b) {
      return b.providerId;
    });
  }
  function Hl(a, b) {
    b && (Il(a, b.providerId), a.providerData.push(b));
  }function Il(a, b) {
    x(a.providerData, function (c) {
      return c.providerId == b;
    });
  }function Jl(a, b, c) {
    ("uid" != b || c) && a.hasOwnProperty(b) && L(a, b, c);
  }
  function Kl(a, b) {
    a != b && (M(a, { uid: b.uid, displayName: b.displayName, photoURL: b.photoURL, email: b.email, emailVerified: b.emailVerified, phoneNumber: b.phoneNumber, isAnonymous: b.isAnonymous, providerData: [] }), b.metadata ? L(a, "metadata", pl(b.metadata)) : L(a, "metadata", new ol()), w(b.providerData, function (c) {
      Hl(a, c);
    }), ml(a.h, b.h), L(a, "refreshToken", a.h.a));
  }h = Q.prototype;h.reload = function () {
    var a = this;return R(this, Fl(this).then(function () {
      return Ll(a).then(function () {
        return Cl(a);
      }).then(El);
    }));
  };
  function Ll(a) {
    return a.F().then(function (b) {
      var c = a.isAnonymous;return Ml(a, b).then(function () {
        c || Jl(a, "isAnonymous", !1);return b;
      });
    });
  }h.dc = function (a) {
    return this.F(a).then(function (b) {
      return new fl(b);
    });
  };h.F = function (a) {
    var b = this;return R(this, Fl(this).then(function () {
      return b.h.getToken(a);
    }).then(function (c) {
      if (!c) throw new N("internal-error");c.accessToken != b.ra && (sl(b, c.accessToken), b.dispatchEvent(new rl("tokenChanged")));Jl(b, "refreshToken", c.refreshToken);return c.accessToken;
    }));
  };
  function Nl(a, b) {
    b[Uf] && a.ra != b[Uf] && (kl(a.h, b), a.dispatchEvent(new rl("tokenChanged")), sl(a, b[Uf]), Jl(a, "refreshToken", a.h.a));
  }function Ml(a, b) {
    return P(a.b, Pi, { idToken: b }).then(t(a.zc, a));
  }
  h.zc = function (a) {
    a = a.users;if (!a || !a.length) throw new N("internal-error");a = a[0];tl(this, { uid: a.localId, displayName: a.displayName, photoURL: a.photoUrl, email: a.email, emailVerified: !!a.emailVerified, phoneNumber: a.phoneNumber, lastLoginAt: a.lastLoginAt, createdAt: a.createdAt });for (var b = Ol(a), c = 0; c < b.length; c++) Hl(this, b[c]);Jl(this, "isAnonymous", !(this.email && a.passwordHash) && !(this.providerData && this.providerData.length));
  };
  function Ol(a) {
    return (a = a.providerUserInfo) && a.length ? Da(a, function (b) {
      return new ql(b.rawId, b.providerId, b.email, b.displayName, b.photoUrl, b.phoneNumber);
    }) : [];
  }h.hb = function (a) {
    var b = this,
        c = null;return R(this, a.f(this.b, this.uid).then(function (d) {
      Nl(b, d);c = Pl(b, d, "reauthenticate");b.i = null;return b.reload();
    }).then(function () {
      return c;
    }), !0);
  };
  h.Ac = function (a) {
    Ne("firebase.User.prototype.reauthenticateWithCredential is deprecated. Please use firebase.User.prototype.reauthenticateAndRetrieveDataWithCredential instead.");return this.hb(a).then(function () {});
  };function Ql(a, b) {
    return Ll(a).then(function () {
      if (Ha(Gl(a), b)) return Cl(a).then(function () {
        throw new N("provider-already-linked");
      });
    });
  }
  h.fb = function (a) {
    var b = this,
        c = null;return R(this, Ql(this, a.providerId).then(function () {
      return b.F();
    }).then(function (d) {
      return a.b(b.b, d);
    }).then(function (d) {
      c = Pl(b, d, "link");return Rl(b, d);
    }).then(function () {
      return c;
    }));
  };h.rc = function (a) {
    Ne("firebase.User.prototype.linkWithCredential is deprecated. Please use firebase.User.prototype.linkAndRetrieveDataWithCredential instead.");return this.fb(a).then(function (b) {
      return b.user;
    });
  };
  h.sc = function (a, b) {
    var c = this;return R(this, Ql(this, "phone").then(function () {
      return el(yl(c), a, b, t(c.fb, c));
    }));
  };h.Bc = function (a, b) {
    var c = this;return R(this, D().then(function () {
      return el(yl(c), a, b, t(c.hb, c));
    }), !0);
  };function Pl(a, b, c) {
    var d = Eg(b);b = Hf(b);return Qe({ user: a, credential: d, additionalUserInfo: b, operationType: c });
  }function Rl(a, b) {
    Nl(a, b);return a.reload().then(function () {
      return a;
    });
  }
  h.qb = function (a) {
    var b = this;return R(this, this.F().then(function (c) {
      return b.b.qb(c, a);
    }).then(function (c) {
      Nl(b, c);return b.reload();
    }));
  };h.Tc = function (a) {
    var b = this;return R(this, this.F().then(function (c) {
      return a.b(b.b, c);
    }).then(function (c) {
      Nl(b, c);return b.reload();
    }));
  };h.rb = function (a) {
    var b = this;return R(this, this.F().then(function (c) {
      return b.b.rb(c, a);
    }).then(function (c) {
      Nl(b, c);return b.reload();
    }));
  };
  h.sb = function (a) {
    if (void 0 === a.displayName && void 0 === a.photoURL) return Fl(this);var b = this;return R(this, this.F().then(function (c) {
      return b.b.sb(c, { displayName: a.displayName, photoUrl: a.photoURL });
    }).then(function (c) {
      Nl(b, c);Jl(b, "displayName", c.displayName || null);Jl(b, "photoURL", c.photoUrl || null);w(b.providerData, function (d) {
        "password" === d.providerId && (L(d, "displayName", b.displayName), L(d, "photoURL", b.photoURL));
      });return Cl(b);
    }).then(El));
  };
  h.Rc = function (a) {
    var b = this;return R(this, Ll(this).then(function (c) {
      return Ha(Gl(b), a) ? Ai(b.b, c, [a]).then(function (d) {
        var e = {};w(d.providerUserInfo || [], function (f) {
          e[f.providerId] = !0;
        });w(Gl(b), function (f) {
          e[f] || Il(b, f);
        });e[Bg.PROVIDER_ID] || L(b, "phoneNumber", null);return Cl(b);
      }) : Cl(b).then(function () {
        throw new N("no-such-provider");
      });
    }));
  };
  h.delete = function () {
    var a = this;return R(this, this.F().then(function (b) {
      return P(a.b, Oi, { idToken: b });
    }).then(function () {
      a.dispatchEvent(new rl("userDeleted"));
    })).then(function () {
      for (var b = 0; b < a.G.length; b++) a.G[b].cancel("app-deleted");wl(a, null);xl(a, null);a.G = [];a.D = !0;Al(a);L(a, "refreshToken", null);a.a && a.a.unsubscribe(a);
    });
  };
  h.wb = function (a, b) {
    return "linkViaPopup" == a && (this.g || null) == b && this.f || "reauthViaPopup" == a && (this.g || null) == b && this.f || "linkViaRedirect" == a && (this.aa || null) == b || "reauthViaRedirect" == a && (this.aa || null) == b ? !0 : !1;
  };h.ha = function (a, b, c, d) {
    "linkViaPopup" != a && "reauthViaPopup" != a || d != (this.g || null) || (c && this.v ? this.v(c) : b && !c && this.f && this.f(b), this.c && (this.c.cancel(), this.c = null), delete this.f, delete this.v);
  };
  h.xa = function (a, b) {
    return "linkViaPopup" == a && b == (this.g || null) ? t(this.Bb, this) : "reauthViaPopup" == a && b == (this.g || null) ? t(this.Cb, this) : "linkViaRedirect" == a && (this.aa || null) == b ? t(this.Bb, this) : "reauthViaRedirect" == a && (this.aa || null) == b ? t(this.Cb, this) : null;
  };h.tc = function (a) {
    var b = this;return Sl(this, "linkViaPopup", a, function () {
      return Ql(b, a.providerId).then(function () {
        return Cl(b);
      });
    }, !1);
  };h.Cc = function (a) {
    return Sl(this, "reauthViaPopup", a, function () {
      return D();
    }, !0);
  };
  function Sl(a, b, c, d, e) {
    if (!xe()) return E(new N("operation-not-supported-in-this-environment"));if (a.i && !e) return E(a.i);var f = Gf(c.providerId),
        g = we(a.uid + ":::"),
        k = null;(!ze() || oe()) && a.u && c.isOAuthProvider && (k = jj(a.u, a.l, a.m, b, c, null, g, __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION || null));var n = fe(k, f && f.Ba, f && f.Aa);d = d().then(function () {
      Tl(a);if (!e) return a.F().then(function () {});
    }).then(function () {
      return Uk(a.a, n, b, c, g, !!k);
    }).then(function () {
      return new C(function (p, z) {
        a.ha(b, null, new N("cancelled-popup-request"), a.g || null);
        a.f = p;a.v = z;a.g = g;a.c = a.a.Ea(a, b, n, g);
      });
    }).then(function (p) {
      n && ee(n);return p ? Qe(p) : null;
    }).s(function (p) {
      n && ee(n);throw p;
    });return R(a, d, e);
  }h.uc = function (a) {
    var b = this;return Ul(this, "linkViaRedirect", a, function () {
      return Ql(b, a.providerId);
    }, !1);
  };h.Dc = function (a) {
    return Ul(this, "reauthViaRedirect", a, function () {
      return D();
    }, !0);
  };
  function Ul(a, b, c, d, e) {
    if (!xe()) return E(new N("operation-not-supported-in-this-environment"));if (a.i && !e) return E(a.i);var f = null,
        g = we(a.uid + ":::");d = d().then(function () {
      Tl(a);if (!e) return a.F().then(function () {});
    }).then(function () {
      a.aa = g;return Cl(a);
    }).then(function (k) {
      a.ba && (k = a.ba, k = k.b.set(Vl, a.w(), k.a));return k;
    }).then(function () {
      return a.a.Ca(b, c, g);
    }).s(function (k) {
      f = k;if (a.ba) return Wl(a.ba);throw f;
    }).then(function () {
      if (f) throw f;
    });return R(a, d, e);
  }
  function Tl(a) {
    if (!a.a || !a.I) {
      if (a.a && !a.I) throw new N("internal-error");throw new N("auth-domain-config-required");
    }
  }h.Bb = function (a, b, c) {
    var d = this;this.c && (this.c.cancel(), this.c = null);var e = null,
        f = this.F().then(function (g) {
      return Yf(d.b, { requestUri: a, postBody: c, sessionId: b, idToken: g });
    }).then(function (g) {
      e = Pl(d, g, "link");return Rl(d, g);
    }).then(function () {
      return e;
    });return R(this, f);
  };
  h.Cb = function (a, b, c) {
    var d = this;this.c && (this.c.cancel(), this.c = null);var e = null,
        f = D().then(function () {
      return Tf(Zf(d.b, { requestUri: a, sessionId: b, postBody: c }), d.uid);
    }).then(function (g) {
      e = Pl(d, g, "reauthenticate");Nl(d, g);d.i = null;return d.reload();
    }).then(function () {
      return e;
    });return R(this, f, !0);
  };h.kb = function (a) {
    var b = this,
        c = null;return R(this, this.F().then(function (d) {
      c = d;return "undefined" === typeof a || Ya(a) ? {} : qf(new ff(a));
    }).then(function (d) {
      return b.b.kb(c, d);
    }).then(function (d) {
      if (b.email != d) return b.reload();
    }).then(function () {}));
  };
  function R(a, b, c) {
    var d = Xl(a, b, c);a.G.push(d);d.ia(function () {
      Ia(a.G, d);
    });return d;
  }function Xl(a, b, c) {
    return a.i && !c ? (b.cancel(), E(a.i)) : b.s(function (d) {
      !d || "auth/user-disabled" != d.code && "auth/user-token-expired" != d.code || (a.i || a.dispatchEvent(new rl("userInvalidated")), a.i = d);throw d;
    });
  }h.toJSON = function () {
    return this.w();
  };
  h.w = function () {
    var a = { uid: this.uid, displayName: this.displayName, photoURL: this.photoURL, email: this.email, emailVerified: this.emailVerified, phoneNumber: this.phoneNumber, isAnonymous: this.isAnonymous, providerData: [], apiKey: this.l, appName: this.m, authDomain: this.u, stsTokenManager: this.h.w(), redirectEventId: this.aa || null };this.metadata && ab(a, this.metadata.w());w(this.providerData, function (b) {
      a.providerData.push(Re(b));
    });return a;
  };
  function Yl(a) {
    if (!a.apiKey) return null;var b = { apiKey: a.apiKey, authDomain: a.authDomain, appName: a.appName },
        c = {};if (a.stsTokenManager && a.stsTokenManager.accessToken && a.stsTokenManager.expirationTime) c[Uf] = a.stsTokenManager.accessToken, c.refreshToken = a.stsTokenManager.refreshToken || null, c.expiresIn = (a.stsTokenManager.expirationTime - qa()) / 1E3;else return null;var d = new Q(b, c, a);a.providerData && w(a.providerData, function (e) {
      e && Hl(d, Qe(e));
    });a.redirectEventId && (d.aa = a.redirectEventId);return d;
  }
  function Zl(a, b, c, d) {
    var e = new Q(a, b);c && (e.ba = c);d && vl(e, d);return e.reload().then(function () {
      return e;
    });
  }function $l(a, b, c, d) {
    b = b || { apiKey: a.l, authDomain: a.u, appName: a.m };var e = a.h,
        f = {};f[Uf] = e.b;f.refreshToken = e.a;f.expiresIn = (e.c - qa()) / 1E3;b = new Q(b, f);c && (b.ba = c);d && vl(b, d);Kl(b, a);return b;
  };function am(a) {
    this.a = a;this.b = Yj();
  }var Vl = { name: "redirectUser", B: "session" };function Wl(a) {
    return ck(a.b, Vl, a.a);
  }function bm(a, b) {
    return a.b.get(Vl, a.a).then(function (c) {
      c && b && (c.authDomain = b);return Yl(c || {});
    });
  };function cm(a) {
    this.a = a;this.b = Yj();this.c = null;this.f = dm(this);this.b.addListener(em("local"), this.a, t(this.g, this));
  }cm.prototype.g = function () {
    var a = this,
        b = em("local");fm(this, function () {
      return D().then(function () {
        return a.c && "local" != a.c.B ? a.b.get(b, a.a) : null;
      }).then(function (c) {
        if (c) return gm(a, "local").then(function () {
          a.c = b;
        });
      });
    });
  };function gm(a, b) {
    var c = [],
        d;for (d in Uj) Uj[d] !== b && c.push(ck(a.b, em(Uj[d]), a.a));c.push(ck(a.b, hm, a.a));return vb(c);
  }
  function dm(a) {
    var b = em("local"),
        c = em("session"),
        d = em("none");return bk(a.b, b, a.a).then(function () {
      return a.b.get(c, a.a);
    }).then(function (e) {
      return e ? c : a.b.get(d, a.a).then(function (f) {
        return f ? d : a.b.get(b, a.a).then(function (g) {
          return g ? b : a.b.get(hm, a.a).then(function (k) {
            return k ? em(k) : b;
          });
        });
      });
    }).then(function (e) {
      a.c = e;return gm(a, e.B);
    }).s(function () {
      a.c || (a.c = b);
    });
  }var hm = { name: "persistence", B: "session" };function em(a) {
    return { name: "authUser", B: a };
  }
  cm.prototype.nb = function (a) {
    var b = null,
        c = this;Vj(a);return fm(this, function () {
      return a != c.c.B ? c.b.get(c.c, c.a).then(function (d) {
        b = d;return gm(c, a);
      }).then(function () {
        c.c = em(a);if (b) return c.b.set(c.c, b, c.a);
      }) : D();
    });
  };function im(a) {
    return fm(a, function () {
      return a.b.set(hm, a.c.B, a.a);
    });
  }function jm(a, b) {
    return fm(a, function () {
      return a.b.set(a.c, b.w(), a.a);
    });
  }function km(a) {
    return fm(a, function () {
      return ck(a.b, a.c, a.a);
    });
  }
  function lm(a, b) {
    return fm(a, function () {
      return a.b.get(a.c, a.a).then(function (c) {
        c && b && (c.authDomain = b);return Yl(c || {});
      });
    });
  }function fm(a, b) {
    a.f = a.f.then(b, b);return a.f;
  };function mm(a) {
    this.l = !1;L(this, "settings", new cl());L(this, "app", a);if (S(this).options && S(this).options.apiKey) a = __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION ? ue(__WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION) : null, this.b = new Vh(S(this).options && S(this).options.apiKey, Bf(Cf), a);else throw new N("invalid-api-key");this.N = [];this.m = [];this.I = [];this.Tb = __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.createSubscribe(t(this.oc, this));this.O = void 0;this.Ub = __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.createSubscribe(t(this.pc, this));nm(this, null);this.h = new cm(S(this).options.apiKey + ":" + S(this).name);this.A = new am(S(this).options.apiKey + ":" + S(this).name);this.V = T(this, om(this));this.i = T(this, pm(this));this.X = !1;this.ka = t(this.Oc, this);this.Ha = t(this.Z, this);this.ra = t(this.bc, this);this.sa = t(this.mc, this);this.ta = t(this.nc, this);qm(this);this.INTERNAL = {};this.INTERNAL["delete"] = t(this.delete, this);this.INTERNAL.logFramework = t(this.vc, this);this.u = 0;H.call(this);rm(this);this.G = [];
  }u(mm, H);function sm(a) {
    F.call(this, "languageCodeChanged");this.g = a;
  }u(sm, F);
  function tm(a) {
    F.call(this, "frameworkChanged");this.c = a;
  }u(tm, F);h = mm.prototype;h.nb = function (a) {
    a = this.h.nb(a);return T(this, a);
  };h.pa = function (a) {
    this.W === a || this.l || (this.W = a, ai(this.b, this.W), this.dispatchEvent(new sm(this.ea())));
  };h.ea = function () {
    return this.W;
  };h.Uc = function () {
    var a = l.navigator;this.pa(a ? a.languages && a.languages[0] || a.language || a.userLanguage || null : null);
  };h.vc = function (a) {
    this.G.push(a);bi(this.b, __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION ? ue(__WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION, this.G) : null);this.dispatchEvent(new tm(this.G));
  };
  h.ya = function () {
    return Ka(this.G);
  };function rm(a) {
    Object.defineProperty(a, "lc", { get: function () {
        return this.ea();
      }, set: function (b) {
        this.pa(b);
      }, enumerable: !1 });a.W = null;
  }h.toJSON = function () {
    return { apiKey: S(this).options.apiKey, authDomain: S(this).options.authDomain, appName: S(this).name, currentUser: U(this) && U(this).w() };
  };function um(a) {
    return a.Sb || E(new N("auth-domain-config-required"));
  }
  function qm(a) {
    var b = S(a).options.authDomain,
        c = S(a).options.apiKey;b && xe() && (a.Sb = a.V.then(function () {
      if (!a.l) {
        a.a = Wk(b, c, S(a).name);a.a.subscribe(a);U(a) && Dl(U(a));if (a.D) {
          Dl(a.D);var d = a.D;d.pa(a.ea());wl(d, a);d = a.D;vl(d, a.G);xl(d, a);a.D = null;
        }return a.a;
      }
    }));
  }h.wb = function (a, b) {
    switch (a) {case "unknown":case "signInViaRedirect":
        return !0;case "signInViaPopup":
        return this.g == b && !!this.f;default:
        return !1;}
  };
  h.ha = function (a, b, c, d) {
    "signInViaPopup" == a && this.g == d && (c && this.v ? this.v(c) : b && !c && this.f && this.f(b), this.c && (this.c.cancel(), this.c = null), delete this.f, delete this.v);
  };h.xa = function (a, b) {
    return "signInViaRedirect" == a || "signInViaPopup" == a && this.g == b && this.f ? t(this.ac, this) : null;
  };
  h.ac = function (a, b, c) {
    var d = this;a = { requestUri: a, postBody: c, sessionId: b };this.c && (this.c.cancel(), this.c = null);var e = null,
        f = null,
        g = Wf(d.b, a).then(function (k) {
      e = Eg(k);f = Hf(k);return k;
    });a = d.V.then(function () {
      return g;
    }).then(function (k) {
      return vm(d, k);
    }).then(function () {
      return Qe({ user: U(d), credential: e, additionalUserInfo: f, operationType: "signIn" });
    });return T(this, a);
  };
  h.Mc = function (a) {
    if (!xe()) return E(new N("operation-not-supported-in-this-environment"));var b = this,
        c = Gf(a.providerId),
        d = we(),
        e = null;(!ze() || oe()) && S(this).options.authDomain && a.isOAuthProvider && (e = jj(S(this).options.authDomain, S(this).options.apiKey, S(this).name, "signInViaPopup", a, null, d, __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION || null));var f = fe(e, c && c.Ba, c && c.Aa);c = um(this).then(function (g) {
      return Uk(g, f, "signInViaPopup", a, d, !!e);
    }).then(function () {
      return new C(function (g, k) {
        b.ha("signInViaPopup", null, new N("cancelled-popup-request"), b.g);b.f = g;b.v = k;b.g = d;b.c = b.a.Ea(b, "signInViaPopup", f, d);
      });
    }).then(function (g) {
      f && ee(f);return g ? Qe(g) : null;
    }).s(function (g) {
      f && ee(f);throw g;
    });return T(this, c);
  };h.Nc = function (a) {
    if (!xe()) return E(new N("operation-not-supported-in-this-environment"));var b = this,
        c = um(this).then(function () {
      return im(b.h);
    }).then(function () {
      return b.a.Ca("signInViaRedirect", a);
    });return T(this, c);
  };
  h.fa = function () {
    if (!xe()) return E(new N("operation-not-supported-in-this-environment"));var a = this,
        b = um(this).then(function () {
      return a.a.fa();
    }).then(function (c) {
      return c ? Qe(c) : null;
    });return T(this, b);
  };
  h.Sc = function (a) {
    if (!a) return E(new N("null-user"));var b = this,
        c = {};c.apiKey = S(this).options.apiKey;c.authDomain = S(this).options.authDomain;c.appName = S(this).name;var d = $l(a, c, b.A, b.ya());return T(this, this.i.then(function () {
      if (S(b).options.apiKey != a.l) return d.reload();
    }).then(function () {
      if (U(b) && a.uid == U(b).uid) return Kl(U(b), a), b.Z(a);nm(b, d);Dl(d);return b.Z(d);
    }).then(function () {
      wm(b);
    }));
  };
  function vm(a, b) {
    var c = {};c.apiKey = S(a).options.apiKey;c.authDomain = S(a).options.authDomain;c.appName = S(a).name;return a.V.then(function () {
      return Zl(c, b, a.A, a.ya());
    }).then(function (d) {
      if (U(a) && d.uid == U(a).uid) return Kl(U(a), d), a.Z(d);nm(a, d);Dl(d);return a.Z(d);
    }).then(function () {
      wm(a);
    });
  }
  function nm(a, b) {
    U(a) && (Bl(U(a), a.Ha), G(U(a), "tokenChanged", a.ra), G(U(a), "userDeleted", a.sa), G(U(a), "userInvalidated", a.ta), Al(U(a)));b && (b.N.push(a.Ha), tc(b, "tokenChanged", a.ra), tc(b, "userDeleted", a.sa), tc(b, "userInvalidated", a.ta), 0 < a.u && zl(b));L(a, "currentUser", b);b && (b.pa(a.ea()), wl(b, a), vl(b, a.G), xl(b, a));
  }h.ob = function () {
    var a = this,
        b = this.i.then(function () {
      if (!U(a)) return D();nm(a, null);return km(a.h).then(function () {
        wm(a);
      });
    });return T(this, b);
  };
  function xm(a) {
    var b = bm(a.A, S(a).options.authDomain).then(function (c) {
      if (a.D = c) c.ba = a.A;return Wl(a.A);
    });return T(a, b);
  }function om(a) {
    var b = S(a).options.authDomain,
        c = xm(a).then(function () {
      return lm(a.h, b);
    }).then(function (d) {
      return d ? (d.ba = a.A, a.D && (a.D.aa || null) == (d.aa || null) ? d : d.reload().then(function () {
        return jm(a.h, d).then(function () {
          return d;
        });
      }).s(function (e) {
        return "auth/network-request-failed" == e.code ? d : km(a.h);
      })) : null;
    }).then(function (d) {
      nm(a, d || null);
    });return T(a, c);
  }
  function pm(a) {
    return a.V.then(function () {
      return a.fa();
    }).s(function () {}).then(function () {
      if (!a.l) return a.ka();
    }).s(function () {}).then(function () {
      if (!a.l) {
        a.X = !0;var b = a.h;b.b.addListener(em("local"), b.a, a.ka);
      }
    });
  }
  h.Oc = function () {
    var a = this;return lm(this.h, S(this).options.authDomain).then(function (b) {
      if (!a.l) {
        var c;if (c = U(a) && b) {
          c = U(a).uid;var d = b.uid;c = void 0 === c || null === c || "" === c || void 0 === d || null === d || "" === d ? !1 : c == d;
        }if (c) return Kl(U(a), b), U(a).F();if (U(a) || b) nm(a, b), b && (Dl(b), b.ba = a.A), a.a && a.a.subscribe(a), wm(a);
      }
    });
  };h.Z = function (a) {
    return jm(this.h, a);
  };h.bc = function () {
    wm(this);this.Z(U(this));
  };h.mc = function () {
    this.ob();
  };h.nc = function () {
    this.ob();
  };
  function ym(a, b) {
    var c = null,
        d = null;return T(a, b.then(function (e) {
      c = Eg(e);d = Hf(e);return vm(a, e);
    }).then(function () {
      return Qe({ user: U(a), credential: c, additionalUserInfo: d, operationType: "signIn" });
    }));
  }h.oc = function (a) {
    var b = this;this.addAuthTokenListener(function () {
      a.next(U(b));
    });
  };h.pc = function (a) {
    var b = this;zm(this, function () {
      a.next(U(b));
    });
  };h.xc = function (a, b, c) {
    var d = this;this.X && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.Promise.resolve().then(function () {
      q(a) ? a(U(d)) : q(a.next) && a.next(U(d));
    });return this.Tb(a, b, c);
  };
  h.wc = function (a, b, c) {
    var d = this;this.X && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.Promise.resolve().then(function () {
      d.O = d.getUid();q(a) ? a(U(d)) : q(a.next) && a.next(U(d));
    });return this.Ub(a, b, c);
  };h.cc = function (a) {
    var b = this,
        c = this.i.then(function () {
      return U(b) ? U(b).F(a).then(function (d) {
        return { accessToken: d };
      }) : null;
    });return T(this, c);
  };h.Nb = function (a) {
    var b = this;return this.i.then(function () {
      return ym(b, P(b.b, Ri, { token: a }));
    }).then(function (c) {
      var d = c.user;Jl(d, "isAnonymous", !1);b.Z(d);return c;
    });
  };
  h.Gc = function (a) {
    Ne("firebase.auth.Auth.prototype.signInAndRetrieveDataWithCustomToken is deprecated. Please use firebase.auth.Auth.prototype.signInWithCustomToken instead.");return this.Nb(a);
  };h.Hc = function (a, b) {
    Ne("firebase.auth.Auth.prototype.signInAndRetrieveDataWithEmailAndPassword is deprecated. Please use firebase.auth.Auth.prototype.signInWithEmailAndPassword instead.");return this.Ob(a, b);
  };h.Ob = function (a, b) {
    var c = this;return this.i.then(function () {
      return ym(c, P(c.b, qg, { email: a, password: b }));
    });
  };
  h.yb = function (a, b) {
    var c = this;return this.i.then(function () {
      return ym(c, P(c.b, Ni, { email: a, password: b }));
    });
  };h.Wb = function (a, b) {
    Ne("firebase.auth.Auth.prototype.createUserAndRetrieveDataWithEmailAndPassword is deprecated. Please use firebase.auth.Auth.prototype.createUserWithEmailAndPassword instead.");return this.yb(a, b);
  };h.Jc = function (a) {
    Ne("firebase.auth.Auth.prototype.signInWithCredential is deprecated. Please use firebase.auth.Auth.prototype.signInAndRetrieveDataWithCredential instead.");return this.Qa(a).then(function (b) {
      return b.user;
    });
  };
  h.Qa = function (a) {
    var b = this;return this.i.then(function () {
      return ym(b, a.la(b.b));
    });
  };h.Ra = function () {
    var a = this;return this.i.then(function () {
      var b = U(a);if (b && b.isAnonymous) {
        var c = Qe({ providerId: null, isNewUser: !1 });return Qe({ user: b, credential: null, additionalUserInfo: c, operationType: "signIn" });
      }return ym(a, a.b.Ra()).then(function (d) {
        var e = d.user;Jl(e, "isAnonymous", !0);a.Z(e);return d;
      });
    });
  };
  h.Ic = function () {
    Ne("firebase.auth.Auth.prototype.signInAnonymouslyAndRetrieveData is deprecated. Please use firebase.auth.Auth.prototype.signInAnonymously instead.");return this.Ra();
  };function S(a) {
    return a.app;
  }function U(a) {
    return a.currentUser;
  }h.getUid = function () {
    return U(this) && U(this).uid || null;
  };function Am(a) {
    return U(a) && U(a)._lat || null;
  }
  function wm(a) {
    if (a.X) {
      for (var b = 0; b < a.m.length; b++) if (a.m[b]) a.m[b](Am(a));if (a.O !== a.getUid() && a.I.length) for (a.O = a.getUid(), b = 0; b < a.I.length; b++) if (a.I[b]) a.I[b](Am(a));
    }
  }h.Vb = function (a) {
    this.addAuthTokenListener(a);this.u++;0 < this.u && U(this) && zl(U(this));
  };h.Ec = function (a) {
    var b = this;w(this.m, function (c) {
      c == a && b.u--;
    });0 > this.u && (this.u = 0);0 == this.u && U(this) && Al(U(this));this.removeAuthTokenListener(a);
  };
  h.addAuthTokenListener = function (a) {
    var b = this;this.m.push(a);T(this, this.i.then(function () {
      b.l || Ha(b.m, a) && a(Am(b));
    }));
  };h.removeAuthTokenListener = function (a) {
    x(this.m, function (b) {
      return b == a;
    });
  };function zm(a, b) {
    a.I.push(b);T(a, a.i.then(function () {
      !a.l && Ha(a.I, b) && a.O !== a.getUid() && (a.O = a.getUid(), b(Am(a)));
    }));
  }
  h.delete = function () {
    this.l = !0;for (var a = 0; a < this.N.length; a++) this.N[a].cancel("app-deleted");this.N = [];this.h && (a = this.h, a.b.removeListener(em("local"), a.a, this.ka));this.a && (this.a.unsubscribe(this), this.a.Za());return __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.Promise.resolve();
  };function T(a, b) {
    a.N.push(b);b.ia(function () {
      Ia(a.N, b);
    });return b;
  }
  h.Zb = function (a) {
    Ne("firebase.auth.Auth.prototype.fetchProvidersForEmail is deprecated. Please use firebase.auth.Auth.prototype.fetchSignInMethodsForEmail instead.");return T(this, li(this.b, a));
  };h.$b = function (a) {
    return T(this, ni(this.b, a));
  };h.qc = function (a) {
    return !!vg(a);
  };h.mb = function (a, b) {
    var c = this;return T(this, D().then(function () {
      var d = new ff(b);if (!d.c) throw new N("argument-error", of + " must be true when sending sign in link to email");return qf(d);
    }).then(function (d) {
      return c.b.mb(a, d);
    }).then(function () {}));
  };
  h.Vc = function (a) {
    return this.Ja(a).then(function (b) {
      return b.data.email;
    });
  };h.$a = function (a, b) {
    return T(this, this.b.$a(a, b).then(function () {}));
  };h.Ja = function (a) {
    return T(this, this.b.Ja(a).then(function (b) {
      return new Ue(b);
    }));
  };h.Xa = function (a) {
    return T(this, this.b.Xa(a).then(function () {}));
  };h.lb = function (a, b) {
    var c = this;return T(this, D().then(function () {
      return "undefined" === typeof b || Ya(b) ? {} : qf(new ff(b));
    }).then(function (d) {
      return c.b.lb(a, d);
    }).then(function () {}));
  };
  h.Lc = function (a, b) {
    return T(this, el(this, a, b, t(this.Qa, this)));
  };h.Kc = function (a, b) {
    var c = this;return T(this, D().then(function () {
      var d = ug(a, b || Yd());return c.Qa(d);
    }));
  };function Bm() {}Bm.prototype.render = function () {};Bm.prototype.reset = function () {};Bm.prototype.getResponse = function () {};Bm.prototype.execute = function () {};function Cm() {
    this.a = {};this.b = 1E12;
  }var Dm = null;Cm.prototype.render = function (a, b) {
    this.a[this.b.toString()] = new Em(a, b);return this.b++;
  };Cm.prototype.reset = function (a) {
    var b = Fm(this, a);a = Gm(a);b && a && (b.delete(), delete this.a[a]);
  };Cm.prototype.getResponse = function (a) {
    return (a = Fm(this, a)) ? a.getResponse() : null;
  };Cm.prototype.execute = function (a) {
    (a = Fm(this, a)) && a.execute();
  };function Fm(a, b) {
    return (b = Gm(b)) ? a.a[b] || null : null;
  }function Gm(a) {
    return (a = "undefined" === typeof a ? 1E12 : a) ? a.toString() : null;
  }
  function Em(a, b) {
    this.g = !1;this.c = b;this.a = this.b = null;this.h = "invisible" !== this.c.size;this.f = Ld(a);var c = this;this.i = function () {
      c.execute();
    };this.h ? this.execute() : tc(this.f, "click", this.i);
  }Em.prototype.getResponse = function () {
    Hm(this);return this.b;
  };
  Em.prototype.execute = function () {
    Hm(this);var a = this;this.a || (this.a = setTimeout(function () {
      a.b = se();var b = a.c.callback,
          c = a.c["expired-callback"];if (b) try {
        b(a.b);
      } catch (d) {}a.a = setTimeout(function () {
        a.a = null;a.b = null;if (c) try {
          c();
        } catch (d) {}a.h && a.execute();
      }, 6E4);
    }, 500));
  };Em.prototype.delete = function () {
    Hm(this);this.g = !0;clearTimeout(this.a);this.a = null;G(this.f, "click", this.i);
  };function Hm(a) {
    if (a.g) throw Error("reCAPTCHA mock was already deleted!");
  };function Im() {}Im.prototype.g = function () {
    Dm || (Dm = new Cm());return D(Dm);
  };Im.prototype.c = function () {};var Jm = null;function Km() {
    this.b = l.grecaptcha ? Infinity : 0;this.f = null;this.a = "__rcb" + Math.floor(1E6 * Math.random()).toString();
  }var Lm = new pd(qd, "https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}"),
      Mm = new Fe(3E4, 6E4);
  Km.prototype.g = function (a) {
    var b = this;return new C(function (c, d) {
      var e = setTimeout(function () {
        d(new N("network-request-failed"));
      }, Mm.get());if (!l.grecaptcha || a !== b.f && !b.b) {
        l[b.a] = function () {
          if (l.grecaptcha) {
            b.f = a;var g = l.grecaptcha.render;l.grecaptcha.render = function (k, n) {
              k = g(k, n);b.b++;return k;
            };clearTimeout(e);c(l.grecaptcha);
          } else clearTimeout(e), d(new N("internal-error"));delete l[b.a];
        };var f = wd(Lm, { onload: b.a, hl: a || "" });D(Oh(f)).s(function () {
          clearTimeout(e);d(new N("internal-error", "Unable to load external reCAPTCHA dependencies!"));
        });
      } else clearTimeout(e), c(l.grecaptcha);
    });
  };Km.prototype.c = function () {
    this.b--;
  };var Nm = null;function Om(a, b, c, d, e, f, g) {
    L(this, "type", "recaptcha");this.c = this.f = null;this.D = !1;this.l = b;this.g = null;g ? (Jm || (Jm = new Im()), g = Jm) : (Nm || (Nm = new Km()), g = Nm);this.m = g;this.a = c || { theme: "light", type: "image" };this.h = [];if (this.a[Pm]) throw new N("argument-error", "sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.");this.i = "invisible" === this.a[Qm];if (!l.document) throw new N("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment with DOM support.");
    if (!Ld(b) || !this.i && Ld(b).hasChildNodes()) throw new N("argument-error", "reCAPTCHA container is either not found or already contains inner elements!");this.u = new Vh(a, f || null, e || null);this.v = d || function () {
      return null;
    };var k = this;this.o = [];var n = this.a[Rm];this.a[Rm] = function (z) {
      Sm(k, z);if ("function" === typeof n) n(z);else if ("string" === typeof n) {
        var A = K(n, l);"function" === typeof A && A(z);
      }
    };var p = this.a[Tm];this.a[Tm] = function () {
      Sm(k, null);if ("function" === typeof p) p();else if ("string" === typeof p) {
        var z = K(p, l);"function" === typeof z && z();
      }
    };
  }var Rm = "callback",
      Tm = "expired-callback",
      Pm = "sitekey",
      Qm = "size";function Sm(a, b) {
    for (var c = 0; c < a.o.length; c++) try {
      a.o[c](b);
    } catch (d) {}
  }function Um(a, b) {
    x(a.o, function (c) {
      return c == b;
    });
  }function Vm(a, b) {
    a.h.push(b);b.ia(function () {
      Ia(a.h, b);
    });return b;
  }h = Om.prototype;
  h.za = function () {
    var a = this;return this.f ? this.f : this.f = Vm(this, D().then(function () {
      if (ye() && !pe()) return ke();throw new N("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.");
    }).then(function () {
      return a.m.g(a.v());
    }).then(function (b) {
      a.g = b;return P(a.u, Qi, {});
    }).then(function (b) {
      a.a[Pm] = b.recaptchaSiteKey;
    }).s(function (b) {
      a.f = null;throw b;
    }));
  };
  h.render = function () {
    Wm(this);var a = this;return Vm(this, this.za().then(function () {
      if (null === a.c) {
        var b = a.l;if (!a.i) {
          var c = Ld(b);b = Od("DIV");c.appendChild(b);
        }a.c = a.g.render(b, a.a);
      }return a.c;
    }));
  };h.verify = function () {
    Wm(this);var a = this;return Vm(this, this.render().then(function (b) {
      return new C(function (c) {
        var d = a.g.getResponse(b);if (d) c(d);else {
          var e = function (f) {
            f && (Um(a, e), c(f));
          };a.o.push(e);a.i && a.g.execute(a.c);
        }
      });
    }));
  };h.reset = function () {
    Wm(this);null !== this.c && this.g.reset(this.c);
  };
  function Wm(a) {
    if (a.D) throw new N("internal-error", "RecaptchaVerifier instance has been destroyed.");
  }h.clear = function () {
    Wm(this);this.D = !0;this.m.c();for (var a = 0; a < this.h.length; a++) this.h[a].cancel("RecaptchaVerifier instance has been destroyed.");if (!this.i) {
      a = Ld(this.l);for (var b; b = a.firstChild;) a.removeChild(b);
    }
  };
  function Xm(a, b, c) {
    var d = !1;try {
      this.b = c || __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.app();
    } catch (g) {
      throw new N("argument-error", "No firebase.app.App instance is currently initialized.");
    }if (this.b.options && this.b.options.apiKey) c = this.b.options.apiKey;else throw new N("invalid-api-key");var e = this,
        f = null;try {
      f = this.b.auth().ya();
    } catch (g) {}try {
      d = this.b.auth().settings.appVerificationDisabledForTesting;
    } catch (g) {}f = __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION ? ue(__WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.SDK_VERSION, f) : null;Om.call(this, c, a, b, function () {
      try {
        var g = e.b.auth().ea();
      } catch (k) {
        g = null;
      }return g;
    }, f, Bf(Cf), d);
  }u(Xm, Om);function Ym(a, b, c, d) {
    a: {
      c = Array.prototype.slice.call(c);var e = 0;for (var f = !1, g = 0; g < b.length; g++) if (b[g].optional) f = !0;else {
        if (f) throw new N("internal-error", "Argument validator encountered a required argument after an optional argument.");e++;
      }f = b.length;if (c.length < e || f < c.length) d = "Expected " + (e == f ? 1 == e ? "1 argument" : e + " arguments" : e + "-" + f + " arguments") + " but got " + c.length + ".";else {
        for (e = 0; e < c.length; e++) if (f = b[e].optional && void 0 === c[e], !b[e].M(c[e]) && !f) {
          b = b[e];if (0 > e || e >= Zm.length) throw new N("internal-error", "Argument validator received an unsupported number of arguments.");c = Zm[e];d = (d ? "" : c + " argument ") + (b.name ? '"' + b.name + '" ' : "") + "must be " + b.K + ".";break a;
        }d = null;
      }
    }if (d) throw new N("argument-error", a + " failed: " + d);
  }var Zm = "First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" ");function V(a, b) {
    return { name: a || "", K: "a valid string", optional: !!b, M: m };
  }function $m(a, b) {
    return { name: a || "", K: "a boolean", optional: !!b, M: ba };
  }
  function W(a, b) {
    return { name: a || "", K: "a valid object", optional: !!b, M: r };
  }function an(a, b) {
    return { name: a || "", K: "a function", optional: !!b, M: q };
  }function bn(a, b) {
    return { name: a || "", K: "null", optional: !!b, M: ia };
  }function cn() {
    return { name: "", K: "an HTML element", optional: !1, M: function (a) {
        return !!(a && a instanceof Element);
      } };
  }function dn() {
    return { name: "auth", K: "an instance of Firebase Auth", optional: !0, M: function (a) {
        return !!(a && a instanceof mm);
      } };
  }
  function en() {
    return { name: "app", K: "an instance of Firebase App", optional: !0, M: function (a) {
        return !!(a && a instanceof __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.app.App);
      } };
  }function fn(a) {
    return { name: a ? a + "Credential" : "credential", K: a ? "a valid " + a + " credential" : "a valid credential", optional: !1, M: function (b) {
        if (!b) return !1;var c = !a || b.providerId === a;return !(!b.la || !c);
      } };
  }
  function gn() {
    return { name: "authProvider", K: "a valid Auth provider", optional: !1, M: function (a) {
        return !!(a && a.providerId && a.hasOwnProperty && a.hasOwnProperty("isOAuthProvider"));
      } };
  }function hn() {
    return { name: "applicationVerifier", K: "an implementation of firebase.auth.ApplicationVerifier", optional: !1, M: function (a) {
        return !!(a && m(a.type) && q(a.verify));
      } };
  }function X(a, b, c, d) {
    return { name: c || "", K: a.K + " or " + b.K, optional: !!d, M: function (e) {
        return a.M(e) || b.M(e);
      } };
  };function Y(a, b) {
    for (var c in b) {
      var d = b[c].name;a[d] = jn(d, a[c], b[c].j);
    }
  }function kn(a, b) {
    for (var c in b) {
      var d = b[c].name;d !== c && Object.defineProperty(a, d, { get: pa(function (e) {
          return this[e];
        }, c), set: pa(function (e, f, g, k) {
          Ym(e, [g], [k], !0);this[f] = k;
        }, d, c, b[c].ub), enumerable: !0 });
    }
  }function Z(a, b, c, d) {
    a[b] = jn(b, c, d);
  }
  function jn(a, b, c) {
    function d() {
      var g = Array.prototype.slice.call(arguments);Ym(e, c, g);return b.apply(this, g);
    }if (!c) return b;var e = ln(a),
        f;for (f in b) d[f] = b[f];for (f in b.prototype) d.prototype[f] = b.prototype[f];return d;
  }function ln(a) {
    a = a.split(".");return a[a.length - 1];
  };Y(mm.prototype, { Xa: { name: "applyActionCode", j: [V("code")] }, Ja: { name: "checkActionCode", j: [V("code")] }, $a: { name: "confirmPasswordReset", j: [V("code"), V("newPassword")] }, yb: { name: "createUserWithEmailAndPassword", j: [V("email"), V("password")] }, Wb: { name: "createUserAndRetrieveDataWithEmailAndPassword", j: [V("email"), V("password")] }, Zb: { name: "fetchProvidersForEmail", j: [V("email")] }, $b: { name: "fetchSignInMethodsForEmail", j: [V("email")] }, fa: { name: "getRedirectResult", j: [] }, qc: { name: "isSignInWithEmailLink", j: [V("emailLink")] },
    wc: { name: "onAuthStateChanged", j: [X(W(), an(), "nextOrObserver"), an("opt_error", !0), an("opt_completed", !0)] }, xc: { name: "onIdTokenChanged", j: [X(W(), an(), "nextOrObserver"), an("opt_error", !0), an("opt_completed", !0)] }, lb: { name: "sendPasswordResetEmail", j: [V("email"), X(W("opt_actionCodeSettings", !0), bn(null, !0), "opt_actionCodeSettings", !0)] }, mb: { name: "sendSignInLinkToEmail", j: [V("email"), W("actionCodeSettings")] }, nb: { name: "setPersistence", j: [V("persistence")] }, Qa: { name: "signInAndRetrieveDataWithCredential",
      j: [fn()] }, Ra: { name: "signInAnonymously", j: [] }, Ic: { name: "signInAnonymouslyAndRetrieveData", j: [] }, Jc: { name: "signInWithCredential", j: [fn()] }, Nb: { name: "signInWithCustomToken", j: [V("token")] }, Gc: { name: "signInAndRetrieveDataWithCustomToken", j: [V("token")] }, Ob: { name: "signInWithEmailAndPassword", j: [V("email"), V("password")] }, Kc: { name: "signInWithEmailLink", j: [V("email"), V("emailLink", !0)] }, Hc: { name: "signInAndRetrieveDataWithEmailAndPassword", j: [V("email"), V("password")] }, Lc: { name: "signInWithPhoneNumber", j: [V("phoneNumber"), hn()] }, Mc: { name: "signInWithPopup", j: [gn()] }, Nc: { name: "signInWithRedirect", j: [gn()] }, Sc: { name: "updateCurrentUser", j: [X(function (a) {
        return { name: "user", K: "an instance of Firebase User", optional: !!a, M: function (b) {
            return !!(b && b instanceof Q);
          } };
      }(), bn(), "user")] }, ob: { name: "signOut", j: [] }, toJSON: { name: "toJSON", j: [V(null, !0)] }, Uc: { name: "useDeviceLanguage", j: [] }, Vc: { name: "verifyPasswordResetCode", j: [V("code")] } });kn(mm.prototype, { lc: { name: "languageCode", ub: X(V(), bn(), "languageCode") } });mm.Persistence = Uj;
  mm.Persistence.LOCAL = "local";mm.Persistence.SESSION = "session";mm.Persistence.NONE = "none";
  Y(Q.prototype, { "delete": { name: "delete", j: [] }, dc: { name: "getIdTokenResult", j: [$m("opt_forceRefresh", !0)] }, F: { name: "getIdToken", j: [$m("opt_forceRefresh", !0)] }, fb: { name: "linkAndRetrieveDataWithCredential", j: [fn()] }, rc: { name: "linkWithCredential", j: [fn()] }, sc: { name: "linkWithPhoneNumber", j: [V("phoneNumber"), hn()] }, tc: { name: "linkWithPopup", j: [gn()] }, uc: { name: "linkWithRedirect", j: [gn()] }, hb: { name: "reauthenticateAndRetrieveDataWithCredential", j: [fn()] }, Ac: { name: "reauthenticateWithCredential", j: [fn()] }, Bc: { name: "reauthenticateWithPhoneNumber",
      j: [V("phoneNumber"), hn()] }, Cc: { name: "reauthenticateWithPopup", j: [gn()] }, Dc: { name: "reauthenticateWithRedirect", j: [gn()] }, reload: { name: "reload", j: [] }, kb: { name: "sendEmailVerification", j: [X(W("opt_actionCodeSettings", !0), bn(null, !0), "opt_actionCodeSettings", !0)] }, toJSON: { name: "toJSON", j: [V(null, !0)] }, Rc: { name: "unlink", j: [V("provider")] }, qb: { name: "updateEmail", j: [V("email")] }, rb: { name: "updatePassword", j: [V("password")] }, Tc: { name: "updatePhoneNumber", j: [fn("phone")] }, sb: { name: "updateProfile", j: [W("profile")] } });
  Y(Cm.prototype, { execute: { name: "execute" }, render: { name: "render" }, reset: { name: "reset" }, getResponse: { name: "getResponse" } });Y(Bm.prototype, { execute: { name: "execute" }, render: { name: "render" }, reset: { name: "reset" }, getResponse: { name: "getResponse" } });Y(C.prototype, { ia: { name: "finally" }, s: { name: "catch" }, then: { name: "then" } });kn(cl.prototype, { appVerificationDisabled: { name: "appVerificationDisabledForTesting", ub: $m("appVerificationDisabledForTesting") } });Y(dl.prototype, { confirm: { name: "confirm", j: [V("verificationCode")] } });
  Z(Sf, "fromJSON", function (a) {
    a = m(a) ? JSON.parse(a) : a;for (var b, c = [cg, tg, Ag, $f], d = 0; d < c.length; d++) if (b = c[d](a)) return b;return null;
  }, [X(V(), W(), "json")]);Z(og, "credential", function (a, b) {
    return new ng(a, b);
  }, [V("email"), V("password")]);Y(ng.prototype, { w: { name: "toJSON", j: [V(null, !0)] } });Y(fg.prototype, { ua: { name: "addScope", j: [V("scope")] }, Da: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });Z(fg, "credential", gg, [X(V(), W(), "token")]);Z(og, "credentialWithLink", ug, [V("email"), V("emailLink")]);
  Y(hg.prototype, { ua: { name: "addScope", j: [V("scope")] }, Da: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });Z(hg, "credential", ig, [X(V(), W(), "token")]);Y(jg.prototype, { ua: { name: "addScope", j: [V("scope")] }, Da: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });Z(jg, "credential", kg, [X(V(), X(W(), bn()), "idToken"), X(V(), bn(), "accessToken", !0)]);Y(lg.prototype, { Da: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });Z(lg, "credential", mg, [X(V(), W(), "token"), V("secret", !0)]);
  Y(O.prototype, { ua: { name: "addScope", j: [V("scope")] }, credential: { name: "credential", j: [X(V(), X(W(), bn()), "optionsOrIdToken"), X(V(), bn(), "accessToken", !0)] }, Da: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });Y(ag.prototype, { w: { name: "toJSON", j: [V(null, !0)] } });Y(Vf.prototype, { w: { name: "toJSON", j: [V(null, !0)] } });Z(Bg, "credential", Dg, [V("verificationId"), V("verificationCode")]);Y(Bg.prototype, { Va: { name: "verifyPhoneNumber", j: [V("phoneNumber"), hn()] } });
  Y(wg.prototype, { w: { name: "toJSON", j: [V(null, !0)] } });Y(N.prototype, { toJSON: { name: "toJSON", j: [V(null, !0)] } });Y(Lg.prototype, { toJSON: { name: "toJSON", j: [V(null, !0)] } });Y(Kg.prototype, { toJSON: { name: "toJSON", j: [V(null, !0)] } });Y(Xm.prototype, { clear: { name: "clear", j: [] }, render: { name: "render", j: [] }, verify: { name: "verify", j: [] } });
  (function () {
    if ("undefined" !== typeof __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL && __WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.registerService) {
      var a = { Auth: mm, AuthCredential: Sf, Error: N };Z(a, "EmailAuthProvider", og, []);Z(a, "FacebookAuthProvider", fg, []);Z(a, "GithubAuthProvider", hg, []);Z(a, "GoogleAuthProvider", jg, []);Z(a, "TwitterAuthProvider", lg, []);Z(a, "OAuthProvider", O, [V("providerId")]);Z(a, "SAMLAuthProvider", eg, [V("providerId")]);Z(a, "PhoneAuthProvider", Bg, [dn()]);Z(a, "RecaptchaVerifier", Xm, [X(V(), cn(), "recaptchaContainer"), W("recaptchaParameters", !0), en()]);__WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.registerService("auth", function (b, c) {
        b = new mm(b);c({ INTERNAL: { getUid: t(b.getUid, b), getToken: t(b.cc, b), addAuthTokenListener: t(b.Vb, b), removeAuthTokenListener: t(b.Ec, b) } });return b;
      }, a, function (b, c) {
        if ("create" === b) try {
          c.auth();
        } catch (d) {}
      });__WEBPACK_IMPORTED_MODULE_0__firebase_app___default.a.INTERNAL.extendNamespace({ User: Q });
    } else throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");
  })();
}).apply(typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});

//# sourceMappingURL=auth.esm.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("h6ac")))

/***/ }),

/***/ "FFZn":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("3v7p"), __esModule: true };

/***/ }),

/***/ "FMmW":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("dmyY");
var anObject = __webpack_require__("hrV0");

module.exports = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) {
    throw TypeError("Can't set " + String(proto) + ' as a prototype');
  }
};

/***/ }),

/***/ "FRpO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};

var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {

  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';

  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = this._events;
  if (events === undefined) return this;

  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }

    if (list.length === 1) events[type] = list[0];

    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;

  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined) return [];

  var evlistener = events[type];
  if (evlistener === undefined) return [];

  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

/***/ }),

/***/ "Fjti":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("b3E9")(function () {
  function F() {/* empty */}
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

/***/ }),

/***/ "G6zQ":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("wJQ+");
var hide = __webpack_require__("2O9B");

module.exports = function (key, value) {
  try {
    hide(global, key, value);
  } catch (error) {
    global[key] = value;
  }return value;
};

/***/ }),

/***/ "GHga":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__("c+Wn");
var createIteratorConstructor = __webpack_require__("4Z/U");
var getPrototypeOf = __webpack_require__("Dylg");
var setPrototypeOf = __webpack_require__("CnGL");
var setToStringTag = __webpack_require__("xyxa");
var hide = __webpack_require__("2O9B");
var redefine = __webpack_require__("iKbl");
var IS_PURE = __webpack_require__("qCGA");
var ITERATOR = __webpack_require__("95jh")('iterator');
var Iterators = __webpack_require__("Gzjq");
var IteratorsCore = __webpack_require__("j68S");
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () {
  return this;
};

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          hide(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() {
      return nativeIterator.call(this);
    };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    hide(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};

/***/ }),

/***/ "GIDK":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("tbG5");
var adler32 = __webpack_require__("uxo6");
var crc32 = __webpack_require__("X4kj");
var inflate_fast = __webpack_require__("LP5M");
var inflate_table = __webpack_require__("2u+n");

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED = 8;

/* STATES ====================================================================*/
/* ===========================================================================*/

var HEAD = 1; /* i: waiting for magic header */
var FLAGS = 2; /* i: waiting for method and flags (gzip) */
var TIME = 3; /* i: waiting for modification time (gzip) */
var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
var EXLEN = 5; /* i: waiting for extra length (gzip) */
var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
var NAME = 7; /* i: waiting for end of file name (gzip) */
var COMMENT = 8; /* i: waiting for end of comment (gzip) */
var HCRC = 9; /* i: waiting for header crc (gzip) */
var DICTID = 10; /* i: waiting for dictionary check value */
var DICT = 11; /* waiting for inflateSetDictionary() call */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
var STORED = 14; /* i: waiting for stored size (length and complement) */
var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
var COPY = 16; /* i/o: waiting for input or output to copy stored block */
var TABLE = 17; /* i: waiting for dynamic block table lengths */
var LENLENS = 18; /* i: waiting for code length code lengths */
var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
var LEN_ = 20; /* i: same as LEN below, but only first time in */
var LEN = 21; /* i: waiting for length/lit/eob code */
var LENEXT = 22; /* i: waiting for length extra bits */
var DIST = 23; /* i: waiting for distance code */
var DISTEXT = 24; /* i: waiting for distance extra bits */
var MATCH = 25; /* o: waiting for output space to copy string */
var LIT = 26; /* o: waiting for output space to write literal */
var CHECK = 27; /* i: waiting for 32-bit check value */
var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
var DONE = 29; /* finished check, done -- remain here until reset */
var BAD = 30; /* got a data error -- remain here until reset */
var MEM = 31; /* got an inflate() memory error -- remain here until reset */
var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0; /* current inflate mode */
  this.last = false; /* true if processing last block */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false; /* true if dictionary provided */
  this.flags = 0; /* gzip header method and flags (0 if zlib) */
  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0; /* protected copy of check value */
  this.total = 0; /* protected copy of output count */
  // TODO: may be {}
  this.head = null; /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0; /* log base 2 of requested window size */
  this.wsize = 0; /* window size or zero if not using window */
  this.whave = 0; /* valid bytes in the window */
  this.wnext = 0; /* window write index */
  this.window = null; /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0; /* input bit accumulator */
  this.bits = 0; /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0; /* literal or length of data to copy */
  this.offset = 0; /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0; /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null; /* starting table for length/literal codes */
  this.distcode = null; /* starting table for distance codes */
  this.lenbits = 0; /* index bits for lencode */
  this.distbits = 0; /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0; /* number of code length code lengths */
  this.nlen = 0; /* number of length code lengths */
  this.ndist = 0; /* number of distance code lengths */
  this.have = 0; /* number of code lengths in lens[] */
  this.next = null; /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
  this.sane = 0; /* if false, allow invalid distance too far */
  this.back = 0; /* bits back of last unprocessed length/lit */
  this.was = 0; /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null /*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null /*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null /*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}

/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers
  var next; /* next input INDEX */
  var put; /* next output INDEX */
  var have, left; /* available input and output */
  var hold; /* bit buffer */
  var bits; /* bits in bit buffer */
  var _in, _out; /* save starting available input and output */
  var copy; /* number of stored or match bytes to copy */
  var from; /* where to copy match bytes from */
  var from_source;
  var here = 0; /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len; /* length to copy for repeats, bits to drop */
  var ret; /* return code */
  var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  } /* skip check */

  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0; /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) || /* check if zlib header allowed */
        (((hold & 0xff) << /*BITS(8)*/8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f) !== /*BITS(4)*/Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f) + /*BITS(4)*/8;
        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
      /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
      /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
      /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        } else if (state.head) {
          state.head.extra = null /*Z_NULL*/;
        }
        state.mode = EXTRA;
      /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) {
            copy = have;
          }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(state.head.extra, input, next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len);
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) {
            break inf_leave;
          }
        }
        state.length = 0;
        state.mode = NAME;
      /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
      /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
      /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
      /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
      /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = hold & 0x01 /*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch (hold & 0x03) {/*BITS(2)*/case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:
            /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_; /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case COPY_:
        state.mode = COPY;
      /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) {
            copy = have;
          }
          if (copy > left) {
            copy = left;
          }
          if (copy === 0) {
            break inf_leave;
          }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f) + /*BITS(5)*/257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f) + /*BITS(5)*/1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f) + /*BITS(4)*/4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        //#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
      /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
      /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) {
          break;
        }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case LEN_:
        state.mode = LEN;
      /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
      /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
      /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;
      /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
      /* falls through */
      case MATCH:
        if (left === 0) {
          break inf_leave;
        }
        copy = _out - left;
        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }
          if (copy > state.length) {
            copy = state.length;
          }
          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) {
          copy = left;
        }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) {
          state.mode = LEN;
        }
        break;
      case LIT:
        if (left === 0) {
          break inf_leave;
        }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
      /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
      /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
      /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) {
      return Z_STREAM_ERROR;
    }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

/***/ }),

/***/ "GRUB":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__("Yj0v");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "GTg1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compressions = __webpack_require__("XfO6");
var ZipFileWorker = __webpack_require__("xtj2");

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function (fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir,
                date = file.date;

            file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                name: relativePath,
                dir: dir,
                date: date,
                comment: file.comment || "",
                unixPermissions: file.unixPermissions,
                dosPermissions: file.dosPermissions
            }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

/***/ }),

/***/ "GUf6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var internalFind = __webpack_require__("W8pO")(5);
var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () {
  SKIPS_HOLES = false;
});

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
__webpack_require__("c+Wn")({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return internalFind(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
__webpack_require__("dqyN")(FIND);

/***/ }),

/***/ "Gfzd":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("zotD");
var IE8_DOM_DEFINE = __webpack_require__("R6c1");
var toPrimitive = __webpack_require__("EKwp");
var dP = Object.defineProperty;

exports.f = __webpack_require__("6MLN") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "GqQl":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _ObjectName = __webpack_require__("bY9t");

var _ObjectName2 = _interopRequireDefault(_ObjectName);

var _ObjectValue = __webpack_require__("fHwt");

var _ObjectValue2 = _interopRequireDefault(_ObjectValue);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * if isNonenumerable is specified, render the name dimmed
 */
var ObjectLabel = function ObjectLabel(_ref) {
  var name = _ref.name,
      data = _ref.data,
      isNonenumerable = _ref.isNonenumerable;

  var object = data;

  return _react2.default.createElement('span', null, _react2.default.createElement(_ObjectName2.default, { name: name, dimmed: isNonenumerable }), _react2.default.createElement('span', null, ': '), _react2.default.createElement(_ObjectValue2.default, { object: object }));
};

ObjectLabel.propTypes = {
  /** Non enumerable object property will be dimmed */
  isNonenumerable: _propTypes2.default.bool
};

ObjectLabel.defaultProps = {
  isNonenumerable: false
};

exports.default = ObjectLabel;

/***/ }),

/***/ "GyB/":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__("6t7t");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__("ibPW");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
};

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "Gzjq":
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "H+g/":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  function doFold(cm, pos, options, force) {
    if (options && options.call) {
      var finder = options;
      options = null;
    } else {
      var finder = getOption(cm, options, "rangeFinder");
    }
    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);
    var minSize = getOption(cm, options, "minFoldSize");

    function getRange(allowFolded) {
      var range = finder(cm, pos);
      if (!range || range.to.line - range.from.line < minSize) return null;
      var marks = cm.findMarksAt(range.from);
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold && force !== "fold") {
          if (!allowFolded) return null;
          range.cleared = true;
          marks[i].clear();
        }
      }
      return range;
    }

    var range = getRange(true);
    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
      pos = CodeMirror.Pos(pos.line - 1, 0);
      range = getRange(false);
    }
    if (!range || range.cleared || force === "unfold") return;

    var myWidget = makeWidget(cm, options);
    CodeMirror.on(myWidget, "mousedown", function (e) {
      myRange.clear();
      CodeMirror.e_preventDefault(e);
    });
    var myRange = cm.markText(range.from, range.to, {
      replacedWith: myWidget,
      clearOnEnter: getOption(cm, options, "clearOnEnter"),
      __isFold: true
    });
    myRange.on("clear", function (from, to) {
      CodeMirror.signal(cm, "unfold", cm, from, to);
    });
    CodeMirror.signal(cm, "fold", cm, range.from, range.to);
  }

  function makeWidget(cm, options) {
    var widget = getOption(cm, options, "widget");
    if (typeof widget == "string") {
      var text = document.createTextNode(widget);
      widget = document.createElement("span");
      widget.appendChild(text);
      widget.className = "CodeMirror-foldmarker";
    } else if (widget) {
      widget = widget.cloneNode(true);
    }
    return widget;
  }

  // Clumsy backwards-compatible interface
  CodeMirror.newFoldFunction = function (rangeFinder, widget) {
    return function (cm, pos) {
      doFold(cm, pos, { rangeFinder: rangeFinder, widget: widget });
    };
  };

  // New-style interface
  CodeMirror.defineExtension("foldCode", function (pos, options, force) {
    doFold(this, pos, options, force);
  });

  CodeMirror.defineExtension("isFolded", function (pos) {
    var marks = this.findMarksAt(pos);
    for (var i = 0; i < marks.length; ++i) if (marks[i].__isFold) return true;
  });

  CodeMirror.commands.toggleFold = function (cm) {
    cm.foldCode(cm.getCursor());
  };
  CodeMirror.commands.fold = function (cm) {
    cm.foldCode(cm.getCursor(), null, "fold");
  };
  CodeMirror.commands.unfold = function (cm) {
    cm.foldCode(cm.getCursor(), null, "unfold");
  };
  CodeMirror.commands.foldAll = function (cm) {
    cm.operation(function () {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");
    });
  };
  CodeMirror.commands.unfoldAll = function (cm) {
    cm.operation(function () {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");
    });
  };

  CodeMirror.registerHelper("fold", "combine", function () {
    var funcs = Array.prototype.slice.call(arguments, 0);
    return function (cm, start) {
      for (var i = 0; i < funcs.length; ++i) {
        var found = funcs[i](cm, start);
        if (found) return found;
      }
    };
  });

  CodeMirror.registerHelper("fold", "auto", function (cm, start) {
    var helpers = cm.getHelpers(start, "fold");
    for (var i = 0; i < helpers.length; i++) {
      var cur = helpers[i](cm, start);
      if (cur) return cur;
    }
  });

  var defaultOptions = {
    rangeFinder: CodeMirror.fold.auto,
    widget: "\u2194",
    minFoldSize: 0,
    scanUp: false,
    clearOnEnter: true
  };

  CodeMirror.defineOption("foldOptions", null);

  function getOption(cm, options, name) {
    if (options && options[name] !== undefined) return options[name];
    var editorOptions = cm.options.foldOptions;
    if (editorOptions && editorOptions[name] !== undefined) return editorOptions[name];
    return defaultOptions[name];
  }

  CodeMirror.defineExtension("foldOption", function (options, name) {
    return getOption(this, options, name);
  });
});

/***/ }),

/***/ "H1RQ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__("RsE0");
} else {
  module.exports = require('./cjs/react-is.development.js');
}

/***/ }),

/***/ "HHE0":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("yS17");
var toObject = __webpack_require__("mbLO");
var IE_PROTO = __webpack_require__("/wuY")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "HOGQ":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("95jh");

/***/ }),

/***/ "HS0v":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("wJQ+").document;

module.exports = document && document.documentElement;

/***/ }),

/***/ "Hba+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__("Yj0v");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__("Q14w");
util.inherits = __webpack_require__("4Bm0");
/*</replacement>*/

var Readable = __webpack_require__("DHrQ");
var Writable = __webpack_require__("WSyY");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "HeB0":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var htmlConfig = {
    autoSelfClosers: { 'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
      'track': true, 'wbr': true, 'menuitem': true },
    implicitlyClosed: { 'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
      'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
      'th': true, 'tr': true },
    contextGrabbers: {
      'dd': { 'dd': true, 'dt': true },
      'dt': { 'dd': true, 'dt': true },
      'li': { 'li': true },
      'option': { 'option': true, 'optgroup': true },
      'optgroup': { 'optgroup': true },
      'p': { 'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
        'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
        'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
        'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
        'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true },
      'rp': { 'rp': true, 'rt': true },
      'rt': { 'rp': true, 'rt': true },
      'tbody': { 'tbody': true, 'tfoot': true },
      'td': { 'td': true, 'th': true },
      'tfoot': { 'tbody': true },
      'th': { 'td': true, 'th': true },
      'thead': { 'tbody': true, 'tfoot': true },
      'tr': { 'tr': true }
    },
    doNotIndent: { "pre": true },
    allowUnquoted: true,
    allowMissing: true,
    caseFold: true
  };

  var xmlConfig = {
    autoSelfClosers: {},
    implicitlyClosed: {},
    contextGrabbers: {},
    doNotIndent: {},
    allowUnquoted: false,
    allowMissing: false,
    allowMissingTagName: false,
    caseFold: false
  };

  CodeMirror.defineMode("xml", function (editorConf, config_) {
    var indentUnit = editorConf.indentUnit;
    var config = {};
    var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
    for (var prop in defaults) config[prop] = defaults[prop];
    for (var prop in config_) config[prop] = config_[prop];

    // Return variables for tokenizers
    var type, setStyle;

    function inText(stream, state) {
      function chain(parser) {
        state.tokenize = parser;
        return parser(stream, state);
      }

      var ch = stream.next();
      if (ch == "<") {
        if (stream.eat("!")) {
          if (stream.eat("[")) {
            if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));else return null;
          } else if (stream.match("--")) {
            return chain(inBlock("comment", "-->"));
          } else if (stream.match("DOCTYPE", true, true)) {
            stream.eatWhile(/[\w\._\-]/);
            return chain(doctype(1));
          } else {
            return null;
          }
        } else if (stream.eat("?")) {
          stream.eatWhile(/[\w\._\-]/);
          state.tokenize = inBlock("meta", "?>");
          return "meta";
        } else {
          type = stream.eat("/") ? "closeTag" : "openTag";
          state.tokenize = inTag;
          return "tag bracket";
        }
      } else if (ch == "&") {
        var ok;
        if (stream.eat("#")) {
          if (stream.eat("x")) {
            ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
          } else {
            ok = stream.eatWhile(/[\d]/) && stream.eat(";");
          }
        } else {
          ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
        }
        return ok ? "atom" : "error";
      } else {
        stream.eatWhile(/[^&<]/);
        return null;
      }
    }
    inText.isInText = true;

    function inTag(stream, state) {
      var ch = stream.next();
      if (ch == ">" || ch == "/" && stream.eat(">")) {
        state.tokenize = inText;
        type = ch == ">" ? "endTag" : "selfcloseTag";
        return "tag bracket";
      } else if (ch == "=") {
        type = "equals";
        return null;
      } else if (ch == "<") {
        state.tokenize = inText;
        state.state = baseState;
        state.tagName = state.tagStart = null;
        var next = state.tokenize(stream, state);
        return next ? next + " tag error" : "tag error";
      } else if (/[\'\"]/.test(ch)) {
        state.tokenize = inAttribute(ch);
        state.stringStartCol = stream.column();
        return state.tokenize(stream, state);
      } else {
        stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
        return "word";
      }
    }

    function inAttribute(quote) {
      var closure = function (stream, state) {
        while (!stream.eol()) {
          if (stream.next() == quote) {
            state.tokenize = inTag;
            break;
          }
        }
        return "string";
      };
      closure.isInAttribute = true;
      return closure;
    }

    function inBlock(style, terminator) {
      return function (stream, state) {
        while (!stream.eol()) {
          if (stream.match(terminator)) {
            state.tokenize = inText;
            break;
          }
          stream.next();
        }
        return style;
      };
    }

    function doctype(depth) {
      return function (stream, state) {
        var ch;
        while ((ch = stream.next()) != null) {
          if (ch == "<") {
            state.tokenize = doctype(depth + 1);
            return state.tokenize(stream, state);
          } else if (ch == ">") {
            if (depth == 1) {
              state.tokenize = inText;
              break;
            } else {
              state.tokenize = doctype(depth - 1);
              return state.tokenize(stream, state);
            }
          }
        }
        return "meta";
      };
    }

    function Context(state, tagName, startOfLine) {
      this.prev = state.context;
      this.tagName = tagName;
      this.indent = state.indented;
      this.startOfLine = startOfLine;
      if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;
    }
    function popContext(state) {
      if (state.context) state.context = state.context.prev;
    }
    function maybePopContext(state, nextTagName) {
      var parentTagName;
      while (true) {
        if (!state.context) {
          return;
        }
        parentTagName = state.context.tagName;
        if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
          return;
        }
        popContext(state);
      }
    }

    function baseState(type, stream, state) {
      if (type == "openTag") {
        state.tagStart = stream.column();
        return tagNameState;
      } else if (type == "closeTag") {
        return closeTagNameState;
      } else {
        return baseState;
      }
    }
    function tagNameState(type, stream, state) {
      if (type == "word") {
        state.tagName = stream.current();
        setStyle = "tag";
        return attrState;
      } else if (config.allowMissingTagName && type == "endTag") {
        setStyle = "tag bracket";
        return attrState(type, stream, state);
      } else {
        setStyle = "error";
        return tagNameState;
      }
    }
    function closeTagNameState(type, stream, state) {
      if (type == "word") {
        var tagName = stream.current();
        if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);
        if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
          setStyle = "tag";
          return closeState;
        } else {
          setStyle = "tag error";
          return closeStateErr;
        }
      } else if (config.allowMissingTagName && type == "endTag") {
        setStyle = "tag bracket";
        return closeState(type, stream, state);
      } else {
        setStyle = "error";
        return closeStateErr;
      }
    }

    function closeState(type, _stream, state) {
      if (type != "endTag") {
        setStyle = "error";
        return closeState;
      }
      popContext(state);
      return baseState;
    }
    function closeStateErr(type, stream, state) {
      setStyle = "error";
      return closeState(type, stream, state);
    }

    function attrState(type, _stream, state) {
      if (type == "word") {
        setStyle = "attribute";
        return attrEqState;
      } else if (type == "endTag" || type == "selfcloseTag") {
        var tagName = state.tagName,
            tagStart = state.tagStart;
        state.tagName = state.tagStart = null;
        if (type == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(tagName)) {
          maybePopContext(state, tagName);
        } else {
          maybePopContext(state, tagName);
          state.context = new Context(state, tagName, tagStart == state.indented);
        }
        return baseState;
      }
      setStyle = "error";
      return attrState;
    }
    function attrEqState(type, stream, state) {
      if (type == "equals") return attrValueState;
      if (!config.allowMissing) setStyle = "error";
      return attrState(type, stream, state);
    }
    function attrValueState(type, stream, state) {
      if (type == "string") return attrContinuedState;
      if (type == "word" && config.allowUnquoted) {
        setStyle = "string";return attrState;
      }
      setStyle = "error";
      return attrState(type, stream, state);
    }
    function attrContinuedState(type, stream, state) {
      if (type == "string") return attrContinuedState;
      return attrState(type, stream, state);
    }

    return {
      startState: function (baseIndent) {
        var state = { tokenize: inText,
          state: baseState,
          indented: baseIndent || 0,
          tagName: null, tagStart: null,
          context: null };
        if (baseIndent != null) state.baseIndent = baseIndent;
        return state;
      },

      token: function (stream, state) {
        if (!state.tagName && stream.sol()) state.indented = stream.indentation();

        if (stream.eatSpace()) return null;
        type = null;
        var style = state.tokenize(stream, state);
        if ((style || type) && style != "comment") {
          setStyle = null;
          state.state = state.state(type || style, stream, state);
          if (setStyle) style = setStyle == "error" ? style + " error" : setStyle;
        }
        return style;
      },

      indent: function (state, textAfter, fullLine) {
        var context = state.context;
        // Indent multi-line strings (e.g. css).
        if (state.tokenize.isInAttribute) {
          if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;
        }
        if (context && context.noIndent) return CodeMirror.Pass;
        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
        // Indent the starts of attribute names.
        if (state.tagName) {
          if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
        }
        if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
        var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
        if (tagAfter && tagAfter[1]) {
          // Closing tag spotted
          while (context) {
            if (context.tagName == tagAfter[2]) {
              context = context.prev;
              break;
            } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
              context = context.prev;
            } else {
              break;
            }
          }
        } else if (tagAfter) {
          // Opening tag spotted
          while (context) {
            var grabbers = config.contextGrabbers[context.tagName];
            if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;
          }
        }
        while (context && context.prev && !context.startOfLine) context = context.prev;
        if (context) return context.indent + indentUnit;else return state.baseIndent || 0;
      },

      electricInput: /<\/[\s\w:]+>$/,
      blockCommentStart: "<!--",
      blockCommentEnd: "-->",

      configuration: config.htmlMode ? "html" : "xml",
      helperType: config.htmlMode ? "html" : "xml",

      skipAttribute: function (state) {
        if (state.state == attrValueState) state.state = attrState;
      }
    };
  });

  CodeMirror.defineMIME("text/xml", "xml");
  CodeMirror.defineMIME("application/xml", "xml");
  if (!CodeMirror.mimeModes.hasOwnProperty("text/html")) CodeMirror.defineMIME("text/html", { name: "xml", htmlMode: true });
});

/***/ }),

/***/ "Hxgu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Inspector = exports.ObjectName = exports.ObjectValue = exports.ObjectRootLabel = exports.ObjectLabel = exports.DOMInspector = exports.TableInspector = exports.ObjectInspector = exports.chromeDark = exports.chromeLight = undefined;

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = __webpack_require__("zCAL");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _themes = __webpack_require__("ERJL");

Object.defineProperty(exports, 'chromeLight', {
  enumerable: true,
  get: function get() {
    return _themes.chromeLight;
  }
});
Object.defineProperty(exports, 'chromeDark', {
  enumerable: true,
  get: function get() {
    return _themes.chromeDark;
  }
});

var _ObjectInspector2 = __webpack_require__("c2iN");

var _ObjectInspector3 = _interopRequireDefault(_ObjectInspector2);

var _TableInspector2 = __webpack_require__("5++D");

var _TableInspector3 = _interopRequireDefault(_TableInspector2);

var _DOMInspector2 = __webpack_require__("jOjK");

var _DOMInspector3 = _interopRequireDefault(_DOMInspector2);

var _ObjectLabel2 = __webpack_require__("GqQl");

var _ObjectLabel3 = _interopRequireDefault(_ObjectLabel2);

var _ObjectRootLabel2 = __webpack_require__("TBQ4");

var _ObjectRootLabel3 = _interopRequireDefault(_ObjectRootLabel2);

var _ObjectValue2 = __webpack_require__("fHwt");

var _ObjectValue3 = _interopRequireDefault(_ObjectValue2);

var _ObjectName2 = __webpack_require__("bY9t");

var _ObjectName3 = _interopRequireDefault(_ObjectName2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _isDom = __webpack_require__("lZLl");

var _isDom2 = _interopRequireDefault(_isDom);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.ObjectInspector = _ObjectInspector3.default;
exports.TableInspector = _TableInspector3.default;
exports.DOMInspector = _DOMInspector3.default;
exports.ObjectLabel = _ObjectLabel3.default;
exports.ObjectRootLabel = _ObjectRootLabel3.default;
exports.ObjectValue = _ObjectValue3.default;
exports.ObjectName = _ObjectName3.default;

// Wrapping the inspectors

var Inspector = function Inspector(_ref) {
  var _ref$table = _ref.table,
      table = _ref$table === undefined ? false : _ref$table,
      data = _ref.data,
      rest = (0, _objectWithoutProperties3.default)(_ref, ['table', 'data']);

  if (table) {
    return _react2.default.createElement(_TableInspector3.default, (0, _extends3.default)({ data: data }, rest));
  }

  if ((0, _isDom2.default)(data)) return _react2.default.createElement(_DOMInspector3.default, (0, _extends3.default)({ data: data }, rest));

  return _react2.default.createElement(_ObjectInspector3.default, (0, _extends3.default)({ data: data }, rest));
};

Inspector.propTypes = {
  data: _propTypes2.default.any,
  name: _propTypes2.default.string,
  table: _propTypes2.default.bool
};

exports.Inspector = Inspector;
exports.default = Inspector;

/***/ }),

/***/ "ID6i":
/***/ (function(module, exports) {

module.exports = function () {/* empty */};

/***/ }),

/***/ "IFQ2":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "IYZm":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("LiPu"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./xml-hint"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var langs = "ab aa af ak sq am ar an hy as av ae ay az bm ba eu be bn bh bi bs br bg my ca ch ce ny zh cv kw co cr hr cs da dv nl dz en eo et ee fo fj fi fr ff gl ka de el gn gu ht ha he hz hi ho hu ia id ie ga ig ik io is it iu ja jv kl kn kr ks kk km ki rw ky kv kg ko ku kj la lb lg li ln lo lt lu lv gv mk mg ms ml mt mi mr mh mn na nv nb nd ne ng nn no ii nr oc oj cu om or os pa pi fa pl ps pt qu rm rn ro ru sa sc sd se sm sg sr gd sn si sk sl so st es su sw ss sv ta te tg th ti bo tk tl tn to tr ts tt tw ty ug uk ur uz ve vi vo wa cy wo fy xh yi yo za zu".split(" ");
  var targets = ["_blank", "_self", "_top", "_parent"];
  var charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
  var methods = ["get", "post", "put", "delete"];
  var encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
  var media = ["all", "screen", "print", "embossed", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "speech", "3d-glasses", "resolution [>][<][=] [X]", "device-aspect-ratio: X/Y", "orientation:portrait", "orientation:landscape", "device-height: [X]", "device-width: [X]"];
  var s = { attrs: {} }; // Simple tag, reused for a whole lot of tags

  var data = {
    a: {
      attrs: {
        href: null, ping: null, type: null,
        media: media,
        target: targets,
        hreflang: langs
      }
    },
    abbr: s,
    acronym: s,
    address: s,
    applet: s,
    area: {
      attrs: {
        alt: null, coords: null, href: null, target: null, ping: null,
        media: media, hreflang: langs, type: null,
        shape: ["default", "rect", "circle", "poly"]
      }
    },
    article: s,
    aside: s,
    audio: {
      attrs: {
        src: null, mediagroup: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["none", "metadata", "auto"],
        autoplay: ["", "autoplay"],
        loop: ["", "loop"],
        controls: ["", "controls"]
      }
    },
    b: s,
    base: { attrs: { href: null, target: targets } },
    basefont: s,
    bdi: s,
    bdo: s,
    big: s,
    blockquote: { attrs: { cite: null } },
    body: s,
    br: s,
    button: {
      attrs: {
        form: null, formaction: null, name: null, value: null,
        autofocus: ["", "autofocus"],
        disabled: ["", "autofocus"],
        formenctype: encs,
        formmethod: methods,
        formnovalidate: ["", "novalidate"],
        formtarget: targets,
        type: ["submit", "reset", "button"]
      }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: s,
    center: s,
    cite: s,
    code: s,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
      attrs: {
        type: ["command", "checkbox", "radio"],
        label: null, icon: null, radiogroup: null, command: null, title: null,
        disabled: ["", "disabled"],
        checked: ["", "checked"]
      }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["", "disabled"], multiple: ["", "multiple"] } },
    datalist: { attrs: { data: null } },
    dd: s,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["", "open"] } },
    dfn: s,
    dir: s,
    div: s,
    dl: s,
    dt: s,
    em: s,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["", "disabled"], form: null, name: null } },
    figcaption: s,
    figure: s,
    font: s,
    footer: s,
    form: {
      attrs: {
        action: null, name: null,
        "accept-charset": charsets,
        autocomplete: ["on", "off"],
        enctype: encs,
        method: methods,
        novalidate: ["", "novalidate"],
        target: targets
      }
    },
    frame: s,
    frameset: s,
    h1: s, h2: s, h3: s, h4: s, h5: s, h6: s,
    head: {
      attrs: {},
      children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: s,
    hgroup: s,
    hr: s,
    html: {
      attrs: { manifest: null },
      children: ["head", "body"]
    },
    i: s,
    iframe: {
      attrs: {
        src: null, srcdoc: null, name: null, width: null, height: null,
        sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
        seamless: ["", "seamless"]
      }
    },
    img: {
      attrs: {
        alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
        crossorigin: ["anonymous", "use-credentials"]
      }
    },
    input: {
      attrs: {
        alt: null, dirname: null, form: null, formaction: null,
        height: null, list: null, max: null, maxlength: null, min: null,
        name: null, pattern: null, placeholder: null, size: null, src: null,
        step: null, value: null, width: null,
        accept: ["audio/*", "video/*", "image/*"],
        autocomplete: ["on", "off"],
        autofocus: ["", "autofocus"],
        checked: ["", "checked"],
        disabled: ["", "disabled"],
        formenctype: encs,
        formmethod: methods,
        formnovalidate: ["", "novalidate"],
        formtarget: targets,
        multiple: ["", "multiple"],
        readonly: ["", "readonly"],
        required: ["", "required"],
        type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio", "file", "submit", "image", "reset", "button"]
      }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: s,
    keygen: {
      attrs: {
        challenge: null, form: null, name: null,
        autofocus: ["", "autofocus"],
        disabled: ["", "disabled"],
        keytype: ["RSA"]
      }
    },
    label: { attrs: { "for": null, form: null } },
    legend: s,
    li: { attrs: { value: null } },
    link: {
      attrs: {
        href: null, type: null,
        hreflang: langs,
        media: media,
        sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
      }
    },
    map: { attrs: { name: null } },
    mark: s,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
      attrs: {
        content: null,
        charset: charsets,
        name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
        "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
      }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: s,
    noframes: s,
    noscript: s,
    object: {
      attrs: {
        data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
        typemustmatch: ["", "typemustmatch"]
      }
    },
    ol: { attrs: { reversed: ["", "reversed"], start: null, type: ["1", "a", "A", "i", "I"] } },
    optgroup: { attrs: { disabled: ["", "disabled"], label: null } },
    option: { attrs: { disabled: ["", "disabled"], label: null, selected: ["", "selected"], value: null } },
    output: { attrs: { "for": null, form: null, name: null } },
    p: s,
    param: { attrs: { name: null, value: null } },
    pre: s,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: s,
    rt: s,
    ruby: s,
    s: s,
    samp: s,
    script: {
      attrs: {
        type: ["text/javascript"],
        src: null,
        async: ["", "async"],
        defer: ["", "defer"],
        charset: charsets
      }
    },
    section: s,
    select: {
      attrs: {
        form: null, name: null, size: null,
        autofocus: ["", "autofocus"],
        disabled: ["", "disabled"],
        multiple: ["", "multiple"]
      }
    },
    small: s,
    source: { attrs: { src: null, type: null, media: null } },
    span: s,
    strike: s,
    strong: s,
    style: {
      attrs: {
        type: ["text/css"],
        media: media,
        scoped: null
      }
    },
    sub: s,
    summary: s,
    sup: s,
    table: s,
    tbody: s,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    textarea: {
      attrs: {
        dirname: null, form: null, maxlength: null, name: null, placeholder: null,
        rows: null, cols: null,
        autofocus: ["", "autofocus"],
        disabled: ["", "disabled"],
        readonly: ["", "readonly"],
        required: ["", "required"],
        wrap: ["soft", "hard"]
      }
    },
    tfoot: s,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: s,
    time: { attrs: { datetime: null } },
    title: s,
    tr: s,
    track: {
      attrs: {
        src: null, label: null, "default": null,
        kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
        srclang: langs
      }
    },
    tt: s,
    u: s,
    ul: s,
    "var": s,
    video: {
      attrs: {
        src: null, poster: null, width: null, height: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["auto", "metadata", "none"],
        autoplay: ["", "autoplay"],
        mediagroup: ["movie"],
        muted: ["", "muted"],
        controls: ["", "controls"]
      }
    },
    wbr: s
  };

  var globalAttrs = {
    accesskey: ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
    "class": null,
    contenteditable: ["true", "false"],
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["en", "es"],
    spellcheck: ["true", "false"],
    autocorrect: ["true", "false"],
    autocapitalize: ["true", "false"],
    style: null,
    tabindex: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    title: null,
    translate: ["yes", "no"],
    onclick: null,
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"]
  };
  function populate(obj) {
    for (var attr in globalAttrs) if (globalAttrs.hasOwnProperty(attr)) obj.attrs[attr] = globalAttrs[attr];
  }

  populate(s);
  for (var tag in data) if (data.hasOwnProperty(tag) && data[tag] != s) populate(data[tag]);

  CodeMirror.htmlSchema = data;
  function htmlHint(cm, options) {
    var local = { schemaInfo: data };
    if (options) for (var opt in options) local[opt] = options[opt];
    return CodeMirror.hint.xml(cm, local);
  }
  CodeMirror.registerHelper("hint", "html", htmlHint);
});

/***/ }),

/***/ "IayR":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("GUf6");

module.exports = __webpack_require__("ALBP")('Array', 'find');

/***/ }),

/***/ "JE34":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("wJQ+");
var setGlobal = __webpack_require__("G6zQ");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.0.1',
  mode: __webpack_require__("qCGA") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "JZf4":
/***/ (function(module, exports, __webpack_require__) {

// JSON[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
__webpack_require__("xyxa")(__webpack_require__("wJQ+").JSON, 'JSON', true);

/***/ }),

/***/ "Jc5s":
/***/ (function(module, exports, __webpack_require__) {

// `String.prototype.repeat` method
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
__webpack_require__("c+Wn")({ target: 'String', proto: true }, {
  repeat: __webpack_require__("QUdu")
});

/***/ }),

/***/ "JgNJ":
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "Jo/m":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Define search commands. Depends on dialog.js or another
// implementation of the openDialog method.

// Replace works a little oddly -- it will do the replace on the next
// Ctrl-G (or whatever is bound to findNext) press. You prevent a
// replace by making sure the match is no longer selected when hitting
// Ctrl-G.

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("29F7"), __webpack_require__("4e7A"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./searchcursor", "../dialog/dialog"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  function searchOverlay(query, caseInsensitive) {
    if (typeof query == "string") query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");else if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");

    return { token: function (stream) {
        query.lastIndex = stream.pos;
        var match = query.exec(stream.string);
        if (match && match.index == stream.pos) {
          stream.pos += match[0].length || 1;
          return "searching";
        } else if (match) {
          stream.pos = match.index;
        } else {
          stream.skipToEnd();
        }
      } };
  }

  function SearchState() {
    this.posFrom = this.posTo = this.lastQuery = this.query = null;
    this.overlay = null;
  }

  function getSearchState(cm) {
    return cm.state.search || (cm.state.search = new SearchState());
  }

  function queryCaseInsensitive(query) {
    return typeof query == "string" && query == query.toLowerCase();
  }

  function getSearchCursor(cm, query, pos) {
    // Heuristic: if the query string is all lowercase, do a case insensitive search.
    return cm.getSearchCursor(query, pos, { caseFold: queryCaseInsensitive(query), multiline: true });
  }

  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {
    cm.openDialog(text, onEnter, {
      value: deflt,
      selectValueOnOpen: true,
      closeOnEnter: false,
      onClose: function () {
        clearSearch(cm);
      },
      onKeyDown: onKeyDown
    });
  }

  function dialog(cm, text, shortText, deflt, f) {
    if (cm.openDialog) cm.openDialog(text, f, { value: deflt, selectValueOnOpen: true });else f(prompt(shortText, deflt));
  }

  function confirmDialog(cm, text, shortText, fs) {
    if (cm.openConfirm) cm.openConfirm(text, fs);else if (confirm(shortText)) fs[0]();
  }

  function parseString(string) {
    return string.replace(/\\([nrt\\])/g, function (match, ch) {
      if (ch == "n") return "\n";
      if (ch == "r") return "\r";
      if (ch == "t") return "\t";
      if (ch == "\\") return "\\";
      return match;
    });
  }

  function parseQuery(query) {
    var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
    if (isRE) {
      try {
        query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i");
      } catch (e) {} // Not a regular expression after all, do a string search
    } else {
      query = parseString(query);
    }
    if (typeof query == "string" ? query == "" : query.test("")) query = /x^/;
    return query;
  }

  function startSearch(cm, state, query) {
    state.queryText = query;
    state.query = parseQuery(query);
    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
    cm.addOverlay(state.overlay);
    if (cm.showMatchesOnScrollbar) {
      if (state.annotate) {
        state.annotate.clear();state.annotate = null;
      }
      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
    }
  }

  function doSearch(cm, rev, persistent, immediate) {
    var state = getSearchState(cm);
    if (state.query) return findNext(cm, rev);
    var q = cm.getSelection() || state.lastQuery;
    if (q instanceof RegExp && q.source == "x^") q = null;
    if (persistent && cm.openDialog) {
      var hiding = null;
      var searchNext = function (query, event) {
        CodeMirror.e_stop(event);
        if (!query) return;
        if (query != state.queryText) {
          startSearch(cm, state, query);
          state.posFrom = state.posTo = cm.getCursor();
        }
        if (hiding) hiding.style.opacity = 1;
        findNext(cm, event.shiftKey, function (_, to) {
          var dialog;
          if (to.line < 3 && document.querySelector && (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) && dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top) (hiding = dialog).style.opacity = .4;
        });
      };
      persistentDialog(cm, getQueryDialog(cm), q, searchNext, function (event, query) {
        var keyName = CodeMirror.keyName(event);
        var extra = cm.getOption('extraKeys'),
            cmd = extra && extra[keyName] || CodeMirror.keyMap[cm.getOption("keyMap")][keyName];
        if (cmd == "findNext" || cmd == "findPrev" || cmd == "findPersistentNext" || cmd == "findPersistentPrev") {
          CodeMirror.e_stop(event);
          startSearch(cm, getSearchState(cm), query);
          cm.execCommand(cmd);
        } else if (cmd == "find" || cmd == "findPersistent") {
          CodeMirror.e_stop(event);
          searchNext(query, event);
        }
      });
      if (immediate && q) {
        startSearch(cm, state, q);
        findNext(cm, rev);
      }
    } else {
      dialog(cm, getQueryDialog(cm), "Search for:", q, function (query) {
        if (query && !state.query) cm.operation(function () {
          startSearch(cm, state, query);
          state.posFrom = state.posTo = cm.getCursor();
          findNext(cm, rev);
        });
      });
    }
  }

  function findNext(cm, rev, callback) {
    cm.operation(function () {
      var state = getSearchState(cm);
      var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
      if (!cursor.find(rev)) {
        cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
        if (!cursor.find(rev)) return;
      }
      cm.setSelection(cursor.from(), cursor.to());
      cm.scrollIntoView({ from: cursor.from(), to: cursor.to() }, 20);
      state.posFrom = cursor.from();state.posTo = cursor.to();
      if (callback) callback(cursor.from(), cursor.to());
    });
  }

  function clearSearch(cm) {
    cm.operation(function () {
      var state = getSearchState(cm);
      state.lastQuery = state.query;
      if (!state.query) return;
      state.query = state.queryText = null;
      cm.removeOverlay(state.overlay);
      if (state.annotate) {
        state.annotate.clear();state.annotate = null;
      }
    });
  }

  function getQueryDialog(cm) {
    return '<span class="CodeMirror-search-label">' + cm.phrase("Search:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use /re/ syntax for regexp search)") + '</span>';
  }
  function getReplaceQueryDialog(cm) {
    return ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use /re/ syntax for regexp search)") + '</span>';
  }
  function getReplacementQueryDialog(cm) {
    return '<span class="CodeMirror-search-label">' + cm.phrase("With:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>';
  }
  function getDoReplaceConfirm(cm) {
    return '<span class="CodeMirror-search-label">' + cm.phrase("Replace?") + '</span> <button>' + cm.phrase("Yes") + '</button> <button>' + cm.phrase("No") + '</button> <button>' + cm.phrase("All") + '</button> <button>' + cm.phrase("Stop") + '</button> ';
  }

  function replaceAll(cm, query, text) {
    cm.operation(function () {
      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {
        if (typeof query != "string") {
          var match = cm.getRange(cursor.from(), cursor.to()).match(query);
          cursor.replace(text.replace(/\$(\d)/g, function (_, i) {
            return match[i];
          }));
        } else cursor.replace(text);
      }
    });
  }

  function replace(cm, all) {
    if (cm.getOption("readOnly")) return;
    var query = cm.getSelection() || getSearchState(cm).lastQuery;
    var dialogText = '<span class="CodeMirror-search-label">' + (all ? cm.phrase("Replace all:") : cm.phrase("Replace:")) + '</span>';
    dialog(cm, dialogText + getReplaceQueryDialog(cm), dialogText, query, function (query) {
      if (!query) return;
      query = parseQuery(query);
      dialog(cm, getReplacementQueryDialog(cm), cm.phrase("Replace with:"), "", function (text) {
        text = parseString(text);
        if (all) {
          replaceAll(cm, query, text);
        } else {
          clearSearch(cm);
          var cursor = getSearchCursor(cm, query, cm.getCursor("from"));
          var advance = function () {
            var start = cursor.from(),
                match;
            if (!(match = cursor.findNext())) {
              cursor = getSearchCursor(cm, query);
              if (!(match = cursor.findNext()) || start && cursor.from().line == start.line && cursor.from().ch == start.ch) return;
            }
            cm.setSelection(cursor.from(), cursor.to());
            cm.scrollIntoView({ from: cursor.from(), to: cursor.to() });
            confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase("Replace?"), [function () {
              doReplace(match);
            }, advance, function () {
              replaceAll(cm, query, text);
            }]);
          };
          var doReplace = function (match) {
            cursor.replace(typeof query == "string" ? text : text.replace(/\$(\d)/g, function (_, i) {
              return match[i];
            }));
            advance();
          };
          advance();
        }
      });
    });
  }

  CodeMirror.commands.find = function (cm) {
    clearSearch(cm);doSearch(cm);
  };
  CodeMirror.commands.findPersistent = function (cm) {
    clearSearch(cm);doSearch(cm, false, true);
  };
  CodeMirror.commands.findPersistentNext = function (cm) {
    doSearch(cm, false, true, true);
  };
  CodeMirror.commands.findPersistentPrev = function (cm) {
    doSearch(cm, true, true, true);
  };
  CodeMirror.commands.findNext = doSearch;
  CodeMirror.commands.findPrev = function (cm) {
    doSearch(cm, true);
  };
  CodeMirror.commands.clearSearch = clearSearch;
  CodeMirror.commands.replace = replace;
  CodeMirror.commands.replaceAll = function (cm) {
    replace(cm, true);
  };
});

/***/ }),

/***/ "KGgk":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("zadB");
var has = __webpack_require__("UYRC");
var wrappedWellKnownSymbolModule = __webpack_require__("HOGQ");
var defineProperty = __webpack_require__("uebg").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};

/***/ }),

/***/ "KM04":
/***/ (function(module, exports, __webpack_require__) {

!function () {
  "use strict";
  function e(e, t) {
    var n,
        o,
        r,
        i,
        l = W;for (i = arguments.length; i-- > 2;) P.push(arguments[i]);t && null != t.children && (P.length || P.push(t.children), delete t.children);while (P.length) if ((o = P.pop()) && void 0 !== o.pop) for (i = o.length; i--;) P.push(o[i]);else "boolean" == typeof o && (o = null), (r = "function" != typeof e) && (null == o ? o = "" : "number" == typeof o ? o += "" : "string" != typeof o && (r = !1)), r && n ? l[l.length - 1] += o : l === W ? l = [o] : l.push(o), n = r;var a = new T();return a.nodeName = e, a.children = l, a.attributes = null == t ? void 0 : t, a.key = null == t ? void 0 : t.key, void 0 !== M.vnode && M.vnode(a), a;
  }function t(e, t) {
    for (var n in t) e[n] = t[n];return e;
  }function n(e, t) {
    e && ("function" == typeof e ? e(t) : e.current = t);
  }function o(n, o) {
    return e(n.nodeName, t(t({}, n.attributes), o), arguments.length > 2 ? [].slice.call(arguments, 2) : n.children);
  }function r(e) {
    !e.__d && (e.__d = !0) && 1 == V.push(e) && (M.debounceRendering || D)(i);
  }function i() {
    var e;while (e = V.pop()) e.__d && x(e);
  }function l(e, t, n) {
    return "string" == typeof t || "number" == typeof t ? void 0 !== e.splitText : "string" == typeof t.nodeName ? !e._componentConstructor && a(e, t.nodeName) : n || e._componentConstructor === t.nodeName;
  }function a(e, t) {
    return e.__n === t || e.nodeName.toLowerCase() === t.toLowerCase();
  }function u(e) {
    var n = t({}, e.attributes);n.children = e.children;var o = e.nodeName.defaultProps;if (void 0 !== o) for (var r in o) void 0 === n[r] && (n[r] = o[r]);return n;
  }function c(e, t) {
    var n = t ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e);return n.__n = e, n;
  }function p(e) {
    var t = e.parentNode;t && t.removeChild(e);
  }function s(e, t, o, r, i) {
    if ("className" === t && (t = "class"), "key" === t) ;else if ("ref" === t) n(o, null), n(r, e);else if ("class" !== t || i) {
      if ("style" === t) {
        if (r && "string" != typeof r && "string" != typeof o || (e.style.cssText = r || ""), r && "object" == typeof r) {
          if ("string" != typeof o) for (var l in o) l in r || (e.style[l] = "");for (var l in r) e.style[l] = "number" == typeof r[l] && !1 === E.test(l) ? r[l] + "px" : r[l];
        }
      } else if ("dangerouslySetInnerHTML" === t) r && (e.innerHTML = r.__html || "");else if ("o" == t[0] && "n" == t[1]) {
        var a = t !== (t = t.replace(/Capture$/, ""));t = t.toLowerCase().substring(2), r ? o || e.addEventListener(t, _, a) : e.removeEventListener(t, _, a), (e.__l || (e.__l = {}))[t] = r;
      } else if ("list" !== t && "type" !== t && !i && t in e) {
        try {
          e[t] = null == r ? "" : r;
        } catch (e) {}null != r && !1 !== r || "spellcheck" == t || e.removeAttribute(t);
      } else {
        var u = i && t !== (t = t.replace(/^xlink:?/, ""));null == r || !1 === r ? u ? e.removeAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase()) : e.removeAttribute(t) : "function" != typeof r && (u ? e.setAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase(), r) : e.setAttribute(t, r));
      }
    } else e.className = r || "";
  }function _(e) {
    return this.__l[e.type](M.event && M.event(e) || e);
  }function f() {
    var e;while (e = A.shift()) M.afterMount && M.afterMount(e), e.componentDidMount && e.componentDidMount();
  }function d(e, t, n, o, r, i) {
    H++ || (R = null != r && void 0 !== r.ownerSVGElement, B = null != e && !("__preactattr_" in e));var l = h(e, t, n, o, i);return r && l.parentNode !== r && r.appendChild(l), --H || (B = !1, i || f()), l;
  }function h(e, t, n, o, r) {
    var i = e,
        l = R;if (null != t && "boolean" != typeof t || (t = ""), "string" == typeof t || "number" == typeof t) return e && void 0 !== e.splitText && e.parentNode && (!e._component || r) ? e.nodeValue != t && (e.nodeValue = t) : (i = document.createTextNode(t), e && (e.parentNode && e.parentNode.replaceChild(i, e), v(e, !0))), i.__preactattr_ = !0, i;var u = t.nodeName;if ("function" == typeof u) return N(e, t, n, o);if (R = "svg" === u || "foreignObject" !== u && R, u += "", (!e || !a(e, u)) && (i = c(u, R), e)) {
      while (e.firstChild) i.appendChild(e.firstChild);e.parentNode && e.parentNode.replaceChild(i, e), v(e, !0);
    }var p = i.firstChild,
        s = i.__preactattr_,
        _ = t.children;if (null == s) {
      s = i.__preactattr_ = {};for (var f = i.attributes, d = f.length; d--;) s[f[d].name] = f[d].value;
    }return !B && _ && 1 === _.length && "string" == typeof _[0] && null != p && void 0 !== p.splitText && null == p.nextSibling ? p.nodeValue != _[0] && (p.nodeValue = _[0]) : (_ && _.length || null != p) && m(i, _, n, o, B || null != s.dangerouslySetInnerHTML), y(i, t.attributes, s), R = l, i;
  }function m(e, t, n, o, r) {
    var i,
        a,
        u,
        c,
        s,
        _ = e.childNodes,
        f = [],
        d = {},
        m = 0,
        b = 0,
        y = _.length,
        g = 0,
        w = t ? t.length : 0;if (0 !== y) for (var C = 0; C < y; C++) {
      var x = _[C],
          N = x.__preactattr_,
          k = w && N ? x._component ? x._component.__k : N.key : null;null != k ? (m++, d[k] = x) : (N || (void 0 !== x.splitText ? !r || x.nodeValue.trim() : r)) && (f[g++] = x);
    }if (0 !== w) for (var C = 0; C < w; C++) {
      c = t[C], s = null;var k = c.key;if (null != k) m && void 0 !== d[k] && (s = d[k], d[k] = void 0, m--);else if (b < g) for (i = b; i < g; i++) if (void 0 !== f[i] && l(a = f[i], c, r)) {
        s = a, f[i] = void 0, i === g - 1 && g--, i === b && b++;break;
      }s = h(s, c, n, o), u = _[C], s && s !== e && s !== u && (null == u ? e.appendChild(s) : s === u.nextSibling ? p(u) : e.insertBefore(s, u));
    }if (m) for (var C in d) void 0 !== d[C] && v(d[C], !1);while (b <= g) void 0 !== (s = f[g--]) && v(s, !1);
  }function v(e, t) {
    var o = e._component;o ? k(o) : (null != e.__preactattr_ && n(e.__preactattr_.ref, null), !1 !== t && null != e.__preactattr_ || p(e), b(e));
  }function b(e) {
    e = e.lastChild;while (e) {
      var t = e.previousSibling;v(e, !0), e = t;
    }
  }function y(e, t, n) {
    var o;for (o in n) t && null != t[o] || null == n[o] || s(e, o, n[o], n[o] = void 0, R);for (o in t) "children" === o || "innerHTML" === o || o in n && t[o] === ("value" === o || "checked" === o ? e[o] : n[o]) || s(e, o, n[o], n[o] = t[o], R);
  }function g(e, t, n) {
    var o,
        r = F.length;e.prototype && e.prototype.render ? (o = new e(t, n), U.call(o, t, n)) : (o = new U(t, n), o.constructor = e, o.render = w);while (r--) if (F[r].constructor === e) return o.__b = F[r].__b, F.splice(r, 1), o;return o;
  }function w(e, t, n) {
    return this.constructor(e, n);
  }function C(e, t, o, i, l) {
    e.__x || (e.__x = !0, e.__r = t.ref, e.__k = t.key, delete t.ref, delete t.key, void 0 === e.constructor.getDerivedStateFromProps && (!e.base || l ? e.componentWillMount && e.componentWillMount() : e.componentWillReceiveProps && e.componentWillReceiveProps(t, i)), i && i !== e.context && (e.__c || (e.__c = e.context), e.context = i), e.__p || (e.__p = e.props), e.props = t, e.__x = !1, 0 !== o && (1 !== o && !1 === M.syncComponentUpdates && e.base ? r(e) : x(e, 1, l)), n(e.__r, e));
  }function x(e, n, o, r) {
    if (!e.__x) {
      var i,
          l,
          a,
          c = e.props,
          p = e.state,
          s = e.context,
          _ = e.__p || c,
          h = e.__s || p,
          m = e.__c || s,
          b = e.base,
          y = e.__b,
          w = b || y,
          N = e._component,
          U = !1,
          S = m;if (e.constructor.getDerivedStateFromProps && (p = t(t({}, p), e.constructor.getDerivedStateFromProps(c, p)), e.state = p), b && (e.props = _, e.state = h, e.context = m, 2 !== n && e.shouldComponentUpdate && !1 === e.shouldComponentUpdate(c, p, s) ? U = !0 : e.componentWillUpdate && e.componentWillUpdate(c, p, s), e.props = c, e.state = p, e.context = s), e.__p = e.__s = e.__c = e.__b = null, e.__d = !1, !U) {
        i = e.render(c, p, s), e.getChildContext && (s = t(t({}, s), e.getChildContext())), b && e.getSnapshotBeforeUpdate && (S = e.getSnapshotBeforeUpdate(_, h));var L,
            T,
            P = i && i.nodeName;if ("function" == typeof P) {
          var W = u(i);l = N, l && l.constructor === P && W.key == l.__k ? C(l, W, 1, s, !1) : (L = l, e._component = l = g(P, W, s), l.__b = l.__b || y, l.__u = e, C(l, W, 0, s, !1), x(l, 1, o, !0)), T = l.base;
        } else a = w, L = N, L && (a = e._component = null), (w || 1 === n) && (a && (a._component = null), T = d(a, i, s, o || !b, w && w.parentNode, !0));if (w && T !== w && l !== N) {
          var D = w.parentNode;D && T !== D && (D.replaceChild(T, w), L || (w._component = null, v(w, !1)));
        }if (L && k(L), e.base = T, T && !r) {
          var E = e,
              V = e;while (V = V.__u) (E = V).base = T;T._component = E, T._componentConstructor = E.constructor;
        }
      }!b || o ? A.push(e) : U || (e.componentDidUpdate && e.componentDidUpdate(_, h, S), M.afterUpdate && M.afterUpdate(e));while (e.__h.length) e.__h.pop().call(e);H || r || f();
    }
  }function N(e, t, n, o) {
    var r = e && e._component,
        i = r,
        l = e,
        a = r && e._componentConstructor === t.nodeName,
        c = a,
        p = u(t);while (r && !c && (r = r.__u)) c = r.constructor === t.nodeName;return r && c && (!o || r._component) ? (C(r, p, 3, n, o), e = r.base) : (i && !a && (k(i), e = l = null), r = g(t.nodeName, p, n), e && !r.__b && (r.__b = e, l = null), C(r, p, 1, n, o), e = r.base, l && e !== l && (l._component = null, v(l, !1))), e;
  }function k(e) {
    M.beforeUnmount && M.beforeUnmount(e);var t = e.base;e.__x = !0, e.componentWillUnmount && e.componentWillUnmount(), e.base = null;var o = e._component;o ? k(o) : t && (null != t.__preactattr_ && n(t.__preactattr_.ref, null), e.__b = t, p(t), F.push(e), b(t)), n(e.__r, null);
  }function U(e, t) {
    this.__d = !0, this.context = t, this.props = e, this.state = this.state || {}, this.__h = [];
  }function S(e, t, n) {
    return d(n, e, {}, !1, t, !1);
  }function L() {
    return {};
  }var T = function () {},
      M = {},
      P = [],
      W = [],
      D = "function" == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout,
      E = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,
      V = [],
      A = [],
      H = 0,
      R = !1,
      B = !1,
      F = [];t(U.prototype, { setState: function (e, n) {
      this.__s || (this.__s = this.state), this.state = t(t({}, this.state), "function" == typeof e ? e(this.state, this.props) : e), n && this.__h.push(n), r(this);
    }, forceUpdate: function (e) {
      e && this.__h.push(e), x(this, 2);
    }, render: function () {} });var j = { h: e, createElement: e, cloneElement: o, createRef: L, Component: U, render: S, rerender: i, options: M }; true ? module.exports = j : self.preact = j;
}();
//# sourceMappingURL=preact.min.js.map

/***/ }),

/***/ "Kfn2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toLength = __webpack_require__("qub/");
var validateArguments = __webpack_require__("6Ks4");
var STARTS_WITH = 'startsWith';
var CORRECT_IS_REGEXP_LOGIC = __webpack_require__("MFFu")(STARTS_WITH);
var nativeStartsWith = ''[STARTS_WITH];

// `String.prototype.startsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
__webpack_require__("c+Wn")({ target: 'String', proto: true, forced: !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = validateArguments(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "Kwbf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toPrimitive = __webpack_require__("i3Mv");
var definePropertyModule = __webpack_require__("uebg");
var createPropertyDescriptor = __webpack_require__("IFQ2");

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
};

/***/ }),

/***/ "KxjL":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "Ky5l":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("Aa2f");
__webpack_require__("tuDi");
__webpack_require__("c6mp");
__webpack_require__("2mwf");
module.exports = __webpack_require__("zKeE").Symbol;

/***/ }),

/***/ "L5wL":
/***/ (function(module, exports, __webpack_require__) {

if (true) {
  module.exports = __webpack_require__("pgIM");
} else {
  module.exports = require("./cjs/react.development.js");
}

/***/ }),

/***/ "LNnS":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("Wyka");
var toLength = __webpack_require__("S7IM");
var toAbsoluteIndex = __webpack_require__("Zwq5");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "LP5M":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js

var BAD = 30; /* got a data error -- remain here until reset */
var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in; /* local strm.input */
  var last; /* have enough input while in < last */
  var _out; /* local strm.output */
  var beg; /* inflate()'s initial strm.output */
  var end; /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
  var dmax; /* maximum distance from zlib header */
  //#endif
  var wsize; /* window size or zero if not using window */
  var whave; /* valid bytes in the window */
  var wnext; /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window; /* allocated sliding window, if wsize != 0 */
  var hold; /* local strm.hold */
  var bits; /* local strm.bits */
  var lcode; /* local strm.lencode */
  var dcode; /* local strm.distcode */
  var lmask; /* mask for first level of length codes */
  var dmask; /* mask for first level of distance codes */
  var here; /* retrieved table entry */
  var op; /* code bits, operation, extra bits, or */
  /*  window position, window bytes to copy */
  var len; /* match length, unused bytes */
  var dist; /* match distance */
  var from; /* where to copy match from */
  var from_source;

  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
  dmax = state.dmax;
  //#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;

  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24 /*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff /*here.op*/;
      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff /*here.val*/;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff /*here.val*/;
        op &= 15; /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24 /*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff /*here.op*/;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff /*here.val*/;
            op &= 15; /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            //#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
            //#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg; /* max distance in output */
            if (dist > op) {
              /* see if copy from window */
              op = dist - op; /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

                // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {
                /* very common case */
                from += wsize - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist; /* copy direct from output */
              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

/***/ }),

/***/ "LZfN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Readable = __webpack_require__("fOjT").Readable;

var utils = __webpack_require__("dvMn");
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if (updateCb) {
            updateCb(meta);
        }
    }).on("error", function (e) {
        self.emit('error', e);
    }).on("end", function () {
        self.push(null);
    });
}

NodejsStreamOutputAdapter.prototype._read = function () {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

/***/ }),

/***/ "LiPu":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var Pos = CodeMirror.Pos;

  function matches(hint, typed, matchInMiddle) {
    if (matchInMiddle) return hint.indexOf(typed) >= 0;else return hint.lastIndexOf(typed, 0) == 0;
  }

  function getHints(cm, options) {
    var tags = options && options.schemaInfo;
    var quote = options && options.quoteChar || '"';
    var matchInMiddle = options && options.matchInMiddle;
    if (!tags) return;
    var cur = cm.getCursor(),
        token = cm.getTokenAt(cur);
    if (token.end > cur.ch) {
      token.end = cur.ch;
      token.string = token.string.slice(0, cur.ch - token.start);
    }
    var inner = CodeMirror.innerMode(cm.getMode(), token.state);
    if (inner.mode.name != "xml") return;
    var result = [],
        replaceToken = false,
        prefix;
    var tag = /\btag\b/.test(token.type) && !/>$/.test(token.string);
    var tagName = tag && /^\w/.test(token.string),
        tagStart;

    if (tagName) {
      var before = cm.getLine(cur.line).slice(Math.max(0, token.start - 2), token.start);
      var tagType = /<\/$/.test(before) ? "close" : /<$/.test(before) ? "open" : null;
      if (tagType) tagStart = token.start - (tagType == "close" ? 2 : 1);
    } else if (tag && token.string == "<") {
      tagType = "open";
    } else if (tag && token.string == "</") {
      tagType = "close";
    }

    if (!tag && !inner.state.tagName || tagType) {
      if (tagName) prefix = token.string;
      replaceToken = tagType;
      var cx = inner.state.context,
          curTag = cx && tags[cx.tagName];
      var childList = cx ? curTag && curTag.children : tags["!top"];
      if (childList && tagType != "close") {
        for (var i = 0; i < childList.length; ++i) if (!prefix || matches(childList[i], prefix, matchInMiddle)) result.push("<" + childList[i]);
      } else if (tagType != "close") {
        for (var name in tags) if (tags.hasOwnProperty(name) && name != "!top" && name != "!attrs" && (!prefix || matches(name, prefix, matchInMiddle))) result.push("<" + name);
      }
      if (cx && (!prefix || tagType == "close" && matches(cx.tagName, prefix, matchInMiddle))) result.push("</" + cx.tagName + ">");
    } else {
      // Attribute completion
      var curTag = tags[inner.state.tagName],
          attrs = curTag && curTag.attrs;
      var globalAttrs = tags["!attrs"];
      if (!attrs && !globalAttrs) return;
      if (!attrs) {
        attrs = globalAttrs;
      } else if (globalAttrs) {
        // Combine tag-local and global attributes
        var set = {};
        for (var nm in globalAttrs) if (globalAttrs.hasOwnProperty(nm)) set[nm] = globalAttrs[nm];
        for (var nm in attrs) if (attrs.hasOwnProperty(nm)) set[nm] = attrs[nm];
        attrs = set;
      }
      if (token.type == "string" || token.string == "=") {
        // A value
        var before = cm.getRange(Pos(cur.line, Math.max(0, cur.ch - 60)), Pos(cur.line, token.type == "string" ? token.start : token.end));
        var atName = before.match(/([^\s\u00a0=<>\"\']+)=$/),
            atValues;
        if (!atName || !attrs.hasOwnProperty(atName[1]) || !(atValues = attrs[atName[1]])) return;
        if (typeof atValues == 'function') atValues = atValues.call(this, cm); // Functions can be used to supply values for autocomplete widget
        if (token.type == "string") {
          prefix = token.string;
          var n = 0;
          if (/['"]/.test(token.string.charAt(0))) {
            quote = token.string.charAt(0);
            prefix = token.string.slice(1);
            n++;
          }
          var len = token.string.length;
          if (/['"]/.test(token.string.charAt(len - 1))) {
            quote = token.string.charAt(len - 1);
            prefix = token.string.substr(n, len - 2);
          }
          if (n) {
            // an opening quote
            var line = cm.getLine(cur.line);
            if (line.length > token.end && line.charAt(token.end) == quote) token.end++; // include a closing quote
          }
          replaceToken = true;
        }
        for (var i = 0; i < atValues.length; ++i) if (!prefix || matches(atValues[i], prefix, matchInMiddle)) result.push(quote + atValues[i] + quote);
      } else {
        // An attribute name
        if (token.type == "attribute") {
          prefix = token.string;
          replaceToken = true;
        }
        for (var attr in attrs) if (attrs.hasOwnProperty(attr) && (!prefix || matches(attr, prefix, matchInMiddle))) result.push(attr);
      }
    }
    return {
      list: result,
      from: replaceToken ? Pos(cur.line, tagStart == null ? token.start : tagStart) : cur,
      to: replaceToken ? Pos(cur.line, token.end) : cur
    };
  }

  CodeMirror.registerHelper("hint", "xml", getHints);
});

/***/ }),

/***/ "Lli7":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("Ug9I")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {/* empty */}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {/* empty */}
  return safe;
};

/***/ }),

/***/ "LnjZ":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("WSyY");

/***/ }),

/***/ "Lvd3":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("COf8");
__webpack_require__("i+u+");
module.exports = __webpack_require__("ugM7");

/***/ }),

/***/ "M3NV":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("hrV0");
var defineProperties = __webpack_require__("AS82");
var enumBugKeys = __webpack_require__("pup0");
var html = __webpack_require__("HS0v");
var documentCreateElement = __webpack_require__("Nfni");
var IE_PROTO = __webpack_require__("YYE9")('IE_PROTO');
var PROTOTYPE = 'prototype';
var Empty = function () {/* empty */};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var length = enumBugKeys.length;
  var lt = '<';
  var script = 'script';
  var gt = '>';
  var js = 'java' + script + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = String(js);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : defineProperties(result, Properties);
};

__webpack_require__("g3pf")[IE_PROTO] = true;

/***/ }),

/***/ "MFFu":
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__("95jh")('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) {/* empty */}
  }return false;
};

/***/ }),

/***/ "ML/b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function (offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function (newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function (newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function (n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function (i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function (size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function (size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function (size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function (sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function (sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function () {
        var dostime = this.readInt(4);
        return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year
        (dostime >> 21 & 0x0f) - 1, // month
        dostime >> 16 & 0x1f, // day
        dostime >> 11 & 0x1f, // hour
        dostime >> 5 & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

/***/ }),

/***/ "MdwO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var TEXT_NODE_MAX_INLINE_CHARS = 80;

var shouldInline = function shouldInline(data) {
  return data.childNodes.length === 0 || data.childNodes.length === 1 && data.childNodes[0].nodeType === Node.TEXT_NODE && data.textContent.length < TEXT_NODE_MAX_INLINE_CHARS;
};

exports.default = shouldInline;

/***/ }),

/***/ "MpYs":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "Mve8":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "N484":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__("3zRh");
var $export = __webpack_require__("vSO4");
var toObject = __webpack_require__("mbLO");
var call = __webpack_require__("hEIm");
var isArrayIter = __webpack_require__("af0K");
var toLength = __webpack_require__("S7IM");
var createProperty = __webpack_require__("vUQk");
var getIterFn = __webpack_require__("7AqT");

$export($export.S + $export.F * !__webpack_require__("Lli7")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "NB7d":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("zKeE");
var global = __webpack_require__("i1Q6");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("1kq3") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "Nfni":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("dmyY");
var document = __webpack_require__("wJQ+").document;
// typeof document.createElement is 'object' in old IE
var exist = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return exist ? document.createElement(it) : {};
};

/***/ }),

/***/ "Ni5N":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("B9Lq");
var hiddenKeys = __webpack_require__("KxjL").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "O35A":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("i+u+");
__webpack_require__("N484");
module.exports = __webpack_require__("zKeE").Array.from;

/***/ }),

/***/ "O6BQ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createStyles = __webpack_require__("uqKE");

var _createStyles2 = _interopRequireDefault(_createStyles);

var _shouldInline = __webpack_require__("MdwO");

var _shouldInline2 = _interopRequireDefault(_shouldInline);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var OpenTag = function OpenTag(_ref) {
  var tagName = _ref.tagName,
      attributes = _ref.attributes,
      styles = _ref.styles;

  return _react2.default.createElement('span', { style: styles.base }, '<', _react2.default.createElement('span', { style: styles.tagName }, tagName), function () {
    if (attributes) {
      var attributeNodes = [];
      for (var i = 0; i < attributes.length; i++) {
        var attribute = attributes[i];
        attributeNodes.push(_react2.default.createElement('span', { key: i }, ' ', _react2.default.createElement('span', { style: styles.htmlAttributeName }, attribute.name), '="', _react2.default.createElement('span', { style: styles.htmlAttributeValue }, attribute.value), '"'));
      }
      return attributeNodes;
    }
  }(), '>');
};

// isChildNode style={{ marginLeft: -12 /* hack: offset placeholder */ }}
var CloseTag = function CloseTag(_ref2) {
  var tagName = _ref2.tagName,
      _ref2$isChildNode = _ref2.isChildNode,
      isChildNode = _ref2$isChildNode === undefined ? false : _ref2$isChildNode,
      styles = _ref2.styles;
  return _react2.default.createElement('span', { style: _extends({}, styles.base, isChildNode && styles.offsetLeft) }, '</', _react2.default.createElement('span', { style: styles.tagName }, tagName), '>');
};

var nameByNodeType = {
  1: 'ELEMENT_NODE',
  3: 'TEXT_NODE',
  7: 'PROCESSING_INSTRUCTION_NODE',
  8: 'COMMENT_NODE',
  9: 'DOCUMENT_NODE',
  10: 'DOCUMENT_TYPE_NODE', // http://stackoverflow.com/questions/6088972/get-doctype-of-an-html-as-string-with-javascript
  11: 'DOCUMENT_FRAGMENT_NODE'
};

var DOMNodePreview = function DOMNodePreview(_ref3, _ref4) {
  var isCloseTag = _ref3.isCloseTag,
      data = _ref3.data,
      expanded = _ref3.expanded;
  var theme = _ref4.theme;

  var styles = (0, _createStyles2.default)('DOMNodePreview', theme);

  if (isCloseTag) {
    return _react2.default.createElement(CloseTag, { styles: styles.htmlCloseTag, isChildNode: true, tagName: data.tagName });
  }

  switch (data.nodeType) {
    case Node.ELEMENT_NODE:
      return _react2.default.createElement('span', null, _react2.default.createElement(OpenTag, {
        tagName: data.tagName,
        attributes: data.attributes,
        styles: styles.htmlOpenTag
      }), (0, _shouldInline2.default)(data) ? data.textContent : !expanded && '…', !expanded && _react2.default.createElement(CloseTag, { tagName: data.tagName, styles: styles.htmlCloseTag }));
    case Node.TEXT_NODE:
      return _react2.default.createElement('span', null, data.textContent);
    case Node.CDATA_SECTION_NODE:
      return _react2.default.createElement('span', null, '<![CDATA[' + data.textContent + ']]>');
    case Node.COMMENT_NODE:
      return _react2.default.createElement('span', { style: styles.htmlComment }, '<!--', data.textContent, '-->');
    case Node.PROCESSING_INSTRUCTION_NODE:
      return _react2.default.createElement('span', null, data.nodeName);
    case Node.DOCUMENT_TYPE_NODE:
      return _react2.default.createElement('span', { style: styles.htmlDoctype }, '<!DOCTYPE ', data.name, data.publicId ? ' PUBLIC "' + data.publicId + '"' : '', !data.publicId && data.systemId ? ' SYSTEM' : '', data.systemId ? ' "' + data.systemId + '"' : '', '>');
    case Node.DOCUMENT_NODE:
      return _react2.default.createElement('span', null, data.nodeName);
    case Node.DOCUMENT_FRAGMENT_NODE:
      return _react2.default.createElement('span', null, data.nodeName);
    default:
      return _react2.default.createElement('span', null, nameByNodeType[data.nodeType]);
  }
};

DOMNodePreview.propTypes = {
  /** If true, just render a close tag */
  isCloseTag: _propTypes2.default.bool,
  /**  */
  name: _propTypes2.default.string,
  /** The DOM Node */
  data: _propTypes2.default.object.isRequired,
  /** Whether the DOM node has been expanded. */
  expanded: _propTypes2.default.bool.isRequired
};

DOMNodePreview.contextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};

exports.default = DOMNodePreview;

/***/ }),

/***/ "OAUW":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _unselectable = __webpack_require__("hu5A");

var _unselectable2 = _interopRequireDefault(_unselectable);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (theme) {
  return {
    DOMNodePreview: {
      htmlOpenTag: {
        base: {
          color: theme.HTML_TAG_COLOR
        },
        tagName: {
          color: theme.HTML_TAGNAME_COLOR,
          textTransform: theme.HTML_TAGNAME_TEXT_TRANSFORM
        },
        htmlAttributeName: {
          color: theme.HTML_ATTRIBUTE_NAME_COLOR
        },
        htmlAttributeValue: {
          color: theme.HTML_ATTRIBUTE_VALUE_COLOR
        }
      },
      htmlCloseTag: {
        base: {
          color: theme.HTML_TAG_COLOR
        },
        offsetLeft: {
          /* hack: offset placeholder */
          marginLeft: -theme.TREENODE_PADDING_LEFT
        },
        tagName: {
          color: theme.HTML_TAGNAME_COLOR,
          textTransform: theme.HTML_TAGNAME_TEXT_TRANSFORM
        }
      },
      htmlComment: {
        color: theme.HTML_COMMENT_COLOR
      },
      htmlDoctype: {
        color: theme.HTML_DOCTYPE_COLOR
      }
    },

    ObjectName: {
      base: {
        color: theme.OBJECT_NAME_COLOR
      },
      dimmed: {
        opacity: 0.6
      }
    },

    ObjectValue: {
      objectValueNull: {
        color: theme.OBJECT_VALUE_NULL_COLOR
      },
      objectValueUndefined: {
        color: theme.OBJECT_VALUE_UNDEFINED_COLOR
      },
      objectValueRegExp: {
        color: theme.OBJECT_VALUE_REGEXP_COLOR
      },
      objectValueString: {
        color: theme.OBJECT_VALUE_STRING_COLOR
      },
      objectValueSymbol: {
        color: theme.OBJECT_VALUE_SYMBOL_COLOR
      },
      objectValueNumber: {
        color: theme.OBJECT_VALUE_NUMBER_COLOR
      },
      objectValueBoolean: {
        color: theme.OBJECT_VALUE_BOOLEAN_COLOR
      },
      objectValueFunctionKeyword: {
        color: theme.OBJECT_VALUE_FUNCTION_KEYWORD_COLOR,
        fontStyle: 'italic'
      },
      objectValueFunctionName: {
        fontStyle: 'italic'
      }
    },

    TreeNode: {
      treeNodeBase: {
        color: theme.BASE_COLOR,
        backgroundColor: theme.BASE_BACKGROUND_COLOR,

        lineHeight: theme.TREENODE_LINE_HEIGHT,
        cursor: 'default',

        boxSizing: 'border-box',
        listStyle: 'none',

        fontFamily: theme.TREENODE_FONT_FAMILY,
        fontSize: theme.TREENODE_FONT_SIZE
      },
      treeNodePreviewContainer: {},
      treeNodePlaceholder: (0, _extends3.default)({
        whiteSpace: 'pre',

        fontSize: theme.ARROW_FONT_SIZE,
        marginRight: theme.ARROW_MARGIN_RIGHT
      }, _unselectable2.default),
      treeNodeArrow: {
        base: (0, _extends3.default)({
          color: theme.ARROW_COLOR,
          display: 'inline-block',
          // lineHeight: '14px',
          fontSize: theme.ARROW_FONT_SIZE,
          marginRight: theme.ARROW_MARGIN_RIGHT
        }, _unselectable2.default),
        expanded: {
          WebkitTransform: 'rotateZ(90deg)',
          MozTransform: 'rotateZ(90deg)',
          transform: 'rotateZ(90deg)'
        },
        collapsed: {
          WebkitTransform: 'rotateZ(0deg)',
          MozTransform: 'rotateZ(0deg)',
          transform: 'rotateZ(0deg)'
        }
      },
      treeNodeChildNodesContainer: {
        margin: 0, // reset user-agent style
        paddingLeft: theme.TREENODE_PADDING_LEFT
      }
    },

    TableInspector: {
      base: {
        color: theme.BASE_COLOR,

        position: 'relative',
        border: '1px solid ' + theme.TABLE_BORDER_COLOR,
        fontFamily: theme.BASE_FONT_FAMILY,
        fontSize: theme.BASE_FONT_SIZE,
        lineHeight: '120%',
        boxSizing: 'border-box',
        cursor: 'default'
      }
    },

    TableInspectorHeaderContainer: {
      base: {
        top: 0,
        height: '17px',
        left: 0,
        right: 0,
        overflowX: 'hidden'
      },
      table: {
        tableLayout: 'fixed',
        borderSpacing: 0,
        borderCollapse: 'separate',
        height: '100%',
        width: '100%',
        margin: 0
      }
    },

    TableInspectorDataContainer: {
      tr: {
        display: 'table-row'
      },
      td: {
        boxSizing: 'border-box',
        border: 'none', // prevent overrides
        height: '16px', // /* 0.5 * table.background-size height */
        verticalAlign: 'top',
        padding: '1px 4px',
        WebkitUserSelect: 'text',

        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        lineHeight: '14px'
      },
      div: {
        position: 'static',
        top: '17px',
        bottom: 0,
        overflowY: 'overlay',
        transform: 'translateZ(0)',

        left: 0,
        right: 0,
        overflowX: 'hidden'
      },
      table: {
        positon: 'static',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        borderTop: '0 none transparent',
        margin: 0, // prevent user agent stylesheet overrides

        backgroundImage: theme.TABLE_DATA_BACKGROUND_IMAGE,
        backgroundSize: theme.TABLE_DATA_BACKGROUND_SIZE,
        tableLayout: 'fixed',

        // table
        borderSpacing: 0,
        borderCollapse: 'separate',
        // height: '100%',
        width: '100%',

        fontSize: theme.BASE_FONT_SIZE,
        lineHeight: '120%'
      }
    },

    TableInspectorTH: {
      base: {
        position: 'relative', // anchor for sort icon container
        height: 'auto',
        textAlign: 'left',
        backgroundColor: theme.TABLE_TH_BACKGROUND_COLOR,
        borderBottom: '1px solid ' + theme.TABLE_BORDER_COLOR,
        fontWeight: 'normal',
        verticalAlign: 'middle',
        padding: '0 4px',

        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        lineHeight: '14px',

        ':hover': {
          backgroundColor: theme.TABLE_TH_HOVER_COLOR
        }
      },
      div: {
        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
        overflow: 'hidden',

        // prevent user agent stylesheet overrides
        fontSize: theme.BASE_FONT_SIZE,
        lineHeight: '120%'
      }
    },

    TableInspectorLeftBorder: {
      none: {
        borderLeft: 'none'
      },
      solid: {
        borderLeft: '1px solid ' + theme.TABLE_BORDER_COLOR
      }
    },

    TableInspectorSortIcon: (0, _extends3.default)({
      display: 'block',
      marginRight: 3, // 4,
      width: 8,
      height: 7,

      marginTop: -7,
      color: theme.TABLE_SORT_ICON_COLOR,
      fontSize: 12
    }, _unselectable2.default)
  };
};

/***/ }),

/***/ "OYXR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__("ID6i");
var step = __webpack_require__("xwD+");
var Iterators = __webpack_require__("dhak");
var toIObject = __webpack_require__("Wyka");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("uRfg")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "Ocr3":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "PDcB":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__("mbLO");
var $keys = __webpack_require__("knrM");

__webpack_require__("cOHw")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "PO9O":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var external = __webpack_require__("8JlO");
var DataWorker = __webpack_require__("ABU1");
var DataLengthProbe = __webpack_require__("S9RN");
var Crc32Probe = __webpack_require__("gpbE");
var DataLengthProbe = __webpack_require__("S9RN");

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker: function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if (this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker: function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

/***/ }),

/***/ "Ps3q":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var support = __webpack_require__("untT");
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

// public method for encoding
exports.encode = function (input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0,
        len = input.length,
        remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }

    return output.join("");
};

// public method for decoding
exports.decode = function (input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0,
        resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
    } else {
        output = new Array(totalLength | 0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }
    }

    return output;
};

/***/ }),

/***/ "Q14w":
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/***/ }),

/***/ "QAmr":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var index = typeof fetch == 'function' ? fetch.bind() : function (url, options) {
	options = options || {};
	return new Promise(function (resolve, reject) {
		var request = new XMLHttpRequest();

		request.open(options.method || 'get', url, true);

		for (var i in options.headers) {
			request.setRequestHeader(i, options.headers[i]);
		}

		request.withCredentials = options.credentials == 'include';

		request.onload = function () {
			resolve(response());
		};

		request.onerror = reject;

		request.send(options.body || null);

		function response() {
			var keys = [],
			    all = [],
			    headers = {},
			    header;

			request.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function (m, key, value) {
				keys.push(key = key.toLowerCase());
				all.push([key, value]);
				header = headers[key];
				headers[key] = header ? header + "," + value : value;
			});

			return {
				ok: (request.status / 100 | 0) == 2, // 200-299
				status: request.status,
				statusText: request.statusText,
				url: request.responseURL,
				clone: response,
				text: function () {
					return Promise.resolve(request.responseText);
				},
				json: function () {
					return Promise.resolve(request.responseText).then(JSON.parse);
				},
				blob: function () {
					return Promise.resolve(new Blob([request.response]));
				},
				headers: {
					keys: function () {
						return keys;
					},
					entries: function () {
						return all;
					},
					get: function (n) {
						return headers[n.toLowerCase()];
					},
					has: function (n) {
						return n.toLowerCase() in headers;
					}
				}
			};
		}
	});
};

/* harmony default export */ __webpack_exports__["default"] = (index);
//# sourceMappingURL=unfetch.es.js.map

/***/ }),

/***/ "QDxr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * @this {Promise}
 */

function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(function (value) {
    return constructor.resolve(callback()).then(function () {
      return value;
    });
  }, function (reason) {
    return constructor.resolve(callback()).then(function () {
      return constructor.reject(reason);
    });
  });
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function () {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function () {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return;
      done = true;
      resolve(self, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(self, reason);
    });
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function (onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = finallyConstructor;

Promise.all = function (arr) {
  return new Promise(function (resolve, reject) {
    if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function (value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function (resolve) {
    resolve(value);
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {
  setImmediate(fn);
} || function (fn) {
  setTimeoutFunc(fn, 0);
};

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/** @suppress {undefinedVars} */
var globalNS = function () {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('unable to locate global object');
}();

if (!('Promise' in globalNS)) {
  globalNS['Promise'] = Promise;
} else if (!globalNS.Promise.prototype['finally']) {
  globalNS.Promise.prototype['finally'] = finallyConstructor;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("h6ac")))

/***/ }),

/***/ "QUdu":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__("jNRJ");
var requireObjectCoercible = __webpack_require__("Vhc8");

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};

/***/ }),

/***/ "QVnC":
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function (arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function () {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}(
// In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this;
}() || Function("return this")());

/***/ }),

/***/ "QYzI":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = function () {
  return this;
}() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__("QVnC");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch (e) {
    g.regeneratorRuntime = undefined;
  }
}

/***/ }),

/***/ "R6c1":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("6MLN") && !__webpack_require__("wLcK")(function () {
  return Object.defineProperty(__webpack_require__("9kxq")('div'), 'a', { get: function () {
      return 7;
    } }).a != 7;
});

/***/ }),

/***/ "REa7":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "RsE0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.9.0
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


Object.defineProperty(exports, "__esModule", { value: !0 });
var b = "function" === typeof Symbol && Symbol.for,
    c = b ? Symbol.for("react.element") : 60103,
    d = b ? Symbol.for("react.portal") : 60106,
    e = b ? Symbol.for("react.fragment") : 60107,
    f = b ? Symbol.for("react.strict_mode") : 60108,
    g = b ? Symbol.for("react.profiler") : 60114,
    h = b ? Symbol.for("react.provider") : 60109,
    k = b ? Symbol.for("react.context") : 60110,
    l = b ? Symbol.for("react.async_mode") : 60111,
    m = b ? Symbol.for("react.concurrent_mode") : 60111,
    n = b ? Symbol.for("react.forward_ref") : 60112,
    p = b ? Symbol.for("react.suspense") : 60113,
    q = b ? Symbol.for("react.suspense_list") : 60120,
    r = b ? Symbol.for("react.memo") : 60115,
    t = b ? Symbol.for("react.lazy") : 60116,
    v = b ? Symbol.for("react.fundamental") : 60117,
    w = b ? Symbol.for("react.responder") : 60118;function x(a) {
  if ("object" === typeof a && null !== a) {
    var u = a.$$typeof;switch (u) {case c:
        switch (a = a.type, a) {case l:case m:case e:case g:case f:case p:
            return a;default:
            switch (a = a && a.$$typeof, a) {case k:case n:case h:
                return a;default:
                return u;}}case t:case r:case d:
        return u;}
  }
}function y(a) {
  return x(a) === m;
}exports.typeOf = x;exports.AsyncMode = l;
exports.ConcurrentMode = m;exports.ContextConsumer = k;exports.ContextProvider = h;exports.Element = c;exports.ForwardRef = n;exports.Fragment = e;exports.Lazy = t;exports.Memo = r;exports.Portal = d;exports.Profiler = g;exports.StrictMode = f;exports.Suspense = p;
exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === v || a.$$typeof === w);
};exports.isAsyncMode = function (a) {
  return y(a) || x(a) === l;
};exports.isConcurrentMode = y;exports.isContextConsumer = function (a) {
  return x(a) === k;
};exports.isContextProvider = function (a) {
  return x(a) === h;
};
exports.isElement = function (a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};exports.isForwardRef = function (a) {
  return x(a) === n;
};exports.isFragment = function (a) {
  return x(a) === e;
};exports.isLazy = function (a) {
  return x(a) === t;
};exports.isMemo = function (a) {
  return x(a) === r;
};exports.isPortal = function (a) {
  return x(a) === d;
};exports.isProfiler = function (a) {
  return x(a) === g;
};exports.isStrictMode = function (a) {
  return x(a) === f;
};exports.isSuspense = function (a) {
  return x(a) === p;
};

/***/ }),

/***/ "S7IM":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("MpYs");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "S9RN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var GenericWorker = __webpack_require__("ZKdc");

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;

/***/ }),

/***/ "SD9a":
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__("u1qH");
var requireObjectCoercible = __webpack_require__("Vhc8");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

/***/ }),

/***/ "SUmx":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("ggoL"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../../mode/css/css"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var pseudoClasses = { link: 1, visited: 1, active: 1, hover: 1, focus: 1,
    "first-letter": 1, "first-line": 1, "first-child": 1,
    before: 1, after: 1, lang: 1 };

  CodeMirror.registerHelper("hint", "css", function (cm) {
    var cur = cm.getCursor(),
        token = cm.getTokenAt(cur);
    var inner = CodeMirror.innerMode(cm.getMode(), token.state);
    if (inner.mode.name != "css") return;

    if (token.type == "keyword" && "!important".indexOf(token.string) == 0) return { list: ["!important"], from: CodeMirror.Pos(cur.line, token.start),
      to: CodeMirror.Pos(cur.line, token.end) };

    var start = token.start,
        end = cur.ch,
        word = token.string.slice(0, end - start);
    if (/[^\w$_-]/.test(word)) {
      word = "";start = end = cur.ch;
    }

    var spec = CodeMirror.resolveMode("text/css");

    var result = [];
    function add(keywords) {
      for (var name in keywords) if (!word || name.lastIndexOf(word, 0) == 0) result.push(name);
    }

    var st = inner.state.state;
    if (st == "pseudo" || token.type == "variable-3") {
      add(pseudoClasses);
    } else if (st == "block" || st == "maybeprop") {
      add(spec.propertyKeywords);
    } else if (st == "prop" || st == "parens" || st == "at" || st == "params") {
      add(spec.valueKeywords);
      add(spec.colorKeywords);
    } else if (st == "media" || st == "media_parens") {
      add(spec.mediaTypes);
      add(spec.mediaFeatures);
    }

    if (result.length) return {
      list: result,
      from: CodeMirror.Pos(cur.line, start),
      to: CodeMirror.Pos(cur.line, end)
    };
  });
});

/***/ }),

/***/ "ShN9":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "Sm7/":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var support = __webpack_require__("untT");
var nodejsUtils = __webpack_require__("c5OX");
var GenericWorker = __webpack_require__("ZKdc");

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i = 0; i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function (str) {
    var buf,
        c,
        c2,
        m_pos,
        i,
        str_len = str.length,
        buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | c >>> 6;
            buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | c >>> 12;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | c >>> 18;
            buf[i++] = 0x80 | c >>> 12 & 0x3f;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function (buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) {
        max = buf.length;
    }

    // go back from last position, until start of sequence found
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
    }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) {
        return max;
    }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) {
        return max;
    }

    return pos + _utf8len[buf[pos]] > max ? pos : max;
};

// convert array to string
var buf2string = function (buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) {
            utf16buf[out++] = c;continue;
        }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) {
            utf16buf[out++] = 0xfffd;i += c_len - 1;continue;
        }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 0x3f;
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) {
            utf16buf[out++] = 0xfffd;continue;
        }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
            utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};

// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};

/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data: exports.utf8decode(usableData),
        meta: chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if (this.leftOver && this.leftOver.length) {
        this.push({
            data: exports.utf8decode(this.leftOver),
            meta: {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data: exports.utf8encode(chunk.data),
        meta: chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

/***/ }),

/***/ "T4f3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__("gc0D");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "TBQ4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _ObjectName = __webpack_require__("bY9t");

var _ObjectName2 = _interopRequireDefault(_ObjectName);

var _ObjectPreview = __webpack_require__("AeFI");

var _ObjectPreview2 = _interopRequireDefault(_ObjectPreview);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var ObjectRootLabel = function ObjectRootLabel(_ref) {
  var name = _ref.name,
      data = _ref.data;

  if (typeof name === 'string') {
    return _react2.default.createElement('span', null, _react2.default.createElement(_ObjectName2.default, { name: name }), _react2.default.createElement('span', null, ': '), _react2.default.createElement(_ObjectPreview2.default, { data: data }));
  } else {
    return _react2.default.createElement(_ObjectPreview2.default, { data: data });
  }
};

exports.default = ObjectRootLabel;

/***/ }),

/***/ "TCoK":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataReader = __webpack_require__("ML/b");
var utils = __webpack_require__("dvMn");

function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 0xFF;
    }
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function (i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

/***/ }),

/***/ "TEgB":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("COf8");
__webpack_require__("i+u+");
module.exports = __webpack_require__("By4a");

/***/ }),

/***/ "TNJq":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("zotD");
var dPs = __webpack_require__("gjjs");
var enumBugKeys = __webpack_require__("KxjL");
var IE_PROTO = __webpack_require__("/wuY")('IE_PROTO');
var Empty = function () {/* empty */};
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("9kxq")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("ebIA").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "TUpU":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return LogLevel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLogLevel", function() { return setLogLevel; });
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A container for all of the Logger instances
 */
var instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
/**
 * The default log level
 */
var defaultLogLevel = LogLevel.INFO;
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */
var defaultLogHandler = function (instance, logType) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    if (logType < instance.logLevel) return;
    var now = new Date().toISOString();
    switch (logType) {
        /**
         * By default, `console.debug` is not displayed in the developer console (in
         * chrome). To avoid forcing users to have to opt-in to these logs twice
         * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
         * logs to the `console.log` function.
         */
        case LogLevel.DEBUG:
            console.log.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
            break;
        case LogLevel.VERBOSE:
            console.log.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
            break;
        case LogLevel.INFO:
            console.info.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
            break;
        case LogLevel.WARN:
            console.warn.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
            break;
        case LogLevel.ERROR:
            console.error.apply(console, ["[" + now + "]  " + instance.name + ":"].concat(args));
            break;
        default:
            throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
    }
};
var Logger = /** @class */function () {
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */
    function Logger(name) {
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */
        this._logLevel = defaultLogLevel;
        /**
         * The log handler for the Logger instance.
         */
        this._logHandler = defaultLogHandler;
        /**
         * Capture the current instance for later use
         */
        instances.push(this);
    }
    Object.defineProperty(Logger.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        set: function (val) {
            if (!(val in LogLevel)) {
                throw new TypeError('Invalid value assigned to `logLevel`');
            }
            this._logLevel = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Logger.prototype, "logHandler", {
        get: function () {
            return this._logHandler;
        },
        set: function (val) {
            if (typeof val !== 'function') {
                throw new TypeError('Value assigned to `logHandler` must be a function');
            }
            this._logHandler = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The functions below are all based on the `console` interface
     */
    Logger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._logHandler.apply(this, [this, LogLevel.DEBUG].concat(args));
    };
    Logger.prototype.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._logHandler.apply(this, [this, LogLevel.VERBOSE].concat(args));
    };
    Logger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._logHandler.apply(this, [this, LogLevel.INFO].concat(args));
    };
    Logger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._logHandler.apply(this, [this, LogLevel.WARN].concat(args));
    };
    Logger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._logHandler.apply(this, [this, LogLevel.ERROR].concat(args));
    };
    return Logger;
}();

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setLogLevel(level) {
    instances.forEach(function (inst) {
        inst.logLevel = level;
    });
}


//# sourceMappingURL=index.esm.js.map

/***/ }),

/***/ "U72i":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "UYRC":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "Ug9I":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("NB7d")('wks');
var uid = __webpack_require__("X6va");
var Symbol = __webpack_require__("i1Q6").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "Uq/2":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIndexedObject = __webpack_require__("SD9a");
var nativeGetOwnPropertyNames = __webpack_require__("+puC").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
};

/***/ }),

/***/ "VMPx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function pad(hash, len) {
  while (hash.length < len) {
    hash = '0' + hash;
  }
  return hash;
}

function fold(hash, text) {
  var i;
  var chr;
  var len;
  if (text.length === 0) {
    return hash;
  }
  for (i = 0, len = text.length; i < len; i++) {
    chr = text.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash < 0 ? hash * -2 : hash;
}

function foldObject(hash, o, seen) {
  return Object.keys(o).sort().reduce(foldKey, hash);
  function foldKey(hash, key) {
    return foldValue(hash, o[key], key, seen);
  }
}

function foldValue(input, value, key, seen) {
  var hash = fold(fold(fold(input, key), toString(value)), typeof value);
  if (value === null) {
    return fold(hash, 'null');
  }
  if (value === undefined) {
    return fold(hash, 'undefined');
  }
  if (typeof value === 'object') {
    if (seen.indexOf(value) !== -1) {
      return fold(hash, '[Circular]' + key);
    }
    seen.push(value);
    return foldObject(hash, value, seen);
  }
  return fold(hash, value.toString());
}

function toString(o) {
  return Object.prototype.toString.call(o);
}

function sum(o) {
  return pad(foldValue(0, o, '', []).toString(16), 8);
}

module.exports = sum;

/***/ }),

/***/ "VOrx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),

/***/ "VS7n":
/***/ (function(module, exports, __webpack_require__) {

module.exports = window.fetch || (window.fetch = __webpack_require__("QAmr").default || __webpack_require__("QAmr"));

/***/ }),

/***/ "Vhc8":
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

/***/ }),

/***/ "VuZO":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("O35A"), __esModule: true };

/***/ }),

/***/ "W8pO":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("3PKL");
var IndexedObject = __webpack_require__("u1qH");
var toObject = __webpack_require__("yocI");
var toLength = __webpack_require__("qub/");
var arraySpeciesCreate = __webpack_require__("ZZ7S");

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
// 0 -> Array#forEach
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
// 1 -> Array#map
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// 2 -> Array#filter
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// 3 -> Array#some
// https://tc39.github.io/ecma262/#sec-array.prototype.some
// 4 -> Array#every
// https://tc39.github.io/ecma262/#sec-array.prototype.every
// 5 -> Array#find
// https://tc39.github.io/ecma262/#sec-array.prototype.find
// 6 -> Array#findIndex
// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
module.exports = function (TYPE, specificCreate) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = specificCreate || arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
            case 3:
              return true; // some
            case 5:
              return value; // find
            case 6:
              return index; // findIndex
            case 2:
              target.push(value); // filter
          } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

/***/ }),

/***/ "WSyY":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__("Yj0v");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__("Q14w");
util.inherits = __webpack_require__("4Bm0");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__("yM1o")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__("1ExO");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__("38Wu").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__("GRUB");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__("Hba+");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__("Hba+");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("h6ac")))

/***/ }),

/***/ "WWuK":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.asyncIterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
__webpack_require__("KGgk")('asyncIterator');

/***/ }),

/***/ "WrsD":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable
__webpack_require__("KGgk")('isConcatSpreadable');

/***/ }),

/***/ "Wyka":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("E5Ce");
var defined = __webpack_require__("U72i");
module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "X4kj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

/***/ }),

/***/ "X6va":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "X7my":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var noOptions = {};
  var nonWS = /[^\s\u00a0]/;
  var Pos = CodeMirror.Pos;

  function firstNonWS(str) {
    var found = str.search(nonWS);
    return found == -1 ? 0 : found;
  }

  CodeMirror.commands.toggleComment = function (cm) {
    cm.toggleComment();
  };

  CodeMirror.defineExtension("toggleComment", function (options) {
    if (!options) options = noOptions;
    var cm = this;
    var minLine = Infinity,
        ranges = this.listSelections(),
        mode = null;
    for (var i = ranges.length - 1; i >= 0; i--) {
      var from = ranges[i].from(),
          to = ranges[i].to();
      if (from.line >= minLine) continue;
      if (to.line >= minLine) to = Pos(minLine, 0);
      minLine = from.line;
      if (mode == null) {
        if (cm.uncomment(from, to, options)) mode = "un";else {
          cm.lineComment(from, to, options);mode = "line";
        }
      } else if (mode == "un") {
        cm.uncomment(from, to, options);
      } else {
        cm.lineComment(from, to, options);
      }
    }
  });

  // Rough heuristic to try and detect lines that are part of multi-line string
  function probablyInsideString(cm, pos, line) {
    return (/\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line)
    );
  }

  function getMode(cm, pos) {
    var mode = cm.getMode();
    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos);
  }

  CodeMirror.defineExtension("lineComment", function (from, to, options) {
    if (!options) options = noOptions;
    var self = this,
        mode = getMode(self, from);
    var firstLine = self.getLine(from.line);
    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;

    var commentString = options.lineComment || mode.lineComment;
    if (!commentString) {
      if (options.blockCommentStart || mode.blockCommentStart) {
        options.fullLines = true;
        self.blockComment(from, to, options);
      }
      return;
    }

    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);
    var pad = options.padding == null ? " " : options.padding;
    var blankLines = options.commentBlankLines || from.line == to.line;

    self.operation(function () {
      if (options.indent) {
        var baseString = null;
        for (var i = from.line; i < end; ++i) {
          var line = self.getLine(i);
          var whitespace = line.slice(0, firstNonWS(line));
          if (baseString == null || baseString.length > whitespace.length) {
            baseString = whitespace;
          }
        }
        for (var i = from.line; i < end; ++i) {
          var line = self.getLine(i),
              cut = baseString.length;
          if (!blankLines && !nonWS.test(line)) continue;
          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);
          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
        }
      } else {
        for (var i = from.line; i < end; ++i) {
          if (blankLines || nonWS.test(self.getLine(i))) self.replaceRange(commentString + pad, Pos(i, 0));
        }
      }
    });
  });

  CodeMirror.defineExtension("blockComment", function (from, to, options) {
    if (!options) options = noOptions;
    var self = this,
        mode = getMode(self, from);
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) {
      if ((options.lineComment || mode.lineComment) && options.fullLines != false) self.lineComment(from, to, options);
      return;
    }
    if (/\bcomment\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return;

    var end = Math.min(to.line, self.lastLine());
    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;

    var pad = options.padding == null ? " " : options.padding;
    if (from.line > end) return;

    self.operation(function () {
      if (options.fullLines != false) {
        var lastLineHasText = nonWS.test(self.getLine(end));
        self.replaceRange(pad + endString, Pos(end));
        self.replaceRange(startString + pad, Pos(from.line, 0));
        var lead = options.blockCommentLead || mode.blockCommentLead;
        if (lead != null) for (var i = from.line + 1; i <= end; ++i) if (i != end || lastLineHasText) self.replaceRange(lead + pad, Pos(i, 0));
      } else {
        self.replaceRange(endString, to);
        self.replaceRange(startString, from);
      }
    });
  });

  CodeMirror.defineExtension("uncomment", function (from, to, options) {
    if (!options) options = noOptions;
    var self = this,
        mode = getMode(self, from);
    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()),
        start = Math.min(from.line, end);

    // Try finding line comments
    var lineString = options.lineComment || mode.lineComment,
        lines = [];
    var pad = options.padding == null ? " " : options.padding,
        didSomething;
    lineComment: {
      if (!lineString) break lineComment;
      for (var i = start; i <= end; ++i) {
        var line = self.getLine(i);
        var found = line.indexOf(lineString);
        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
        if (found == -1 && nonWS.test(line)) break lineComment;
        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
        lines.push(line);
      }
      self.operation(function () {
        for (var i = start; i <= end; ++i) {
          var line = lines[i - start];
          var pos = line.indexOf(lineString),
              endPos = pos + lineString.length;
          if (pos < 0) continue;
          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
          didSomething = true;
          self.replaceRange("", Pos(i, pos), Pos(i, endPos));
        }
      });
      if (didSomething) return true;
    }

    // Try block comments
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) return false;
    var lead = options.blockCommentLead || mode.blockCommentLead;
    var startLine = self.getLine(start),
        open = startLine.indexOf(startString);
    if (open == -1) return false;
    var endLine = end == start ? startLine : self.getLine(end);
    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
    var insideStart = Pos(start, open + 1),
        insideEnd = Pos(end, close + 1);
    if (close == -1 || !/comment/.test(self.getTokenTypeAt(insideStart)) || !/comment/.test(self.getTokenTypeAt(insideEnd)) || self.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1) return false;

    // Avoid killing block comments completely outside the selection.
    // Positions of the last startString before the start of the selection, and the first endString after it.
    var lastStart = startLine.lastIndexOf(startString, from.ch);
    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;
    // Positions of the first endString after the end of the selection, and the last startString before it.
    firstEnd = endLine.indexOf(endString, to.ch);
    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
    lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;
    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;

    self.operation(function () {
      self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end, close + endString.length));
      var openEnd = open + startString.length;
      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
      self.replaceRange("", Pos(start, open), Pos(start, openEnd));
      if (lead) for (var i = start + 1; i <= end; ++i) {
        var line = self.getLine(i),
            found = line.indexOf(lead);
        if (found == -1 || nonWS.test(line.slice(0, found))) continue;
        var foundEnd = found + lead.length;
        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
        self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
      }
    });
    return true;
  });
});

/***/ }),

/***/ "X9RM":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("Lvd3"), __esModule: true };

/***/ }),

/***/ "Xc2M":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// A rough approximation of Sublime Text's keybindings
// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("29F7"), __webpack_require__("uQIK"));else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/edit/matchbrackets"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var cmds = CodeMirror.commands;
  var Pos = CodeMirror.Pos;

  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.
  function findPosSubword(doc, start, dir) {
    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));
    var line = doc.getLine(start.line);
    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));
    var state = "start",
        type;
    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
      var next = line.charAt(dir < 0 ? pos - 1 : pos);
      var cat = next != "_" && CodeMirror.isWordChar(next) ? "w" : "o";
      if (cat == "w" && next.toUpperCase() == next) cat = "W";
      if (state == "start") {
        if (cat != "o") {
          state = "in";type = cat;
        }
      } else if (state == "in") {
        if (type != cat) {
          if (type == "w" && cat == "W" && dir < 0) pos--;
          if (type == "W" && cat == "w" && dir > 0) {
            type = "w";continue;
          }
          break;
        }
      }
    }
    return Pos(start.line, pos);
  }

  function moveSubword(cm, dir) {
    cm.extendSelectionsBy(function (range) {
      if (cm.display.shift || cm.doc.extend || range.empty()) return findPosSubword(cm.doc, range.head, dir);else return dir < 0 ? range.from() : range.to();
    });
  }

  cmds.goSubwordLeft = function (cm) {
    moveSubword(cm, -1);
  };
  cmds.goSubwordRight = function (cm) {
    moveSubword(cm, 1);
  };

  cmds.scrollLineUp = function (cm) {
    var info = cm.getScrollInfo();
    if (!cm.somethingSelected()) {
      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");
      if (cm.getCursor().line >= visibleBottomLine) cm.execCommand("goLineUp");
    }
    cm.scrollTo(null, info.top - cm.defaultTextHeight());
  };
  cmds.scrollLineDown = function (cm) {
    var info = cm.getScrollInfo();
    if (!cm.somethingSelected()) {
      var visibleTopLine = cm.lineAtHeight(info.top, "local") + 1;
      if (cm.getCursor().line <= visibleTopLine) cm.execCommand("goLineDown");
    }
    cm.scrollTo(null, info.top + cm.defaultTextHeight());
  };

  cmds.splitSelectionByLine = function (cm) {
    var ranges = cm.listSelections(),
        lineRanges = [];
    for (var i = 0; i < ranges.length; i++) {
      var from = ranges[i].from(),
          to = ranges[i].to();
      for (var line = from.line; line <= to.line; ++line) if (!(to.line > from.line && line == to.line && to.ch == 0)) lineRanges.push({ anchor: line == from.line ? from : Pos(line, 0),
        head: line == to.line ? to : Pos(line) });
    }
    cm.setSelections(lineRanges, 0);
  };

  cmds.singleSelectionTop = function (cm) {
    var range = cm.listSelections()[0];
    cm.setSelection(range.anchor, range.head, { scroll: false });
  };

  cmds.selectLine = function (cm) {
    var ranges = cm.listSelections(),
        extended = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      extended.push({ anchor: Pos(range.from().line, 0),
        head: Pos(range.to().line + 1, 0) });
    }
    cm.setSelections(extended);
  };

  function insertLine(cm, above) {
    if (cm.isReadOnly()) return CodeMirror.Pass;
    cm.operation(function () {
      var len = cm.listSelections().length,
          newSelection = [],
          last = -1;
      for (var i = 0; i < len; i++) {
        var head = cm.listSelections()[i].head;
        if (head.line <= last) continue;
        var at = Pos(head.line + (above ? 0 : 1), 0);
        cm.replaceRange("\n", at, null, "+insertLine");
        cm.indentLine(at.line, null, true);
        newSelection.push({ head: at, anchor: at });
        last = head.line + 1;
      }
      cm.setSelections(newSelection);
    });
    cm.execCommand("indentAuto");
  }

  cmds.insertLineAfter = function (cm) {
    return insertLine(cm, false);
  };

  cmds.insertLineBefore = function (cm) {
    return insertLine(cm, true);
  };

  function wordAt(cm, pos) {
    var start = pos.ch,
        end = start,
        line = cm.getLine(pos.line);
    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;
    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;
    return { from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end) };
  }

  cmds.selectNextOccurrence = function (cm) {
    var from = cm.getCursor("from"),
        to = cm.getCursor("to");
    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
    if (CodeMirror.cmpPos(from, to) == 0) {
      var word = wordAt(cm, from);
      if (!word.word) return;
      cm.setSelection(word.from, word.to);
      fullWord = true;
    } else {
      var text = cm.getRange(from, to);
      var query = fullWord ? new RegExp("\\b" + text + "\\b") : text;
      var cur = cm.getSearchCursor(query, to);
      var found = cur.findNext();
      if (!found) {
        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
        found = cur.findNext();
      }
      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return CodeMirror.Pass;
      cm.addSelection(cur.from(), cur.to());
    }
    if (fullWord) cm.state.sublimeFindFullWord = cm.doc.sel;
  };

  function addCursorToSelection(cm, dir) {
    var ranges = cm.listSelections(),
        newRanges = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var newAnchor = cm.findPosV(range.anchor, dir, "line", range.anchor.goalColumn);
      var newHead = cm.findPosV(range.head, dir, "line", range.head.goalColumn);
      newAnchor.goalColumn = range.anchor.goalColumn != null ? range.anchor.goalColumn : cm.cursorCoords(range.anchor, "div").left;
      newHead.goalColumn = range.head.goalColumn != null ? range.head.goalColumn : cm.cursorCoords(range.head, "div").left;
      var newRange = { anchor: newAnchor, head: newHead };
      newRanges.push(range);
      newRanges.push(newRange);
    }
    cm.setSelections(newRanges);
  }
  cmds.addCursorToPrevLine = function (cm) {
    addCursorToSelection(cm, -1);
  };
  cmds.addCursorToNextLine = function (cm) {
    addCursorToSelection(cm, 1);
  };

  function isSelectedRange(ranges, from, to) {
    for (var i = 0; i < ranges.length; i++) if (ranges[i].from() == from && ranges[i].to() == to) return true;
    return false;
  }

  var mirror = "(){}[]";
  function selectBetweenBrackets(cm) {
    var ranges = cm.listSelections(),
        newRanges = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
          pos = range.head,
          opening = cm.scanForBracket(pos, -1);
      if (!opening) return false;
      for (;;) {
        var closing = cm.scanForBracket(pos, 1);
        if (!closing) return false;
        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);
          if (CodeMirror.cmpPos(startPos, range.from()) == 0 && CodeMirror.cmpPos(closing.pos, range.to()) == 0) {
            opening = cm.scanForBracket(opening.pos, -1);
            if (!opening) return false;
          } else {
            newRanges.push({ anchor: startPos, head: closing.pos });
            break;
          }
        }
        pos = Pos(closing.pos.line, closing.pos.ch + 1);
      }
    }
    cm.setSelections(newRanges);
    return true;
  }

  cmds.selectScope = function (cm) {
    selectBetweenBrackets(cm) || cm.execCommand("selectAll");
  };
  cmds.selectBetweenBrackets = function (cm) {
    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;
  };

  cmds.goToBracket = function (cm) {
    cm.extendSelectionsBy(function (range) {
      var next = cm.scanForBracket(range.head, 1);
      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;
      var prev = cm.scanForBracket(range.head, -1);
      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;
    });
  };

  cmds.swapLineUp = function (cm) {
    if (cm.isReadOnly()) return CodeMirror.Pass;
    var ranges = cm.listSelections(),
        linesToMove = [],
        at = cm.firstLine() - 1,
        newSels = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
          from = range.from().line - 1,
          to = range.to().line;
      newSels.push({ anchor: Pos(range.anchor.line - 1, range.anchor.ch),
        head: Pos(range.head.line - 1, range.head.ch) });
      if (range.to().ch == 0 && !range.empty()) --to;
      if (from > at) linesToMove.push(from, to);else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
      at = to;
    }
    cm.operation(function () {
      for (var i = 0; i < linesToMove.length; i += 2) {
        var from = linesToMove[i],
            to = linesToMove[i + 1];
        var line = cm.getLine(from);
        cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
        if (to > cm.lastLine()) cm.replaceRange("\n" + line, Pos(cm.lastLine()), null, "+swapLine");else cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
      }
      cm.setSelections(newSels);
      cm.scrollIntoView();
    });
  };

  cmds.swapLineDown = function (cm) {
    if (cm.isReadOnly()) return CodeMirror.Pass;
    var ranges = cm.listSelections(),
        linesToMove = [],
        at = cm.lastLine() + 1;
    for (var i = ranges.length - 1; i >= 0; i--) {
      var range = ranges[i],
          from = range.to().line + 1,
          to = range.from().line;
      if (range.to().ch == 0 && !range.empty()) from--;
      if (from < at) linesToMove.push(from, to);else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
      at = to;
    }
    cm.operation(function () {
      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {
        var from = linesToMove[i],
            to = linesToMove[i + 1];
        var line = cm.getLine(from);
        if (from == cm.lastLine()) cm.replaceRange("", Pos(from - 1), Pos(from), "+swapLine");else cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
        cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
      }
      cm.scrollIntoView();
    });
  };

  cmds.toggleCommentIndented = function (cm) {
    cm.toggleComment({ indent: true });
  };

  cmds.joinLines = function (cm) {
    var ranges = cm.listSelections(),
        joined = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
          from = range.from();
      var start = from.line,
          end = range.to().line;
      while (i < ranges.length - 1 && ranges[i + 1].from().line == end) end = ranges[++i].to().line;
      joined.push({ start: start, end: end, anchor: !range.empty() && from });
    }
    cm.operation(function () {
      var offset = 0,
          ranges = [];
      for (var i = 0; i < joined.length; i++) {
        var obj = joined[i];
        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch),
            head;
        for (var line = obj.start; line <= obj.end; line++) {
          var actual = line - offset;
          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);
          if (actual < cm.lastLine()) {
            cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
            ++offset;
          }
        }
        ranges.push({ anchor: anchor || head, head: head });
      }
      cm.setSelections(ranges, 0);
    });
  };

  cmds.duplicateLine = function (cm) {
    cm.operation(function () {
      var rangeCount = cm.listSelections().length;
      for (var i = 0; i < rangeCount; i++) {
        var range = cm.listSelections()[i];
        if (range.empty()) cm.replaceRange(cm.getLine(range.head.line) + "\n", Pos(range.head.line, 0));else cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());
      }
      cm.scrollIntoView();
    });
  };

  function sortLines(cm, caseSensitive) {
    if (cm.isReadOnly()) return CodeMirror.Pass;
    var ranges = cm.listSelections(),
        toSort = [],
        selected;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      if (range.empty()) continue;
      var from = range.from().line,
          to = range.to().line;
      while (i < ranges.length - 1 && ranges[i + 1].from().line == to) to = ranges[++i].to().line;
      if (!ranges[i].to().ch) to--;
      toSort.push(from, to);
    }
    if (toSort.length) selected = true;else toSort.push(cm.firstLine(), cm.lastLine());

    cm.operation(function () {
      var ranges = [];
      for (var i = 0; i < toSort.length; i += 2) {
        var from = toSort[i],
            to = toSort[i + 1];
        var start = Pos(from, 0),
            end = Pos(to);
        var lines = cm.getRange(start, end, false);
        if (caseSensitive) lines.sort();else lines.sort(function (a, b) {
          var au = a.toUpperCase(),
              bu = b.toUpperCase();
          if (au != bu) {
            a = au;b = bu;
          }
          return a < b ? -1 : a == b ? 0 : 1;
        });
        cm.replaceRange(lines, start, end);
        if (selected) ranges.push({ anchor: start, head: Pos(to + 1, 0) });
      }
      if (selected) cm.setSelections(ranges, 0);
    });
  }

  cmds.sortLines = function (cm) {
    sortLines(cm, true);
  };
  cmds.sortLinesInsensitive = function (cm) {
    sortLines(cm, false);
  };

  cmds.nextBookmark = function (cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) while (marks.length) {
      var current = marks.shift();
      var found = current.find();
      if (found) {
        marks.push(current);
        return cm.setSelection(found.from, found.to);
      }
    }
  };

  cmds.prevBookmark = function (cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) while (marks.length) {
      marks.unshift(marks.pop());
      var found = marks[marks.length - 1].find();
      if (!found) marks.pop();else return cm.setSelection(found.from, found.to);
    }
  };

  cmds.toggleBookmark = function (cm) {
    var ranges = cm.listSelections();
    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);
    for (var i = 0; i < ranges.length; i++) {
      var from = ranges[i].from(),
          to = ranges[i].to();
      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);
      for (var j = 0; j < found.length; j++) {
        if (found[j].sublimeBookmark) {
          found[j].clear();
          for (var k = 0; k < marks.length; k++) if (marks[k] == found[j]) marks.splice(k--, 1);
          break;
        }
      }
      if (j == found.length) marks.push(cm.markText(from, to, { sublimeBookmark: true, clearWhenEmpty: false }));
    }
  };

  cmds.clearBookmarks = function (cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
    marks.length = 0;
  };

  cmds.selectBookmarks = function (cm) {
    var marks = cm.state.sublimeBookmarks,
        ranges = [];
    if (marks) for (var i = 0; i < marks.length; i++) {
      var found = marks[i].find();
      if (!found) marks.splice(i--, 0);else ranges.push({ anchor: found.from, head: found.to });
    }
    if (ranges.length) cm.setSelections(ranges, 0);
  };

  function modifyWordOrSelection(cm, mod) {
    cm.operation(function () {
      var ranges = cm.listSelections(),
          indices = [],
          replacements = [];
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.empty()) {
          indices.push(i);replacements.push("");
        } else replacements.push(mod(cm.getRange(range.from(), range.to())));
      }
      cm.replaceSelections(replacements, "around", "case");
      for (var i = indices.length - 1, at; i >= 0; i--) {
        var range = ranges[indices[i]];
        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;
        var word = wordAt(cm, range.head);
        at = word.from;
        cm.replaceRange(mod(word.word), word.from, word.to);
      }
    });
  }

  cmds.smartBackspace = function (cm) {
    if (cm.somethingSelected()) return CodeMirror.Pass;

    cm.operation(function () {
      var cursors = cm.listSelections();
      var indentUnit = cm.getOption("indentUnit");

      for (var i = cursors.length - 1; i >= 0; i--) {
        var cursor = cursors[i].head;
        var toStartOfLine = cm.getRange({ line: cursor.line, ch: 0 }, cursor);
        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption("tabSize"));

        // Delete by one character by default
        var deletePos = cm.findPosH(cursor, -1, "char", false);

        if (toStartOfLine && !/\S/.test(toStartOfLine) && column % indentUnit == 0) {
          var prevIndent = new Pos(cursor.line, CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));

          // Smart delete only if we found a valid prevIndent location
          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;
        }

        cm.replaceRange("", deletePos, cursor, "+delete");
      }
    });
  };

  cmds.delLineRight = function (cm) {
    cm.operation(function () {
      var ranges = cm.listSelections();
      for (var i = ranges.length - 1; i >= 0; i--) cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");
      cm.scrollIntoView();
    });
  };

  cmds.upcaseAtCursor = function (cm) {
    modifyWordOrSelection(cm, function (str) {
      return str.toUpperCase();
    });
  };
  cmds.downcaseAtCursor = function (cm) {
    modifyWordOrSelection(cm, function (str) {
      return str.toLowerCase();
    });
  };

  cmds.setSublimeMark = function (cm) {
    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();
    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
  };
  cmds.selectToSublimeMark = function (cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) cm.setSelection(cm.getCursor(), found);
  };
  cmds.deleteToSublimeMark = function (cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) {
      var from = cm.getCursor(),
          to = found;
      if (CodeMirror.cmpPos(from, to) > 0) {
        var tmp = to;to = from;from = tmp;
      }
      cm.state.sublimeKilled = cm.getRange(from, to);
      cm.replaceRange("", from, to);
    }
  };
  cmds.swapWithSublimeMark = function (cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) {
      cm.state.sublimeMark.clear();
      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
      cm.setCursor(found);
    }
  };
  cmds.sublimeYank = function (cm) {
    if (cm.state.sublimeKilled != null) cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
  };

  cmds.showInCenter = function (cm) {
    var pos = cm.cursorCoords(null, "local");
    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
  };

  function getTarget(cm) {
    var from = cm.getCursor("from"),
        to = cm.getCursor("to");
    if (CodeMirror.cmpPos(from, to) == 0) {
      var word = wordAt(cm, from);
      if (!word.word) return;
      from = word.from;
      to = word.to;
    }
    return { from: from, to: to, query: cm.getRange(from, to), word: word };
  }

  function findAndGoTo(cm, forward) {
    var target = getTarget(cm);
    if (!target) return;
    var query = target.query;
    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);

    if (forward ? cur.findNext() : cur.findPrevious()) {
      cm.setSelection(cur.from(), cur.to());
    } else {
      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0) : cm.clipPos(Pos(cm.lastLine())));
      if (forward ? cur.findNext() : cur.findPrevious()) cm.setSelection(cur.from(), cur.to());else if (target.word) cm.setSelection(target.from, target.to);
    }
  };
  cmds.findUnder = function (cm) {
    findAndGoTo(cm, true);
  };
  cmds.findUnderPrevious = function (cm) {
    findAndGoTo(cm, false);
  };
  cmds.findAllUnder = function (cm) {
    var target = getTarget(cm);
    if (!target) return;
    var cur = cm.getSearchCursor(target.query);
    var matches = [];
    var primaryIndex = -1;
    while (cur.findNext()) {
      matches.push({ anchor: cur.from(), head: cur.to() });
      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch) primaryIndex++;
    }
    cm.setSelections(matches, primaryIndex);
  };

  var keyMap = CodeMirror.keyMap;
  keyMap.macSublime = {
    "Cmd-Left": "goLineStartSmart",
    "Shift-Tab": "indentLess",
    "Shift-Ctrl-K": "deleteLine",
    "Alt-Q": "wrapLines",
    "Ctrl-Left": "goSubwordLeft",
    "Ctrl-Right": "goSubwordRight",
    "Ctrl-Alt-Up": "scrollLineUp",
    "Ctrl-Alt-Down": "scrollLineDown",
    "Cmd-L": "selectLine",
    "Shift-Cmd-L": "splitSelectionByLine",
    "Esc": "singleSelectionTop",
    "Cmd-Enter": "insertLineAfter",
    "Shift-Cmd-Enter": "insertLineBefore",
    "Cmd-D": "selectNextOccurrence",
    "Shift-Cmd-Space": "selectScope",
    "Shift-Cmd-M": "selectBetweenBrackets",
    "Cmd-M": "goToBracket",
    "Cmd-Ctrl-Up": "swapLineUp",
    "Cmd-Ctrl-Down": "swapLineDown",
    "Cmd-/": "toggleCommentIndented",
    "Cmd-J": "joinLines",
    "Shift-Cmd-D": "duplicateLine",
    "F5": "sortLines",
    "Cmd-F5": "sortLinesInsensitive",
    "F2": "nextBookmark",
    "Shift-F2": "prevBookmark",
    "Cmd-F2": "toggleBookmark",
    "Shift-Cmd-F2": "clearBookmarks",
    "Alt-F2": "selectBookmarks",
    "Backspace": "smartBackspace",
    "Cmd-K Cmd-K": "delLineRight",
    "Cmd-K Cmd-U": "upcaseAtCursor",
    "Cmd-K Cmd-L": "downcaseAtCursor",
    "Cmd-K Cmd-Space": "setSublimeMark",
    "Cmd-K Cmd-A": "selectToSublimeMark",
    "Cmd-K Cmd-W": "deleteToSublimeMark",
    "Cmd-K Cmd-X": "swapWithSublimeMark",
    "Cmd-K Cmd-Y": "sublimeYank",
    "Cmd-K Cmd-C": "showInCenter",
    "Cmd-K Cmd-G": "clearBookmarks",
    "Cmd-K Cmd-Backspace": "delLineLeft",
    "Cmd-K Cmd-0": "unfoldAll",
    "Cmd-K Cmd-J": "unfoldAll",
    "Ctrl-Shift-Up": "addCursorToPrevLine",
    "Ctrl-Shift-Down": "addCursorToNextLine",
    "Cmd-F3": "findUnder",
    "Shift-Cmd-F3": "findUnderPrevious",
    "Alt-F3": "findAllUnder",
    "Shift-Cmd-[": "fold",
    "Shift-Cmd-]": "unfold",
    "Cmd-I": "findIncremental",
    "Shift-Cmd-I": "findIncrementalReverse",
    "Cmd-H": "replace",
    "F3": "findNext",
    "Shift-F3": "findPrev",
    "fallthrough": "macDefault"
  };
  CodeMirror.normalizeKeyMap(keyMap.macSublime);

  keyMap.pcSublime = {
    "Shift-Tab": "indentLess",
    "Shift-Ctrl-K": "deleteLine",
    "Alt-Q": "wrapLines",
    "Ctrl-T": "transposeChars",
    "Alt-Left": "goSubwordLeft",
    "Alt-Right": "goSubwordRight",
    "Ctrl-Up": "scrollLineUp",
    "Ctrl-Down": "scrollLineDown",
    "Ctrl-L": "selectLine",
    "Shift-Ctrl-L": "splitSelectionByLine",
    "Esc": "singleSelectionTop",
    "Ctrl-Enter": "insertLineAfter",
    "Shift-Ctrl-Enter": "insertLineBefore",
    "Ctrl-D": "selectNextOccurrence",
    "Shift-Ctrl-Space": "selectScope",
    "Shift-Ctrl-M": "selectBetweenBrackets",
    "Ctrl-M": "goToBracket",
    "Shift-Ctrl-Up": "swapLineUp",
    "Shift-Ctrl-Down": "swapLineDown",
    "Ctrl-/": "toggleCommentIndented",
    "Ctrl-J": "joinLines",
    "Shift-Ctrl-D": "duplicateLine",
    "F9": "sortLines",
    "Ctrl-F9": "sortLinesInsensitive",
    "F2": "nextBookmark",
    "Shift-F2": "prevBookmark",
    "Ctrl-F2": "toggleBookmark",
    "Shift-Ctrl-F2": "clearBookmarks",
    "Alt-F2": "selectBookmarks",
    "Backspace": "smartBackspace",
    "Ctrl-K Ctrl-K": "delLineRight",
    "Ctrl-K Ctrl-U": "upcaseAtCursor",
    "Ctrl-K Ctrl-L": "downcaseAtCursor",
    "Ctrl-K Ctrl-Space": "setSublimeMark",
    "Ctrl-K Ctrl-A": "selectToSublimeMark",
    "Ctrl-K Ctrl-W": "deleteToSublimeMark",
    "Ctrl-K Ctrl-X": "swapWithSublimeMark",
    "Ctrl-K Ctrl-Y": "sublimeYank",
    "Ctrl-K Ctrl-C": "showInCenter",
    "Ctrl-K Ctrl-G": "clearBookmarks",
    "Ctrl-K Ctrl-Backspace": "delLineLeft",
    "Ctrl-K Ctrl-0": "unfoldAll",
    "Ctrl-K Ctrl-J": "unfoldAll",
    "Ctrl-Alt-Up": "addCursorToPrevLine",
    "Ctrl-Alt-Down": "addCursorToNextLine",
    "Ctrl-F3": "findUnder",
    "Shift-Ctrl-F3": "findUnderPrevious",
    "Alt-F3": "findAllUnder",
    "Shift-Ctrl-[": "fold",
    "Shift-Ctrl-]": "unfold",
    "Ctrl-I": "findIncremental",
    "Shift-Ctrl-I": "findIncrementalReverse",
    "Ctrl-H": "replace",
    "F3": "findNext",
    "Shift-F3": "findPrev",
    "fallthrough": "pcDefault"
  };
  CodeMirror.normalizeKeyMap(keyMap.pcSublime);

  var mac = keyMap.default == keyMap.macDefault;
  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;
});

/***/ }),

/***/ "XfO6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__("ZKdc");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function (compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker: function () {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = __webpack_require__("p7rG");

/***/ }),

/***/ "Xos8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__("FFZn");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),

/***/ "Xu4i":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-observable
__webpack_require__("KGgk")('observable');

/***/ }),

/***/ "YD0x":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("vSO4");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("uj5A") });

/***/ }),

/***/ "YXwe":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.search` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.search
__webpack_require__("KGgk")('search');

/***/ }),

/***/ "YYE9":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("JE34")('keys');
var uid = __webpack_require__("6n5Z");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "Yj0v":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}

/***/ }),

/***/ "Z8Qa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = __webpack_require__("+KPf");
var isObject = __webpack_require__("dmyY");
var toObject = __webpack_require__("yocI");
var toLength = __webpack_require__("qub/");
var createProperty = __webpack_require__("Kwbf");
var arraySpeciesCreate = __webpack_require__("ZZ7S");
var IS_CONCAT_SPREADABLE = __webpack_require__("95jh")('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

var IS_CONCAT_SPREADABLE_SUPPORT = !__webpack_require__("b3E9")(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = __webpack_require__("8h5B")('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
__webpack_require__("c+Wn")({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) {
    // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});

/***/ }),

/***/ "ZHvQ":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("ShN9");
var TAG = __webpack_require__("Ug9I")('toStringTag');
// ES3 wrong here
var ARG = cof(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) {/* empty */}
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  // builtinTag case
  : ARG ? cof(O)
  // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "ZKdc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */

function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data': [],
        'end': [],
        'error': []
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push: function (chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end: function () {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error: function (e) {
        if (this.isFinished) {
            return false;
        }

        if (this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if (this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on: function (name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp: function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit: function (name, arg) {
        if (this._listeners[name]) {
            for (var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe: function (next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious: function (previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous = previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause: function () {
        if (this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if (this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume: function () {
        if (!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if (this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if (this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush: function () {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk: function (chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo: function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo: function () {
        for (var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function () {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString: function () {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

/***/ }),

/***/ "ZKjc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__("Aq8W");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__("yeEC");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),

/***/ "ZQr7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__("dACh");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("jx4H");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("VOrx");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("ZKjc");

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__("eW0v");

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var ThemeProvider = function (_Component) {
  (0, _inherits3.default)(ThemeProvider, _Component);

  function ThemeProvider() {
    (0, _classCallCheck3.default)(this, ThemeProvider);
    return (0, _possibleConstructorReturn3.default)(this, (ThemeProvider.__proto__ || Object.getPrototypeOf(ThemeProvider)).apply(this, arguments));
  }

  (0, _createClass3.default)(ThemeProvider, [{
    key: 'getChildContext',
    value: function getChildContext() {
      var theme = this.props.theme;

      return {
        // createStyles: createStyles
        theme: theme
      };
    }
  }, {
    key: 'render',
    value: function render() {
      return this.props.children;
    }
  }]);
  return ThemeProvider;
}(_react.Component);

ThemeProvider.childContextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
};

exports.default = ThemeProvider;

/***/ }),

/***/ "ZShz":
/***/ (function(module, exports, __webpack_require__) {

!function (n, t) {
   true ? t(exports, __webpack_require__("KM04")) : "function" == typeof define && define.amd ? define(["exports", "preact"], t) : t((n = n || self).preactContext = {}, n.preact);
}(this, function (n, t) {
  "use strict";
  var i = { register: function (n) {
      console.warn("Consumer used without a Provider");
    }, unregister: function (n) {}, val: function (n) {} };function r(n) {
    var t = n.children;return { child: 1 === t.length ? t[0] : null, children: t };
  }var e,
      u = window && window.__extends || (e = function (n, t) {
    return (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, t) {
      n.__proto__ = t;
    } || function (n, t) {
      for (var i in t) t.hasOwnProperty(i) && (n[i] = t[i]);
    })(n, t);
  }, function (n, t) {
    function i() {
      this.constructor = n;
    }e(n, t), n.prototype = null === t ? Object.create(t) : (i.prototype = t.prototype, new i());
  });function o(n) {
    return r(n).child || "render" in n && n.render;
  }var c = 1073741823,
      f = function () {
    return c;
  },
      s = 0;function a(n, e) {
    var a = "_preactContextProvider-" + s++;return { Provider: function (n) {
        function i(t) {
          var i = n.call(this, t) || this;return i.t = function (n, t) {
            var i = [],
                r = n,
                e = function (n) {
              return 0 | t(r, n);
            };return { register: function (n) {
                i.push(n), n(r, e(r));
              }, unregister: function (n) {
                i = i.filter(function (t) {
                  return t !== n;
                });
              }, val: function (n) {
                if (void 0 === n || n == r) return r;var t = e(n);return r = n, i.forEach(function (i) {
                  return i(n, t);
                }), r;
              } };
          }(t.value, e || f), i;
        }return u(i, n), i.prototype.getChildContext = function () {
          var n;return (n = {})[a] = this.t, n;
        }, i.prototype.componentDidUpdate = function () {
          this.t.val(this.props.value);
        }, i.prototype.render = function () {
          var n = r(this.props),
              i = n.child,
              e = n.children;return i || t.h("span", null, e);
        }, i;
      }(t.Component), Consumer: function (t) {
        function r(i, r) {
          var e = t.call(this, i, r) || this;return e.i = function (n, t) {
            var i = e.props.unstable_observedBits,
                r = void 0 === i || null === i ? c : i;0 != ((r |= 0) & t) && e.setState({ value: n });
          }, e.state = { value: e.u().val() || n }, e;
        }return u(r, t), r.prototype.componentDidMount = function () {
          this.u().register(this.i);
        }, r.prototype.shouldComponentUpdate = function (n, t) {
          return this.state.value !== t.value || o(this.props) !== o(n);
        }, r.prototype.componentWillUnmount = function () {
          this.u().unregister(this.i);
        }, r.prototype.componentDidUpdate = function (n, t, r) {
          var e = r[a];e !== this.context[a] && ((e || i).unregister(this.i), this.componentDidMount());
        }, r.prototype.render = function () {
          var n = "render" in this.props && this.props.render,
              t = o(this.props);if (n && n !== t && console.warn("Both children and a render function are defined. Children will be used"), "function" == typeof t) return t(this.state.value);console.warn("Consumer is expecting a function as one and only child but didn't find any");
        }, r.prototype.u = function () {
          return this.context[a] || i;
        }, r;
      }(t.Component) };
  }var d = a;n.default = a, n.createContext = d, Object.defineProperty(n, "__esModule", { value: !0 });
});

/***/ }),

/***/ "ZUhP":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("b3E9");
var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;

/***/ }),

/***/ "ZUoI":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

__webpack_require__("wGjj");
var firebase = _interopDefault(__webpack_require__("dP58"));

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = firebase;
//# sourceMappingURL=index.cjs.js.map

/***/ }),

/***/ "ZZ7S":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("dmyY");
var isArray = __webpack_require__("+KPf");
var SPECIES = __webpack_require__("95jh")('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

/***/ }),

/***/ "ZaKr":
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__("BxvP");
var anObject = __webpack_require__("zotD");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__("3zRh")(Function.call, __webpack_require__("sxPs").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "Zwq5":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("MpYs");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "ZxII":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("Ug9I");

/***/ }),

/***/ "a6mx":
/***/ (function(module, exports, __webpack_require__) {

var DOMIterables = __webpack_require__("d9Yk");
var ArrayIteratorMethods = __webpack_require__("DoY4");
var global = __webpack_require__("wJQ+");
var hide = __webpack_require__("2O9B");
var wellKnownSymbol = __webpack_require__("95jh");
var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      hide(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) hide(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        hide(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}

/***/ }),

/***/ "aIIw":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("QYzI");

/***/ }),

/***/ "af0K":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("dhak");
var ITERATOR = __webpack_require__("Ug9I")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "akPY":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("Gfzd");
var createDesc = __webpack_require__("0WCH");
module.exports = __webpack_require__("6MLN") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "ayXv":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("ShN9");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "b1tA":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__("vSO4");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__("ZaKr").set });

/***/ }),

/***/ "b3E9":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

/***/ }),

/***/ "b7Q2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__("TNJq");
var descriptor = __webpack_require__("0WCH");
var setToStringTag = __webpack_require__("11Ut");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("akPY")(IteratorPrototype, __webpack_require__("Ug9I")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "bU21":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.registerGlobalHelper("fold", "comment", function (mode) {
    return mode.blockCommentStart && mode.blockCommentEnd;
  }, function (cm, start) {
    var mode = cm.getModeAt(start),
        startToken = mode.blockCommentStart,
        endToken = mode.blockCommentEnd;
    if (!startToken || !endToken) return;
    var line = start.line,
        lineText = cm.getLine(line);

    var startCh;
    for (var at = start.ch, pass = 0;;) {
      var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);
      if (found == -1) {
        if (pass == 1) return;
        pass = 1;
        at = lineText.length;
        continue;
      }
      if (pass == 1 && found < start.ch) return;
      if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) && (found == 0 || lineText.slice(found - endToken.length, found) == endToken || !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {
        startCh = found + startToken.length;
        break;
      }
      at = found - 1;
    }

    var depth = 1,
        lastLine = cm.lastLine(),
        end,
        endCh;
    outer: for (var i = line; i <= lastLine; ++i) {
      var text = cm.getLine(i),
          pos = i == line ? startCh : 0;
      for (;;) {
        var nextOpen = text.indexOf(startToken, pos),
            nextClose = text.indexOf(endToken, pos);
        if (nextOpen < 0) nextOpen = text.length;
        if (nextClose < 0) nextClose = text.length;
        pos = Math.min(nextOpen, nextClose);
        if (pos == text.length) break;
        if (pos == nextOpen) ++depth;else if (! --depth) {
          end = i;endCh = pos;break outer;
        }
        ++pos;
      }
    }
    if (end == null || line == end && endCh == startCh) return;
    return { from: CodeMirror.Pos(line, startCh),
      to: CodeMirror.Pos(end, endCh) };
  });
});

/***/ }),

/***/ "bY9t":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createStyles = __webpack_require__("uqKE");

var _createStyles2 = _interopRequireDefault(_createStyles);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * A view for object property names.
 *
 * If the property name is enumerable (in Object.keys(object)),
 * the property name will be rendered normally.
 *
 * If the property name is not enumerable (`Object.prototype.propertyIsEnumerable()`),
 * the property name will be dimmed to show the difference.
 */
var ObjectName = function ObjectName(_ref, _ref2) {
  var name = _ref.name,
      dimmed = _ref.dimmed,
      styles = _ref.styles;
  var theme = _ref2.theme;

  var themeStyles = (0, _createStyles2.default)('ObjectName', theme);
  var appliedStyles = (0, _extends3.default)({}, themeStyles.base, dimmed ? themeStyles['dimmed'] : {}, styles);

  return _react2.default.createElement('span', { style: appliedStyles }, name);
};

ObjectName.propTypes = {
  /** Property name */
  name: _propTypes2.default.string,
  /** Should property name be dimmed */
  dimmed: _propTypes2.default.bool
};

ObjectName.defaultProps = {
  dimmed: false
};

ObjectName.contextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
};

exports.default = ObjectName;

/***/ }),

/***/ "bdtv":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = '' /*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2 /*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

/***/ }),

/***/ "bien":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("dmyY");
var classof = __webpack_require__("rQTS");
var MATCH = __webpack_require__("95jh")('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

/***/ }),

/***/ "br85":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("jNRJ");
var requireObjectCoercible = __webpack_require__("Vhc8");
// CONVERT_TO_STRING: true  -> String#at
// CONVERT_TO_STRING: false -> String#codePointAt
module.exports = function (that, pos, CONVERT_TO_STRING) {
  var S = String(requireObjectCoercible(that));
  var position = toInteger(pos);
  var size = S.length;
  var first, second;
  if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
  first = S.charCodeAt(position);
  return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
};

/***/ }),

/***/ "c+Wn":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("wJQ+");
var getOwnPropertyDescriptor = __webpack_require__("1g0E").f;
var hide = __webpack_require__("2O9B");
var redefine = __webpack_require__("iKbl");
var setGlobal = __webpack_require__("G6zQ");
var copyConstructorProperties = __webpack_require__("CAJ1");
var isForced = __webpack_require__("ZUhP");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || targetProperty && targetProperty.sham) {
      hide(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

/***/ }),

/***/ "c2iN":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = __webpack_require__("zCAL");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _classCallCheck2 = __webpack_require__("dACh");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("jx4H");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("VOrx");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("ZKjc");

var _inherits3 = _interopRequireDefault(_inherits2);

var _regenerator = __webpack_require__("aIIw");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _slicedToArray2 = __webpack_require__("m8OI");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _TreeView = __webpack_require__("iLWV");

var _TreeView2 = _interopRequireDefault(_TreeView);

var _ObjectRootLabel = __webpack_require__("TBQ4");

var _ObjectRootLabel2 = _interopRequireDefault(_ObjectRootLabel);

var _ObjectLabel = __webpack_require__("GqQl");

var _ObjectLabel2 = _interopRequireDefault(_ObjectLabel);

var _ThemeProvider = __webpack_require__("ZQr7");

var _ThemeProvider2 = _interopRequireDefault(_ThemeProvider);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var createIterator = function createIterator(showNonenumerable, sortObjectKeys) {
  var objectIterator = /*#__PURE__*/_regenerator2.default.mark(function objectIterator(data) {
    var shouldIterate, dataIsArray, i, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, _entry, k, v, keys, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, propertyName, propertyValue, _propertyValue;

    return _regenerator2.default.wrap(function objectIterator$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            shouldIterate = (typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) === 'object' && data !== null || typeof data === 'function';

            if (shouldIterate) {
              _context.next = 3;
              break;
            }

            return _context.abrupt('return');

          case 3:
            dataIsArray = Array.isArray(data);

            // iterable objects (except arrays)

            if (!(!dataIsArray && data[Symbol.iterator])) {
              _context.next = 41;
              break;
            }

            i = 0;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 9;
            _iterator = data[Symbol.iterator]();

          case 11:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context.next = 25;
              break;
            }

            entry = _step.value;

            if (!(Array.isArray(entry) && entry.length === 2)) {
              _context.next = 19;
              break;
            }

            _entry = (0, _slicedToArray3.default)(entry, 2), k = _entry[0], v = _entry[1];
            _context.next = 17;
            return {
              name: k,
              data: v
            };

          case 17:
            _context.next = 21;
            break;

          case 19:
            _context.next = 21;
            return {
              name: i.toString(),
              data: entry
            };

          case 21:
            i++;

          case 22:
            _iteratorNormalCompletion = true;
            _context.next = 11;
            break;

          case 25:
            _context.next = 31;
            break;

          case 27:
            _context.prev = 27;
            _context.t0 = _context['catch'](9);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 31:
            _context.prev = 31;
            _context.prev = 32;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 34:
            _context.prev = 34;

            if (!_didIteratorError) {
              _context.next = 37;
              break;
            }

            throw _iteratorError;

          case 37:
            return _context.finish(34);

          case 38:
            return _context.finish(31);

          case 39:
            _context.next = 82;
            break;

          case 41:
            keys = Object.getOwnPropertyNames(data);

            if (sortObjectKeys === true && !dataIsArray) {
              // Array keys should not be sorted in alphabetical order
              keys.sort();
            } else if (typeof sortObjectKeys === 'function') {
              keys.sort(sortObjectKeys);
            }

            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            _context.prev = 46;
            _iterator2 = keys[Symbol.iterator]();

          case 48:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              _context.next = 65;
              break;
            }

            propertyName = _step2.value;

            if (!data.propertyIsEnumerable(propertyName)) {
              _context.next = 56;
              break;
            }

            propertyValue = data[propertyName];
            _context.next = 54;
            return {
              name: propertyName || '""',
              data: propertyValue
            };

          case 54:
            _context.next = 62;
            break;

          case 56:
            if (!showNonenumerable) {
              _context.next = 62;
              break;
            }

            // To work around the error (happens some time when propertyName === 'caller' || propertyName === 'arguments')
            // 'caller' and 'arguments' are restricted function properties and cannot be accessed in this context
            // http://stackoverflow.com/questions/31921189/caller-and-arguments-are-restricted-function-properties-and-cannot-be-access
            _propertyValue = void 0;

            try {
              _propertyValue = data[propertyName];
            } catch (e) {
              // console.warn(e)
            }

            if (!(_propertyValue !== undefined)) {
              _context.next = 62;
              break;
            }

            _context.next = 62;
            return {
              name: propertyName,
              data: _propertyValue,
              isNonenumerable: true
            };

          case 62:
            _iteratorNormalCompletion2 = true;
            _context.next = 48;
            break;

          case 65:
            _context.next = 71;
            break;

          case 67:
            _context.prev = 67;
            _context.t1 = _context['catch'](46);
            _didIteratorError2 = true;
            _iteratorError2 = _context.t1;

          case 71:
            _context.prev = 71;
            _context.prev = 72;

            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }

          case 74:
            _context.prev = 74;

            if (!_didIteratorError2) {
              _context.next = 77;
              break;
            }

            throw _iteratorError2;

          case 77:
            return _context.finish(74);

          case 78:
            return _context.finish(71);

          case 79:
            if (!(showNonenumerable && data !== Object.prototype /* already added */)) {
              _context.next = 82;
              break;
            }

            _context.next = 82;
            return {
              name: '__proto__',
              data: Object.getPrototypeOf(data),
              isNonenumerable: true
            };

          case 82:
          case 'end':
            return _context.stop();
        }
      }
    }, objectIterator, this, [[9, 27, 31, 39], [32,, 34, 38], [46, 67, 71, 79], [72,, 74, 78]]);
  });

  return objectIterator;
};

var defaultNodeRenderer = function defaultNodeRenderer(_ref) {
  var depth = _ref.depth,
      name = _ref.name,
      data = _ref.data,
      isNonenumerable = _ref.isNonenumerable;
  return depth === 0 ? _react2.default.createElement(_ObjectRootLabel2.default, { name: name, data: data }) : _react2.default.createElement(_ObjectLabel2.default, { name: name, data: data, isNonenumerable: isNonenumerable });
};

/**
 * Tree-view for objects
 */

var ObjectInspector = function (_Component) {
  (0, _inherits3.default)(ObjectInspector, _Component);

  function ObjectInspector() {
    (0, _classCallCheck3.default)(this, ObjectInspector);
    return (0, _possibleConstructorReturn3.default)(this, (ObjectInspector.__proto__ || Object.getPrototypeOf(ObjectInspector)).apply(this, arguments));
  }

  (0, _createClass3.default)(ObjectInspector, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          showNonenumerable = _props.showNonenumerable,
          sortObjectKeys = _props.sortObjectKeys,
          nodeRenderer = _props.nodeRenderer,
          rest = (0, _objectWithoutProperties3.default)(_props, ['showNonenumerable', 'sortObjectKeys', 'nodeRenderer']);

      var dataIterator = createIterator(showNonenumerable, sortObjectKeys);

      var renderer = nodeRenderer ? nodeRenderer : defaultNodeRenderer;

      return _react2.default.createElement(_ThemeProvider2.default, { theme: this.props.theme }, _react2.default.createElement(_TreeView2.default, (0, _extends3.default)({ nodeRenderer: renderer, dataIterator: dataIterator }, rest)));
    }
  }]);
  return ObjectInspector;
}(_react.Component);

ObjectInspector.defaultProps = {
  showNonenumerable: false,

  theme: 'chromeLight'
};
ObjectInspector.propTypes = {
  /** An integer specifying to which level the tree should be initially expanded. */
  expandLevel: _propTypes2.default.number,
  /** An array containing all the paths that should be expanded when the component is initialized, or a string of just one path */
  expandPaths: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),

  name: _propTypes2.default.string,
  /** Not required prop because we also allow undefined value */
  data: _propTypes2.default.any,

  /** A known theme or theme object */
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),

  /** Show non-enumerable properties */
  showNonenumerable: _propTypes2.default.bool,
  /** Sort object keys with optional compare function. */
  sortObjectKeys: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),

  /** Provide a custom nodeRenderer */
  nodeRenderer: _propTypes2.default.func
};
exports.default = ObjectInspector;

/***/ }),

/***/ "c2zY":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("i1Q6");
var core = __webpack_require__("zKeE");
var LIBRARY = __webpack_require__("1kq3");
var wksExt = __webpack_require__("ZxII");
var defineProperty = __webpack_require__("Gfzd").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

/***/ }),

/***/ "c5OX":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode: typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function (data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
            return Buffer.from(data, encoding);
        } else {
            if (typeof data === "number") {
                // Safeguard for old Node.js versions. On newer versions,
                // Buffer.from(number) / Buffer(number, encoding) already throw.
                throw new Error("The \"data\" argument must not be a number");
            }
            return new Buffer(data, encoding);
        }
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function (size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            var buf = new Buffer(size);
            buf.fill(0);
            return buf;
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer: function (b) {
        return Buffer.isBuffer(b);
    },

    isStream: function (obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
};

/***/ }),

/***/ "c6mp":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("c2zY")('asyncIterator');

/***/ }),

/***/ "cOHw":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("vSO4");
var core = __webpack_require__("zKeE");
var fails = __webpack_require__("wLcK");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "cjsw":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("yOG5");
var $Object = __webpack_require__("zKeE").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

/***/ }),

/***/ "cjyi":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var internalObjectKeys = __webpack_require__("p7FV");
var enumBugKeys = __webpack_require__("pup0");

module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};

/***/ }),

/***/ "cpTA":
/***/ (function(module, exports) {

(function (self) {
  'use strict';

  if (self.fetch) {
    return;
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && function () {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    }(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

    var isDataView = function (obj) {
      return obj && DataView.prototype.isPrototypeOf(obj);
    };

    var isArrayBufferView = ArrayBuffer.isView || function (obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name');
    }
    return name.toLowerCase();
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value;
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function () {
        var value = items.shift();
        return { done: value === undefined, value: value };
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function () {
        return iterator;
      };
    }

    return iterator;
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function (value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function (header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function (name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function (name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ',' + value : value;
  };

  Headers.prototype['delete'] = function (name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function (name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
  };

  Headers.prototype.has = function (name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };

  Headers.prototype.set = function (name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function (callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  };

  Headers.prototype.values = function () {
    var items = [];
    this.forEach(function (value) {
      items.push(value);
    });
    return iteratorFor(items);
  };

  Headers.prototype.entries = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'));
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function (resolve, reject) {
      reader.onload = function () {
        resolve(reader.result);
      };
      reader.onerror = function () {
        reject(reader.error);
      };
    });
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise;
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('');
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0);
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer;
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function (body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type');
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob');
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };

      this.arrayBuffer = function () {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
        } else {
          return this.blob().then(readBlobAsArrayBuffer);
        }
      };
    }

    this.text = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text');
      } else {
        return Promise.resolve(this._bodyText);
      }
    };

    if (support.formData) {
      this.formData = function () {
        return this.text().then(decode);
      };
    }

    this.json = function () {
      return this.text().then(JSON.parse);
    };

    return this;
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read');
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests');
    }
    this._initBody(body);
  }

  Request.prototype.clone = function () {
    return new Request(this, { body: this._bodyInit });
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function (bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers;
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function () {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    });
  };

  Response.error = function () {
    var response = new Response(null, { status: 0, statusText: '' });
    response.type = 'error';
    return response;
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function (url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code');
    }

    return new Response(null, { status: status, headers: { location: url } });
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function (input, init) {
    return new Promise(function (resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function () {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    });
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : this);

/***/ }),

/***/ "cvyR":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc = crc ^ -1;

    for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc = crc ^ -1;

    for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
    } else {
        return crc32str(crc | 0, input, input.length, 0);
    }
};

/***/ }),

/***/ "d5jv":
/***/ (function(module, exports, __webpack_require__) {

var assign = __webpack_require__("AP0c");

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
__webpack_require__("c+Wn")({ target: 'Object', stat: true, forced: Object.assign !== assign }, { assign: assign });

/***/ }),

/***/ "d9Yk":
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

/***/ }),

/***/ "dACh":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "dFUs":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var readerFor = __webpack_require__("9Uuy");
var utils = __webpack_require__("dvMn");
var CompressedObject = __webpack_require__("PO9O");
var crc32fn = __webpack_require__("cvyR");
var utf8 = __webpack_require__("Sm7/");
var compressions = __webpack_require__("XfO6");
var support = __webpack_require__("untT");

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function (compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function () {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function () {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function (reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) {
            // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function (reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if (madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function (reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function (reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function () {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function () {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function () {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

/***/ }),

/***/ "dGHV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var theme = {
  BASE_FONT_FAMILY: 'Menlo, monospace',
  BASE_FONT_SIZE: '11px',
  BASE_LINE_HEIGHT: '14px',

  BASE_BACKGROUND_COLOR: 'rgb(36, 36, 36)',
  BASE_COLOR: 'rgb(213, 213, 213)',

  OBJECT_NAME_COLOR: 'rgb(227, 110, 236)',
  OBJECT_VALUE_NULL_COLOR: 'rgb(127, 127, 127)',
  OBJECT_VALUE_UNDEFINED_COLOR: 'rgb(127, 127, 127)',
  OBJECT_VALUE_REGEXP_COLOR: 'rgb(233, 63, 59)',
  OBJECT_VALUE_STRING_COLOR: 'rgb(233, 63, 59)',
  OBJECT_VALUE_SYMBOL_COLOR: 'rgb(233, 63, 59)',
  OBJECT_VALUE_NUMBER_COLOR: 'hsl(252, 100%, 75%)',
  OBJECT_VALUE_BOOLEAN_COLOR: 'hsl(252, 100%, 75%)',
  OBJECT_VALUE_FUNCTION_KEYWORD_COLOR: 'rgb(242, 85, 217)',

  HTML_TAG_COLOR: 'rgb(93, 176, 215)',
  HTML_TAGNAME_COLOR: 'rgb(93, 176, 215)',
  HTML_TAGNAME_TEXT_TRANSFORM: 'lowercase',
  HTML_ATTRIBUTE_NAME_COLOR: 'rgb(155, 187, 220)',
  HTML_ATTRIBUTE_VALUE_COLOR: 'rgb(242, 151, 102)',
  HTML_COMMENT_COLOR: 'rgb(137, 137, 137)',
  HTML_DOCTYPE_COLOR: 'rgb(192, 192, 192)',

  ARROW_COLOR: 'rgb(145, 145, 145)',
  ARROW_MARGIN_RIGHT: 3,
  ARROW_FONT_SIZE: 12,

  TREENODE_FONT_FAMILY: 'Menlo, monospace',
  TREENODE_FONT_SIZE: '11px',
  TREENODE_LINE_HEIGHT: '14px',
  TREENODE_PADDING_LEFT: 12,

  TABLE_BORDER_COLOR: 'rgb(85, 85, 85)',
  TABLE_TH_BACKGROUND_COLOR: 'rgb(44, 44, 44)',
  TABLE_TH_HOVER_COLOR: 'rgb(48, 48, 48)',
  TABLE_SORT_ICON_COLOR: 'black', //'rgb(48, 57, 66)',
  TABLE_DATA_BACKGROUND_IMAGE: 'linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(51, 139, 255, 0.0980392) 50%, rgba(51, 139, 255, 0.0980392))',
  TABLE_DATA_BACKGROUND_SIZE: '128px 32px'
};

exports.default = theme;

/***/ }),

/***/ "dLYn":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }return it;
};

/***/ }),

/***/ "dP58":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_1 = __webpack_require__("vCxL");
var util = __webpack_require__("58xA");

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;
var ERRORS = (_a = {}, _a["no-app" /* NO_APP */] = "No Firebase App '{$name}' has been created - " + 'call Firebase App.initializeApp()', _a["bad-app-name" /* BAD_APP_NAME */] = "Illegal App name: '{$name}", _a["duplicate-app" /* DUPLICATE_APP */] = "Firebase App named '{$name}' already exists", _a["app-deleted" /* APP_DELETED */] = "Firebase App named '{$name}' already deleted", _a["duplicate-service" /* DUPLICATE_SERVICE */] = "Firebase service named '{$name}' already registered", _a["invalid-app-argument" /* INVALID_APP_ARGUMENT */] = 'firebase.{$name}() takes either no argument or a ' + 'Firebase App instance.', _a);
var appErrors = new util.ErrorFactory('app', 'Firebase', ERRORS);
function error(code, args) {
    throw appErrors.create(code, args);
}

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_ENTRY_NAME = '[DEFAULT]';

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// An array to capture listeners before the true auth functions
// exist
var tokenListeners = [];
/**
 * Global context object for a collection of services using
 * a shared authentication state.
 */
var FirebaseAppImpl = /** @class */function () {
    function FirebaseAppImpl(options, config, firebase_) {
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.services_ = {};
        this.name_ = config.name;
        this.automaticDataCollectionEnabled_ = config.automaticDataCollectionEnabled || false;
        this.options_ = util.deepCopy(options);
        this.INTERNAL = {
            getUid: function () {
                return null;
            },
            getToken: function () {
                return Promise.resolve(null);
            },
            addAuthTokenListener: function (callback) {
                tokenListeners.push(callback);
                // Make sure callback is called, asynchronously, in the absence of the auth module
                setTimeout(function () {
                    return callback(null);
                }, 0);
            },
            removeAuthTokenListener: function (callback) {
                tokenListeners = tokenListeners.filter(function (listener) {
                    return listener !== callback;
                });
            }
        };
    }
    Object.defineProperty(FirebaseAppImpl.prototype, "automaticDataCollectionEnabled", {
        get: function () {
            this.checkDestroyed_();
            return this.automaticDataCollectionEnabled_;
        },
        set: function (val) {
            this.checkDestroyed_();
            this.automaticDataCollectionEnabled_ = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseAppImpl.prototype, "name", {
        get: function () {
            this.checkDestroyed_();
            return this.name_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseAppImpl.prototype, "options", {
        get: function () {
            this.checkDestroyed_();
            return this.options_;
        },
        enumerable: true,
        configurable: true
    });
    FirebaseAppImpl.prototype.delete = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.checkDestroyed_();
            resolve();
        }).then(function () {
            _this.firebase_.INTERNAL.removeApp(_this.name_);
            var services = [];
            for (var _i = 0, _a = Object.keys(_this.services_); _i < _a.length; _i++) {
                var serviceKey = _a[_i];
                for (var _b = 0, _c = Object.keys(_this.services_[serviceKey]); _b < _c.length; _b++) {
                    var instanceKey = _c[_b];
                    services.push(_this.services_[serviceKey][instanceKey]);
                }
            }
            return Promise.all(services.map(function (service) {
                return service.INTERNAL.delete();
            }));
        }).then(function () {
            _this.isDeleted_ = true;
            _this.services_ = {};
        });
    };
    /**
     * Return a service instance associated with this app (creating it
     * on demand), identified by the passed instanceIdentifier.
     *
     * NOTE: Currently storage is the only one that is leveraging this
     * functionality. They invoke it by calling:
     *
     * ```javascript
     * firebase.app().storage('STORAGE BUCKET ID')
     * ```
     *
     * The service name is passed to this already
     * @internal
     */
    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {
        if (instanceIdentifier === void 0) {
            instanceIdentifier = DEFAULT_ENTRY_NAME;
        }
        this.checkDestroyed_();
        if (!this.services_[name]) {
            this.services_[name] = {};
        }
        if (!this.services_[name][instanceIdentifier]) {
            /**
             * If a custom instance has been defined (i.e. not '[DEFAULT]')
             * then we will pass that instance on, otherwise we pass `null`
             */
            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;
            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);
            this.services_[name][instanceIdentifier] = service;
        }
        return this.services_[name][instanceIdentifier];
    };
    /**
     * Callback function used to extend an App instance at the time
     * of service instance creation.
     */
    FirebaseAppImpl.prototype.extendApp = function (props) {
        var _this = this;
        // Copy the object onto the FirebaseAppImpl prototype
        util.deepExtend(this, props);
        /**
         * If the app has overwritten the addAuthTokenListener stub, forward
         * the active token listeners on to the true fxn.
         *
         * TODO: This function is required due to our current module
         * structure. Once we are able to rely strictly upon a single module
         * implementation, this code should be refactored and Auth should
         * provide these stubs and the upgrade logic
         */
        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {
            tokenListeners.forEach(function (listener) {
                _this.INTERNAL.addAuthTokenListener(listener);
            });
            tokenListeners = [];
        }
    };
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    FirebaseAppImpl.prototype.checkDestroyed_ = function () {
        if (this.isDeleted_) {
            error("app-deleted" /* APP_DELETED */, { name: this.name_ });
        }
    };
    return FirebaseAppImpl;
}();
// Prevent dead-code elimination of these methods w/o invalid property
// copying.
FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log('dc');

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
/**
 * Because auth can't share code with other components, we attach the utility functions
 * in an internal namespace to share code.
 * This function return a firebase namespace object without
 * any utility functions, so it can be shared between the regular firebaseNamespace and
 * the lite version.
 */
function createFirebaseNamespaceCore(firebaseAppImpl) {
    var apps = {};
    var factories = {};
    var appHooks = {};
    // A namespace is a plain JavaScript Object.
    var namespace = {
        // Hack to prevent Babel from modifying the object returned
        // as the firebase namespace.
        // @ts-ignore
        __esModule: true,
        initializeApp: initializeApp,
        app: app,
        apps: null,
        Promise: Promise,
        SDK_VERSION: '5.11.0',
        INTERNAL: {
            registerService: registerService,
            removeApp: removeApp,
            factories: factories,
            useAsService: useAsService
        }
    };
    // Inject a circular default export to allow Babel users who were previously
    // using:
    //
    //   import firebase from 'firebase';
    //   which becomes: var firebase = require('firebase').default;
    //
    // instead of
    //
    //   import * as firebase from 'firebase';
    //   which becomes: var firebase = require('firebase');
    util.patchProperty(namespace, 'default', namespace);
    // firebase.apps is a read-only getter.
    Object.defineProperty(namespace, 'apps', {
        get: getApps
    });
    /**
     * Called by App.delete() - but before any services associated with the App
     * are deleted.
     */
    function removeApp(name) {
        var app = apps[name];
        callAppHooks(app, 'delete');
        delete apps[name];
    }
    /**
     * Get the App object for a given name (or DEFAULT).
     */
    function app(name) {
        name = name || DEFAULT_ENTRY_NAME;
        if (!contains(apps, name)) {
            error("no-app" /* NO_APP */, { name: name });
        }
        return apps[name];
    }
    util.patchProperty(app, 'App', firebaseAppImpl);
    function initializeApp(options, rawConfig) {
        if (rawConfig === void 0) {
            rawConfig = {};
        }
        if (typeof rawConfig !== 'object' || rawConfig === null) {
            var name_1 = rawConfig;
            rawConfig = { name: name_1 };
        }
        var config = rawConfig;
        if (config.name === undefined) {
            config.name = DEFAULT_ENTRY_NAME;
        }
        var name = config.name;
        if (typeof name !== 'string' || !name) {
            error("bad-app-name" /* BAD_APP_NAME */, { name: String(name) });
        }
        if (contains(apps, name)) {
            error("duplicate-app" /* DUPLICATE_APP */, { name: name });
        }
        var app = new firebaseAppImpl(options, config, namespace);
        apps[name] = app;
        callAppHooks(app, 'create');
        return app;
    }
    /*
     * Return an array of all the non-deleted FirebaseApps.
     */
    function getApps() {
        // Make a copy so caller cannot mutate the apps list.
        return Object.keys(apps).map(function (name) {
            return apps[name];
        });
    }
    /*
     * Register a Firebase Service.
     *
     * firebase.INTERNAL.registerService()
     *
     * TODO: Implement serviceProperties.
     */
    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {
        if (allowMultipleInstances === void 0) {
            allowMultipleInstances = false;
        }
        // Cannot re-register a service that already exists
        if (factories[name]) {
            error("duplicate-service" /* DUPLICATE_SERVICE */, { name: name });
        }
        // Capture the service factory for later service instantiation
        factories[name] = createService;
        // Capture the appHook, if passed
        if (appHook) {
            appHooks[name] = appHook;
            // Run the **new** app hook on all existing apps
            getApps().forEach(function (app) {
                appHook('create', app);
            });
        }
        // The Service namespace is an accessor function ...
        function serviceNamespace(appArg) {
            if (appArg === void 0) {
                appArg = app();
            }
            if (typeof appArg[name] !== 'function') {
                // Invalid argument.
                // This happens in the following case: firebase.storage('gs:/')
                error("invalid-app-argument" /* INVALID_APP_ARGUMENT */, { name: name });
            }
            // Forward service instance lookup to the FirebaseApp.
            return appArg[name]();
        }
        // ... and a container for service-level properties.
        if (serviceProperties !== undefined) {
            util.deepExtend(serviceNamespace, serviceProperties);
        }
        // Monkey-patch the serviceNamespace onto the firebase namespace
        namespace[name] = serviceNamespace;
        // Patch the FirebaseAppImpl prototype
        firebaseAppImpl.prototype[name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var serviceFxn = this._getService.bind(this, name);
            return serviceFxn.apply(this, allowMultipleInstances ? args : []);
        };
        return serviceNamespace;
    }
    function callAppHooks(app, eventName) {
        for (var _i = 0, _a = Object.keys(factories); _i < _a.length; _i++) {
            var serviceName = _a[_i];
            // Ignore virtual services
            var factoryName = useAsService(app, serviceName);
            if (factoryName === null) {
                return;
            }
            if (appHooks[factoryName]) {
                appHooks[factoryName](eventName, app);
            }
        }
    }
    // Map the requested service to a registered service name
    // (used to map auth to serverAuth service when needed).
    function useAsService(app, name) {
        if (name === 'serverAuth') {
            return null;
        }
        var useService = name;
        var options = app.options;
        return useService;
    }
    return namespace;
}

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Return a firebase namespace object.
 *
 * In production, this will be called exactly once and the result
 * assigned to the 'firebase' global.  It may be called multiple times
 * in unit tests.
 */
function createFirebaseNamespace() {
    var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
    namespace.INTERNAL = tslib_1.__assign({}, namespace.INTERNAL, { createFirebaseNamespace: createFirebaseNamespace, extendNamespace: extendNamespace, createSubscribe: util.createSubscribe, ErrorFactory: util.ErrorFactory, deepExtend: util.deepExtend });
    /**
     * Patch the top-level firebase namespace with additional properties.
     *
     * firebase.INTERNAL.extendNamespace()
     */
    function extendNamespace(props) {
        util.deepExtend(namespace, props);
    }
    return namespace;
}

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Node detection logic from: https://github.com/iliakan/detect-node/
var isNode = false;
try {
    isNode = Object.prototype.toString.call(global.process) === '[object process]';
} catch (e) {}
isNode && console.warn("\nWarning: This is a browser-targeted Firebase bundle but it appears it is being\nrun in a Node environment.  If running in a Node environment, make sure you\nare using the bundle specified by the \"main\" field in package.json.\n\nIf you are using Webpack, you can specify \"main\" as the first item in\n\"resolve.mainFields\":\nhttps://webpack.js.org/configuration/resolve/#resolvemainfields\n\nIf using Rollup, use the rollup-plugin-node-resolve plugin and set \"module\"\nto false and \"main\" to true:\nhttps://github.com/rollup/rollup-plugin-node-resolve\n");
// Firebase Lite detection
if (self && 'firebase' in self) {
    console.warn("\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  ");
    var sdkVersion = self.firebase.SDK_VERSION;
    if (sdkVersion && sdkVersion.indexOf('LITE') >= 0) {
        console.warn("\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ");
    }
}
var firebase = createFirebaseNamespace();

exports.default = firebase;
exports.firebase = firebase;
//# sourceMappingURL=index.cjs.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("h6ac")))

/***/ }),

/***/ "dXs8":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("b1tA");
module.exports = __webpack_require__("zKeE").Object.setPrototypeOf;

/***/ }),

/***/ "daDe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Uint8ArrayReader = __webpack_require__("nR4t");
var utils = __webpack_require__("dvMn");

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function (size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

/***/ }),

/***/ "dhak":
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "dmyY":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "dqyN":
/***/ (function(module, exports, __webpack_require__) {

var UNSCOPABLES = __webpack_require__("95jh")('unscopables');
var create = __webpack_require__("M3NV");
var hide = __webpack_require__("2O9B");
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  hide(ArrayPrototype, UNSCOPABLES, create(null));
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "dvMn":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var support = __webpack_require__("untT");
var base64 = __webpack_require__("Ps3q");
var nodejsUtils = __webpack_require__("c5OX");
var setImmediate = __webpack_require__("e0Yl");
var external = __webpack_require__("8JlO");

/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
        result = new Uint8Array(str.length);
    } else {
        result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function (part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    } catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        } catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }
};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function (array, type, chunk) {
        var result = [],
            k = 0,
            len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            } else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function (array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        }()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;

/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function (input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function (input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function (input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function (input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function (input) {
        return new Uint8Array(input).buffer;
    },
    "uint8array": function (input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function (input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function (input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function (input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function (input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function (input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function (input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function (input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function (input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function (input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function (input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function (input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function (outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function (input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function (type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function (str) {
    var res = '',
        code,
        i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function (callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function () {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function () {
    var result = {},
        i,
        attr;
    for (i = 0; i < arguments.length; i++) {
        // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function (data) {

        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function (e) {
                    resolve(e.target.result);
                };
                reader.onerror = function (e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function (data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            } else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

/***/ }),

/***/ "dzzp":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.split` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.split
__webpack_require__("KGgk")('split');

/***/ }),

/***/ "e0Yl":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = typeof setImmediate === 'function' ? setImmediate : function setImmediate() {
	var args = [].slice.apply(arguments);
	args.splice(1, 0, 0);
	setTimeout.apply(null, args);
};

/***/ }),

/***/ "e4aZ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utf8 = __webpack_require__("Sm7/");
var utils = __webpack_require__("dvMn");
var GenericWorker = __webpack_require__("ZKdc");
var StreamHelper = __webpack_require__("2P9T");
var defaults = __webpack_require__("lUr3");
var CompressedObject = __webpack_require__("PO9O");
var ZipObject = __webpack_require__("geN+");
var generate = __webpack_require__("GTg1");
var nodejsUtils = __webpack_require__("c5OX");
var NodejsStreamInputAdapter = __webpack_require__("AsaI");

/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function (name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;

    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && o.unixPermissions & 0x4000) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && o.dosPermissions & 0x0010) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }

    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?
     return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function (path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function (path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function (name, createFolders) {
    createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function () {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function (cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) {
                // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function (search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) {
                // the file matches the function
                result.push(entry);
            }
        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function (name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function (relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            } else {
                // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        } else {
            // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function (arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function (relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function (name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function (relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function (options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function (options) {
        var worker,
            opts = {};
        try {
            opts = utils.extend(options || {}, {
                streamFiles: false,
                compression: "STORE",
                compressionOptions: null,
                type: "",
                platform: "DOS",
                comment: null,
                mimeType: 'application/zip',
                encodeFileName: utf8.utf8encode
            });

            opts.type = opts.type.toLowerCase();
            opts.compression = opts.compression.toUpperCase();

            // "binarystring" is prefered but the internals use "string".
            if (opts.type === "binarystring") {
                opts.type = "string";
            }

            if (!opts.type) {
                throw new Error("No output type specified.");
            }

            utils.checkSupport(opts.type);

            // accept nodejs `process.platform`
            if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {
                opts.platform = "UNIX";
            }
            if (opts.platform === 'win32') {
                opts.platform = "DOS";
            }

            var comment = opts.comment || this.comment || "";
            worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
            worker = new GenericWorker("error");
            worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function (options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function (options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

/***/ }),

/***/ "e8vu":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("X6va")('meta');
var isObject = __webpack_require__("BxvP");
var has = __webpack_require__("yS17");
var setDesc = __webpack_require__("Gfzd").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("wLcK")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {} // weak collections IDs
    } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
    // return object ID
  }return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
    // return hash weak collections IDs
  }return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "eA7g":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'__esModule',{value:true});function _interopDefault(ex){return ex&&typeof ex==='object'&&'default'in ex?ex['default']:ex;}var firebase=_interopDefault(__webpack_require__("dP58"));var logger=__webpack_require__("TUpU");var tslib_1=__webpack_require__("vCxL");var webchannelWrapper=__webpack_require__("ueHA");var util=__webpack_require__("58xA");/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//** The semver (www.semver.org) version of the SDK. */var SDK_VERSION=firebase.SDK_VERSION;/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var logClient=new logger.Logger('@firebase/firestore');var LogLevel;(function(LogLevel){LogLevel[LogLevel["DEBUG"]=0]="DEBUG";LogLevel[LogLevel["ERROR"]=1]="ERROR";LogLevel[LogLevel["SILENT"]=2]="SILENT";})(LogLevel||(LogLevel={}));// Helper methods are needed because variables can't be exported as read/write
function getLogLevel(){if(logClient.logLevel===logger.LogLevel.DEBUG){return LogLevel.DEBUG;}else if(logClient.logLevel===logger.LogLevel.SILENT){return LogLevel.SILENT;}else{return LogLevel.ERROR;}}function setLogLevel(newLevel){/**
     * Map the new log level to the associated Firebase Log Level
     */switch(newLevel){case LogLevel.DEBUG:logClient.logLevel=logger.LogLevel.DEBUG;break;case LogLevel.ERROR:logClient.logLevel=logger.LogLevel.ERROR;break;case LogLevel.SILENT:logClient.logLevel=logger.LogLevel.SILENT;break;default:logClient.error("Firestore ("+SDK_VERSION+"): Invalid value passed to `setLogLevel`");}}function debug(tag,msg){var obj=[];for(var _i=2;_i<arguments.length;_i++){obj[_i-2]=arguments[_i];}if(logClient.logLevel<=logger.LogLevel.DEBUG){var args=obj.map(argToString);logClient.debug.apply(logClient,["Firestore ("+SDK_VERSION+") ["+tag+"]: "+msg].concat(args));}}function error(msg){var obj=[];for(var _i=1;_i<arguments.length;_i++){obj[_i-1]=arguments[_i];}if(logClient.logLevel<=logger.LogLevel.ERROR){var args=obj.map(argToString);logClient.error.apply(logClient,["Firestore ("+SDK_VERSION+"): "+msg].concat(args));}}/**
 * Converts an additional log parameter to a string representation.
 */function argToString(obj){if(typeof obj==='string'){return obj;}else{var platform=PlatformSupport.getPlatform();try{return platform.formatJSON(obj);}catch(e){// Converting to JSON failed, just log the object directly
return obj;}}}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Unconditionally fails, throwing an Error with the given message.
 *
 * Returns any so it can be used in expressions:
 * @example
 * let futureVar = fail('not implemented yet');
 */function fail(failure){// Log the failure in addition to throw an exception, just in case the
// exception is swallowed.
var message="FIRESTORE ("+SDK_VERSION+") INTERNAL ASSERTION FAILED: "+failure;error(message);// NOTE: We don't use FirestoreError here because these are internal failures
// that cannot be handled by the user. (Also it would create a circular
// dependency between the error and assert modules which doesn't work.)
throw new Error(message);}/**
 * Fails if the given assertion condition is false, throwing an Error with the
 * given message if it did.
 */function assert(assertion,message){if(!assertion){fail(message);}}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Provides singleton helpers where setup code can inject a platform at runtime.
 * setPlatform needs to be set before Firestore is used and must be set exactly
 * once.
 */var PlatformSupport=/** @class */function(){function PlatformSupport(){}PlatformSupport.setPlatform=function(platform){if(PlatformSupport.platform){fail('Platform already defined');}PlatformSupport.platform=platform;};PlatformSupport.getPlatform=function(){if(!PlatformSupport.platform){fail('Platform not set');}return PlatformSupport.platform;};return PlatformSupport;}();/**
 * Returns the representation of an empty "proto" byte string for the
 * platform.
 */function emptyByteString(){return PlatformSupport.getPlatform().emptyByteString;}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */// TODO(mcg): Change to a string enum once we've upgraded to typescript 2.4.
//  tslint:disable-next-line:variable-name Intended to look like a TS 2.4 enum
var Code={// Causes are copied from:
// https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
/** Not an error; returned on success. */OK:'ok',/** The operation was cancelled (typically by the caller). */CANCELLED:'cancelled',/** Unknown error or an error from a different error domain. */UNKNOWN:'unknown',/**
     * Client specified an invalid argument. Note that this differs from
     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
     * problematic regardless of the state of the system (e.g., a malformed file
     * name).
     */INVALID_ARGUMENT:'invalid-argument',/**
     * Deadline expired before operation could complete. For operations that
     * change the state of the system, this error may be returned even if the
     * operation has completed successfully. For example, a successful response
     * from a server could have been delayed long enough for the deadline to
     * expire.
     */DEADLINE_EXCEEDED:'deadline-exceeded',/** Some requested entity (e.g., file or directory) was not found. */NOT_FOUND:'not-found',/**
     * Some entity that we attempted to create (e.g., file or directory) already
     * exists.
     */ALREADY_EXISTS:'already-exists',/**
     * The caller does not have permission to execute the specified operation.
     * PERMISSION_DENIED must not be used for rejections caused by exhausting
     * some resource (use RESOURCE_EXHAUSTED instead for those errors).
     * PERMISSION_DENIED must not be used if the caller can not be identified
     * (use UNAUTHENTICATED instead for those errors).
     */PERMISSION_DENIED:'permission-denied',/**
     * The request does not have valid authentication credentials for the
     * operation.
     */UNAUTHENTICATED:'unauthenticated',/**
     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
     * entire file system is out of space.
     */RESOURCE_EXHAUSTED:'resource-exhausted',/**
     * Operation was rejected because the system is not in a state required for
     * the operation's execution. For example, directory to be deleted may be
     * non-empty, an rmdir operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
     *  (a) Use UNAVAILABLE if the client can retry just the failing call.
     *  (b) Use ABORTED if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FAILED_PRECONDITION if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FAILED_PRECONDITION
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FAILED_PRECONDITION if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     */FAILED_PRECONDITION:'failed-precondition',/**
     * The operation was aborted, typically due to a concurrency issue like
     * sequencer check failures, transaction aborts, etc.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
     * and UNAVAILABLE.
     */ABORTED:'aborted',/**
     * Operation was attempted past the valid range. E.g., seeking or reading
     * past end of file.
     *
     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
     * if the system state changes. For example, a 32-bit file system will
     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
     * an offset past the current file size.
     *
     * There is a fair bit of overlap between FAILED_PRECONDITION and
     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
     * when it applies so that callers who are iterating through a space can
     * easily look for an OUT_OF_RANGE error to detect when they are done.
     */OUT_OF_RANGE:'out-of-range',/** Operation is not implemented or not supported/enabled in this service. */UNIMPLEMENTED:'unimplemented',/**
     * Internal errors. Means some invariants expected by underlying System has
     * been broken. If you see one of these errors, Something is very broken.
     */INTERNAL:'internal',/**
     * The service is currently unavailable. This is a most likely a transient
     * condition and may be corrected by retrying with a backoff.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
     * and UNAVAILABLE.
     */UNAVAILABLE:'unavailable',/** Unrecoverable data loss or corruption. */DATA_LOSS:'data-loss'};/**
 * An error class used for Firestore-generated errors. Ideally we should be
 * using FirebaseError, but integrating with it is overly arduous at the moment,
 * so we define our own compatible error class (with a `name` of 'FirebaseError'
 * and compatible `code` and `message` fields.)
 */var FirestoreError=/** @class */function(_super){tslib_1.__extends(FirestoreError,_super);function FirestoreError(code,message){var _this=_super.call(this,message)||this;_this.code=code;_this.message=message;_this.name='FirebaseError';// HACK: We write a toString property directly because Error is not a real
// class and so inheritance does not work correctly. We could alternatively
// do the same "back-door inheritance" trick that FirebaseError does.
_this.toString=function(){return _this.name+": [code="+_this.code+"]: "+_this.message;};return _this;}return FirestoreError;}(Error);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Helper function to prevent instantiation through the constructor.
 *
 * This method creates a new constructor that throws when it's invoked.
 * The prototype of that constructor is then set to the prototype of the hidden
 * "class" to expose all the prototype methods and allow for instanceof
 * checks.
 *
 * To also make all the static methods available, all properties of the
 * original constructor are copied to the new constructor.
 */function makeConstructorPrivate(cls,optionalMessage){function PublicConstructor(){var error='This constructor is private.';if(optionalMessage){error+=' ';error+=optionalMessage;}throw new FirestoreError(Code.INVALID_ARGUMENT,error);}// Make sure instanceof checks work and all methods are exposed on the public
// constructor
PublicConstructor.prototype=cls.prototype;// Copy any static methods/members
for(var staticProperty in cls){if(cls.hasOwnProperty(staticProperty)){PublicConstructor[staticProperty]=cls[staticProperty];}}return PublicConstructor;}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function contains(obj,key){return Object.prototype.hasOwnProperty.call(obj,key);}/** Returns the given value if it's defined or the defaultValue otherwise. */function defaulted(value,defaultValue){return value!==undefined?value:defaultValue;}function forEachNumber(obj,fn){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var num=Number(key);if(!isNaN(num)){fn(num,obj[key]);}}}}function values(obj){var vs=[];forEach(obj,function(_,v){return vs.push(v);});return vs;}function forEach(obj,fn){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){fn(key,obj[key]);}}}function isEmpty(obj){assert(obj!=null&&typeof obj==='object','isEmpty() expects object parameter.');for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){return false;}}return true;}function shallowCopy(obj){assert(obj&&typeof obj==='object','shallowCopy() expects object parameter.');var result={};for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){result[key]=obj[key];}}return result;}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Validates that no arguments were passed in the invocation of functionName.
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateNoArgs('myFunction', arguments);
 */function validateNoArgs(functionName,args){if(args.length!==0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() does not support arguments, "+'but was called with '+formatPlural(args.length,'argument')+'.');}}/**
 * Validates the invocation of functionName has the exact number of arguments.
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateExactNumberOfArgs('myFunction', arguments, 2);
 */function validateExactNumberOfArgs(functionName,args,numberOfArgs){if(args.length!==numberOfArgs){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires "+formatPlural(numberOfArgs,'argument')+', but was called with '+formatPlural(args.length,'argument')+'.');}}/**
 * Validates the invocation of functionName has at least the provided number of
 * arguments (but can have many more).
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateAtLeastNumberOfArgs('myFunction', arguments, 2);
 */function validateAtLeastNumberOfArgs(functionName,args,minNumberOfArgs){if(args.length<minNumberOfArgs){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires at least "+formatPlural(minNumberOfArgs,'argument')+', but was called with '+formatPlural(args.length,'argument')+'.');}}/**
 * Validates the invocation of functionName has number of arguments between
 * the values provided.
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateBetweenNumberOfArgs('myFunction', arguments, 2, 3);
 */function validateBetweenNumberOfArgs(functionName,args,minNumberOfArgs,maxNumberOfArgs){if(args.length<minNumberOfArgs||args.length>maxNumberOfArgs){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires between "+minNumberOfArgs+" and "+(maxNumberOfArgs+" arguments, but was called with ")+formatPlural(args.length,'argument')+'.');}}/**
 * Validates the provided argument is an array and has as least the expected
 * number of elements.
 */function validateNamedArrayAtLeastNumberOfElements(functionName,value,name,minNumberOfElements){if(!(value instanceof Array)||value.length<minNumberOfElements){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires its "+name+" argument to be an "+'array with at least '+(formatPlural(minNumberOfElements,'element')+"."));}}/**
 * Validates the provided positional argument has the native JavaScript type
 * using typeof checks.
 */function validateArgType(functionName,type,position,argument){validateType(functionName,type,ordinal(position)+" argument",argument);}/**
 * Validates the provided argument has the native JavaScript type using
 * typeof checks or is undefined.
 */function validateOptionalArgType(functionName,type,position,argument){if(argument!==undefined){validateArgType(functionName,type,position,argument);}}/**
 * Validates the provided named option has the native JavaScript type using
 * typeof checks.
 */function validateNamedType(functionName,type,optionName,argument){validateType(functionName,type,optionName+" option",argument);}/**
 * Validates the provided named option has the native JavaScript type using
 * typeof checks or is undefined.
 */function validateNamedOptionalType(functionName,type,optionName,argument){if(argument!==undefined){validateNamedType(functionName,type,optionName,argument);}}function validateArrayElements(functionName,optionName,typeDescription,argument,validator){if(!(argument instanceof Array)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires its "+optionName+" "+("option to be an array, but it was: "+valueDescription(argument)));}for(var i=0;i<argument.length;++i){if(!validator(argument[i])){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires all "+optionName+" "+("elements to be "+typeDescription+", but the value at index "+i+" ")+("was: "+valueDescription(argument[i])));}}}function validateOptionalArrayElements(functionName,optionName,typeDescription,argument,validator){if(argument!==undefined){validateArrayElements(functionName,optionName,typeDescription,argument,validator);}}/**
 * Validates that the provided named option equals one of the expected values.
 */function validateNamedPropertyEquals(functionName,inputName,optionName,input,expected){var expectedDescription=[];for(var _i=0,expected_1=expected;_i<expected_1.length;_i++){var val=expected_1[_i];if(val===input){return;}expectedDescription.push(valueDescription(val));}var actualDescription=valueDescription(input);throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid value "+actualDescription+" provided to function "+functionName+"() for option "+("\""+optionName+"\". Acceptable values: "+expectedDescription.join(', ')));}/**
 * Validates that the provided named option equals one of the expected values or
 * is undefined.
 */function validateNamedOptionalPropertyEquals(functionName,inputName,optionName,input,expected){if(input!==undefined){validateNamedPropertyEquals(functionName,inputName,optionName,input,expected);}}/**
 * Validates that the provided argument is a valid enum.
 *
 * @param functionName Function making the validation call.
 * @param enums Array containing all possible values for the enum.
 * @param position Position of the argument in `functionName`.
 * @param argument Arugment to validate.
 */function validateStringEnum(functionName,enums,position,argument){if(!enums.some(function(element){return element===argument;})){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid value "+valueDescription(argument)+" provided to function "+(functionName+"() for its "+ordinal(position)+" argument. Acceptable ")+("values: "+enums.join(', ')));}}/** Helper to validate the type of a provided input. */function validateType(functionName,type,inputName,input){var valid=false;if(type==='object'){valid=isPlainObject(input);}else if(type==='non-empty string'){valid=typeof input==='string'&&input!=='';}else{valid=typeof input===type;}if(!valid){var description=valueDescription(input);throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires its "+inputName+" "+("to be of type "+type+", but it was: "+description));}}/**
 * Returns true if it's a non-null object without a custom prototype
 * (i.e. excludes Array, Date, etc.).
 */function isPlainObject(input){return typeof input==='object'&&input!==null&&(Object.getPrototypeOf(input)===Object.prototype||Object.getPrototypeOf(input)===null);}/** Returns a string describing the type / value of the provided input. */function valueDescription(input){if(input===undefined){return'undefined';}else if(input===null){return'null';}else if(typeof input==='string'){if(input.length>20){input=input.substring(0,20)+"...";}return JSON.stringify(input);}else if(typeof input==='number'||typeof input==='boolean'){return''+input;}else if(typeof input==='object'){if(input instanceof Array){return'an array';}else{var customObjectName=tryGetCustomObjectType(input);if(customObjectName){return"a custom "+customObjectName+" object";}else{return'an object';}}}else if(typeof input==='function'){return'a function';}else{return fail('Unknown wrong type: '+typeof input);}}/** Hacky method to try to get the constructor name for an object. */function tryGetCustomObjectType(input){if(input.constructor){var funcNameRegex=/function\s+([^\s(]+)\s*\(/;var results=funcNameRegex.exec(input.constructor.toString());if(results&&results.length>1){return results[1];}}return null;}/** Validates the provided argument is defined. */function validateDefined(functionName,position,argument){if(argument===undefined){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires a valid "+ordinal(position)+" "+"argument, but it was undefined.");}}/**
 * Validates the provided positional argument is an object, and its keys and
 * values match the expected keys and types provided in optionTypes.
 */function validateOptionNames(functionName,options,optionNames){forEach(options,function(key,_){if(optionNames.indexOf(key)<0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Unknown option '"+key+"' passed to function "+functionName+"(). "+'Available options: '+optionNames.join(', '));}});}/**
 * Helper method to throw an error that the provided argument did not pass
 * an instanceof check.
 */function invalidClassError(functionName,type,position,argument){var description=valueDescription(argument);return new FirestoreError(Code.INVALID_ARGUMENT,"Function "+functionName+"() requires its "+ordinal(position)+" "+("argument to be a "+type+", but it was: "+description));}/** Converts a number to its english word representation */function ordinal(num){switch(num){case 1:return'first';case 2:return'second';case 3:return'third';default:return num+'th';}}/**
 * Formats the given word as plural conditionally given the preceding number.
 */function formatPlural(num,str){return num+" "+str+(num===1?'':'s');}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */// tslint:disable-next-line:class-as-namespace
var AutoId=/** @class */function(){function AutoId(){}AutoId.newId=function(){// Alphanumeric characters
var chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';var autoId='';for(var i=0;i<20;i++){autoId+=chars.charAt(Math.floor(Math.random()*chars.length));}assert(autoId.length===20,'Invalid auto ID: '+autoId);return autoId;};return AutoId;}();function primitiveComparator(left,right){if(left<right)return-1;if(left>right)return 1;return 0;}/** Helper to compare nullable (or undefined-able) objects using isEqual(). */function equals(left,right){if(left!==null&&left!==undefined){return!!(right&&left.isEqual(right));}else{// HACK: Explicitly cast since TypeScript's type narrowing apparently isn't
// smart enough.
return left===right;}}/** Helper to compare arrays using isEqual(). */function arrayEquals(left,right){if(left.length!==right.length){return false;}for(var i=0;i<left.length;i++){if(!left[i].isEqual(right[i])){return false;}}return true;}/**
 * Returns the immediate lexicographically-following string. This is useful to
 * construct an inclusive range for indexeddb iterators.
 */function immediateSuccessor(s){// Return the input string, with an additional NUL byte appended.
return s+'\0';}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//** Helper function to assert Uint8Array is available at runtime. */function assertUint8ArrayAvailable(){if(typeof Uint8Array==='undefined'){throw new FirestoreError(Code.UNIMPLEMENTED,'Uint8Arrays are not available in this environment.');}}/** Helper function to assert Base64 functions are available at runtime. */function assertBase64Available(){if(!PlatformSupport.getPlatform().base64Available){throw new FirestoreError(Code.UNIMPLEMENTED,'Blobs are unavailable in Firestore in this environment.');}}/**
 * Immutable class holding a blob (binary data).
 * This class is directly exposed in the public API.
 *
 * Note that while you can't hide the constructor in JavaScript code, we are
 * using the hack above to make sure no-one outside this module can call it.
 */var Blob=/** @class */function(){function Blob(binaryString){assertBase64Available();this._binaryString=binaryString;}Blob.fromBase64String=function(base64){validateExactNumberOfArgs('Blob.fromBase64String',arguments,1);validateArgType('Blob.fromBase64String','string',1,base64);assertBase64Available();try{var binaryString=PlatformSupport.getPlatform().atob(base64);return new Blob(binaryString);}catch(e){throw new FirestoreError(Code.INVALID_ARGUMENT,'Failed to construct Blob from Base64 string: '+e);}};Blob.fromUint8Array=function(array){validateExactNumberOfArgs('Blob.fromUint8Array',arguments,1);assertUint8ArrayAvailable();if(!(array instanceof Uint8Array)){throw invalidClassError('Blob.fromUint8Array','Uint8Array',1,array);}// We can't call array.map directly because it expects the return type to
// be a Uint8Array, whereas we can convert it to a regular array by invoking
// map on the Array prototype.
var binaryString=Array.prototype.map.call(array,function(char){return String.fromCharCode(char);}).join('');return new Blob(binaryString);};Blob.prototype.toBase64=function(){validateExactNumberOfArgs('Blob.toBase64',arguments,0);assertBase64Available();return PlatformSupport.getPlatform().btoa(this._binaryString);};Blob.prototype.toUint8Array=function(){validateExactNumberOfArgs('Blob.toUint8Array',arguments,0);assertUint8ArrayAvailable();var buffer=new Uint8Array(this._binaryString.length);for(var i=0;i<this._binaryString.length;i++){buffer[i]=this._binaryString.charCodeAt(i);}return buffer;};Blob.prototype.toString=function(){return'Blob(base64: '+this.toBase64()+')';};Blob.prototype.isEqual=function(other){return this._binaryString===other._binaryString;};/**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */Blob.prototype._compareTo=function(other){return primitiveComparator(this._binaryString,other._binaryString);};return Blob;}();// Public instance that disallows construction at runtime. This constructor is
// used when exporting Blob on firebase.firestore.Blob and will be called Blob
// publicly. Internally we still use Blob which has a type checked private
// constructor. Note that Blob and PublicBlob can be used interchangeably in
// instanceof checks.
// For our internal TypeScript code PublicBlob doesn't exist as a type, and so
// we need to use Blob as type and export it too.
// tslint:disable-next-line:variable-name We're treating this as a class name.
var PublicBlob=makeConstructorPrivate(Blob,'Use Blob.fromUint8Array() or Blob.fromBase64String() instead.');/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Immutable class representing a geo point as latitude-longitude pair.
 * This class is directly exposed in the public API, including its constructor.
 */var GeoPoint=/** @class */function(){function GeoPoint(latitude,longitude){validateExactNumberOfArgs('GeoPoint',arguments,2);validateArgType('GeoPoint','number',1,latitude);validateArgType('GeoPoint','number',2,longitude);if(!isFinite(latitude)||latitude<-90||latitude>90){throw new FirestoreError(Code.INVALID_ARGUMENT,'Latitude must be a number between -90 and 90, but was: '+latitude);}if(!isFinite(longitude)||longitude<-180||longitude>180){throw new FirestoreError(Code.INVALID_ARGUMENT,'Longitude must be a number between -180 and 180, but was: '+longitude);}this._lat=latitude;this._long=longitude;}Object.defineProperty(GeoPoint.prototype,"latitude",{/**
         * Returns the latitude of this geo point, a number between -90 and 90.
         */get:function(){return this._lat;},enumerable:true,configurable:true});Object.defineProperty(GeoPoint.prototype,"longitude",{/**
         * Returns the longitude of this geo point, a number between -180 and 180.
         */get:function(){return this._long;},enumerable:true,configurable:true});GeoPoint.prototype.isEqual=function(other){return this._lat===other._lat&&this._long===other._long;};/**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */GeoPoint.prototype._compareTo=function(other){return primitiveComparator(this._lat,other._lat)||primitiveComparator(this._long,other._long);};return GeoPoint;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Timestamp=/** @class */function(){function Timestamp(seconds,nanoseconds){this.seconds=seconds;this.nanoseconds=nanoseconds;if(nanoseconds<0){throw new FirestoreError(Code.INVALID_ARGUMENT,'Timestamp nanoseconds out of range: '+nanoseconds);}if(nanoseconds>=1e9){throw new FirestoreError(Code.INVALID_ARGUMENT,'Timestamp nanoseconds out of range: '+nanoseconds);}// Midnight at the beginning of 1/1/1 is the earliest Firestore supports.
if(seconds<-62135596800){throw new FirestoreError(Code.INVALID_ARGUMENT,'Timestamp seconds out of range: '+seconds);}// This will break in the year 10,000.
if(seconds>=253402300800){throw new FirestoreError(Code.INVALID_ARGUMENT,'Timestamp seconds out of range: '+seconds);}}Timestamp.now=function(){return Timestamp.fromMillis(Date.now());};Timestamp.fromDate=function(date){return Timestamp.fromMillis(date.getTime());};Timestamp.fromMillis=function(milliseconds){var seconds=Math.floor(milliseconds/1000);var nanos=(milliseconds-seconds*1000)*1e6;return new Timestamp(seconds,nanos);};Timestamp.prototype.toDate=function(){return new Date(this.toMillis());};Timestamp.prototype.toMillis=function(){return this.seconds*1000+this.nanoseconds/1e6;};Timestamp.prototype._compareTo=function(other){if(this.seconds===other.seconds){return primitiveComparator(this.nanoseconds,other.nanoseconds);}return primitiveComparator(this.seconds,other.seconds);};Timestamp.prototype.isEqual=function(other){return other.seconds===this.seconds&&other.nanoseconds===this.nanoseconds;};Timestamp.prototype.toString=function(){return'Timestamp(seconds='+this.seconds+', nanoseconds='+this.nanoseconds+')';};return Timestamp;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DatabaseInfo=/** @class */function(){/**
     * Constructs a DatabaseInfo using the provided host, databaseId and
     * persistenceKey.
     *
     * @param databaseId The database to use.
     * @param persistenceKey A unique identifier for this Firestore's local
     * storage (used in conjunction with the databaseId).
     * @param host The Firestore backend host to connect to.
     * @param ssl Whether to use SSL when connecting.
     * @param forceLongPolling Whether to use the forceLongPolling option
     * when using WebChannel as the network transport.
     */function DatabaseInfo(databaseId,persistenceKey,host,ssl,forceLongPolling){this.databaseId=databaseId;this.persistenceKey=persistenceKey;this.host=host;this.ssl=ssl;this.forceLongPolling=forceLongPolling;}return DatabaseInfo;}();/** The default database name for a project. */var DEFAULT_DATABASE_NAME='(default)';/** Represents the database ID a Firestore client is associated with. */var DatabaseId=/** @class */function(){function DatabaseId(projectId,database){this.projectId=projectId;this.database=database?database:DEFAULT_DATABASE_NAME;}Object.defineProperty(DatabaseId.prototype,"isDefaultDatabase",{get:function(){return this.database===DEFAULT_DATABASE_NAME;},enumerable:true,configurable:true});DatabaseId.prototype.isEqual=function(other){return other instanceof DatabaseId&&other.projectId===this.projectId&&other.database===this.database;};DatabaseId.prototype.compareTo=function(other){return primitiveComparator(this.projectId,other.projectId)||primitiveComparator(this.database,other.database);};return DatabaseId;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DOCUMENT_KEY_NAME='__name__';/**
 * Path represents an ordered sequence of string segments.
 */var Path=/** @class */function(){function Path(segments,offset,length){this.init(segments,offset,length);}/**
     * An initialization method that can be called from outside the constructor.
     * We need this so that we can have a non-static construct method that returns
     * the polymorphic `this` type.
     */Path.prototype.init=function(segments,offset,length){if(offset===undefined){offset=0;}else if(offset>segments.length){fail('offset '+offset+' out of range '+segments.length);}if(length===undefined){length=segments.length-offset;}else if(length>segments.length-offset){fail('length '+length+' out of range '+(segments.length-offset));}this.segments=segments;this.offset=offset;this.len=length;};/**
     * Constructs a new instance of Path using the same concrete type as `this`.
     * We need this instead of using the normal constructor, because polymorphic
     * `this` doesn't work on static methods.
     */Path.prototype.construct=function(segments,offset,length){var path=Object.create(Object.getPrototypeOf(this));path.init(segments,offset,length);return path;};Object.defineProperty(Path.prototype,"length",{get:function(){return this.len;},enumerable:true,configurable:true});Path.prototype.isEqual=function(other){return Path.comparator(this,other)===0;};Path.prototype.child=function(nameOrPath){var segments=this.segments.slice(this.offset,this.limit());if(nameOrPath instanceof Path){nameOrPath.forEach(function(segment){segments.push(segment);});}else if(typeof nameOrPath==='string'){segments.push(nameOrPath);}else{fail('Unknown parameter type for Path.child(): '+nameOrPath);}return this.construct(segments);};/** The index of one past the last segment of the path. */Path.prototype.limit=function(){return this.offset+this.length;};Path.prototype.popFirst=function(size){size=size===undefined?1:size;assert(this.length>=size,"Can't call popFirst() with less segments");return this.construct(this.segments,this.offset+size,this.length-size);};Path.prototype.popLast=function(){assert(!this.isEmpty(),"Can't call popLast() on empty path");return this.construct(this.segments,this.offset,this.length-1);};Path.prototype.firstSegment=function(){assert(!this.isEmpty(),"Can't call firstSegment() on empty path");return this.segments[this.offset];};Path.prototype.lastSegment=function(){return this.get(this.length-1);};Path.prototype.get=function(index){assert(index<this.length,'Index out of range');return this.segments[this.offset+index];};Path.prototype.isEmpty=function(){return this.length===0;};Path.prototype.isPrefixOf=function(other){if(other.length<this.length){return false;}for(var i=0;i<this.length;i++){if(this.get(i)!==other.get(i)){return false;}}return true;};Path.prototype.isImmediateParentOf=function(potentialChild){if(this.length+1!==potentialChild.length){return false;}for(var i=0;i<this.length;i++){if(this.get(i)!==potentialChild.get(i)){return false;}}return true;};Path.prototype.forEach=function(fn){for(var i=this.offset,end=this.limit();i<end;i++){fn(this.segments[i]);}};Path.prototype.toArray=function(){return this.segments.slice(this.offset,this.limit());};Path.comparator=function(p1,p2){var len=Math.min(p1.length,p2.length);for(var i=0;i<len;i++){var left=p1.get(i);var right=p2.get(i);if(left<right)return-1;if(left>right)return 1;}if(p1.length<p2.length)return-1;if(p1.length>p2.length)return 1;return 0;};return Path;}();/**
 * A slash-separated path for navigating resources (documents and collections)
 * within Firestore.
 */var ResourcePath=/** @class */function(_super){tslib_1.__extends(ResourcePath,_super);function ResourcePath(){return _super!==null&&_super.apply(this,arguments)||this;}ResourcePath.prototype.canonicalString=function(){// NOTE: The client is ignorant of any path segments containing escape
// sequences (e.g. __id123__) and just passes them through raw (they exist
// for legacy reasons and should not be used frequently).
return this.toArray().join('/');};ResourcePath.prototype.toString=function(){return this.canonicalString();};/**
     * Creates a resource path from the given slash-delimited string.
     */ResourcePath.fromString=function(path){// NOTE: The client is ignorant of any path segments containing escape
// sequences (e.g. __id123__) and just passes them through raw (they exist
// for legacy reasons and should not be used frequently).
if(path.indexOf('//')>=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid path ("+path+"). Paths must not contain // in them.");}// We may still have an empty segment at the beginning or end if they had a
// leading or trailing slash (which we allow).
var segments=path.split('/').filter(function(segment){return segment.length>0;});return new ResourcePath(segments);};ResourcePath.EMPTY_PATH=new ResourcePath([]);return ResourcePath;}(Path);var identifierRegExp=/^[_a-zA-Z][_a-zA-Z0-9]*$/;/** A dot-separated path for navigating sub-objects within a document. */var FieldPath=/** @class */function(_super){tslib_1.__extends(FieldPath,_super);function FieldPath(){return _super!==null&&_super.apply(this,arguments)||this;}/**
     * Returns true if the string could be used as a segment in a field path
     * without escaping.
     */FieldPath.isValidIdentifier=function(segment){return identifierRegExp.test(segment);};FieldPath.prototype.canonicalString=function(){return this.toArray().map(function(str){str=str.replace('\\','\\\\').replace('`','\\`');if(!FieldPath.isValidIdentifier(str)){str='`'+str+'`';}return str;}).join('.');};FieldPath.prototype.toString=function(){return this.canonicalString();};/**
     * Returns true if this field references the key of a document.
     */FieldPath.prototype.isKeyField=function(){return this.length===1&&this.get(0)===DOCUMENT_KEY_NAME;};/**
     * The field designating the key of a document.
     */FieldPath.keyField=function(){return new FieldPath([DOCUMENT_KEY_NAME]);};/**
     * Parses a field string from the given server-formatted string.
     *
     * - Splitting the empty string is not allowed (for now at least).
     * - Empty segments within the string (e.g. if there are two consecutive
     *   separators) are not allowed.
     *
     * TODO(b/37244157): we should make this more strict. Right now, it allows
     * non-identifier path components, even if they aren't escaped.
     */FieldPath.fromServerFormat=function(path){var segments=[];var current='';var i=0;var addCurrentSegment=function(){if(current.length===0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid field path ("+path+"). Paths must not be empty, begin "+"with '.', end with '.', or contain '..'");}segments.push(current);current='';};var inBackticks=false;while(i<path.length){var c=path[i];if(c==='\\'){if(i+1===path.length){throw new FirestoreError(Code.INVALID_ARGUMENT,'Path has trailing escape character: '+path);}var next=path[i+1];if(!(next==='\\'||next==='.'||next==='`')){throw new FirestoreError(Code.INVALID_ARGUMENT,'Path has invalid escape sequence: '+path);}current+=next;i+=2;}else if(c==='`'){inBackticks=!inBackticks;i++;}else if(c==='.'&&!inBackticks){addCurrentSegment();i++;}else{current+=c;i++;}}addCurrentSegment();if(inBackticks){throw new FirestoreError(Code.INVALID_ARGUMENT,'Unterminated ` in path: '+path);}return new FieldPath(segments);};FieldPath.EMPTY_PATH=new FieldPath([]);return FieldPath;}(Path);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DocumentKey=/** @class */function(){function DocumentKey(path){this.path=path;assert(DocumentKey.isDocumentKey(path),'Invalid DocumentKey with an odd number of segments: '+path.toArray().join('/'));}/** Returns true if the document is in the specified collectionId. */DocumentKey.prototype.hasCollectionId=function(collectionId){return this.path.length>=2&&this.path.get(this.path.length-2)===collectionId;};DocumentKey.prototype.isEqual=function(other){return other!==null&&ResourcePath.comparator(this.path,other.path)===0;};DocumentKey.prototype.toString=function(){return this.path.toString();};DocumentKey.comparator=function(k1,k2){return ResourcePath.comparator(k1.path,k2.path);};DocumentKey.isDocumentKey=function(path){return path.length%2===0;};/**
     * Creates and returns a new document key with the given segments.
     *
     * @param path The segments of the path to the document
     * @return A new instance of DocumentKey
     */DocumentKey.fromSegments=function(segments){return new DocumentKey(new ResourcePath(segments.slice()));};/**
     * Creates and returns a new document key using '/' to split the string into
     * segments.
     *
     * @param path The slash-separated path string to the document
     * @return A new instance of DocumentKey
     */DocumentKey.fromPathString=function(path){return new DocumentKey(ResourcePath.fromString(path));};DocumentKey.EMPTY=new DocumentKey(new ResourcePath([]));return DocumentKey;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * The result of a lookup for a given path may be an existing document or a
 * marker that this document does not exist at a given version.
 */var MaybeDocument=/** @class */function(){function MaybeDocument(key,version){this.key=key;this.version=version;}MaybeDocument.compareByKey=function(d1,d2){return DocumentKey.comparator(d1.key,d2.key);};return MaybeDocument;}();/**
 * Represents a document in Firestore with a key, version, data and whether the
 * data has local mutations applied to it.
 */var Document=/** @class */function(_super){tslib_1.__extends(Document,_super);function Document(key,version,data,options,/**
     * Memoized serialized form of the document for optimization purposes (avoids repeated
     * serialization). Might be undefined.
     */proto){var _this=_super.call(this,key,version)||this;_this.data=data;_this.proto=proto;_this.hasLocalMutations=!!options.hasLocalMutations;_this.hasCommittedMutations=!!options.hasCommittedMutations;return _this;}Document.prototype.field=function(path){return this.data.field(path);};Document.prototype.fieldValue=function(path){var field=this.field(path);return field?field.value():undefined;};Document.prototype.value=function(){return this.data.value();};Document.prototype.isEqual=function(other){return other instanceof Document&&this.key.isEqual(other.key)&&this.version.isEqual(other.version)&&this.data.isEqual(other.data)&&this.hasLocalMutations===other.hasLocalMutations&&this.hasCommittedMutations===other.hasCommittedMutations;};Document.prototype.toString=function(){return"Document("+this.key+", "+this.version+", "+this.data.toString()+", "+("{hasLocalMutations: "+this.hasLocalMutations+"}), ")+("{hasCommittedMutations: "+this.hasCommittedMutations+"})");};Object.defineProperty(Document.prototype,"hasPendingWrites",{get:function(){return this.hasLocalMutations||this.hasCommittedMutations;},enumerable:true,configurable:true});Document.compareByField=function(field,d1,d2){var v1=d1.field(field);var v2=d2.field(field);if(v1!==undefined&&v2!==undefined){return v1.compareTo(v2);}else{return fail("Trying to compare documents on fields that don't exist");}};return Document;}(MaybeDocument);/**
 * A class representing a deleted document.
 * Version is set to 0 if we don't point to any specific time, otherwise it
 * denotes time we know it didn't exist at.
 */var NoDocument=/** @class */function(_super){tslib_1.__extends(NoDocument,_super);function NoDocument(key,version,options){var _this=_super.call(this,key,version)||this;_this.hasCommittedMutations=!!(options&&options.hasCommittedMutations);return _this;}NoDocument.prototype.toString=function(){return"NoDocument("+this.key+", "+this.version+")";};Object.defineProperty(NoDocument.prototype,"hasPendingWrites",{get:function(){return this.hasCommittedMutations;},enumerable:true,configurable:true});NoDocument.prototype.isEqual=function(other){return other instanceof NoDocument&&other.hasCommittedMutations===this.hasCommittedMutations&&other.version.isEqual(this.version)&&other.key.isEqual(this.key);};return NoDocument;}(MaybeDocument);/**
 * A class representing an existing document whose data is unknown (e.g. a
 * document that was updated without a known base document).
 */var UnknownDocument=/** @class */function(_super){tslib_1.__extends(UnknownDocument,_super);function UnknownDocument(key,version){return _super.call(this,key,version)||this;}UnknownDocument.prototype.toString=function(){return"UnknownDocument("+this.key+", "+this.version+")";};Object.defineProperty(UnknownDocument.prototype,"hasPendingWrites",{get:function(){return true;},enumerable:true,configurable:true});UnknownDocument.prototype.isEqual=function(other){return other instanceof UnknownDocument&&other.version.isEqual(this.version)&&other.key.isEqual(this.key);};return UnknownDocument;}(MaybeDocument);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */// An immutable sorted map implementation, based on a Left-leaning Red-Black
// tree.
var SortedMap=/** @class */function(){function SortedMap(comparator,root){this.comparator=comparator;this.root=root?root:LLRBNode.EMPTY;}// Returns a copy of the map, with the specified key/value added or replaced.
SortedMap.prototype.insert=function(key,value){return new SortedMap(this.comparator,this.root.insert(key,value,this.comparator).copy(null,null,LLRBNode.BLACK,null,null));};// Returns a copy of the map, with the specified key removed.
SortedMap.prototype.remove=function(key){return new SortedMap(this.comparator,this.root.remove(key,this.comparator).copy(null,null,LLRBNode.BLACK,null,null));};// Returns the value of the node with the given key, or null.
SortedMap.prototype.get=function(key){var node=this.root;while(!node.isEmpty()){var cmp=this.comparator(key,node.key);if(cmp===0){return node.value;}else if(cmp<0){node=node.left;}else if(cmp>0){node=node.right;}}return null;};// Returns the index of the element in this sorted map, or -1 if it doesn't
// exist.
SortedMap.prototype.indexOf=function(key){// Number of nodes that were pruned when descending right
var prunedNodes=0;var node=this.root;while(!node.isEmpty()){var cmp=this.comparator(key,node.key);if(cmp===0){return prunedNodes+node.left.size;}else if(cmp<0){node=node.left;}else{// Count all nodes left of the node plus the node itself
prunedNodes+=node.left.size+1;node=node.right;}}// Node not found
return-1;};SortedMap.prototype.isEmpty=function(){return this.root.isEmpty();};Object.defineProperty(SortedMap.prototype,"size",{// Returns the total number of nodes in the map.
get:function(){return this.root.size;},enumerable:true,configurable:true});// Returns the minimum key in the map.
SortedMap.prototype.minKey=function(){return this.root.minKey();};// Returns the maximum key in the map.
SortedMap.prototype.maxKey=function(){return this.root.maxKey();};// Traverses the map in key order and calls the specified action function
// for each key/value pair. If action returns true, traversal is aborted.
// Returns the first truthy value returned by action, or the last falsey
// value returned by action.
SortedMap.prototype.inorderTraversal=function(action){return this.root.inorderTraversal(action);};SortedMap.prototype.forEach=function(fn){this.inorderTraversal(function(k,v){fn(k,v);return false;});};SortedMap.prototype.toString=function(){var descriptions=[];this.inorderTraversal(function(k,v){descriptions.push(k+":"+v);return false;});return"{"+descriptions.join(', ')+"}";};// Traverses the map in reverse key order and calls the specified action
// function for each key/value pair. If action returns true, traversal is
// aborted.
// Returns the first truthy value returned by action, or the last falsey
// value returned by action.
SortedMap.prototype.reverseTraversal=function(action){return this.root.reverseTraversal(action);};// Returns an iterator over the SortedMap.
SortedMap.prototype.getIterator=function(){return new SortedMapIterator(this.root,null,this.comparator,false);};SortedMap.prototype.getIteratorFrom=function(key){return new SortedMapIterator(this.root,key,this.comparator,false);};SortedMap.prototype.getReverseIterator=function(){return new SortedMapIterator(this.root,null,this.comparator,true);};SortedMap.prototype.getReverseIteratorFrom=function(key){return new SortedMapIterator(this.root,key,this.comparator,true);};return SortedMap;}();// end SortedMap
// An iterator over an LLRBNode.
var SortedMapIterator=/** @class */function(){function SortedMapIterator(node,startKey,comparator,isReverse){this.isReverse=isReverse;this.nodeStack=[];var cmp=1;while(!node.isEmpty()){cmp=startKey?comparator(node.key,startKey):1;// flip the comparison if we're going in reverse
if(isReverse)cmp*=-1;if(cmp<0){// This node is less than our start key. ignore it
if(this.isReverse){node=node.left;}else{node=node.right;}}else if(cmp===0){// This node is exactly equal to our start key. Push it on the stack,
// but stop iterating;
this.nodeStack.push(node);break;}else{// This node is greater than our start key, add it to the stack and move
// to the next one
this.nodeStack.push(node);if(this.isReverse){node=node.right;}else{node=node.left;}}}}SortedMapIterator.prototype.getNext=function(){assert(this.nodeStack.length>0,'getNext() called on iterator when hasNext() is false.');var node=this.nodeStack.pop();var result={key:node.key,value:node.value};if(this.isReverse){node=node.left;while(!node.isEmpty()){this.nodeStack.push(node);node=node.right;}}else{node=node.right;while(!node.isEmpty()){this.nodeStack.push(node);node=node.left;}}return result;};SortedMapIterator.prototype.hasNext=function(){return this.nodeStack.length>0;};SortedMapIterator.prototype.peek=function(){if(this.nodeStack.length===0)return null;var node=this.nodeStack[this.nodeStack.length-1];return{key:node.key,value:node.value};};return SortedMapIterator;}();// end SortedMapIterator
// Represents a node in a Left-leaning Red-Black tree.
var LLRBNode=/** @class */function(){function LLRBNode(key,value,color,left,right){this.key=key;this.value=value;this.color=color!=null?color:LLRBNode.RED;this.left=left!=null?left:LLRBNode.EMPTY;this.right=right!=null?right:LLRBNode.EMPTY;this.size=this.left.size+1+this.right.size;}// Returns a copy of the current node, optionally replacing pieces of it.
LLRBNode.prototype.copy=function(key,value,color,left,right){return new LLRBNode(key!=null?key:this.key,value!=null?value:this.value,color!=null?color:this.color,left!=null?left:this.left,right!=null?right:this.right);};LLRBNode.prototype.isEmpty=function(){return false;};// Traverses the tree in key order and calls the specified action function
// for each node. If action returns true, traversal is aborted.
// Returns the first truthy value returned by action, or the last falsey
// value returned by action.
LLRBNode.prototype.inorderTraversal=function(action){return this.left.inorderTraversal(action)||action(this.key,this.value)||this.right.inorderTraversal(action);};// Traverses the tree in reverse key order and calls the specified action
// function for each node. If action returns true, traversal is aborted.
// Returns the first truthy value returned by action, or the last falsey
// value returned by action.
LLRBNode.prototype.reverseTraversal=function(action){return this.right.reverseTraversal(action)||action(this.key,this.value)||this.left.reverseTraversal(action);};// Returns the minimum node in the tree.
LLRBNode.prototype.min=function(){if(this.left.isEmpty()){return this;}else{return this.left.min();}};// Returns the maximum key in the tree.
LLRBNode.prototype.minKey=function(){return this.min().key;};// Returns the maximum key in the tree.
LLRBNode.prototype.maxKey=function(){if(this.right.isEmpty()){return this.key;}else{return this.right.maxKey();}};// Returns new tree, with the key/value added.
LLRBNode.prototype.insert=function(key,value,comparator){var n=this;var cmp=comparator(key,n.key);if(cmp<0){n=n.copy(null,null,null,n.left.insert(key,value,comparator),null);}else if(cmp===0){n=n.copy(null,value,null,null,null);}else{n=n.copy(null,null,null,null,n.right.insert(key,value,comparator));}return n.fixUp();};LLRBNode.prototype.removeMin=function(){if(this.left.isEmpty()){return LLRBNode.EMPTY;}var n=this;if(!n.left.isRed()&&!n.left.left.isRed())n=n.moveRedLeft();n=n.copy(null,null,null,n.left.removeMin(),null);return n.fixUp();};// Returns new tree, with the specified item removed.
LLRBNode.prototype.remove=function(key,comparator){var smallest;var n=this;if(comparator(key,n.key)<0){if(!n.left.isEmpty()&&!n.left.isRed()&&!n.left.left.isRed()){n=n.moveRedLeft();}n=n.copy(null,null,null,n.left.remove(key,comparator),null);}else{if(n.left.isRed())n=n.rotateRight();if(!n.right.isEmpty()&&!n.right.isRed()&&!n.right.left.isRed()){n=n.moveRedRight();}if(comparator(key,n.key)===0){if(n.right.isEmpty()){return LLRBNode.EMPTY;}else{smallest=n.right.min();n=n.copy(smallest.key,smallest.value,null,null,n.right.removeMin());}}n=n.copy(null,null,null,null,n.right.remove(key,comparator));}return n.fixUp();};LLRBNode.prototype.isRed=function(){return this.color;};// Returns new tree after performing any needed rotations.
LLRBNode.prototype.fixUp=function(){var n=this;if(n.right.isRed()&&!n.left.isRed())n=n.rotateLeft();if(n.left.isRed()&&n.left.left.isRed())n=n.rotateRight();if(n.left.isRed()&&n.right.isRed())n=n.colorFlip();return n;};LLRBNode.prototype.moveRedLeft=function(){var n=this.colorFlip();if(n.right.left.isRed()){n=n.copy(null,null,null,null,n.right.rotateRight());n=n.rotateLeft();n=n.colorFlip();}return n;};LLRBNode.prototype.moveRedRight=function(){var n=this.colorFlip();if(n.left.left.isRed()){n=n.rotateRight();n=n.colorFlip();}return n;};LLRBNode.prototype.rotateLeft=function(){var nl=this.copy(null,null,LLRBNode.RED,null,this.right.left);return this.right.copy(null,null,this.color,nl,null);};LLRBNode.prototype.rotateRight=function(){var nr=this.copy(null,null,LLRBNode.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,nr);};LLRBNode.prototype.colorFlip=function(){var left=this.left.copy(null,null,!this.left.color,null,null);var right=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,left,right);};// For testing.
LLRBNode.prototype.checkMaxDepth=function(){var blackDepth=this.check();if(Math.pow(2.0,blackDepth)<=this.size+1){return true;}else{return false;}};// In a balanced RB tree, the black-depth (number of black nodes) from root to
// leaves is equal on both sides.  This function verifies that or asserts.
LLRBNode.prototype.check=function(){if(this.isRed()&&this.left.isRed()){throw fail('Red node has red child('+this.key+','+this.value+')');}if(this.right.isRed()){throw fail('Right child of ('+this.key+','+this.value+') is red');}var blackDepth=this.left.check();if(blackDepth!==this.right.check()){throw fail('Black depths differ');}else{return blackDepth+(this.isRed()?0:1);}};// tslint:disable-next-line:no-any Empty node is shared between all LLRB trees.
LLRBNode.EMPTY=null;LLRBNode.RED=true;LLRBNode.BLACK=false;return LLRBNode;}();// end LLRBNode
// Represents an empty node (a leaf node in the Red-Black Tree).
var LLRBEmptyNode=/** @class */function(){function LLRBEmptyNode(){this.size=0;}// Returns a copy of the current node.
LLRBEmptyNode.prototype.copy=function(key,value,color,left,right){return this;};// Returns a copy of the tree, with the specified key/value added.
LLRBEmptyNode.prototype.insert=function(key,value,comparator){return new LLRBNode(key,value);};// Returns a copy of the tree, with the specified key removed.
LLRBEmptyNode.prototype.remove=function(key,comparator){return this;};LLRBEmptyNode.prototype.isEmpty=function(){return true;};LLRBEmptyNode.prototype.inorderTraversal=function(action){return false;};LLRBEmptyNode.prototype.reverseTraversal=function(action){return false;};LLRBEmptyNode.prototype.minKey=function(){return null;};LLRBEmptyNode.prototype.maxKey=function(){return null;};LLRBEmptyNode.prototype.isRed=function(){return false;};// For testing.
LLRBEmptyNode.prototype.checkMaxDepth=function(){return true;};LLRBEmptyNode.prototype.check=function(){return 0;};return LLRBEmptyNode;}();// end LLRBEmptyNode
LLRBNode.EMPTY=new LLRBEmptyNode();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var TypeOrder;(function(TypeOrder){// This order is defined by the backend.
TypeOrder[TypeOrder["NullValue"]=0]="NullValue";TypeOrder[TypeOrder["BooleanValue"]=1]="BooleanValue";TypeOrder[TypeOrder["NumberValue"]=2]="NumberValue";TypeOrder[TypeOrder["TimestampValue"]=3]="TimestampValue";TypeOrder[TypeOrder["StringValue"]=4]="StringValue";TypeOrder[TypeOrder["BlobValue"]=5]="BlobValue";TypeOrder[TypeOrder["RefValue"]=6]="RefValue";TypeOrder[TypeOrder["GeoPointValue"]=7]="GeoPointValue";TypeOrder[TypeOrder["ArrayValue"]=8]="ArrayValue";TypeOrder[TypeOrder["ObjectValue"]=9]="ObjectValue";})(TypeOrder||(TypeOrder={}));/** Defines the return value for pending server timestamps. */var ServerTimestampBehavior;(function(ServerTimestampBehavior){ServerTimestampBehavior[ServerTimestampBehavior["Default"]=0]="Default";ServerTimestampBehavior[ServerTimestampBehavior["Estimate"]=1]="Estimate";ServerTimestampBehavior[ServerTimestampBehavior["Previous"]=2]="Previous";})(ServerTimestampBehavior||(ServerTimestampBehavior={}));/** Holds properties that define field value deserialization options. */var FieldValueOptions=/** @class */function(){function FieldValueOptions(serverTimestampBehavior,timestampsInSnapshots){this.serverTimestampBehavior=serverTimestampBehavior;this.timestampsInSnapshots=timestampsInSnapshots;}FieldValueOptions.fromSnapshotOptions=function(options,timestampsInSnapshots){switch(options.serverTimestamps){case'estimate':return new FieldValueOptions(ServerTimestampBehavior.Estimate,timestampsInSnapshots);case'previous':return new FieldValueOptions(ServerTimestampBehavior.Previous,timestampsInSnapshots);case'none':// Fall-through intended.
case undefined:return new FieldValueOptions(ServerTimestampBehavior.Default,timestampsInSnapshots);default:return fail('fromSnapshotOptions() called with invalid options.');}};return FieldValueOptions;}();/**
 * A field value represents a datatype as stored by Firestore.
 */var FieldValue=/** @class */function(){function FieldValue(){}FieldValue.prototype.toString=function(){var val=this.value();return val===null?'null':val.toString();};FieldValue.prototype.defaultCompareTo=function(other){assert(this.typeOrder!==other.typeOrder,'Default compareTo should not be used for values of same type.');var cmp=primitiveComparator(this.typeOrder,other.typeOrder);return cmp;};return FieldValue;}();var NullValue=/** @class */function(_super){tslib_1.__extends(NullValue,_super);function NullValue(){var _this=_super.call(this)||this;_this.typeOrder=TypeOrder.NullValue;// internalValue is unused but we add it to work around
// https://github.com/Microsoft/TypeScript/issues/15585
_this.internalValue=null;return _this;}NullValue.prototype.value=function(options){return null;};NullValue.prototype.isEqual=function(other){return other instanceof NullValue;};NullValue.prototype.compareTo=function(other){if(other instanceof NullValue){return 0;}return this.defaultCompareTo(other);};NullValue.INSTANCE=new NullValue();return NullValue;}(FieldValue);var BooleanValue=/** @class */function(_super){tslib_1.__extends(BooleanValue,_super);function BooleanValue(internalValue){var _this=_super.call(this)||this;_this.internalValue=internalValue;_this.typeOrder=TypeOrder.BooleanValue;return _this;}BooleanValue.prototype.value=function(options){return this.internalValue;};BooleanValue.prototype.isEqual=function(other){return other instanceof BooleanValue&&this.internalValue===other.internalValue;};BooleanValue.prototype.compareTo=function(other){if(other instanceof BooleanValue){return primitiveComparator(this,other);}return this.defaultCompareTo(other);};BooleanValue.of=function(value){return value?BooleanValue.TRUE:BooleanValue.FALSE;};BooleanValue.TRUE=new BooleanValue(true);BooleanValue.FALSE=new BooleanValue(false);return BooleanValue;}(FieldValue);/** Base class for IntegerValue and DoubleValue. */var NumberValue=/** @class */function(_super){tslib_1.__extends(NumberValue,_super);function NumberValue(internalValue){var _this=_super.call(this)||this;_this.internalValue=internalValue;_this.typeOrder=TypeOrder.NumberValue;return _this;}NumberValue.prototype.value=function(options){return this.internalValue;};NumberValue.prototype.compareTo=function(other){if(other instanceof NumberValue){return numericComparator(this.internalValue,other.internalValue);}return this.defaultCompareTo(other);};return NumberValue;}(FieldValue);/** Utility function to compare doubles (using Firestore semantics for NaN). */function numericComparator(left,right){if(left<right){return-1;}else if(left>right){return 1;}else if(left===right){return 0;}else{// one or both are NaN.
if(isNaN(left)){return isNaN(right)?0:-1;}else{return 1;}}}/**
 * Utility function to check numbers for equality using Firestore semantics
 * (NaN === NaN, -0.0 !== 0.0).
 */function numericEquals(left,right){// Implemented based on Object.is() polyfill from
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
if(left===right){// +0 != -0
return left!==0||1/left===1/right;}else{// NaN == NaN
return left!==left&&right!==right;}}var IntegerValue=/** @class */function(_super){tslib_1.__extends(IntegerValue,_super);function IntegerValue(internalValue){return _super.call(this,internalValue)||this;}IntegerValue.prototype.isEqual=function(other){// NOTE: DoubleValue and IntegerValue instances may compareTo() the same,
// but that doesn't make them equal via isEqual().
if(other instanceof IntegerValue){return numericEquals(this.internalValue,other.internalValue);}else{return false;}};return IntegerValue;}(NumberValue);var DoubleValue=/** @class */function(_super){tslib_1.__extends(DoubleValue,_super);function DoubleValue(internalValue){var _this=_super.call(this,internalValue)||this;_this.internalValue=internalValue;return _this;}DoubleValue.prototype.isEqual=function(other){// NOTE: DoubleValue and IntegerValue instances may compareTo() the same,
// but that doesn't make them equal via isEqual().
if(other instanceof DoubleValue){return numericEquals(this.internalValue,other.internalValue);}else{return false;}};DoubleValue.NAN=new DoubleValue(NaN);DoubleValue.POSITIVE_INFINITY=new DoubleValue(Infinity);DoubleValue.NEGATIVE_INFINITY=new DoubleValue(-Infinity);return DoubleValue;}(NumberValue);// TODO(b/37267885): Add truncation support
var StringValue=/** @class */function(_super){tslib_1.__extends(StringValue,_super);function StringValue(internalValue){var _this=_super.call(this)||this;_this.internalValue=internalValue;_this.typeOrder=TypeOrder.StringValue;return _this;}StringValue.prototype.value=function(options){return this.internalValue;};StringValue.prototype.isEqual=function(other){return other instanceof StringValue&&this.internalValue===other.internalValue;};StringValue.prototype.compareTo=function(other){if(other instanceof StringValue){return primitiveComparator(this.internalValue,other.internalValue);}return this.defaultCompareTo(other);};return StringValue;}(FieldValue);var TimestampValue=/** @class */function(_super){tslib_1.__extends(TimestampValue,_super);function TimestampValue(internalValue){var _this=_super.call(this)||this;_this.internalValue=internalValue;_this.typeOrder=TypeOrder.TimestampValue;return _this;}TimestampValue.prototype.value=function(options){if(!options||options.timestampsInSnapshots){return this.internalValue;}else{return this.internalValue.toDate();}};TimestampValue.prototype.isEqual=function(other){return other instanceof TimestampValue&&this.internalValue.isEqual(other.internalValue);};TimestampValue.prototype.compareTo=function(other){if(other instanceof TimestampValue){return this.internalValue._compareTo(other.internalValue);}else if(other instanceof ServerTimestampValue){// Concrete timestamps come before server timestamps.
return-1;}else{return this.defaultCompareTo(other);}};return TimestampValue;}(FieldValue);/**
 * Represents a locally-applied ServerTimestamp.
 *
 * Notes:
 * - ServerTimestampValue instances are created as the result of applying a
 *   TransformMutation (see TransformMutation.applyTo()). They can only exist in
 *   the local view of a document. Therefore they do not need to be parsed or
 *   serialized.
 * - When evaluated locally (e.g. for snapshot.data()), they by default
 *   evaluate to `null`. This behavior can be configured by passing custom
 *   FieldValueOptions to value().
 * - With respect to other ServerTimestampValues, they sort by their
 *   localWriteTime.
 */var ServerTimestampValue=/** @class */function(_super){tslib_1.__extends(ServerTimestampValue,_super);function ServerTimestampValue(localWriteTime,previousValue){var _this=_super.call(this)||this;_this.localWriteTime=localWriteTime;_this.previousValue=previousValue;_this.typeOrder=TypeOrder.TimestampValue;return _this;}ServerTimestampValue.prototype.value=function(options){if(options&&options.serverTimestampBehavior===ServerTimestampBehavior.Estimate){return new TimestampValue(this.localWriteTime).value(options);}else if(options&&options.serverTimestampBehavior===ServerTimestampBehavior.Previous){return this.previousValue?this.previousValue.value(options):null;}else{return null;}};ServerTimestampValue.prototype.isEqual=function(other){return other instanceof ServerTimestampValue&&this.localWriteTime.isEqual(other.localWriteTime);};ServerTimestampValue.prototype.compareTo=function(other){if(other instanceof ServerTimestampValue){return this.localWriteTime._compareTo(other.localWriteTime);}else if(other instanceof TimestampValue){// Server timestamps come after all concrete timestamps.
return 1;}else{return this.defaultCompareTo(other);}};ServerTimestampValue.prototype.toString=function(){return'<ServerTimestamp localTime='+this.localWriteTime.toString()+'>';};return ServerTimestampValue;}(FieldValue);var BlobValue=/** @class */function(_super){tslib_1.__extends(BlobValue,_super);function BlobValue(internalValue){var _this=_super.call(this)||this;_this.internalValue=internalValue;_this.typeOrder=TypeOrder.BlobValue;return _this;}BlobValue.prototype.value=function(options){return this.internalValue;};BlobValue.prototype.isEqual=function(other){return other instanceof BlobValue&&this.internalValue.isEqual(other.internalValue);};BlobValue.prototype.compareTo=function(other){if(other instanceof BlobValue){return this.internalValue._compareTo(other.internalValue);}return this.defaultCompareTo(other);};return BlobValue;}(FieldValue);var RefValue=/** @class */function(_super){tslib_1.__extends(RefValue,_super);function RefValue(databaseId,key){var _this=_super.call(this)||this;_this.databaseId=databaseId;_this.key=key;_this.typeOrder=TypeOrder.RefValue;return _this;}RefValue.prototype.value=function(options){return this.key;};RefValue.prototype.isEqual=function(other){if(other instanceof RefValue){return this.key.isEqual(other.key)&&this.databaseId.isEqual(other.databaseId);}else{return false;}};RefValue.prototype.compareTo=function(other){if(other instanceof RefValue){var cmp=this.databaseId.compareTo(other.databaseId);return cmp!==0?cmp:DocumentKey.comparator(this.key,other.key);}return this.defaultCompareTo(other);};return RefValue;}(FieldValue);var GeoPointValue=/** @class */function(_super){tslib_1.__extends(GeoPointValue,_super);function GeoPointValue(internalValue){var _this=_super.call(this)||this;_this.internalValue=internalValue;_this.typeOrder=TypeOrder.GeoPointValue;return _this;}GeoPointValue.prototype.value=function(options){return this.internalValue;};GeoPointValue.prototype.isEqual=function(other){return other instanceof GeoPointValue&&this.internalValue.isEqual(other.internalValue);};GeoPointValue.prototype.compareTo=function(other){if(other instanceof GeoPointValue){return this.internalValue._compareTo(other.internalValue);}return this.defaultCompareTo(other);};return GeoPointValue;}(FieldValue);var ObjectValue=/** @class */function(_super){tslib_1.__extends(ObjectValue,_super);function ObjectValue(internalValue){var _this=_super.call(this)||this;_this.internalValue=internalValue;_this.typeOrder=TypeOrder.ObjectValue;return _this;}ObjectValue.prototype.value=function(options){var result={};this.internalValue.inorderTraversal(function(key,val){result[key]=val.value(options);});return result;};ObjectValue.prototype.forEach=function(action){this.internalValue.inorderTraversal(action);};ObjectValue.prototype.isEqual=function(other){if(other instanceof ObjectValue){var it1=this.internalValue.getIterator();var it2=other.internalValue.getIterator();while(it1.hasNext()&&it2.hasNext()){var next1=it1.getNext();var next2=it2.getNext();if(next1.key!==next2.key||!next1.value.isEqual(next2.value)){return false;}}return!it1.hasNext()&&!it2.hasNext();}return false;};ObjectValue.prototype.compareTo=function(other){if(other instanceof ObjectValue){var it1=this.internalValue.getIterator();var it2=other.internalValue.getIterator();while(it1.hasNext()&&it2.hasNext()){var next1=it1.getNext();var next2=it2.getNext();var cmp=primitiveComparator(next1.key,next2.key)||next1.value.compareTo(next2.value);if(cmp){return cmp;}}// Only equal if both iterators are exhausted
return primitiveComparator(it1.hasNext(),it2.hasNext());}else{return this.defaultCompareTo(other);}};ObjectValue.prototype.set=function(path,to){assert(!path.isEmpty(),'Cannot set field for empty path on ObjectValue');if(path.length===1){return this.setChild(path.firstSegment(),to);}else{var child=this.child(path.firstSegment());if(!(child instanceof ObjectValue)){child=ObjectValue.EMPTY;}var newChild=child.set(path.popFirst(),to);return this.setChild(path.firstSegment(),newChild);}};ObjectValue.prototype.delete=function(path){assert(!path.isEmpty(),'Cannot delete field for empty path on ObjectValue');if(path.length===1){return new ObjectValue(this.internalValue.remove(path.firstSegment()));}else{// nested field
var child=this.child(path.firstSegment());if(child instanceof ObjectValue){var newChild=child.delete(path.popFirst());return new ObjectValue(this.internalValue.insert(path.firstSegment(),newChild));}else{// Don't actually change a primitive value to an object for a delete
return this;}}};ObjectValue.prototype.contains=function(path){return this.field(path)!==undefined;};ObjectValue.prototype.field=function(path){assert(!path.isEmpty(),"Can't get field of empty path");var field=this;path.forEach(function(pathSegment){if(field instanceof ObjectValue){field=field.internalValue.get(pathSegment)||undefined;}else{field=undefined;}});return field;};ObjectValue.prototype.toString=function(){return this.internalValue.toString();};ObjectValue.prototype.child=function(childName){return this.internalValue.get(childName)||undefined;};ObjectValue.prototype.setChild=function(childName,value){return new ObjectValue(this.internalValue.insert(childName,value));};ObjectValue.EMPTY=new ObjectValue(new SortedMap(primitiveComparator));return ObjectValue;}(FieldValue);var ArrayValue=/** @class */function(_super){tslib_1.__extends(ArrayValue,_super);function ArrayValue(internalValue){var _this=_super.call(this)||this;_this.internalValue=internalValue;_this.typeOrder=TypeOrder.ArrayValue;return _this;}ArrayValue.prototype.value=function(options){return this.internalValue.map(function(v){return v.value(options);});};ArrayValue.prototype.forEach=function(action){this.internalValue.forEach(action);};ArrayValue.prototype.isEqual=function(other){if(other instanceof ArrayValue){if(this.internalValue.length!==other.internalValue.length){return false;}for(var i=0;i<this.internalValue.length;i++){if(!this.internalValue[i].isEqual(other.internalValue[i])){return false;}}return true;}return false;};ArrayValue.prototype.compareTo=function(other){if(other instanceof ArrayValue){var minLength=Math.min(this.internalValue.length,other.internalValue.length);for(var i=0;i<minLength;i++){var cmp=this.internalValue[i].compareTo(other.internalValue[i]);if(cmp){return cmp;}}return primitiveComparator(this.internalValue.length,other.internalValue.length);}else{return this.defaultCompareTo(other);}};ArrayValue.prototype.toString=function(){var descriptions=this.internalValue.map(function(v){return v.toString();});return"["+descriptions.join(',')+"]";};return ArrayValue;}(FieldValue);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */// Untyped Number alias we can use to check for ES6 methods / properties.
// tslint:disable-next-line:no-any variable-name
var NumberAsAny=Number;/**
 * Minimum safe integer in Javascript because of floating point precision.
 * Added to not rely on ES6 features.
 */var MIN_SAFE_INTEGER=NumberAsAny.MIN_SAFE_INTEGER||-(Math.pow(2,53)-1);/**
 * Maximum safe integer in Javascript because of floating point precision.
 * Added to not rely on ES6 features.
 */var MAX_SAFE_INTEGER=NumberAsAny.MAX_SAFE_INTEGER||Math.pow(2,53)-1;/**
 * Returns whether an number is an integer, uses native implementation if
 * available.
 * Added to not rely on ES6 features.
 * @param value The value to test for being an integer
 */var isInteger=NumberAsAny.isInteger||function(value){return typeof value==='number'&&isFinite(value)&&Math.floor(value)===value;};/**
 * Returns whether a variable is either undefined or null.
 */function isNullOrUndefined(value){return value===null||value===undefined;}/**
 * Returns whether a value is an integer and in the safe integer range
 * @param value The value to test for being an integer and in the safe range
 */function isSafeInteger(value){return isInteger(value)&&value<=MAX_SAFE_INTEGER&&value>=MIN_SAFE_INTEGER;}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Query=/** @class */function(){/**
     * Initializes a Query with a path and optional additional query constraints.
     * Path must currently be empty if this is a collection group query.
     */function Query(path,collectionGroup,explicitOrderBy,filters,limit,startAt,endAt){if(collectionGroup===void 0){collectionGroup=null;}if(explicitOrderBy===void 0){explicitOrderBy=[];}if(filters===void 0){filters=[];}if(limit===void 0){limit=null;}if(startAt===void 0){startAt=null;}if(endAt===void 0){endAt=null;}this.path=path;this.collectionGroup=collectionGroup;this.explicitOrderBy=explicitOrderBy;this.filters=filters;this.limit=limit;this.startAt=startAt;this.endAt=endAt;this.memoizedCanonicalId=null;this.memoizedOrderBy=null;if(this.startAt){this.assertValidBound(this.startAt);}if(this.endAt){this.assertValidBound(this.endAt);}}Query.atPath=function(path){return new Query(path);};Object.defineProperty(Query.prototype,"orderBy",{get:function(){if(this.memoizedOrderBy===null){var inequalityField=this.getInequalityFilterField();var firstOrderByField=this.getFirstOrderByField();if(inequalityField!==null&&firstOrderByField===null){// In order to implicitly add key ordering, we must also add the
// inequality filter field for it to be a valid query.
// Note that the default inequality field and key ordering is ascending.
if(inequalityField.isKeyField()){this.memoizedOrderBy=[KEY_ORDERING_ASC];}else{this.memoizedOrderBy=[new OrderBy(inequalityField),KEY_ORDERING_ASC];}}else{assert(inequalityField===null||firstOrderByField!==null&&inequalityField.isEqual(firstOrderByField),'First orderBy should match inequality field.');this.memoizedOrderBy=[];var foundKeyOrdering=false;for(var _i=0,_a=this.explicitOrderBy;_i<_a.length;_i++){var orderBy=_a[_i];this.memoizedOrderBy.push(orderBy);if(orderBy.field.isKeyField()){foundKeyOrdering=true;}}if(!foundKeyOrdering){// The order of the implicit key ordering always matches the last
// explicit order by
var lastDirection=this.explicitOrderBy.length>0?this.explicitOrderBy[this.explicitOrderBy.length-1].dir:Direction.ASCENDING;this.memoizedOrderBy.push(lastDirection===Direction.ASCENDING?KEY_ORDERING_ASC:KEY_ORDERING_DESC);}}}return this.memoizedOrderBy;},enumerable:true,configurable:true});Query.prototype.addFilter=function(filter){assert(this.getInequalityFilterField()==null||!(filter instanceof RelationFilter)||!filter.isInequality()||filter.field.isEqual(this.getInequalityFilterField()),'Query must only have one inequality field.');assert(!this.isDocumentQuery(),'No filtering allowed for document query');var newFilters=this.filters.concat([filter]);return new Query(this.path,this.collectionGroup,this.explicitOrderBy.slice(),newFilters,this.limit,this.startAt,this.endAt);};Query.prototype.addOrderBy=function(orderBy){assert(!this.startAt&&!this.endAt,'Bounds must be set after orderBy');// TODO(dimond): validate that orderBy does not list the same key twice.
var newOrderBy=this.explicitOrderBy.concat([orderBy]);return new Query(this.path,this.collectionGroup,newOrderBy,this.filters.slice(),this.limit,this.startAt,this.endAt);};Query.prototype.withLimit=function(limit){return new Query(this.path,this.collectionGroup,this.explicitOrderBy.slice(),this.filters.slice(),limit,this.startAt,this.endAt);};Query.prototype.withStartAt=function(bound){return new Query(this.path,this.collectionGroup,this.explicitOrderBy.slice(),this.filters.slice(),this.limit,bound,this.endAt);};Query.prototype.withEndAt=function(bound){return new Query(this.path,this.collectionGroup,this.explicitOrderBy.slice(),this.filters.slice(),this.limit,this.startAt,bound);};/**
     * Helper to convert a collection group query into a collection query at a
     * specific path. This is used when executing collection group queries, since
     * we have to split the query into a set of collection queries at multiple
     * paths.
     */Query.prototype.asCollectionQueryAtPath=function(path){return new Query(path,/*collectionGroup=*/null,this.explicitOrderBy.slice(),this.filters.slice(),this.limit,this.startAt,this.endAt);};// TODO(b/29183165): This is used to get a unique string from a query to, for
// example, use as a dictionary key, but the implementation is subject to
// collisions. Make it collision-free.
Query.prototype.canonicalId=function(){if(this.memoizedCanonicalId===null){var canonicalId=this.path.canonicalString();if(this.isCollectionGroupQuery()){canonicalId+='|cg:'+this.collectionGroup;}canonicalId+='|f:';for(var _i=0,_a=this.filters;_i<_a.length;_i++){var filter=_a[_i];canonicalId+=filter.canonicalId();canonicalId+=',';}canonicalId+='|ob:';// TODO(dimond): make this collision resistant
for(var _b=0,_c=this.orderBy;_b<_c.length;_b++){var orderBy=_c[_b];canonicalId+=orderBy.canonicalId();canonicalId+=',';}if(!isNullOrUndefined(this.limit)){canonicalId+='|l:';canonicalId+=this.limit;}if(this.startAt){canonicalId+='|lb:';canonicalId+=this.startAt.canonicalId();}if(this.endAt){canonicalId+='|ub:';canonicalId+=this.endAt.canonicalId();}this.memoizedCanonicalId=canonicalId;}return this.memoizedCanonicalId;};Query.prototype.toString=function(){var str='Query('+this.path.canonicalString();if(this.isCollectionGroupQuery()){str+=' collectionGroup='+this.collectionGroup;}if(this.filters.length>0){str+=", filters: ["+this.filters.join(', ')+"]";}if(!isNullOrUndefined(this.limit)){str+=', limit: '+this.limit;}if(this.explicitOrderBy.length>0){str+=", orderBy: ["+this.explicitOrderBy.join(', ')+"]";}if(this.startAt){str+=', startAt: '+this.startAt.canonicalId();}if(this.endAt){str+=', endAt: '+this.endAt.canonicalId();}return str+')';};Query.prototype.isEqual=function(other){if(this.limit!==other.limit){return false;}if(this.orderBy.length!==other.orderBy.length){return false;}for(var i=0;i<this.orderBy.length;i++){if(!this.orderBy[i].isEqual(other.orderBy[i])){return false;}}if(this.filters.length!==other.filters.length){return false;}for(var i=0;i<this.filters.length;i++){if(!this.filters[i].isEqual(other.filters[i])){return false;}}if(this.collectionGroup!==other.collectionGroup){return false;}if(!this.path.isEqual(other.path)){return false;}if(this.startAt!==null?!this.startAt.isEqual(other.startAt):other.startAt!==null){return false;}return this.endAt!==null?this.endAt.isEqual(other.endAt):other.endAt===null;};Query.prototype.docComparator=function(d1,d2){var comparedOnKeyField=false;for(var _i=0,_a=this.orderBy;_i<_a.length;_i++){var orderBy=_a[_i];var comp=orderBy.compare(d1,d2);if(comp!==0)return comp;comparedOnKeyField=comparedOnKeyField||orderBy.field.isKeyField();}// Assert that we actually compared by key
assert(comparedOnKeyField,"orderBy used that doesn't compare on key field");return 0;};Query.prototype.matches=function(doc){return this.matchesPathAndCollectionGroup(doc)&&this.matchesOrderBy(doc)&&this.matchesFilters(doc)&&this.matchesBounds(doc);};Query.prototype.hasLimit=function(){return!isNullOrUndefined(this.limit);};Query.prototype.getFirstOrderByField=function(){return this.explicitOrderBy.length>0?this.explicitOrderBy[0].field:null;};Query.prototype.getInequalityFilterField=function(){for(var _i=0,_a=this.filters;_i<_a.length;_i++){var filter=_a[_i];if(filter instanceof RelationFilter&&filter.isInequality()){return filter.field;}}return null;};Query.prototype.hasArrayContainsFilter=function(){return this.filters.find(function(filter){return filter instanceof RelationFilter&&filter.op===RelationOp.ARRAY_CONTAINS;})!==undefined;};Query.prototype.isDocumentQuery=function(){return DocumentKey.isDocumentKey(this.path)&&this.collectionGroup===null&&this.filters.length===0;};Query.prototype.isCollectionGroupQuery=function(){return this.collectionGroup!==null;};Query.prototype.matchesPathAndCollectionGroup=function(doc){var docPath=doc.key.path;if(this.collectionGroup!==null){// NOTE: this.path is currently always empty since we don't expose Collection
// Group queries rooted at a document path yet.
return doc.key.hasCollectionId(this.collectionGroup)&&this.path.isPrefixOf(docPath);}else if(DocumentKey.isDocumentKey(this.path)){// exact match for document queries
return this.path.isEqual(docPath);}else{// shallow ancestor queries by default
return this.path.isImmediateParentOf(docPath);}};/**
     * A document must have a value for every ordering clause in order to show up
     * in the results.
     */Query.prototype.matchesOrderBy=function(doc){for(var _i=0,_a=this.explicitOrderBy;_i<_a.length;_i++){var orderBy=_a[_i];// order by key always matches
if(!orderBy.field.isKeyField()&&doc.field(orderBy.field)===undefined){return false;}}return true;};Query.prototype.matchesFilters=function(doc){for(var _i=0,_a=this.filters;_i<_a.length;_i++){var filter=_a[_i];if(!filter.matches(doc)){return false;}}return true;};/**
     * Makes sure a document is within the bounds, if provided.
     */Query.prototype.matchesBounds=function(doc){if(this.startAt&&!this.startAt.sortsBeforeDocument(this.orderBy,doc)){return false;}if(this.endAt&&this.endAt.sortsBeforeDocument(this.orderBy,doc)){return false;}return true;};Query.prototype.assertValidBound=function(bound){assert(bound.position.length<=this.orderBy.length,'Bound is longer than orderBy');};return Query;}();var Filter=/** @class */function(){function Filter(){}/**
     * Creates a filter based on the provided arguments.
     */Filter.create=function(field,op,value){if(value.isEqual(NullValue.INSTANCE)){if(op!==RelationOp.EQUAL){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You can only perform equals comparisons on null.');}return new NullFilter(field);}else if(value.isEqual(DoubleValue.NAN)){if(op!==RelationOp.EQUAL){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You can only perform equals comparisons on NaN.');}return new NanFilter(field);}else{return new RelationFilter(field,op,value);}};return Filter;}();var RelationOp=/** @class */function(){function RelationOp(name){this.name=name;}RelationOp.fromString=function(op){switch(op){case'<':return RelationOp.LESS_THAN;case'<=':return RelationOp.LESS_THAN_OR_EQUAL;case'==':return RelationOp.EQUAL;case'>=':return RelationOp.GREATER_THAN_OR_EQUAL;case'>':return RelationOp.GREATER_THAN;case'array-contains':return RelationOp.ARRAY_CONTAINS;default:return fail('Unknown relation: '+op);}};RelationOp.prototype.toString=function(){return this.name;};RelationOp.prototype.isEqual=function(other){return this.name===other.name;};RelationOp.LESS_THAN=new RelationOp('<');RelationOp.LESS_THAN_OR_EQUAL=new RelationOp('<=');RelationOp.EQUAL=new RelationOp('==');RelationOp.GREATER_THAN=new RelationOp('>');RelationOp.GREATER_THAN_OR_EQUAL=new RelationOp('>=');RelationOp.ARRAY_CONTAINS=new RelationOp('array-contains');return RelationOp;}();var RelationFilter=/** @class */function(_super){tslib_1.__extends(RelationFilter,_super);function RelationFilter(field,op,value){var _this=_super.call(this)||this;_this.field=field;_this.op=op;_this.value=value;return _this;}RelationFilter.prototype.matches=function(doc){if(this.field.isKeyField()){assert(this.value instanceof RefValue,'Comparing on key, but filter value not a RefValue');assert(this.op!==RelationOp.ARRAY_CONTAINS,"array-contains queries don't make sense on document keys.");var refValue=this.value;var comparison=DocumentKey.comparator(doc.key,refValue.key);return this.matchesComparison(comparison);}else{var val=doc.field(this.field);return val!==undefined&&this.matchesValue(val);}};RelationFilter.prototype.matchesValue=function(value){var _this=this;if(this.op===RelationOp.ARRAY_CONTAINS){return value instanceof ArrayValue&&value.internalValue.find(function(element){return element.isEqual(_this.value);})!==undefined;}else{// Only compare types with matching backend order (such as double and int).
return this.value.typeOrder===value.typeOrder&&this.matchesComparison(value.compareTo(this.value));}};RelationFilter.prototype.matchesComparison=function(comparison){switch(this.op){case RelationOp.LESS_THAN:return comparison<0;case RelationOp.LESS_THAN_OR_EQUAL:return comparison<=0;case RelationOp.EQUAL:return comparison===0;case RelationOp.GREATER_THAN:return comparison>0;case RelationOp.GREATER_THAN_OR_EQUAL:return comparison>=0;default:return fail('Unknown relation op'+this.op);}};RelationFilter.prototype.isInequality=function(){return this.op!==RelationOp.EQUAL&&this.op!==RelationOp.ARRAY_CONTAINS;};RelationFilter.prototype.canonicalId=function(){// TODO(b/29183165): Technically, this won't be unique if two values have
// the same description, such as the int 3 and the string "3". So we should
// add the types in here somehow, too.
return this.field.canonicalString()+this.op.toString()+this.value.toString();};RelationFilter.prototype.isEqual=function(other){if(other instanceof RelationFilter){return this.op.isEqual(other.op)&&this.field.isEqual(other.field)&&this.value.isEqual(other.value);}else{return false;}};RelationFilter.prototype.toString=function(){return this.field.canonicalString()+" "+this.op+" "+this.value.value();};return RelationFilter;}(Filter);/**
 * Filter that matches 'null' values.
 */var NullFilter=/** @class */function(_super){tslib_1.__extends(NullFilter,_super);function NullFilter(field){var _this=_super.call(this)||this;_this.field=field;return _this;}NullFilter.prototype.matches=function(doc){var val=doc.field(this.field);return val!==undefined&&val.value()===null;};NullFilter.prototype.canonicalId=function(){return this.field.canonicalString()+' IS null';};NullFilter.prototype.toString=function(){return this.field.canonicalString()+" IS null";};NullFilter.prototype.isEqual=function(other){if(other instanceof NullFilter){return this.field.isEqual(other.field);}else{return false;}};return NullFilter;}(Filter);/**
 * Filter that matches 'NaN' values.
 */var NanFilter=/** @class */function(_super){tslib_1.__extends(NanFilter,_super);function NanFilter(field){var _this=_super.call(this)||this;_this.field=field;return _this;}NanFilter.prototype.matches=function(doc){var field=doc.field(this.field);var val=field&&field.value();return typeof val==='number'&&isNaN(val);};NanFilter.prototype.canonicalId=function(){return this.field.canonicalString()+' IS NaN';};NanFilter.prototype.toString=function(){return this.field.canonicalString()+" IS NaN";};NanFilter.prototype.isEqual=function(other){if(other instanceof NanFilter){return this.field.isEqual(other.field);}else{return false;}};return NanFilter;}(Filter);/**
 * The direction of sorting in an order by.
 */var Direction=/** @class */function(){function Direction(name){this.name=name;}Direction.prototype.toString=function(){return this.name;};Direction.ASCENDING=new Direction('asc');Direction.DESCENDING=new Direction('desc');return Direction;}();/**
 * Represents a bound of a query.
 *
 * The bound is specified with the given components representing a position and
 * whether it's just before or just after the position (relative to whatever the
 * query order is).
 *
 * The position represents a logical index position for a query. It's a prefix
 * of values for the (potentially implicit) order by clauses of a query.
 *
 * Bound provides a function to determine whether a document comes before or
 * after a bound. This is influenced by whether the position is just before or
 * just after the provided values.
 */var Bound=/** @class */function(){function Bound(position,before){this.position=position;this.before=before;}Bound.prototype.canonicalId=function(){// TODO(b/29183165): Make this collision robust.
var canonicalId=this.before?'b:':'a:';for(var _i=0,_a=this.position;_i<_a.length;_i++){var component=_a[_i];canonicalId+=component.toString();}return canonicalId;};/**
     * Returns true if a document sorts before a bound using the provided sort
     * order.
     */Bound.prototype.sortsBeforeDocument=function(orderBy,doc){assert(this.position.length<=orderBy.length,"Bound has more components than query's orderBy");var comparison=0;for(var i=0;i<this.position.length;i++){var orderByComponent=orderBy[i];var component=this.position[i];if(orderByComponent.field.isKeyField()){assert(component instanceof RefValue,'Bound has a non-key value where the key path is being used.');comparison=DocumentKey.comparator(component.key,doc.key);}else{var docValue=doc.field(orderByComponent.field);assert(docValue!==undefined,'Field should exist since document matched the orderBy already.');comparison=component.compareTo(docValue);}if(orderByComponent.dir===Direction.DESCENDING){comparison=comparison*-1;}if(comparison!==0){break;}}return this.before?comparison<=0:comparison<0;};Bound.prototype.isEqual=function(other){if(other===null){return false;}if(this.before!==other.before||this.position.length!==other.position.length){return false;}for(var i=0;i<this.position.length;i++){var thisPosition=this.position[i];var otherPosition=other.position[i];return thisPosition.isEqual(otherPosition);}return true;};return Bound;}();/**
 * An ordering on a field, in some Direction. Direction defaults to ASCENDING.
 */var OrderBy=/** @class */function(){function OrderBy(field,dir){this.field=field;if(dir===undefined){dir=Direction.ASCENDING;}this.dir=dir;this.isKeyOrderBy=field.isKeyField();}OrderBy.prototype.compare=function(d1,d2){var comparison=this.isKeyOrderBy?Document.compareByKey(d1,d2):Document.compareByField(this.field,d1,d2);switch(this.dir){case Direction.ASCENDING:return comparison;case Direction.DESCENDING:return-1*comparison;default:return fail('Unknown direction: '+this.dir);}};OrderBy.prototype.canonicalId=function(){// TODO(b/29183165): Make this collision robust.
return this.field.canonicalString()+this.dir.toString();};OrderBy.prototype.toString=function(){return this.field.canonicalString()+" ("+this.dir+")";};OrderBy.prototype.isEqual=function(other){return this.dir===other.dir&&this.field.isEqual(other.field);};return OrderBy;}();var KEY_ORDERING_ASC=new OrderBy(FieldPath.keyField(),Direction.ASCENDING);var KEY_ORDERING_DESC=new OrderBy(FieldPath.keyField(),Direction.DESCENDING);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * A version of a document in Firestore. This corresponds to the version
 * timestamp, such as update_time or read_time.
 */var SnapshotVersion=/** @class */function(){function SnapshotVersion(timestamp){this.timestamp=timestamp;}// TODO(b/34176344): Once we no longer need to use the old alpha protos,
// delete this constructor and use a timestamp-backed version everywhere.
SnapshotVersion.fromMicroseconds=function(value){var seconds=Math.floor(value/1e6);var nanos=value%1e6*1e3;return new SnapshotVersion(new Timestamp(seconds,nanos));};SnapshotVersion.fromTimestamp=function(value){return new SnapshotVersion(value);};SnapshotVersion.forDeletedDoc=function(){return SnapshotVersion.MIN;};SnapshotVersion.prototype.compareTo=function(other){return this.timestamp._compareTo(other.timestamp);};SnapshotVersion.prototype.isEqual=function(other){return this.timestamp.isEqual(other.timestamp);};/** Returns a number representation of the version for use in spec tests. */SnapshotVersion.prototype.toMicroseconds=function(){// Convert to microseconds.
return this.timestamp.seconds*1e6+this.timestamp.nanoseconds/1000;};SnapshotVersion.prototype.toString=function(){return'SnapshotVersion('+this.timestamp.toString()+')';};SnapshotVersion.prototype.toTimestamp=function(){return this.timestamp;};SnapshotVersion.MIN=new SnapshotVersion(new Timestamp(0,0));return SnapshotVersion;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//** An enumeration of the different purposes we have for queries. */var QueryPurpose;(function(QueryPurpose){/** A regular, normal query. */QueryPurpose[QueryPurpose["Listen"]=0]="Listen";/**
     * The query was used to refill a query after an existence filter mismatch.
     */QueryPurpose[QueryPurpose["ExistenceFilterMismatch"]=1]="ExistenceFilterMismatch";/** The query was used to resolve a limbo document. */QueryPurpose[QueryPurpose["LimboResolution"]=2]="LimboResolution";})(QueryPurpose||(QueryPurpose={}));/**
 * An immutable set of metadata that the local store tracks for each query.
 */var QueryData=/** @class */function(){function QueryData(/** The query being listened to. */query,/**
     * The target ID to which the query corresponds; Assigned by the
     * LocalStore for user listens and by the SyncEngine for limbo watches.
     */targetId,/** The purpose of the query. */purpose,/** The sequence number of the last transaction during which this query data was modified */sequenceNumber,/** The latest snapshot version seen for this target. */snapshotVersion,/**
     * An opaque, server-assigned token that allows watching a query to be
     * resumed after disconnecting without retransmitting all the data that
     * matches the query. The resume token essentially identifies a point in
     * time from which the server should resume sending results.
     */resumeToken){if(snapshotVersion===void 0){snapshotVersion=SnapshotVersion.MIN;}if(resumeToken===void 0){resumeToken=emptyByteString();}this.query=query;this.targetId=targetId;this.purpose=purpose;this.sequenceNumber=sequenceNumber;this.snapshotVersion=snapshotVersion;this.resumeToken=resumeToken;}/**
     * Creates a new query data instance with an updated snapshot version and
     * resume token.
     */QueryData.prototype.copy=function(overwrite){return new QueryData(this.query,this.targetId,this.purpose,overwrite.sequenceNumber===undefined?this.sequenceNumber:overwrite.sequenceNumber,overwrite.snapshotVersion===undefined?this.snapshotVersion:overwrite.snapshotVersion,overwrite.resumeToken===undefined?this.resumeToken:overwrite.resumeToken);};QueryData.prototype.isEqual=function(other){return this.targetId===other.targetId&&this.purpose===other.purpose&&this.sequenceNumber===other.sequenceNumber&&this.snapshotVersion.isEqual(other.snapshotVersion)&&this.resumeToken===other.resumeToken&&this.query.isEqual(other.query);};return QueryData;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * SortedSet is an immutable (copy-on-write) collection that holds elements
 * in order specified by the provided comparator.
 *
 * NOTE: if provided comparator returns 0 for two elements, we consider them to
 * be equal!
 */var SortedSet=/** @class */function(){function SortedSet(comparator){this.comparator=comparator;this.data=new SortedMap(this.comparator);}/**
     * Creates a SortedSet from the keys of the map.
     * This is currently implemented as an O(n) copy.
     */SortedSet.fromMapKeys=function(map){var keys=new SortedSet(map.comparator);map.forEach(function(key){keys=keys.add(key);});return keys;};SortedSet.prototype.has=function(elem){return this.data.get(elem)!==null;};SortedSet.prototype.first=function(){return this.data.minKey();};SortedSet.prototype.last=function(){return this.data.maxKey();};Object.defineProperty(SortedSet.prototype,"size",{get:function(){return this.data.size;},enumerable:true,configurable:true});SortedSet.prototype.indexOf=function(elem){return this.data.indexOf(elem);};/** Iterates elements in order defined by "comparator" */SortedSet.prototype.forEach=function(cb){this.data.inorderTraversal(function(k,v){cb(k);return false;});};/** Iterates over `elem`s such that: range[0] <= elem < range[1]. */SortedSet.prototype.forEachInRange=function(range,cb){var iter=this.data.getIteratorFrom(range[0]);while(iter.hasNext()){var elem=iter.getNext();if(this.comparator(elem.key,range[1])>=0)return;cb(elem.key);}};/**
     * Iterates over `elem`s such that: start <= elem until false is returned.
     */SortedSet.prototype.forEachWhile=function(cb,start){var iter;if(start!==undefined){iter=this.data.getIteratorFrom(start);}else{iter=this.data.getIterator();}while(iter.hasNext()){var elem=iter.getNext();var result=cb(elem.key);if(!result)return;}};/** Finds the least element greater than or equal to `elem`. */SortedSet.prototype.firstAfterOrEqual=function(elem){var iter=this.data.getIteratorFrom(elem);return iter.hasNext()?iter.getNext().key:null;};SortedSet.prototype.getIterator=function(){return new SortedSetIterator(this.data.getIterator());};SortedSet.prototype.getIteratorFrom=function(key){return new SortedSetIterator(this.data.getIteratorFrom(key));};/** Inserts or updates an element */SortedSet.prototype.add=function(elem){return this.copy(this.data.remove(elem).insert(elem,true));};/** Deletes an element */SortedSet.prototype.delete=function(elem){if(!this.has(elem))return this;return this.copy(this.data.remove(elem));};SortedSet.prototype.isEmpty=function(){return this.data.isEmpty();};SortedSet.prototype.unionWith=function(other){var result=this;other.forEach(function(elem){result=result.add(elem);});return result;};SortedSet.prototype.isEqual=function(other){if(!(other instanceof SortedSet))return false;if(this.size!==other.size)return false;var thisIt=this.data.getIterator();var otherIt=other.data.getIterator();while(thisIt.hasNext()){var thisElem=thisIt.getNext().key;var otherElem=otherIt.getNext().key;if(this.comparator(thisElem,otherElem)!==0)return false;}return true;};SortedSet.prototype.toArray=function(){var res=[];this.forEach(function(targetId){res.push(targetId);});return res;};SortedSet.prototype.toString=function(){var result=[];this.forEach(function(elem){return result.push(elem);});return'SortedSet('+result.toString()+')';};SortedSet.prototype.copy=function(data){var result=new SortedSet(this.comparator);result.data=data;return result;};return SortedSet;}();var SortedSetIterator=/** @class */function(){function SortedSetIterator(iter){this.iter=iter;}SortedSetIterator.prototype.getNext=function(){return this.iter.getNext().key;};SortedSetIterator.prototype.hasNext=function(){return this.iter.hasNext();};return SortedSetIterator;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Provides a set of fields that can be used to partially patch a document.
 * FieldMask is used in conjunction with ObjectValue.
 * Examples:
 *   foo - Overwrites foo entirely with the provided value. If foo is not
 *         present in the companion ObjectValue, the field is deleted.
 *   foo.bar - Overwrites only the field bar of the object foo.
 *             If foo is not an object, foo is replaced with an object
 *             containing foo
 */var FieldMask=/** @class */function(){function FieldMask(fields){this.fields=fields;// TODO(dimond): validation of FieldMask
}FieldMask.fromSet=function(fields){return new FieldMask(fields);};FieldMask.fromArray=function(fields){var fieldsAsSet=new SortedSet(FieldPath.comparator);fields.forEach(function(fieldPath){return fieldsAsSet=fieldsAsSet.add(fieldPath);});return new FieldMask(fieldsAsSet);};/**
     * Verifies that `fieldPath` is included by at least one field in this field
     * mask.
     *
     * This is an O(n) operation, where `n` is the size of the field mask.
     */FieldMask.prototype.covers=function(fieldPath){var found=false;this.fields.forEach(function(fieldMaskPath){if(fieldMaskPath.isPrefixOf(fieldPath)){found=true;}});return found;};/**
     * Applies this field mask to the provided object value and returns an object
     * that only contains fields that are specified in both the input object and
     * this field mask.
     */FieldMask.prototype.applyTo=function(data){var filteredObject=ObjectValue.EMPTY;this.fields.forEach(function(fieldMaskPath){if(fieldMaskPath.isEmpty()){return data;}else{var newValue=data.field(fieldMaskPath);if(newValue!==undefined){filteredObject=filteredObject.set(fieldMaskPath,newValue);}}});return filteredObject;};FieldMask.prototype.isEqual=function(other){return this.fields.isEqual(other.fields);};return FieldMask;}();/** A field path and the TransformOperation to perform upon it. */var FieldTransform=/** @class */function(){function FieldTransform(field,transform){this.field=field;this.transform=transform;}Object.defineProperty(FieldTransform.prototype,"isIdempotent",{/** Whether this field transform is idempotent. */get:function(){return this.transform.isIdempotent;},enumerable:true,configurable:true});FieldTransform.prototype.isEqual=function(other){return this.field.isEqual(other.field)&&this.transform.isEqual(other.transform);};return FieldTransform;}();/** The result of successfully applying a mutation to the backend. */var MutationResult=/** @class */function(){function MutationResult(/**
     * The version at which the mutation was committed:
     *
     * - For most operations, this is the updateTime in the WriteResult.
     * - For deletes, the commitTime of the WriteResponse (because deletes are
     *   not stored and have no updateTime).
     *
     * Note that these versions can be different: No-op writes will not change
     * the updateTime even though the commitTime advances.
     */version,/**
     * The resulting fields returned from the backend after a
     * TransformMutation has been committed. Contains one FieldValue for each
     * FieldTransform that was in the mutation.
     *
     * Will be null if the mutation was not a TransformMutation.
     */transformResults){this.version=version;this.transformResults=transformResults;}return MutationResult;}();var MutationType;(function(MutationType){MutationType[MutationType["Set"]=0]="Set";MutationType[MutationType["Patch"]=1]="Patch";MutationType[MutationType["Transform"]=2]="Transform";MutationType[MutationType["Delete"]=3]="Delete";})(MutationType||(MutationType={}));/**
 * Encodes a precondition for a mutation. This follows the model that the
 * backend accepts with the special case of an explicit "empty" precondition
 * (meaning no precondition).
 */var Precondition=/** @class */function(){function Precondition(updateTime,exists){this.updateTime=updateTime;this.exists=exists;assert(updateTime===undefined||exists===undefined,'Precondition can specify "exists" or "updateTime" but not both');}/** Creates a new Precondition with an exists flag. */Precondition.exists=function(exists){return new Precondition(undefined,exists);};/** Creates a new Precondition based on a version a document exists at. */Precondition.updateTime=function(version){return new Precondition(version);};Object.defineProperty(Precondition.prototype,"isNone",{/** Returns whether this Precondition is empty. */get:function(){return this.updateTime===undefined&&this.exists===undefined;},enumerable:true,configurable:true});/**
     * Returns true if the preconditions is valid for the given document
     * (or null if no document is available).
     */Precondition.prototype.isValidFor=function(maybeDoc){if(this.updateTime!==undefined){return maybeDoc instanceof Document&&maybeDoc.version.isEqual(this.updateTime);}else if(this.exists!==undefined){return this.exists===maybeDoc instanceof Document;}else{assert(this.isNone,'Precondition should be empty');return true;}};Precondition.prototype.isEqual=function(other){return equals(this.updateTime,other.updateTime)&&this.exists===other.exists;};Precondition.NONE=new Precondition();return Precondition;}();/**
 * A mutation describes a self-contained change to a document. Mutations can
 * create, replace, delete, and update subsets of documents.
 *
 * Mutations not only act on the value of the document but also it version.
 *
 * For local mutations (mutations that haven't been committed yet), we preserve
 * the existing version for Set, Patch, and Transform mutations. For Delete
 * mutations, we reset the version to 0.
 *
 * Here's the expected transition table.
 *
 * MUTATION           APPLIED TO            RESULTS IN
 *
 * SetMutation        Document(v3)          Document(v3)
 * SetMutation        NoDocument(v3)        Document(v0)
 * SetMutation        null                  Document(v0)
 * PatchMutation      Document(v3)          Document(v3)
 * PatchMutation      NoDocument(v3)        NoDocument(v3)
 * PatchMutation      null                  null
 * TransformMutation  Document(v3)          Document(v3)
 * TransformMutation  NoDocument(v3)        NoDocument(v3)
 * TransformMutation  null                  null
 * DeleteMutation     Document(v3)          NoDocument(v0)
 * DeleteMutation     NoDocument(v3)        NoDocument(v0)
 * DeleteMutation     null                  NoDocument(v0)
 *
 * For acknowledged mutations, we use the updateTime of the WriteResponse as
 * the resulting version for Set, Patch, and Transform mutations. As deletes
 * have no explicit update time, we use the commitTime of the WriteResponse for
 * Delete mutations.
 *
 * If a mutation is acknowledged by the backend but fails the precondition check
 * locally, we return an `UnknownDocument` and rely on Watch to send us the
 * updated version.
 *
 * Note that TransformMutations don't create Documents (in the case of being
 * applied to a NoDocument), even though they would on the backend. This is
 * because the client always combines the TransformMutation with a SetMutation
 * or PatchMutation and we only want to apply the transform if the prior
 * mutation resulted in a Document (always true for a SetMutation, but not
 * necessarily for a PatchMutation).
 *
 * ## Subclassing Notes
 *
 * Subclasses of Mutation need to implement applyToRemoteDocument() and
 * applyToLocalView() to implement the actual behavior of applying the mutation
 * to some source document.
 */var Mutation=/** @class */function(){function Mutation(){}Mutation.prototype.verifyKeyMatches=function(maybeDoc){if(maybeDoc!=null){assert(maybeDoc.key.isEqual(this.key),'Can only apply a mutation to a document with the same key');}};/**
     * Returns the version from the given document for use as the result of a
     * mutation. Mutations are defined to return the version of the base document
     * only if it is an existing document. Deleted and unknown documents have a
     * post-mutation version of SnapshotVersion.MIN.
     */Mutation.getPostMutationVersion=function(maybeDoc){if(maybeDoc instanceof Document){return maybeDoc.version;}else{return SnapshotVersion.MIN;}};return Mutation;}();/**
 * A mutation that creates or replaces the document at the given key with the
 * object value contents.
 */var SetMutation=/** @class */function(_super){tslib_1.__extends(SetMutation,_super);function SetMutation(key,value,precondition){var _this=_super.call(this)||this;_this.key=key;_this.value=value;_this.precondition=precondition;_this.type=MutationType.Set;return _this;}SetMutation.prototype.applyToRemoteDocument=function(maybeDoc,mutationResult){this.verifyKeyMatches(maybeDoc);assert(mutationResult.transformResults==null,'Transform results received by SetMutation.');// Unlike applyToLocalView, if we're applying a mutation to a remote
// document the server has accepted the mutation so the precondition must
// have held.
var version=mutationResult.version;return new Document(this.key,version,this.value,{hasCommittedMutations:true});};SetMutation.prototype.applyToLocalView=function(maybeDoc,baseDoc,localWriteTime){this.verifyKeyMatches(maybeDoc);if(!this.precondition.isValidFor(maybeDoc)){return maybeDoc;}var version=Mutation.getPostMutationVersion(maybeDoc);return new Document(this.key,version,this.value,{hasLocalMutations:true});};Object.defineProperty(SetMutation.prototype,"isIdempotent",{get:function(){return true;},enumerable:true,configurable:true});Object.defineProperty(SetMutation.prototype,"fieldMask",{get:function(){return null;},enumerable:true,configurable:true});SetMutation.prototype.isEqual=function(other){return other instanceof SetMutation&&this.key.isEqual(other.key)&&this.value.isEqual(other.value)&&this.precondition.isEqual(other.precondition);};return SetMutation;}(Mutation);/**
 * A mutation that modifies fields of the document at the given key with the
 * given values. The values are applied through a field mask:
 *
 *  * When a field is in both the mask and the values, the corresponding field
 *    is updated.
 *  * When a field is in neither the mask nor the values, the corresponding
 *    field is unmodified.
 *  * When a field is in the mask but not in the values, the corresponding field
 *    is deleted.
 *  * When a field is not in the mask but is in the values, the values map is
 *    ignored.
 */var PatchMutation=/** @class */function(_super){tslib_1.__extends(PatchMutation,_super);function PatchMutation(key,data,fieldMask,precondition){var _this=_super.call(this)||this;_this.key=key;_this.data=data;_this.fieldMask=fieldMask;_this.precondition=precondition;_this.type=MutationType.Patch;return _this;}PatchMutation.prototype.applyToRemoteDocument=function(maybeDoc,mutationResult){this.verifyKeyMatches(maybeDoc);assert(mutationResult.transformResults==null,'Transform results received by PatchMutation.');if(!this.precondition.isValidFor(maybeDoc)){// Since the mutation was not rejected, we know that the  precondition
// matched on the backend. We therefore must not have the expected version
// of the document in our cache and return an UnknownDocument with the
// known updateTime.
return new UnknownDocument(this.key,mutationResult.version);}var newData=this.patchDocument(maybeDoc);return new Document(this.key,mutationResult.version,newData,{hasCommittedMutations:true});};PatchMutation.prototype.applyToLocalView=function(maybeDoc,baseDoc,localWriteTime){this.verifyKeyMatches(maybeDoc);if(!this.precondition.isValidFor(maybeDoc)){return maybeDoc;}var version=Mutation.getPostMutationVersion(maybeDoc);var newData=this.patchDocument(maybeDoc);return new Document(this.key,version,newData,{hasLocalMutations:true});};Object.defineProperty(PatchMutation.prototype,"isIdempotent",{get:function(){return true;},enumerable:true,configurable:true});PatchMutation.prototype.isEqual=function(other){return other instanceof PatchMutation&&this.key.isEqual(other.key)&&this.fieldMask.isEqual(other.fieldMask)&&this.precondition.isEqual(other.precondition);};/**
     * Patches the data of document if available or creates a new document. Note
     * that this does not check whether or not the precondition of this patch
     * holds.
     */PatchMutation.prototype.patchDocument=function(maybeDoc){var data;if(maybeDoc instanceof Document){data=maybeDoc.data;}else{data=ObjectValue.EMPTY;}return this.patchObject(data);};PatchMutation.prototype.patchObject=function(data){var _this=this;this.fieldMask.fields.forEach(function(fieldPath){if(!fieldPath.isEmpty()){var newValue=_this.data.field(fieldPath);if(newValue!==undefined){data=data.set(fieldPath,newValue);}else{data=data.delete(fieldPath);}}});return data;};return PatchMutation;}(Mutation);/**
 * A mutation that modifies specific fields of the document with transform
 * operations. Currently the only supported transform is a server timestamp, but
 * IP Address, increment(n), etc. could be supported in the future.
 *
 * It is somewhat similar to a PatchMutation in that it patches specific fields
 * and has no effect when applied to a null or NoDocument (see comment on
 * Mutation for rationale).
 */var TransformMutation=/** @class */function(_super){tslib_1.__extends(TransformMutation,_super);function TransformMutation(key,fieldTransforms){var _this=_super.call(this)||this;_this.key=key;_this.fieldTransforms=fieldTransforms;_this.type=MutationType.Transform;// NOTE: We set a precondition of exists: true as a safety-check, since we
// always combine TransformMutations with a SetMutation or PatchMutation which
// (if successful) should end up with an existing document.
_this.precondition=Precondition.exists(true);return _this;}TransformMutation.prototype.applyToRemoteDocument=function(maybeDoc,mutationResult){this.verifyKeyMatches(maybeDoc);assert(mutationResult.transformResults!=null,'Transform results missing for TransformMutation.');if(!this.precondition.isValidFor(maybeDoc)){// Since the mutation was not rejected, we know that the  precondition
// matched on the backend. We therefore must not have the expected version
// of the document in our cache and return an UnknownDocument with the
// known updateTime.
return new UnknownDocument(this.key,mutationResult.version);}var doc=this.requireDocument(maybeDoc);var transformResults=this.serverTransformResults(maybeDoc,mutationResult.transformResults);var version=mutationResult.version;var newData=this.transformObject(doc.data,transformResults);return new Document(this.key,version,newData,{hasCommittedMutations:true});};TransformMutation.prototype.applyToLocalView=function(maybeDoc,baseDoc,localWriteTime){this.verifyKeyMatches(maybeDoc);if(!this.precondition.isValidFor(maybeDoc)){return maybeDoc;}var doc=this.requireDocument(maybeDoc);var transformResults=this.localTransformResults(localWriteTime,baseDoc);var newData=this.transformObject(doc.data,transformResults);return new Document(this.key,doc.version,newData,{hasLocalMutations:true});};Object.defineProperty(TransformMutation.prototype,"isIdempotent",{get:function(){for(var _i=0,_a=this.fieldTransforms;_i<_a.length;_i++){var fieldTransform=_a[_i];if(!fieldTransform.isIdempotent){return false;}}return true;},enumerable:true,configurable:true});Object.defineProperty(TransformMutation.prototype,"fieldMask",{get:function(){var fieldMask=new SortedSet(FieldPath.comparator);this.fieldTransforms.forEach(function(transform){return fieldMask=fieldMask.add(transform.field);});return new FieldMask(fieldMask);},enumerable:true,configurable:true});TransformMutation.prototype.isEqual=function(other){return other instanceof TransformMutation&&this.key.isEqual(other.key)&&arrayEquals(this.fieldTransforms,other.fieldTransforms)&&this.precondition.isEqual(other.precondition);};/**
     * Asserts that the given MaybeDocument is actually a Document and verifies
     * that it matches the key for this mutation. Since we only support
     * transformations with precondition exists this method is guaranteed to be
     * safe.
     */TransformMutation.prototype.requireDocument=function(maybeDoc){assert(maybeDoc instanceof Document,'Unknown MaybeDocument type '+maybeDoc);var doc=maybeDoc;assert(doc.key.isEqual(this.key),'Can only transform a document with the same key');return doc;};/**
     * Creates a list of "transform results" (a transform result is a field value
     * representing the result of applying a transform) for use after a
     * TransformMutation has been acknowledged by the server.
     *
     * @param baseDoc The document prior to applying this mutation batch.
     * @param serverTransformResults The transform results received by the server.
     * @return The transform results list.
     */TransformMutation.prototype.serverTransformResults=function(baseDoc,serverTransformResults){var transformResults=[];assert(this.fieldTransforms.length===serverTransformResults.length,"server transform result count ("+serverTransformResults.length+") "+("should match field transform count ("+this.fieldTransforms.length+")"));for(var i=0;i<serverTransformResults.length;i++){var fieldTransform=this.fieldTransforms[i];var transform=fieldTransform.transform;var previousValue=null;if(baseDoc instanceof Document){previousValue=baseDoc.field(fieldTransform.field)||null;}transformResults.push(transform.applyToRemoteDocument(previousValue,serverTransformResults[i]));}return transformResults;};/**
     * Creates a list of "transform results" (a transform result is a field value
     * representing the result of applying a transform) for use when applying a
     * TransformMutation locally.
     *
     * @param localWriteTime The local time of the transform mutation (used to
     *     generate ServerTimestampValues).
     * @param baseDoc The document prior to applying this mutation batch.
     * @return The transform results list.
     */TransformMutation.prototype.localTransformResults=function(localWriteTime,baseDoc){var transformResults=[];for(var _i=0,_a=this.fieldTransforms;_i<_a.length;_i++){var fieldTransform=_a[_i];var transform=fieldTransform.transform;var previousValue=null;if(baseDoc instanceof Document){previousValue=baseDoc.field(fieldTransform.field)||null;}transformResults.push(transform.applyToLocalView(previousValue,localWriteTime));}return transformResults;};TransformMutation.prototype.transformObject=function(data,transformResults){assert(transformResults.length===this.fieldTransforms.length,'TransformResults length mismatch.');for(var i=0;i<this.fieldTransforms.length;i++){var fieldTransform=this.fieldTransforms[i];var fieldPath=fieldTransform.field;data=data.set(fieldPath,transformResults[i]);}return data;};return TransformMutation;}(Mutation);/** A mutation that deletes the document at the given key. */var DeleteMutation=/** @class */function(_super){tslib_1.__extends(DeleteMutation,_super);function DeleteMutation(key,precondition){var _this=_super.call(this)||this;_this.key=key;_this.precondition=precondition;_this.type=MutationType.Delete;return _this;}DeleteMutation.prototype.applyToRemoteDocument=function(maybeDoc,mutationResult){this.verifyKeyMatches(maybeDoc);assert(mutationResult.transformResults==null,'Transform results received by DeleteMutation.');// Unlike applyToLocalView, if we're applying a mutation to a remote
// document the server has accepted the mutation so the precondition must
// have held.
return new NoDocument(this.key,mutationResult.version,{hasCommittedMutations:true});};DeleteMutation.prototype.applyToLocalView=function(maybeDoc,baseDoc,localWriteTime){this.verifyKeyMatches(maybeDoc);if(!this.precondition.isValidFor(maybeDoc)){return maybeDoc;}if(maybeDoc){assert(maybeDoc.key.isEqual(this.key),'Can only apply mutation to document with same key');}return new NoDocument(this.key,SnapshotVersion.forDeletedDoc());};DeleteMutation.prototype.isEqual=function(other){return other instanceof DeleteMutation&&this.key.isEqual(other.key)&&this.precondition.isEqual(other.precondition);};Object.defineProperty(DeleteMutation.prototype,"isIdempotent",{get:function(){return true;},enumerable:true,configurable:true});Object.defineProperty(DeleteMutation.prototype,"fieldMask",{get:function(){return null;},enumerable:true,configurable:true});return DeleteMutation;}(Mutation);/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//** Transforms a value into a server-generated timestamp. */var ServerTimestampTransform=/** @class */function(){function ServerTimestampTransform(){this.isIdempotent=true;}ServerTimestampTransform.prototype.applyToLocalView=function(previousValue,localWriteTime){return new ServerTimestampValue(localWriteTime,previousValue);};ServerTimestampTransform.prototype.applyToRemoteDocument=function(previousValue,transformResult){return transformResult;};ServerTimestampTransform.prototype.isEqual=function(other){return other instanceof ServerTimestampTransform;};ServerTimestampTransform.instance=new ServerTimestampTransform();return ServerTimestampTransform;}();/** Transforms an array value via a union operation. */var ArrayUnionTransformOperation=/** @class */function(){function ArrayUnionTransformOperation(elements){this.elements=elements;this.isIdempotent=true;}ArrayUnionTransformOperation.prototype.applyToLocalView=function(previousValue,localWriteTime){return this.apply(previousValue);};ArrayUnionTransformOperation.prototype.applyToRemoteDocument=function(previousValue,transformResult){// The server just sends null as the transform result for array operations,
// so we have to calculate a result the same as we do for local
// applications.
return this.apply(previousValue);};ArrayUnionTransformOperation.prototype.apply=function(previousValue){var result=coercedFieldValuesArray(previousValue);var _loop_1=function(toUnion){if(!result.find(function(element){return element.isEqual(toUnion);})){result.push(toUnion);}};for(var _i=0,_a=this.elements;_i<_a.length;_i++){var toUnion=_a[_i];_loop_1(toUnion);}return new ArrayValue(result);};ArrayUnionTransformOperation.prototype.isEqual=function(other){return other instanceof ArrayUnionTransformOperation&&arrayEquals(other.elements,this.elements);};return ArrayUnionTransformOperation;}();/** Transforms an array value via a remove operation. */var ArrayRemoveTransformOperation=/** @class */function(){function ArrayRemoveTransformOperation(elements){this.elements=elements;this.isIdempotent=true;}ArrayRemoveTransformOperation.prototype.applyToLocalView=function(previousValue,localWriteTime){return this.apply(previousValue);};ArrayRemoveTransformOperation.prototype.applyToRemoteDocument=function(previousValue,transformResult){// The server just sends null as the transform result for array operations,
// so we have to calculate a result the same as we do for local
// applications.
return this.apply(previousValue);};ArrayRemoveTransformOperation.prototype.apply=function(previousValue){var result=coercedFieldValuesArray(previousValue);var _loop_2=function(toRemove){result=result.filter(function(element){return!element.isEqual(toRemove);});};for(var _i=0,_a=this.elements;_i<_a.length;_i++){var toRemove=_a[_i];_loop_2(toRemove);}return new ArrayValue(result);};ArrayRemoveTransformOperation.prototype.isEqual=function(other){return other instanceof ArrayRemoveTransformOperation&&arrayEquals(other.elements,this.elements);};return ArrayRemoveTransformOperation;}();/**
 * Implements the backend semantics for locally computed NUMERIC_ADD (increment)
 * transforms. Converts all field values to integers or doubles, but unlike the
 * backend does not cap integer values at 2^63. Instead, JavaScript number
 * arithmetic is used and precision loss can occur for values greater than 2^53.
 */var NumericIncrementTransformOperation=/** @class */function(){function NumericIncrementTransformOperation(operand){this.operand=operand;this.isIdempotent=false;}NumericIncrementTransformOperation.prototype.applyToLocalView=function(previousValue,localWriteTime){// PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit
// precision and resolves overflows by reducing precision, we do not
// manually cap overflows at 2^63.
// Return an integer value iff the previous value and the operand is an
// integer.
if(previousValue instanceof IntegerValue&&this.operand instanceof IntegerValue){var sum=previousValue.internalValue+this.operand.internalValue;return new IntegerValue(sum);}else if(previousValue instanceof NumberValue){var sum=previousValue.internalValue+this.operand.internalValue;return new DoubleValue(sum);}else{// If the existing value is not a number, use the value of the transform as
// the new base value.
return this.operand;}};NumericIncrementTransformOperation.prototype.applyToRemoteDocument=function(previousValue,transformResult){assert(transformResult!==null,"Didn't receive transformResult for NUMERIC_ADD transform");return transformResult;};NumericIncrementTransformOperation.prototype.isEqual=function(other){return other instanceof NumericIncrementTransformOperation&&this.operand.isEqual(other.operand);};return NumericIncrementTransformOperation;}();function coercedFieldValuesArray(value){if(value instanceof ArrayValue){return value.internalValue.slice();}else{// coerce to empty array.
return[];}}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var ExistenceFilter=/** @class */function(){// TODO(b/33078163): just use simplest form of existence filter for now
function ExistenceFilter(count){this.count=count;}ExistenceFilter.prototype.isEqual=function(other){return other&&other.count===this.count;};return ExistenceFilter;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Error Codes describing the different ways GRPC can fail. These are copied
 * directly from GRPC's sources here:
 *
 * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
 *
 * Important! The names of these identifiers matter because the string forms
 * are used for reverse lookups from the webchannel stream. Do NOT change the
 * names of these identifiers.
 */var RpcCode;(function(RpcCode){RpcCode[RpcCode["OK"]=0]="OK";RpcCode[RpcCode["CANCELLED"]=1]="CANCELLED";RpcCode[RpcCode["UNKNOWN"]=2]="UNKNOWN";RpcCode[RpcCode["INVALID_ARGUMENT"]=3]="INVALID_ARGUMENT";RpcCode[RpcCode["DEADLINE_EXCEEDED"]=4]="DEADLINE_EXCEEDED";RpcCode[RpcCode["NOT_FOUND"]=5]="NOT_FOUND";RpcCode[RpcCode["ALREADY_EXISTS"]=6]="ALREADY_EXISTS";RpcCode[RpcCode["PERMISSION_DENIED"]=7]="PERMISSION_DENIED";RpcCode[RpcCode["UNAUTHENTICATED"]=16]="UNAUTHENTICATED";RpcCode[RpcCode["RESOURCE_EXHAUSTED"]=8]="RESOURCE_EXHAUSTED";RpcCode[RpcCode["FAILED_PRECONDITION"]=9]="FAILED_PRECONDITION";RpcCode[RpcCode["ABORTED"]=10]="ABORTED";RpcCode[RpcCode["OUT_OF_RANGE"]=11]="OUT_OF_RANGE";RpcCode[RpcCode["UNIMPLEMENTED"]=12]="UNIMPLEMENTED";RpcCode[RpcCode["INTERNAL"]=13]="INTERNAL";RpcCode[RpcCode["UNAVAILABLE"]=14]="UNAVAILABLE";RpcCode[RpcCode["DATA_LOSS"]=15]="DATA_LOSS";})(RpcCode||(RpcCode={}));/**
 * Determines whether an error code represents a permanent error when received
 * in response to a non-write operation.
 *
 * See isPermanentWriteError for classifying write errors.
 */function isPermanentError(code){switch(code){case Code.OK:return fail('Treated status OK as error');case Code.CANCELLED:case Code.UNKNOWN:case Code.DEADLINE_EXCEEDED:case Code.RESOURCE_EXHAUSTED:case Code.INTERNAL:case Code.UNAVAILABLE:// Unauthenticated means something went wrong with our token and we need
// to retry with new credentials which will happen automatically.
case Code.UNAUTHENTICATED:return false;case Code.INVALID_ARGUMENT:case Code.NOT_FOUND:case Code.ALREADY_EXISTS:case Code.PERMISSION_DENIED:case Code.FAILED_PRECONDITION:// Aborted might be retried in some scenarios, but that is dependant on
// the context and should handled individually by the calling code.
// See https://cloud.google.com/apis/design/errors.
case Code.ABORTED:case Code.OUT_OF_RANGE:case Code.UNIMPLEMENTED:case Code.DATA_LOSS:return true;default:return fail('Unknown status code: '+code);}}/**
 * Determines whether an error code represents a permanent error when received
 * in response to a write operation.
 *
 * Write operations must be handled specially because as of b/119437764, ABORTED
 * errors on the write stream should be retried too (even though ABORTED errors
 * are not generally retryable).
 *
 * Note that during the initial handshake on the write stream an ABORTED error
 * signals that we should discard our stream token (i.e. it is permanent). This
 * means a handshake error should be classified with isPermanentError, above.
 */function isPermanentWriteError(code){return isPermanentError(code)&&code!==Code.ABORTED;}/**
 * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.
 *
 * @returns The Code equivalent to the given status string or undefined if
 *     there is no match.
 */function mapCodeFromRpcStatus(status){// tslint:disable-next-line:no-any lookup by string
var code=RpcCode[status];if(code===undefined){return undefined;}return mapCodeFromRpcCode(code);}/**
 * Maps an error Code from GRPC status code number, like 0, 1, or 14. These
 * are not the same as HTTP status codes.
 *
 * @returns The Code equivalent to the given GRPC status code. Fails if there
 *     is no match.
 */function mapCodeFromRpcCode(code){if(code===undefined){// This shouldn't normally happen, but in certain error cases (like trying
// to send invalid proto messages) we may get an error with no GRPC code.
error('GRPC error has no .code');return Code.UNKNOWN;}switch(code){case RpcCode.OK:return Code.OK;case RpcCode.CANCELLED:return Code.CANCELLED;case RpcCode.UNKNOWN:return Code.UNKNOWN;case RpcCode.DEADLINE_EXCEEDED:return Code.DEADLINE_EXCEEDED;case RpcCode.RESOURCE_EXHAUSTED:return Code.RESOURCE_EXHAUSTED;case RpcCode.INTERNAL:return Code.INTERNAL;case RpcCode.UNAVAILABLE:return Code.UNAVAILABLE;case RpcCode.UNAUTHENTICATED:return Code.UNAUTHENTICATED;case RpcCode.INVALID_ARGUMENT:return Code.INVALID_ARGUMENT;case RpcCode.NOT_FOUND:return Code.NOT_FOUND;case RpcCode.ALREADY_EXISTS:return Code.ALREADY_EXISTS;case RpcCode.PERMISSION_DENIED:return Code.PERMISSION_DENIED;case RpcCode.FAILED_PRECONDITION:return Code.FAILED_PRECONDITION;case RpcCode.ABORTED:return Code.ABORTED;case RpcCode.OUT_OF_RANGE:return Code.OUT_OF_RANGE;case RpcCode.UNIMPLEMENTED:return Code.UNIMPLEMENTED;case RpcCode.DATA_LOSS:return Code.DATA_LOSS;default:return fail('Unknown status code: '+code);}}/**
 * Maps an RPC code from a Code. This is the reverse operation from
 * mapCodeFromRpcCode and should really only be used in tests.
 */function mapRpcCodeFromCode(code){if(code===undefined){return RpcCode.OK;}switch(code){case Code.OK:return RpcCode.OK;case Code.CANCELLED:return RpcCode.CANCELLED;case Code.UNKNOWN:return RpcCode.UNKNOWN;case Code.DEADLINE_EXCEEDED:return RpcCode.DEADLINE_EXCEEDED;case Code.RESOURCE_EXHAUSTED:return RpcCode.RESOURCE_EXHAUSTED;case Code.INTERNAL:return RpcCode.INTERNAL;case Code.UNAVAILABLE:return RpcCode.UNAVAILABLE;case Code.UNAUTHENTICATED:return RpcCode.UNAUTHENTICATED;case Code.INVALID_ARGUMENT:return RpcCode.INVALID_ARGUMENT;case Code.NOT_FOUND:return RpcCode.NOT_FOUND;case Code.ALREADY_EXISTS:return RpcCode.ALREADY_EXISTS;case Code.PERMISSION_DENIED:return RpcCode.PERMISSION_DENIED;case Code.FAILED_PRECONDITION:return RpcCode.FAILED_PRECONDITION;case Code.ABORTED:return RpcCode.ABORTED;case Code.OUT_OF_RANGE:return RpcCode.OUT_OF_RANGE;case Code.UNIMPLEMENTED:return RpcCode.UNIMPLEMENTED;case Code.DATA_LOSS:return RpcCode.DATA_LOSS;default:return fail('Unknown status code: '+code);}}/**
 * Converts an HTTP Status Code to the equivalent error code.
 *
 * @param status An HTTP Status Code, like 200, 404, 503, etc.
 * @returns The equivalent Code. Unknown status codes are mapped to
 *     Code.UNKNOWN.
 */function mapCodeFromHttpStatus(status){// The canonical error codes for Google APIs [1] specify mapping onto HTTP
// status codes but the mapping is not bijective. In each case of ambiguity
// this function chooses a primary error.
//
// [1]
// https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto
switch(status){case 200:// OK
return Code.OK;case 400:// Bad Request
return Code.INVALID_ARGUMENT;// Other possibilities based on the forward mapping
// return Code.FAILED_PRECONDITION;
// return Code.OUT_OF_RANGE;
case 401:// Unauthorized
return Code.UNAUTHENTICATED;case 403:// Forbidden
return Code.PERMISSION_DENIED;case 404:// Not Found
return Code.NOT_FOUND;case 409:// Conflict
return Code.ABORTED;// Other possibilities:
// return Code.ALREADY_EXISTS;
case 416:// Range Not Satisfiable
return Code.OUT_OF_RANGE;case 429:// Too Many Requests
return Code.RESOURCE_EXHAUSTED;case 499:// Client Closed Request
return Code.CANCELLED;case 500:// Internal Server Error
return Code.UNKNOWN;// Other possibilities:
// return Code.INTERNAL;
// return Code.DATA_LOSS;
case 501:// Unimplemented
return Code.UNIMPLEMENTED;case 503:// Service Unavailable
return Code.UNAVAILABLE;case 504:// Gateway Timeout
return Code.DEADLINE_EXCEEDED;default:if(status>=200&&status<300)return Code.OK;if(status>=400&&status<500)return Code.FAILED_PRECONDITION;if(status>=500&&status<600)return Code.INTERNAL;return Code.UNKNOWN;}}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var EMPTY_MAYBE_DOCUMENT_MAP=new SortedMap(DocumentKey.comparator);function maybeDocumentMap(){return EMPTY_MAYBE_DOCUMENT_MAP;}function nullableMaybeDocumentMap(){return maybeDocumentMap();}var EMPTY_DOCUMENT_MAP=new SortedMap(DocumentKey.comparator);function documentMap(){return EMPTY_DOCUMENT_MAP;}var EMPTY_DOCUMENT_VERSION_MAP=new SortedMap(DocumentKey.comparator);function documentVersionMap(){return EMPTY_DOCUMENT_VERSION_MAP;}var EMPTY_DOCUMENT_KEY_SET=new SortedSet(DocumentKey.comparator);function documentKeySet(){var keys=[];for(var _i=0;_i<arguments.length;_i++){keys[_i]=arguments[_i];}var set=EMPTY_DOCUMENT_KEY_SET;for(var _a=0,keys_1=keys;_a<keys_1.length;_a++){var key=keys_1[_a];set=set.add(key);}return set;}var EMPTY_TARGET_ID_SET=new SortedSet(primitiveComparator);function targetIdSet(){return EMPTY_TARGET_ID_SET;}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * DocumentSet is an immutable (copy-on-write) collection that holds documents
 * in order specified by the provided comparator. We always add a document key
 * comparator on top of what is provided to guarantee document equality based on
 * the key.
 */var DocumentSet=/** @class */function(){/** The default ordering is by key if the comparator is omitted */function DocumentSet(comp){// We are adding document key comparator to the end as it's the only
// guaranteed unique property of a document.
if(comp){this.comparator=function(d1,d2){return comp(d1,d2)||DocumentKey.comparator(d1.key,d2.key);};}else{this.comparator=function(d1,d2){return DocumentKey.comparator(d1.key,d2.key);};}this.keyedMap=documentMap();this.sortedSet=new SortedMap(this.comparator);}/**
     * Returns an empty copy of the existing DocumentSet, using the same
     * comparator.
     */DocumentSet.emptySet=function(oldSet){return new DocumentSet(oldSet.comparator);};DocumentSet.prototype.has=function(key){return this.keyedMap.get(key)!=null;};DocumentSet.prototype.get=function(key){return this.keyedMap.get(key);};DocumentSet.prototype.first=function(){return this.sortedSet.minKey();};DocumentSet.prototype.last=function(){return this.sortedSet.maxKey();};DocumentSet.prototype.isEmpty=function(){return this.sortedSet.isEmpty();};/**
     * Returns the index of the provided key in the document set, or -1 if the
     * document key is not present in the set;
     */DocumentSet.prototype.indexOf=function(key){var doc=this.keyedMap.get(key);return doc?this.sortedSet.indexOf(doc):-1;};Object.defineProperty(DocumentSet.prototype,"size",{get:function(){return this.sortedSet.size;},enumerable:true,configurable:true});/** Iterates documents in order defined by "comparator" */DocumentSet.prototype.forEach=function(cb){this.sortedSet.inorderTraversal(function(k,v){cb(k);return false;});};/** Inserts or updates a document with the same key */DocumentSet.prototype.add=function(doc){// First remove the element if we have it.
var set=this.delete(doc.key);return set.copy(set.keyedMap.insert(doc.key,doc),set.sortedSet.insert(doc,null));};/** Deletes a document with a given key */DocumentSet.prototype.delete=function(key){var doc=this.get(key);if(!doc){return this;}return this.copy(this.keyedMap.remove(key),this.sortedSet.remove(doc));};DocumentSet.prototype.isEqual=function(other){if(!(other instanceof DocumentSet))return false;if(this.size!==other.size)return false;var thisIt=this.sortedSet.getIterator();var otherIt=other.sortedSet.getIterator();while(thisIt.hasNext()){var thisDoc=thisIt.getNext().key;var otherDoc=otherIt.getNext().key;if(!thisDoc.isEqual(otherDoc))return false;}return true;};DocumentSet.prototype.toString=function(){var docStrings=[];this.forEach(function(doc){docStrings.push(doc.toString());});if(docStrings.length===0){return'DocumentSet ()';}else{return'DocumentSet (\n  '+docStrings.join('  \n')+'\n)';}};DocumentSet.prototype.copy=function(keyedMap,sortedSet){var newSet=new DocumentSet();newSet.comparator=this.comparator;newSet.keyedMap=keyedMap;newSet.sortedSet=sortedSet;return newSet;};return DocumentSet;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var ChangeType;(function(ChangeType){ChangeType[ChangeType["Added"]=0]="Added";ChangeType[ChangeType["Removed"]=1]="Removed";ChangeType[ChangeType["Modified"]=2]="Modified";ChangeType[ChangeType["Metadata"]=3]="Metadata";})(ChangeType||(ChangeType={}));var SyncState;(function(SyncState){SyncState[SyncState["Local"]=0]="Local";SyncState[SyncState["Synced"]=1]="Synced";})(SyncState||(SyncState={}));/**
 * DocumentChangeSet keeps track of a set of changes to docs in a query, merging
 * duplicate events for the same doc.
 */var DocumentChangeSet=/** @class */function(){function DocumentChangeSet(){this.changeMap=new SortedMap(DocumentKey.comparator);}DocumentChangeSet.prototype.track=function(change){var key=change.doc.key;var oldChange=this.changeMap.get(key);if(!oldChange){this.changeMap=this.changeMap.insert(key,change);return;}// Merge the new change with the existing change.
if(change.type!==ChangeType.Added&&oldChange.type===ChangeType.Metadata){this.changeMap=this.changeMap.insert(key,change);}else if(change.type===ChangeType.Metadata&&oldChange.type!==ChangeType.Removed){this.changeMap=this.changeMap.insert(key,{type:oldChange.type,doc:change.doc});}else if(change.type===ChangeType.Modified&&oldChange.type===ChangeType.Modified){this.changeMap=this.changeMap.insert(key,{type:ChangeType.Modified,doc:change.doc});}else if(change.type===ChangeType.Modified&&oldChange.type===ChangeType.Added){this.changeMap=this.changeMap.insert(key,{type:ChangeType.Added,doc:change.doc});}else if(change.type===ChangeType.Removed&&oldChange.type===ChangeType.Added){this.changeMap=this.changeMap.remove(key);}else if(change.type===ChangeType.Removed&&oldChange.type===ChangeType.Modified){this.changeMap=this.changeMap.insert(key,{type:ChangeType.Removed,doc:oldChange.doc});}else if(change.type===ChangeType.Added&&oldChange.type===ChangeType.Removed){this.changeMap=this.changeMap.insert(key,{type:ChangeType.Modified,doc:change.doc});}else{// This includes these cases, which don't make sense:
// Added->Added
// Removed->Removed
// Modified->Added
// Removed->Modified
// Metadata->Added
// Removed->Metadata
fail('unsupported combination of changes: '+JSON.stringify(change)+' after '+JSON.stringify(oldChange));}};DocumentChangeSet.prototype.getChanges=function(){var changes=[];this.changeMap.inorderTraversal(function(key,change){changes.push(change);});return changes;};return DocumentChangeSet;}();var ViewSnapshot=/** @class */function(){function ViewSnapshot(query,docs,oldDocs,docChanges,mutatedKeys,fromCache,syncStateChanged,excludesMetadataChanges){this.query=query;this.docs=docs;this.oldDocs=oldDocs;this.docChanges=docChanges;this.mutatedKeys=mutatedKeys;this.fromCache=fromCache;this.syncStateChanged=syncStateChanged;this.excludesMetadataChanges=excludesMetadataChanges;}/** Returns a view snapshot as if all documents in the snapshot were added. */ViewSnapshot.fromInitialDocuments=function(query,documents,mutatedKeys,fromCache){var changes=[];documents.forEach(function(doc){changes.push({type:ChangeType.Added,doc:doc});});return new ViewSnapshot(query,documents,DocumentSet.emptySet(documents),changes,mutatedKeys,fromCache,true,false);};Object.defineProperty(ViewSnapshot.prototype,"hasPendingWrites",{get:function(){return!this.mutatedKeys.isEmpty();},enumerable:true,configurable:true});ViewSnapshot.prototype.isEqual=function(other){if(this.fromCache!==other.fromCache||this.syncStateChanged!==other.syncStateChanged||!this.mutatedKeys.isEqual(other.mutatedKeys)||!this.query.isEqual(other.query)||!this.docs.isEqual(other.docs)||!this.oldDocs.isEqual(other.oldDocs)){return false;}var changes=this.docChanges;var otherChanges=other.docChanges;if(changes.length!==otherChanges.length){return false;}for(var i=0;i<changes.length;i++){if(changes[i].type!==otherChanges[i].type||!changes[i].doc.isEqual(otherChanges[i].doc)){return false;}}return true;};return ViewSnapshot;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * An event from the RemoteStore. It is split into targetChanges (changes to the
 * state or the set of documents in our watched targets) and documentUpdates
 * (changes to the actual documents).
 */var RemoteEvent=/** @class */function(){function RemoteEvent(/**
     * The snapshot version this event brings us up to, or MIN if not set.
     */snapshotVersion,/**
     * A map from target to changes to the target. See TargetChange.
     */targetChanges,/**
     * A set of targets that is known to be inconsistent. Listens for these
     * targets should be re-established without resume tokens.
     */targetMismatches,/**
     * A set of which documents have changed or been deleted, along with the
     * doc's new values (if not deleted).
     */documentUpdates,/**
     * A set of which document updates are due only to limbo resolution targets.
     */resolvedLimboDocuments){this.snapshotVersion=snapshotVersion;this.targetChanges=targetChanges;this.targetMismatches=targetMismatches;this.documentUpdates=documentUpdates;this.resolvedLimboDocuments=resolvedLimboDocuments;}/**
     * HACK: Views require RemoteEvents in order to determine whether the view is
     * CURRENT, but secondary tabs don't receive remote events. So this method is
     * used to create a synthesized RemoteEvent that can be used to apply a
     * CURRENT status change to a View, for queries executed in a different tab.
     */// PORTING NOTE: Multi-tab only
RemoteEvent.createSynthesizedRemoteEventForCurrentChange=function(targetId,current){var _a;var targetChanges=(_a={},_a[targetId]=TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId,current),_a);return new RemoteEvent(SnapshotVersion.MIN,targetChanges,targetIdSet(),maybeDocumentMap(),documentKeySet());};return RemoteEvent;}();/**
 * A TargetChange specifies the set of changes for a specific target as part of
 * a RemoteEvent. These changes track which documents are added, modified or
 * removed, as well as the target's resume token and whether the target is
 * marked CURRENT.
 * The actual changes *to* documents are not part of the TargetChange since
 * documents may be part of multiple targets.
 */var TargetChange=/** @class */function(){function TargetChange(/**
     * An opaque, server-assigned token that allows watching a query to be resumed
     * after disconnecting without retransmitting all the data that matches the
     * query. The resume token essentially identifies a point in time from which
     * the server should resume sending results.
     */resumeToken,/**
     * The "current" (synced) status of this target. Note that "current"
     * has special meaning in the RPC protocol that implies that a target is
     * both up-to-date and consistent with the rest of the watch stream.
     */current,/**
     * The set of documents that were newly assigned to this target as part of
     * this remote event.
     */addedDocuments,/**
     * The set of documents that were already assigned to this target but received
     * an update during this remote event.
     */modifiedDocuments,/**
     * The set of documents that were removed from this target as part of this
     * remote event.
     */removedDocuments){this.resumeToken=resumeToken;this.current=current;this.addedDocuments=addedDocuments;this.modifiedDocuments=modifiedDocuments;this.removedDocuments=removedDocuments;}/**
     * HACK: Views require TargetChanges in order to determine whether the view is
     * CURRENT, but secondary tabs don't receive remote events. So this method is
     * used to create a synthesized TargetChanges that can be used to apply a
     * CURRENT status change to a View, for queries executed in a different tab.
     */// PORTING NOTE: Multi-tab only
TargetChange.createSynthesizedTargetChangeForCurrentChange=function(targetId,current){return new TargetChange(emptyByteString(),current,documentKeySet(),documentKeySet(),documentKeySet());};return TargetChange;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Represents a changed document and a list of target ids to which this change
 * applies.
 *
 * If document has been deleted NoDocument will be provided.
 */var DocumentWatchChange=/** @class */function(){function DocumentWatchChange(/** The new document applies to all of these targets. */updatedTargetIds,/** The new document is removed from all of these targets. */removedTargetIds,/** The key of the document for this change. */key,/**
     * The new document or NoDocument if it was deleted. Is null if the
     * document went out of view without the server sending a new document.
     */newDoc){this.updatedTargetIds=updatedTargetIds;this.removedTargetIds=removedTargetIds;this.key=key;this.newDoc=newDoc;}return DocumentWatchChange;}();var ExistenceFilterChange=/** @class */function(){function ExistenceFilterChange(targetId,existenceFilter){this.targetId=targetId;this.existenceFilter=existenceFilter;}return ExistenceFilterChange;}();var WatchTargetChangeState;(function(WatchTargetChangeState){WatchTargetChangeState[WatchTargetChangeState["NoChange"]=0]="NoChange";WatchTargetChangeState[WatchTargetChangeState["Added"]=1]="Added";WatchTargetChangeState[WatchTargetChangeState["Removed"]=2]="Removed";WatchTargetChangeState[WatchTargetChangeState["Current"]=3]="Current";WatchTargetChangeState[WatchTargetChangeState["Reset"]=4]="Reset";})(WatchTargetChangeState||(WatchTargetChangeState={}));var WatchTargetChange=/** @class */function(){function WatchTargetChange(/** What kind of change occurred to the watch target. */state,/** The target IDs that were added/removed/set. */targetIds,/**
     * An opaque, server-assigned token that allows watching a query to be
     * resumed after disconnecting without retransmitting all the data that
     * matches the query. The resume token essentially identifies a point in
     * time from which the server should resume sending results.
     */resumeToken,/** An RPC error indicating why the watch failed. */cause){if(resumeToken===void 0){resumeToken=emptyByteString();}if(cause===void 0){cause=null;}this.state=state;this.targetIds=targetIds;this.resumeToken=resumeToken;this.cause=cause;}return WatchTargetChange;}();/** Tracks the internal state of a Watch target. */var TargetState=/** @class */function(){function TargetState(){/**
         * The number of pending responses (adds or removes) that we are waiting on.
         * We only consider targets active that have no pending responses.
         */this.pendingResponses=0;/**
         * Keeps track of the document changes since the last raised snapshot.
         *
         * These changes are continuously updated as we receive document updates and
         * always reflect the current set of changes against the last issued snapshot.
         */this.documentChanges=snapshotChangesMap();/** See public getters for explanations of these fields. */this._resumeToken=emptyByteString();this._current=false;/**
         * Whether this target state should be included in the next snapshot. We
         * initialize to true so that newly-added targets are included in the next
         * RemoteEvent.
         */this._hasPendingChanges=true;}Object.defineProperty(TargetState.prototype,"current",{/**
         * Whether this target has been marked 'current'.
         *
         * 'Current' has special meaning in the RPC protocol: It implies that the
         * Watch backend has sent us all changes up to the point at which the target
         * was added and that the target is consistent with the rest of the watch
         * stream.
         */get:function(){return this._current;},enumerable:true,configurable:true});Object.defineProperty(TargetState.prototype,"resumeToken",{/** The last resume token sent to us for this target. */get:function(){return this._resumeToken;},enumerable:true,configurable:true});Object.defineProperty(TargetState.prototype,"isPending",{/** Whether this target has pending target adds or target removes. */get:function(){return this.pendingResponses!==0;},enumerable:true,configurable:true});Object.defineProperty(TargetState.prototype,"hasPendingChanges",{/** Whether we have modified any state that should trigger a snapshot. */get:function(){return this._hasPendingChanges;},enumerable:true,configurable:true});/**
     * Applies the resume token to the TargetChange, but only when it has a new
     * value. Empty resumeTokens are discarded.
     */TargetState.prototype.updateResumeToken=function(resumeToken){if(resumeToken.length>0){this._hasPendingChanges=true;this._resumeToken=resumeToken;}};/**
     * Creates a target change from the current set of changes.
     *
     * To reset the document changes after raising this snapshot, call
     * `clearPendingChanges()`.
     */TargetState.prototype.toTargetChange=function(){var addedDocuments=documentKeySet();var modifiedDocuments=documentKeySet();var removedDocuments=documentKeySet();this.documentChanges.forEach(function(key,changeType){switch(changeType){case ChangeType.Added:addedDocuments=addedDocuments.add(key);break;case ChangeType.Modified:modifiedDocuments=modifiedDocuments.add(key);break;case ChangeType.Removed:removedDocuments=removedDocuments.add(key);break;default:fail('Encountered invalid change type: '+changeType);}});return new TargetChange(this._resumeToken,this._current,addedDocuments,modifiedDocuments,removedDocuments);};/**
     * Resets the document changes and sets `hasPendingChanges` to false.
     */TargetState.prototype.clearPendingChanges=function(){this._hasPendingChanges=false;this.documentChanges=snapshotChangesMap();};TargetState.prototype.addDocumentChange=function(key,changeType){this._hasPendingChanges=true;this.documentChanges=this.documentChanges.insert(key,changeType);};TargetState.prototype.removeDocumentChange=function(key){this._hasPendingChanges=true;this.documentChanges=this.documentChanges.remove(key);};TargetState.prototype.recordPendingTargetRequest=function(){this.pendingResponses+=1;};TargetState.prototype.recordTargetResponse=function(){this.pendingResponses-=1;};TargetState.prototype.markCurrent=function(){this._hasPendingChanges=true;this._current=true;};return TargetState;}();/**
 * A helper class to accumulate watch changes into a RemoteEvent.
 */var WatchChangeAggregator=/** @class */function(){function WatchChangeAggregator(metadataProvider){this.metadataProvider=metadataProvider;/** The internal state of all tracked targets. */this.targetStates={};/** Keeps track of the documents to update since the last raised snapshot. */this.pendingDocumentUpdates=maybeDocumentMap();/** A mapping of document keys to their set of target IDs. */this.pendingDocumentTargetMapping=documentTargetMap();/**
         * A list of targets with existence filter mismatches. These targets are
         * known to be inconsistent and their listens needs to be re-established by
         * RemoteStore.
         */this.pendingTargetResets=new SortedSet(primitiveComparator);}/**
     * Processes and adds the DocumentWatchChange to the current set of changes.
     */WatchChangeAggregator.prototype.handleDocumentChange=function(docChange){for(var _i=0,_a=docChange.updatedTargetIds;_i<_a.length;_i++){var targetId=_a[_i];if(docChange.newDoc instanceof Document){this.addDocumentToTarget(targetId,docChange.newDoc);}else if(docChange.newDoc instanceof NoDocument){this.removeDocumentFromTarget(targetId,docChange.key,docChange.newDoc);}}for(var _b=0,_c=docChange.removedTargetIds;_b<_c.length;_b++){var targetId=_c[_b];this.removeDocumentFromTarget(targetId,docChange.key,docChange.newDoc);}};/** Processes and adds the WatchTargetChange to the current set of changes. */WatchChangeAggregator.prototype.handleTargetChange=function(targetChange){var _this=this;this.forEachTarget(targetChange,function(targetId){var targetState=_this.ensureTargetState(targetId);switch(targetChange.state){case WatchTargetChangeState.NoChange:if(_this.isActiveTarget(targetId)){targetState.updateResumeToken(targetChange.resumeToken);}break;case WatchTargetChangeState.Added:// We need to decrement the number of pending acks needed from watch
// for this targetId.
targetState.recordTargetResponse();if(!targetState.isPending){// We have a freshly added target, so we need to reset any state
// that we had previously. This can happen e.g. when remove and add
// back a target for existence filter mismatches.
targetState.clearPendingChanges();}targetState.updateResumeToken(targetChange.resumeToken);break;case WatchTargetChangeState.Removed:// We need to keep track of removed targets to we can post-filter and
// remove any target changes.
// We need to decrement the number of pending acks needed from watch
// for this targetId.
targetState.recordTargetResponse();if(!targetState.isPending){_this.removeTarget(targetId);}assert(!targetChange.cause,'WatchChangeAggregator does not handle errored targets');break;case WatchTargetChangeState.Current:if(_this.isActiveTarget(targetId)){targetState.markCurrent();targetState.updateResumeToken(targetChange.resumeToken);}break;case WatchTargetChangeState.Reset:if(_this.isActiveTarget(targetId)){// Reset the target and synthesizes removes for all existing
// documents. The backend will re-add any documents that still
// match the target before it sends the next global snapshot.
_this.resetTarget(targetId);targetState.updateResumeToken(targetChange.resumeToken);}break;default:fail('Unknown target watch change state: '+targetChange.state);}});};/**
     * Iterates over all targetIds that the watch change applies to: either the
     * targetIds explicitly listed in the change or the targetIds of all currently
     * active targets.
     */WatchChangeAggregator.prototype.forEachTarget=function(targetChange,fn){if(targetChange.targetIds.length>0){targetChange.targetIds.forEach(fn);}else{forEachNumber(this.targetStates,fn);}};/**
     * Handles existence filters and synthesizes deletes for filter mismatches.
     * Targets that are invalidated by filter mismatches are added to
     * `pendingTargetResets`.
     */WatchChangeAggregator.prototype.handleExistenceFilter=function(watchChange){var targetId=watchChange.targetId;var expectedCount=watchChange.existenceFilter.count;var queryData=this.queryDataForActiveTarget(targetId);if(queryData){var query=queryData.query;if(query.isDocumentQuery()){if(expectedCount===0){// The existence filter told us the document does not exist. We deduce
// that this document does not exist and apply a deleted document to
// our updates. Without applying this deleted document there might be
// another query that will raise this document as part of a snapshot
// until it is resolved, essentially exposing inconsistency between
// queries.
var key=new DocumentKey(query.path);this.removeDocumentFromTarget(targetId,key,new NoDocument(key,SnapshotVersion.forDeletedDoc()));}else{assert(expectedCount===1,'Single document existence filter with count: '+expectedCount);}}else{var currentSize=this.getCurrentDocumentCountForTarget(targetId);if(currentSize!==expectedCount){// Existence filter mismatch: We reset the mapping and raise a new
// snapshot with `isFromCache:true`.
this.resetTarget(targetId);this.pendingTargetResets=this.pendingTargetResets.add(targetId);}}}};/**
     * Converts the currently accumulated state into a remote event at the
     * provided snapshot version. Resets the accumulated changes before returning.
     */WatchChangeAggregator.prototype.createRemoteEvent=function(snapshotVersion){var _this=this;var targetChanges={};forEachNumber(this.targetStates,function(targetId,targetState){var queryData=_this.queryDataForActiveTarget(targetId);if(queryData){if(targetState.current&&queryData.query.isDocumentQuery()){// Document queries for document that don't exist can produce an empty
// result set. To update our local cache, we synthesize a document
// delete if we have not previously received the document. This
// resolves the limbo state of the document, removing it from
// limboDocumentRefs.
//
// TODO(dimond): Ideally we would have an explicit lookup query
// instead resulting in an explicit delete message and we could
// remove this special logic.
var key=new DocumentKey(queryData.query.path);if(_this.pendingDocumentUpdates.get(key)===null&&!_this.targetContainsDocument(targetId,key)){_this.removeDocumentFromTarget(targetId,key,new NoDocument(key,snapshotVersion));}}if(targetState.hasPendingChanges){targetChanges[targetId]=targetState.toTargetChange();targetState.clearPendingChanges();}}});var resolvedLimboDocuments=documentKeySet();// We extract the set of limbo-only document updates as the GC logic
// special-cases documents that do not appear in the query cache.
//
// TODO(gsoltis): Expand on this comment once GC is available in the JS
// client.
this.pendingDocumentTargetMapping.forEach(function(key,targets){var isOnlyLimboTarget=true;targets.forEachWhile(function(targetId){var queryData=_this.queryDataForActiveTarget(targetId);if(queryData&&queryData.purpose!==QueryPurpose.LimboResolution){isOnlyLimboTarget=false;return false;}return true;});if(isOnlyLimboTarget){resolvedLimboDocuments=resolvedLimboDocuments.add(key);}});var remoteEvent=new RemoteEvent(snapshotVersion,targetChanges,this.pendingTargetResets,this.pendingDocumentUpdates,resolvedLimboDocuments);this.pendingDocumentUpdates=maybeDocumentMap();this.pendingDocumentTargetMapping=documentTargetMap();this.pendingTargetResets=new SortedSet(primitiveComparator);return remoteEvent;};/**
     * Adds the provided document to the internal list of document updates and
     * its document key to the given target's mapping.
     */// Visible for testing.
WatchChangeAggregator.prototype.addDocumentToTarget=function(targetId,document){if(!this.isActiveTarget(targetId)){return;}var changeType=this.targetContainsDocument(targetId,document.key)?ChangeType.Modified:ChangeType.Added;var targetState=this.ensureTargetState(targetId);targetState.addDocumentChange(document.key,changeType);this.pendingDocumentUpdates=this.pendingDocumentUpdates.insert(document.key,document);this.pendingDocumentTargetMapping=this.pendingDocumentTargetMapping.insert(document.key,this.ensureDocumentTargetMapping(document.key).add(targetId));};/**
     * Removes the provided document from the target mapping. If the
     * document no longer matches the target, but the document's state is still
     * known (e.g. we know that the document was deleted or we received the change
     * that caused the filter mismatch), the new document can be provided
     * to update the remote document cache.
     */// Visible for testing.
WatchChangeAggregator.prototype.removeDocumentFromTarget=function(targetId,key,updatedDocument){if(!this.isActiveTarget(targetId)){return;}var targetState=this.ensureTargetState(targetId);if(this.targetContainsDocument(targetId,key)){targetState.addDocumentChange(key,ChangeType.Removed);}else{// The document may have entered and left the target before we raised a
// snapshot, so we can just ignore the change.
targetState.removeDocumentChange(key);}this.pendingDocumentTargetMapping=this.pendingDocumentTargetMapping.insert(key,this.ensureDocumentTargetMapping(key).delete(targetId));if(updatedDocument){this.pendingDocumentUpdates=this.pendingDocumentUpdates.insert(key,updatedDocument);}};WatchChangeAggregator.prototype.removeTarget=function(targetId){delete this.targetStates[targetId];};/**
     * Returns the current count of documents in the target. This includes both
     * the number of documents that the LocalStore considers to be part of the
     * target as well as any accumulated changes.
     */WatchChangeAggregator.prototype.getCurrentDocumentCountForTarget=function(targetId){var targetState=this.ensureTargetState(targetId);var targetChange=targetState.toTargetChange();return this.metadataProvider.getRemoteKeysForTarget(targetId).size+targetChange.addedDocuments.size-targetChange.removedDocuments.size;};/**
     * Increment the number of acks needed from watch before we can consider the
     * server to be 'in-sync' with the client's active targets.
     */WatchChangeAggregator.prototype.recordPendingTargetRequest=function(targetId){// For each request we get we need to record we need a response for it.
var targetState=this.ensureTargetState(targetId);targetState.recordPendingTargetRequest();};WatchChangeAggregator.prototype.ensureTargetState=function(targetId){if(!this.targetStates[targetId]){this.targetStates[targetId]=new TargetState();}return this.targetStates[targetId];};WatchChangeAggregator.prototype.ensureDocumentTargetMapping=function(key){var targetMapping=this.pendingDocumentTargetMapping.get(key);if(!targetMapping){targetMapping=new SortedSet(primitiveComparator);this.pendingDocumentTargetMapping=this.pendingDocumentTargetMapping.insert(key,targetMapping);}return targetMapping;};/**
     * Verifies that the user is still interested in this target (by calling
     * `getQueryDataForTarget()`) and that we are not waiting for pending ADDs
     * from watch.
     */WatchChangeAggregator.prototype.isActiveTarget=function(targetId){return this.queryDataForActiveTarget(targetId)!==null;};/**
     * Returns the QueryData for an active target (i.e. a target that the user
     * is still interested in that has no outstanding target change requests).
     */WatchChangeAggregator.prototype.queryDataForActiveTarget=function(targetId){var targetState=this.targetStates[targetId];return targetState&&targetState.isPending?null:this.metadataProvider.getQueryDataForTarget(targetId);};/**
     * Resets the state of a Watch target to its initial state (e.g. sets
     * 'current' to false, clears the resume token and removes its target mapping
     * from all documents).
     */WatchChangeAggregator.prototype.resetTarget=function(targetId){var _this=this;assert(!this.targetStates[targetId].isPending,'Should only reset active targets');this.targetStates[targetId]=new TargetState();// Trigger removal for any documents currently mapped to this target.
// These removals will be part of the initial snapshot if Watch does not
// resend these documents.
var existingKeys=this.metadataProvider.getRemoteKeysForTarget(targetId);existingKeys.forEach(function(key){_this.removeDocumentFromTarget(targetId,key,/*updatedDocument=*/null);});};/**
     * Returns whether the LocalStore considers the document to be part of the
     * specified target.
     */WatchChangeAggregator.prototype.targetContainsDocument=function(targetId,key){var existingKeys=this.metadataProvider.getRemoteKeysForTarget(targetId);return existingKeys.has(key);};return WatchChangeAggregator;}();function documentTargetMap(){return new SortedMap(DocumentKey.comparator);}function snapshotChangesMap(){return new SortedMap(DocumentKey.comparator);}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DIRECTIONS=function(){var dirs={};dirs[Direction.ASCENDING.name]='ASCENDING';dirs[Direction.DESCENDING.name]='DESCENDING';return dirs;}();var OPERATORS=function(){var ops={};ops[RelationOp.LESS_THAN.name]='LESS_THAN';ops[RelationOp.LESS_THAN_OR_EQUAL.name]='LESS_THAN_OR_EQUAL';ops[RelationOp.GREATER_THAN.name]='GREATER_THAN';ops[RelationOp.GREATER_THAN_OR_EQUAL.name]='GREATER_THAN_OR_EQUAL';ops[RelationOp.EQUAL.name]='EQUAL';ops[RelationOp.ARRAY_CONTAINS.name]='ARRAY_CONTAINS';return ops;}();// A RegExp matching ISO 8601 UTC timestamps with optional fraction.
var ISO_REG_EXP=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);function assertPresent(value,description){assert(!isNullOrUndefined(value),description+' is missing');}function parseInt64(value){// TODO(bjornick): Handle int64 greater than 53 bits.
if(typeof value==='number'){return value;}else if(typeof value==='string'){return Number(value);}else{return fail("can't parse "+value);}}/**
 * Generates JsonObject values for the Datastore API suitable for sending to
 * either GRPC stub methods or via the JSON/HTTP REST API.
 * TODO(klimt): We can remove the databaseId argument if we keep the full
 * resource name in documents.
 */var JsonProtoSerializer=/** @class */function(){function JsonProtoSerializer(databaseId,options){this.databaseId=databaseId;this.options=options;}JsonProtoSerializer.prototype.emptyByteString=function(){if(this.options.useProto3Json){return'';}else{return new Uint8Array(0);}};JsonProtoSerializer.prototype.unsafeCastProtoByteString=function(byteString){// byteStrings can be either string or UInt8Array, but the typings say
// it's always a string. Cast as string to avoid type check failing
return byteString;};JsonProtoSerializer.prototype.fromRpcStatus=function(status){var code=status.code===undefined?Code.UNKNOWN:mapCodeFromRpcCode(status.code);return new FirestoreError(code,status.message||'');};/**
     * Returns a value for a number (or undefined) that's appropriate to put into
     * a google.protobuf.Int32Value proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "number" because that's what
     * our generated proto interfaces say Int32Value must be. But GRPC actually
     * expects a { value: <number> } struct.
     */JsonProtoSerializer.prototype.toInt32Value=function(val){if(!isNullOrUndefined(val)){// tslint:disable-next-line:no-any We need to match generated Proto types.
return{value:val};}else{return undefined;}};/**
     * Returns a number (or null) from a google.protobuf.Int32Value proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as accepting "number" because that's what
     * our generated proto interfaces say Int32Value must be, but it actually
     * accepts { value: number } to match our serialization in toInt32Value().
     */JsonProtoSerializer.prototype.fromInt32Value=function(val){var result;if(typeof val==='object'){// tslint:disable-next-line:no-any We need to match generated Proto types.
result=val.value;}else{// We accept raw numbers (without the {value: ... } wrapper) for
// compatibility with legacy persisted data.
result=val;}return isNullOrUndefined(result)?null:result;};/**
     * Returns a value for a Date that's appropriate to put into a proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "string" because that's what
     * our generated proto interfaces say dates must be. But it's easier and safer
     * to actually return a Timestamp proto.
     */JsonProtoSerializer.prototype.toTimestamp=function(timestamp){return{seconds:timestamp.seconds,nanos:timestamp.nanoseconds// tslint:disable-next-line:no-any
};};JsonProtoSerializer.prototype.fromTimestamp=function(date){// The json interface (for the browser) will return an iso timestamp string,
// while the proto js library (for node) will return a
// google.protobuf.Timestamp instance.
if(typeof date==='string'){// TODO(b/37282237): Use strings for Proto3 timestamps
// assert(this.options.useProto3Json,
//   'The timestamp string format requires Proto3.');
return this.fromIso8601String(date);}else{assert(!!date,'Cannot deserialize null or undefined timestamp.');// TODO(b/37282237): Use strings for Proto3 timestamps
// assert(!this.options.useProto3Json,
//   'The timestamp instance format requires Proto JS.');
var seconds=parseInt64(date.seconds||'0');var nanos=date.nanos||0;return new Timestamp(seconds,nanos);}};JsonProtoSerializer.prototype.fromIso8601String=function(utc){// The date string can have higher precision (nanos) than the Date class
// (millis), so we do some custom parsing here.
// Parse the nanos right out of the string.
var nanos=0;var fraction=ISO_REG_EXP.exec(utc);assert(!!fraction,'invalid timestamp: '+utc);if(fraction[1]){// Pad the fraction out to 9 digits (nanos).
var nanoStr=fraction[1];nanoStr=(nanoStr+'000000000').substr(0,9);nanos=Number(nanoStr);}// Parse the date to get the seconds.
var date=new Date(utc);var seconds=Math.floor(date.getTime()/1000);return new Timestamp(seconds,nanos);};/**
     * Returns a value for bytes that's appropriate to put in a proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "string" because that's what
     * our generated proto interfaces say bytes must be. But it should return
     * an Uint8Array in Node.
     */JsonProtoSerializer.prototype.toBytes=function(bytes){if(this.options.useProto3Json){return bytes.toBase64();}else{// The typings say it's a string, but it needs to be a Uint8Array in Node.
return this.unsafeCastProtoByteString(bytes.toUint8Array());}};/**
     * Parse the blob from the protos into the internal Blob class. Note that the
     * typings assume all blobs are strings, but they are actually Uint8Arrays
     * on Node.
     */JsonProtoSerializer.prototype.fromBlob=function(blob){if(typeof blob==='string'){assert(this.options.useProto3Json,'Expected bytes to be passed in as Uint8Array, but got a string instead.');return Blob.fromBase64String(blob);}else{assert(!this.options.useProto3Json,'Expected bytes to be passed in as string, but got something else instead.');return Blob.fromUint8Array(blob);}};JsonProtoSerializer.prototype.toVersion=function(version){return this.toTimestamp(version.toTimestamp());};JsonProtoSerializer.prototype.fromVersion=function(version){assert(!!version,"Trying to deserialize version that isn't set");return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));};JsonProtoSerializer.prototype.toResourceName=function(databaseId,path){return this.fullyQualifiedPrefixPath(databaseId).child('documents').child(path).canonicalString();};JsonProtoSerializer.prototype.fromResourceName=function(name){var resource=ResourcePath.fromString(name);assert(this.isValidResourceName(resource),'Tried to deserialize invalid key '+resource.toString());return resource;};JsonProtoSerializer.prototype.toName=function(key){return this.toResourceName(this.databaseId,key.path);};JsonProtoSerializer.prototype.fromName=function(name){var resource=this.fromResourceName(name);assert(resource.get(1)===this.databaseId.projectId,'Tried to deserialize key from different project: '+resource.get(1)+' vs '+this.databaseId.projectId);assert(!resource.get(3)&&!this.databaseId.database||resource.get(3)===this.databaseId.database,'Tried to deserialize key from different database: '+resource.get(3)+' vs '+this.databaseId.database);return new DocumentKey(this.extractLocalPathFromResourceName(resource));};JsonProtoSerializer.prototype.toQueryPath=function(path){return this.toResourceName(this.databaseId,path);};JsonProtoSerializer.prototype.fromQueryPath=function(name){var resourceName=this.fromResourceName(name);// In v1beta1 queries for collections at the root did not have a trailing
// "/documents". In v1 all resource paths contain "/documents". Preserve the
// ability to read the v1beta1 form for compatibility with queries persisted
// in the local query cache.
if(resourceName.length===4){return ResourcePath.EMPTY_PATH;}return this.extractLocalPathFromResourceName(resourceName);};Object.defineProperty(JsonProtoSerializer.prototype,"encodedDatabaseId",{get:function(){var path=new ResourcePath(['projects',this.databaseId.projectId,'databases',this.databaseId.database]);return path.canonicalString();},enumerable:true,configurable:true});JsonProtoSerializer.prototype.fullyQualifiedPrefixPath=function(databaseId){return new ResourcePath(['projects',databaseId.projectId,'databases',databaseId.database]);};JsonProtoSerializer.prototype.extractLocalPathFromResourceName=function(resourceName){assert(resourceName.length>4&&resourceName.get(4)==='documents','tried to deserialize invalid key '+resourceName.toString());return resourceName.popFirst(5);};JsonProtoSerializer.prototype.isValidResourceName=function(path){// Resource names have at least 4 components (project ID, database ID)
return path.length>=4&&path.get(0)==='projects'&&path.get(2)==='databases';};JsonProtoSerializer.prototype.toValue=function(val){if(val instanceof NullValue){return{nullValue:'NULL_VALUE'};}else if(val instanceof BooleanValue){return{booleanValue:val.value()};}else if(val instanceof IntegerValue){return{integerValue:''+val.value()};}else if(val instanceof DoubleValue){var doubleValue=val.value();if(this.options.useProto3Json){// Proto 3 let's us encode NaN and Infinity as string values as
// expected by the backend. This is currently not checked by our unit
// tests because they rely on protobuf.js.
if(isNaN(doubleValue)){return{doubleValue:'NaN'};}else if(doubleValue===Infinity){return{doubleValue:'Infinity'};}else if(doubleValue===-Infinity){return{doubleValue:'-Infinity'};}}return{doubleValue:val.value()};}else if(val instanceof StringValue){return{stringValue:val.value()};}else if(val instanceof ObjectValue){return{mapValue:this.toMapValue(val)};}else if(val instanceof ArrayValue){return{arrayValue:this.toArrayValue(val)};}else if(val instanceof TimestampValue){return{timestampValue:this.toTimestamp(val.internalValue)};}else if(val instanceof GeoPointValue){return{geoPointValue:{latitude:val.value().latitude,longitude:val.value().longitude}};}else if(val instanceof BlobValue){return{bytesValue:this.toBytes(val.value())};}else if(val instanceof RefValue){return{referenceValue:this.toResourceName(val.databaseId,val.key.path)};}else{return fail('Unknown FieldValue '+JSON.stringify(val));}};JsonProtoSerializer.prototype.fromValue=function(obj){var _this=this;// tslint:disable-next-line:no-any
var type=obj['value_type'];if(hasTag(obj,type,'nullValue')){return NullValue.INSTANCE;}else if(hasTag(obj,type,'booleanValue')){return BooleanValue.of(obj.booleanValue);}else if(hasTag(obj,type,'integerValue')){return new IntegerValue(parseInt64(obj.integerValue));}else if(hasTag(obj,type,'doubleValue')){if(this.options.useProto3Json){// Proto 3 uses the string values 'NaN' and 'Infinity'.
if(obj.doubleValue==='NaN'){return DoubleValue.NAN;}else if(obj.doubleValue==='Infinity'){return DoubleValue.POSITIVE_INFINITY;}else if(obj.doubleValue==='-Infinity'){return DoubleValue.NEGATIVE_INFINITY;}}return new DoubleValue(obj.doubleValue);}else if(hasTag(obj,type,'stringValue')){return new StringValue(obj.stringValue);}else if(hasTag(obj,type,'mapValue')){return this.fromFields(obj.mapValue.fields||{});}else if(hasTag(obj,type,'arrayValue')){// "values" is not present if the array is empty
assertPresent(obj.arrayValue,'arrayValue');var values=obj.arrayValue.values||[];return new ArrayValue(values.map(function(v){return _this.fromValue(v);}));}else if(hasTag(obj,type,'timestampValue')){assertPresent(obj.timestampValue,'timestampValue');return new TimestampValue(this.fromTimestamp(obj.timestampValue));}else if(hasTag(obj,type,'geoPointValue')){assertPresent(obj.geoPointValue,'geoPointValue');var latitude=obj.geoPointValue.latitude||0;var longitude=obj.geoPointValue.longitude||0;return new GeoPointValue(new GeoPoint(latitude,longitude));}else if(hasTag(obj,type,'bytesValue')){assertPresent(obj.bytesValue,'bytesValue');var blob=this.fromBlob(obj.bytesValue);return new BlobValue(blob);}else if(hasTag(obj,type,'referenceValue')){assertPresent(obj.referenceValue,'referenceValue');var resourceName=this.fromResourceName(obj.referenceValue);var dbId=new DatabaseId(resourceName.get(1),resourceName.get(3));var key=new DocumentKey(this.extractLocalPathFromResourceName(resourceName));return new RefValue(dbId,key);}else{return fail('Unknown Value proto '+JSON.stringify(obj));}};/** Creates an api.Document from key and fields (but no create/update time) */JsonProtoSerializer.prototype.toMutationDocument=function(key,fields){return{name:this.toName(key),fields:this.toFields(fields)};};JsonProtoSerializer.prototype.toDocument=function(document){assert(!document.hasLocalMutations,"Can't serialize documents with mutations.");return{name:this.toName(document.key),fields:this.toFields(document.data),updateTime:this.toTimestamp(document.version.toTimestamp())};};JsonProtoSerializer.prototype.fromDocument=function(document,hasCommittedMutations){return new Document(this.fromName(document.name),this.fromVersion(document.updateTime),this.fromFields(document.fields||{}),{hasCommittedMutations:!!hasCommittedMutations});};JsonProtoSerializer.prototype.toFields=function(fields){var _this=this;var result={};fields.forEach(function(key,value){result[key]=_this.toValue(value);});return result;};JsonProtoSerializer.prototype.fromFields=function(object){var _this=this;// Proto map<string, Value> gets mapped to Object, so cast it.
var map=object;var result=ObjectValue.EMPTY;forEach(map,function(key,value){result=result.set(new FieldPath([key]),_this.fromValue(value));});return result;};JsonProtoSerializer.prototype.toMapValue=function(map){return{fields:this.toFields(map)};};JsonProtoSerializer.prototype.toArrayValue=function(array){var _this=this;var result=[];array.forEach(function(value){result.push(_this.toValue(value));});return{values:result};};JsonProtoSerializer.prototype.fromFound=function(doc){assert(!!doc.found,'Tried to deserialize a found document from a missing document.');assertPresent(doc.found.name,'doc.found.name');assertPresent(doc.found.updateTime,'doc.found.updateTime');var key=this.fromName(doc.found.name);var version=this.fromVersion(doc.found.updateTime);var fields=this.fromFields(doc.found.fields||{});return new Document(key,version,fields,{},doc.found);};JsonProtoSerializer.prototype.fromMissing=function(result){assert(!!result.missing,'Tried to deserialize a missing document from a found document.');assert(!!result.readTime,'Tried to deserialize a missing document without a read time.');var key=this.fromName(result.missing);var version=this.fromVersion(result.readTime);return new NoDocument(key,version);};JsonProtoSerializer.prototype.fromMaybeDocument=function(result){// tslint:disable-next-line:no-any
var type=result['result'];if(hasTag(result,type,'found')){return this.fromFound(result);}else if(hasTag(result,type,'missing')){return this.fromMissing(result);}return fail('invalid batch get response: '+JSON.stringify(result));};JsonProtoSerializer.prototype.toWatchTargetChangeState=function(state){switch(state){case WatchTargetChangeState.Added:return'ADD';case WatchTargetChangeState.Current:return'CURRENT';case WatchTargetChangeState.NoChange:return'NO_CHANGE';case WatchTargetChangeState.Removed:return'REMOVE';case WatchTargetChangeState.Reset:return'RESET';default:return fail('Unknown WatchTargetChangeState: '+state);}};JsonProtoSerializer.prototype.toTestWatchChange=function(watchChange){if(watchChange instanceof ExistenceFilterChange){return{filter:{count:watchChange.existenceFilter.count,targetId:watchChange.targetId}};}if(watchChange instanceof DocumentWatchChange){if(watchChange.newDoc instanceof Document){var doc=watchChange.newDoc;return{documentChange:{document:{name:this.toName(doc.key),fields:this.toFields(doc.data),updateTime:this.toVersion(doc.version)},targetIds:watchChange.updatedTargetIds,removedTargetIds:watchChange.removedTargetIds}};}else if(watchChange.newDoc instanceof NoDocument){var doc=watchChange.newDoc;return{documentDelete:{document:this.toName(doc.key),readTime:this.toVersion(doc.version),removedTargetIds:watchChange.removedTargetIds}};}else if(watchChange.newDoc===null){return{documentRemove:{document:this.toName(watchChange.key),removedTargetIds:watchChange.removedTargetIds}};}}if(watchChange instanceof WatchTargetChange){var cause=undefined;if(watchChange.cause){cause={code:mapRpcCodeFromCode(watchChange.cause.code),message:watchChange.cause.message};}return{targetChange:{targetChangeType:this.toWatchTargetChangeState(watchChange.state),targetIds:watchChange.targetIds,resumeToken:this.unsafeCastProtoByteString(watchChange.resumeToken),cause:cause}};}return fail('Unrecognized watch change: '+JSON.stringify(watchChange));};JsonProtoSerializer.prototype.fromWatchChange=function(change){// tslint:disable-next-line:no-any
var type=change['response_type'];var watchChange;if(hasTag(change,type,'targetChange')){assertPresent(change.targetChange,'targetChange');// proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'
// if unset
var state=this.fromWatchTargetChangeState(change.targetChange.targetChangeType||'NO_CHANGE');var targetIds=change.targetChange.targetIds||[];var resumeToken=change.targetChange.resumeToken||this.emptyByteString();var causeProto=change.targetChange.cause;var cause=causeProto&&this.fromRpcStatus(causeProto);watchChange=new WatchTargetChange(state,targetIds,resumeToken,cause||null);}else if(hasTag(change,type,'documentChange')){assertPresent(change.documentChange,'documentChange');assertPresent(change.documentChange.document,'documentChange.name');assertPresent(change.documentChange.document.name,'documentChange.document.name');assertPresent(change.documentChange.document.updateTime,'documentChange.document.updateTime');var entityChange=change.documentChange;var key=this.fromName(entityChange.document.name);var version=this.fromVersion(entityChange.document.updateTime);var fields=this.fromFields(entityChange.document.fields||{});// The document may soon be re-serialized back to protos in order to store it in local
// persistence. Memoize the encoded form to avoid encoding it again.
var doc=new Document(key,version,fields,{},entityChange.document);var updatedTargetIds=entityChange.targetIds||[];var removedTargetIds=entityChange.removedTargetIds||[];watchChange=new DocumentWatchChange(updatedTargetIds,removedTargetIds,doc.key,doc);}else if(hasTag(change,type,'documentDelete')){assertPresent(change.documentDelete,'documentDelete');assertPresent(change.documentDelete.document,'documentDelete.document');var docDelete=change.documentDelete;var key=this.fromName(docDelete.document);var version=docDelete.readTime?this.fromVersion(docDelete.readTime):SnapshotVersion.forDeletedDoc();var doc=new NoDocument(key,version);var removedTargetIds=docDelete.removedTargetIds||[];watchChange=new DocumentWatchChange([],removedTargetIds,doc.key,doc);}else if(hasTag(change,type,'documentRemove')){assertPresent(change.documentRemove,'documentRemove');assertPresent(change.documentRemove.document,'documentRemove');var docRemove=change.documentRemove;var key=this.fromName(docRemove.document);var removedTargetIds=docRemove.removedTargetIds||[];watchChange=new DocumentWatchChange([],removedTargetIds,key,null);}else if(hasTag(change,type,'filter')){// TODO(dimond): implement existence filter parsing with strategy.
assertPresent(change.filter,'filter');assertPresent(change.filter.targetId,'filter.targetId');var filter=change.filter;var count=filter.count||0;var existenceFilter=new ExistenceFilter(count);var targetId=filter.targetId;watchChange=new ExistenceFilterChange(targetId,existenceFilter);}else{return fail('Unknown change type '+JSON.stringify(change));}return watchChange;};JsonProtoSerializer.prototype.fromWatchTargetChangeState=function(state){if(state==='NO_CHANGE'){return WatchTargetChangeState.NoChange;}else if(state==='ADD'){return WatchTargetChangeState.Added;}else if(state==='REMOVE'){return WatchTargetChangeState.Removed;}else if(state==='CURRENT'){return WatchTargetChangeState.Current;}else if(state==='RESET'){return WatchTargetChangeState.Reset;}else{return fail('Got unexpected TargetChange.state: '+state);}};JsonProtoSerializer.prototype.versionFromListenResponse=function(change){// We have only reached a consistent snapshot for the entire stream if there
// is a read_time set and it applies to all targets (i.e. the list of
// targets is empty). The backend is guaranteed to send such responses.
// tslint:disable-next-line:no-any
var type=change['response_type'];if(!hasTag(change,type,'targetChange')){return SnapshotVersion.MIN;}var targetChange=change.targetChange;if(targetChange.targetIds&&targetChange.targetIds.length){return SnapshotVersion.MIN;}if(!targetChange.readTime){return SnapshotVersion.MIN;}return this.fromVersion(targetChange.readTime);};JsonProtoSerializer.prototype.toMutation=function(mutation){var _this=this;var result;if(mutation instanceof SetMutation){result={update:this.toMutationDocument(mutation.key,mutation.value)};}else if(mutation instanceof DeleteMutation){result={delete:this.toName(mutation.key)};}else if(mutation instanceof PatchMutation){result={update:this.toMutationDocument(mutation.key,mutation.data),updateMask:this.toDocumentMask(mutation.fieldMask)};}else if(mutation instanceof TransformMutation){result={transform:{document:this.toName(mutation.key),fieldTransforms:mutation.fieldTransforms.map(function(transform){return _this.toFieldTransform(transform);})}};}else{return fail('Unknown mutation type '+mutation.type);}if(!mutation.precondition.isNone){result.currentDocument=this.toPrecondition(mutation.precondition);}return result;};JsonProtoSerializer.prototype.fromMutation=function(proto){var _this=this;var precondition=proto.currentDocument?this.fromPrecondition(proto.currentDocument):Precondition.NONE;if(proto.update){assertPresent(proto.update.name,'name');var key=this.fromName(proto.update.name);var value=this.fromFields(proto.update.fields||{});if(proto.updateMask){var fieldMask=this.fromDocumentMask(proto.updateMask);return new PatchMutation(key,value,fieldMask,precondition);}else{return new SetMutation(key,value,precondition);}}else if(proto.delete){var key=this.fromName(proto.delete);return new DeleteMutation(key,precondition);}else if(proto.transform){var key=this.fromName(proto.transform.document);var fieldTransforms=proto.transform.fieldTransforms.map(function(transform){return _this.fromFieldTransform(transform);});assert(precondition.exists===true,'Transforms only support precondition "exists == true"');return new TransformMutation(key,fieldTransforms);}else{return fail('unknown mutation proto: '+JSON.stringify(proto));}};JsonProtoSerializer.prototype.toPrecondition=function(precondition){assert(!precondition.isNone,"Can't serialize an empty precondition");if(precondition.updateTime!==undefined){return{updateTime:this.toVersion(precondition.updateTime)};}else if(precondition.exists!==undefined){return{exists:precondition.exists};}else{return fail('Unknown precondition');}};JsonProtoSerializer.prototype.fromPrecondition=function(precondition){if(precondition.updateTime!==undefined){return Precondition.updateTime(this.fromVersion(precondition.updateTime));}else if(precondition.exists!==undefined){return Precondition.exists(precondition.exists);}else{return Precondition.NONE;}};JsonProtoSerializer.prototype.fromWriteResult=function(proto,commitTime){var _this=this;// NOTE: Deletes don't have an updateTime.
var version=proto.updateTime?this.fromVersion(proto.updateTime):this.fromVersion(commitTime);var transformResults=null;if(proto.transformResults&&proto.transformResults.length>0){transformResults=proto.transformResults.map(function(result){return _this.fromValue(result);});}return new MutationResult(version,transformResults);};JsonProtoSerializer.prototype.fromWriteResults=function(protos,commitTime){var _this=this;if(protos&&protos.length>0){assert(commitTime!==undefined,'Received a write result without a commit time');return protos.map(function(proto){return _this.fromWriteResult(proto,commitTime);});}else{return[];}};JsonProtoSerializer.prototype.toFieldTransform=function(fieldTransform){var _this=this;var transform=fieldTransform.transform;if(transform instanceof ServerTimestampTransform){return{fieldPath:fieldTransform.field.canonicalString(),setToServerValue:'REQUEST_TIME'};}else if(transform instanceof ArrayUnionTransformOperation){return{fieldPath:fieldTransform.field.canonicalString(),appendMissingElements:{values:transform.elements.map(function(v){return _this.toValue(v);})}};}else if(transform instanceof ArrayRemoveTransformOperation){return{fieldPath:fieldTransform.field.canonicalString(),removeAllFromArray:{values:transform.elements.map(function(v){return _this.toValue(v);})}};}else if(transform instanceof NumericIncrementTransformOperation){return{fieldPath:fieldTransform.field.canonicalString(),increment:this.toValue(transform.operand)};}else{throw fail('Unknown transform: '+fieldTransform.transform);}};JsonProtoSerializer.prototype.fromFieldTransform=function(proto){var _this=this;// tslint:disable-next-line:no-any We need to match generated Proto types.
var type=proto['transform_type'];var transform=null;if(hasTag(proto,type,'setToServerValue')){assert(proto.setToServerValue==='REQUEST_TIME','Unknown server value transform proto: '+JSON.stringify(proto));transform=ServerTimestampTransform.instance;}else if(hasTag(proto,type,'appendMissingElements')){var values=proto.appendMissingElements.values||[];transform=new ArrayUnionTransformOperation(values.map(function(v){return _this.fromValue(v);}));}else if(hasTag(proto,type,'removeAllFromArray')){var values=proto.removeAllFromArray.values||[];transform=new ArrayRemoveTransformOperation(values.map(function(v){return _this.fromValue(v);}));}else if(hasTag(proto,type,'increment')){var operand=this.fromValue(proto.increment);assert(operand instanceof NumberValue,'NUMERIC_ADD transform requires a NumberValue');transform=new NumericIncrementTransformOperation(operand);}else{fail('Unknown transform proto: '+JSON.stringify(proto));}var fieldPath=FieldPath.fromServerFormat(proto.fieldPath);return new FieldTransform(fieldPath,transform);};JsonProtoSerializer.prototype.toDocumentsTarget=function(query){return{documents:[this.toQueryPath(query.path)]};};JsonProtoSerializer.prototype.fromDocumentsTarget=function(documentsTarget){var count=documentsTarget.documents.length;assert(count===1,'DocumentsTarget contained other than 1 document: '+count);var name=documentsTarget.documents[0];return Query.atPath(this.fromQueryPath(name));};JsonProtoSerializer.prototype.toQueryTarget=function(query){// Dissect the path into parent, collectionId, and optional key filter.
var result={structuredQuery:{}};var path=query.path;if(query.collectionGroup!==null){assert(path.length%2===0,'Collection Group queries should be within a document path or root.');result.parent=this.toQueryPath(path);result.structuredQuery.from=[{collectionId:query.collectionGroup,allDescendants:true}];}else{assert(path.length%2!==0,'Document queries with filters are not supported.');result.parent=this.toQueryPath(path.popLast());result.structuredQuery.from=[{collectionId:path.lastSegment()}];}var where=this.toFilter(query.filters);if(where){result.structuredQuery.where=where;}var orderBy=this.toOrder(query.orderBy);if(orderBy){result.structuredQuery.orderBy=orderBy;}var limit=this.toInt32Value(query.limit);if(limit!==undefined){result.structuredQuery.limit=limit;}if(query.startAt){result.structuredQuery.startAt=this.toCursor(query.startAt);}if(query.endAt){result.structuredQuery.endAt=this.toCursor(query.endAt);}return result;};JsonProtoSerializer.prototype.fromQueryTarget=function(target){var path=this.fromQueryPath(target.parent);var query=target.structuredQuery;var fromCount=query.from?query.from.length:0;var collectionGroup=null;if(fromCount>0){assert(fromCount===1,'StructuredQuery.from with more than one collection is not supported.');var from=query.from[0];if(from.allDescendants){collectionGroup=from.collectionId;}else{path=path.child(from.collectionId);}}var filterBy=[];if(query.where){filterBy=this.fromFilter(query.where);}var orderBy=[];if(query.orderBy){orderBy=this.fromOrder(query.orderBy);}var limit=null;if(query.limit){limit=this.fromInt32Value(query.limit);}var startAt=null;if(query.startAt){startAt=this.fromCursor(query.startAt);}var endAt=null;if(query.endAt){endAt=this.fromCursor(query.endAt);}return new Query(path,collectionGroup,orderBy,filterBy,limit,startAt,endAt);};JsonProtoSerializer.prototype.toListenRequestLabels=function(queryData){var value=this.toLabel(queryData.purpose);if(value==null){return null;}else{return{'goog-listen-tags':value};}};JsonProtoSerializer.prototype.toLabel=function(purpose){switch(purpose){case QueryPurpose.Listen:return null;case QueryPurpose.ExistenceFilterMismatch:return'existence-filter-mismatch';case QueryPurpose.LimboResolution:return'limbo-document';default:return fail('Unrecognized query purpose: '+purpose);}};JsonProtoSerializer.prototype.toTarget=function(queryData){var result;var query=queryData.query;if(query.isDocumentQuery()){result={documents:this.toDocumentsTarget(query)};}else{result={query:this.toQueryTarget(query)};}result.targetId=queryData.targetId;if(queryData.resumeToken.length>0){result.resumeToken=this.unsafeCastProtoByteString(queryData.resumeToken);}return result;};JsonProtoSerializer.prototype.toFilter=function(filters){var _this=this;if(filters.length===0)return;var protos=filters.map(function(filter){return filter instanceof RelationFilter?_this.toRelationFilter(filter):_this.toUnaryFilter(filter);});if(protos.length===1){return protos[0];}return{compositeFilter:{op:'AND',filters:protos}};};JsonProtoSerializer.prototype.fromFilter=function(filter){var _this=this;if(!filter){return[];}else if(filter.unaryFilter!==undefined){return[this.fromUnaryFilter(filter)];}else if(filter.fieldFilter!==undefined){return[this.fromRelationFilter(filter)];}else if(filter.compositeFilter!==undefined){return filter.compositeFilter.filters.map(function(f){return _this.fromFilter(f);}).reduce(function(accum,current){return accum.concat(current);});}else{return fail('Unknown filter: '+JSON.stringify(filter));}};JsonProtoSerializer.prototype.toOrder=function(orderBys){var _this=this;if(orderBys.length===0)return;return orderBys.map(function(order){return _this.toPropertyOrder(order);});};JsonProtoSerializer.prototype.fromOrder=function(orderBys){var _this=this;return orderBys.map(function(order){return _this.fromPropertyOrder(order);});};JsonProtoSerializer.prototype.toCursor=function(cursor){var _this=this;return{before:cursor.before,values:cursor.position.map(function(component){return _this.toValue(component);})};};JsonProtoSerializer.prototype.fromCursor=function(cursor){var _this=this;var before=!!cursor.before;var position=cursor.values.map(function(component){return _this.fromValue(component);});return new Bound(position,before);};// visible for testing
JsonProtoSerializer.prototype.toDirection=function(dir){return DIRECTIONS[dir.name];};// visible for testing
JsonProtoSerializer.prototype.fromDirection=function(dir){switch(dir){case'ASCENDING':return Direction.ASCENDING;case'DESCENDING':return Direction.DESCENDING;default:return undefined;}};// visible for testing
JsonProtoSerializer.prototype.toOperatorName=function(op){return OPERATORS[op.name];};JsonProtoSerializer.prototype.fromOperatorName=function(op){switch(op){case'EQUAL':return RelationOp.EQUAL;case'GREATER_THAN':return RelationOp.GREATER_THAN;case'GREATER_THAN_OR_EQUAL':return RelationOp.GREATER_THAN_OR_EQUAL;case'LESS_THAN':return RelationOp.LESS_THAN;case'LESS_THAN_OR_EQUAL':return RelationOp.LESS_THAN_OR_EQUAL;case'ARRAY_CONTAINS':return RelationOp.ARRAY_CONTAINS;case'OPERATOR_UNSPECIFIED':return fail('Unspecified relation');default:return fail('Unknown relation');}};JsonProtoSerializer.prototype.toFieldPathReference=function(path){return{fieldPath:path.canonicalString()};};JsonProtoSerializer.prototype.fromFieldPathReference=function(fieldReference){return FieldPath.fromServerFormat(fieldReference.fieldPath);};// visible for testing
JsonProtoSerializer.prototype.toPropertyOrder=function(orderBy){return{field:this.toFieldPathReference(orderBy.field),direction:this.toDirection(orderBy.dir)};};JsonProtoSerializer.prototype.fromPropertyOrder=function(orderBy){return new OrderBy(this.fromFieldPathReference(orderBy.field),this.fromDirection(orderBy.direction));};// visible for testing
JsonProtoSerializer.prototype.toRelationFilter=function(filter){if(filter instanceof RelationFilter){return{fieldFilter:{field:this.toFieldPathReference(filter.field),op:this.toOperatorName(filter.op),value:this.toValue(filter.value)}};}else{return fail('Unrecognized filter: '+JSON.stringify(filter));}};JsonProtoSerializer.prototype.fromRelationFilter=function(filter){return new RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field),this.fromOperatorName(filter.fieldFilter.op),this.fromValue(filter.fieldFilter.value));};// visible for testing
JsonProtoSerializer.prototype.toUnaryFilter=function(filter){if(filter instanceof NanFilter){return{unaryFilter:{field:this.toFieldPathReference(filter.field),op:'IS_NAN'}};}else if(filter instanceof NullFilter){return{unaryFilter:{field:this.toFieldPathReference(filter.field),op:'IS_NULL'}};}else{return fail('Unrecognized filter: '+JSON.stringify(filter));}};JsonProtoSerializer.prototype.fromUnaryFilter=function(filter){switch(filter.unaryFilter.op){case'IS_NAN':var nanField=this.fromFieldPathReference(filter.unaryFilter.field);return new NanFilter(nanField);case'IS_NULL':var nullField=this.fromFieldPathReference(filter.unaryFilter.field);return new NullFilter(nullField);case'OPERATOR_UNSPECIFIED':return fail('Unspecified filter');default:return fail('Unknown filter');}};JsonProtoSerializer.prototype.toDocumentMask=function(fieldMask){var canonicalFields=[];fieldMask.fields.forEach(function(field){return canonicalFields.push(field.canonicalString());});return{fieldPaths:canonicalFields};};JsonProtoSerializer.prototype.fromDocumentMask=function(proto){var paths=proto.fieldPaths||[];var fields=paths.map(function(path){return FieldPath.fromServerFormat(path);});return FieldMask.fromArray(fields);};return JsonProtoSerializer;}();/**
 * Checks for a specific oneof tag in a protocol buffer message.
 *
 * This intentionally accommodates two distinct cases:
 *
 * 1) Messages containing a type tag: these are the format produced by GRPC in
 * return values. These may contain default-value mappings for all tags in the
 * oneof but the type tag specifies which one was actually set.
 *
 * 2) Messages that don't contain a type tag: these are the format required by
 * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would
 * choke claiming that the tags aren't fields in the Message.
 *
 * Allowing both formats here makes the serializer able to consume the outputs
 * it produces: for all messages it supports, fromX(toX(value)) == value.
 *
 * Note that case 2 suffers from ambiguity: if multiple tags are present
 * without a type tag then the callers are structured in such a way that the
 * first invocation will win. Since we only parse in this mode when parsing
 * the output of a serialize method this works, but it's not a general
 * solution.
 *
 * Unfortunately there is no general solution here because proto3 makes it
 * impossible to distinguish unset from explicitly set fields: both have the
 * default value for the type. Without the type tag but multiple value tags
 * it's possible to have default values for each tag in the oneof and not be
 * able to know which was actually in effect.
 */function hasTag(obj,type,tag){return type===tag||!type&&tag in obj;}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Provides a simple helper class that implements the Stream interface to
 * bridge to other implementations that are streams but do not implement the
 * interface. The stream callbacks are invoked with the callOn... methods.
 */var StreamBridge=/** @class */function(){function StreamBridge(args){this.sendFn=args.sendFn;this.closeFn=args.closeFn;}StreamBridge.prototype.onOpen=function(callback){assert(!this.wrappedOnOpen,'Called onOpen on stream twice!');this.wrappedOnOpen=callback;};StreamBridge.prototype.onClose=function(callback){assert(!this.wrappedOnClose,'Called onClose on stream twice!');this.wrappedOnClose=callback;};StreamBridge.prototype.onMessage=function(callback){assert(!this.wrappedOnMessage,'Called onMessage on stream twice!');this.wrappedOnMessage=callback;};StreamBridge.prototype.close=function(){this.closeFn();};StreamBridge.prototype.send=function(msg){this.sendFn(msg);};StreamBridge.prototype.callOnOpen=function(){assert(this.wrappedOnOpen!==undefined,'Cannot call onOpen because no callback was set');this.wrappedOnOpen();};StreamBridge.prototype.callOnClose=function(err){assert(this.wrappedOnClose!==undefined,'Cannot call onClose because no callback was set');this.wrappedOnClose(err);};StreamBridge.prototype.callOnMessage=function(msg){assert(this.wrappedOnMessage!==undefined,'Cannot call onMessage because no callback was set');this.wrappedOnMessage(msg);};return StreamBridge;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG='Connection';var RPC_STREAM_SERVICE='google.firestore.v1.Firestore';var RPC_URL_VERSION='v1';/** Maps RPC names to the corresponding REST endpoint name. */var RPC_NAME_REST_MAPPING={BatchGetDocuments:'batchGet',Commit:'commit'};// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because
// we are doing out-of-band releases. Once we release as part of Firebase, we
// should use the Firebase version instead.
var X_GOOG_API_CLIENT_VALUE='gl-js/ fire/'+SDK_VERSION;var XHR_TIMEOUT_SECS=15;var WebChannelConnection=/** @class */function(){function WebChannelConnection(info){this.databaseId=info.databaseId;var proto=info.ssl?'https':'http';this.baseUrl=proto+'://'+info.host;this.forceLongPolling=info.forceLongPolling;}/**
     * Modifies the headers for a request, adding any authorization token if
     * present and any additional headers for the request.
     */WebChannelConnection.prototype.modifyHeadersForRequest=function(headers,token){if(token){for(var header in token.authHeaders){if(token.authHeaders.hasOwnProperty(header)){headers[header]=token.authHeaders[header];}}}headers['X-Goog-Api-Client']=X_GOOG_API_CLIENT_VALUE;};WebChannelConnection.prototype.invokeRPC=function(rpcName,request,token){var _this=this;var url=this.makeUrl(rpcName);return new Promise(function(resolve,reject){// tslint:disable-next-line:no-any XhrIo doesn't have TS typings.
var xhr=new webchannelWrapper.XhrIo();xhr.listenOnce(webchannelWrapper.EventType.COMPLETE,function(){try{switch(xhr.getLastErrorCode()){case webchannelWrapper.ErrorCode.NO_ERROR:var json=xhr.getResponseJson();debug(LOG_TAG,'XHR received:',JSON.stringify(json));resolve(json);break;case webchannelWrapper.ErrorCode.TIMEOUT:debug(LOG_TAG,'RPC "'+rpcName+'" timed out');reject(new FirestoreError(Code.DEADLINE_EXCEEDED,'Request time out'));break;case webchannelWrapper.ErrorCode.HTTP_ERROR:var status_1=xhr.getStatus();debug(LOG_TAG,'RPC "'+rpcName+'" failed with status:',status_1,'response text:',xhr.getResponseText());if(status_1>0){reject(new FirestoreError(mapCodeFromHttpStatus(status_1),'Server responded with status '+xhr.getStatusText()));}else{// If we received an HTTP_ERROR but there's no status code,
// it's most probably a connection issue
debug(LOG_TAG,'RPC "'+rpcName+'" failed');reject(new FirestoreError(Code.UNAVAILABLE,'Connection failed.'));}break;default:fail('RPC "'+rpcName+'" failed with unanticipated '+'webchannel error '+xhr.getLastErrorCode()+': '+xhr.getLastError()+', giving up.');}}finally{debug(LOG_TAG,'RPC "'+rpcName+'" completed.');}});var requestString=JSON.stringify(request);debug(LOG_TAG,'XHR sending: ',url+' '+requestString);// Content-Type: text/plain will avoid preflight requests which might
// mess with CORS and redirects by proxies. If we add custom headers
// we will need to change this code to potentially use the
// $httpOverwrite parameter supported by ESF to avoid
// triggering preflight requests.
var headers={'Content-Type':'text/plain'};_this.modifyHeadersForRequest(headers,token);xhr.send(url,'POST',requestString,headers,XHR_TIMEOUT_SECS);});};WebChannelConnection.prototype.invokeStreamingRPC=function(rpcName,request,token){// The REST API automatically aggregates all of the streamed results, so we
// can just use the normal invoke() method.
return this.invokeRPC(rpcName,request,token);};WebChannelConnection.prototype.openStream=function(rpcName,token){var urlParts=[this.baseUrl,'/',RPC_STREAM_SERVICE,'/',rpcName,'/channel'];var webchannelTransport=webchannelWrapper.createWebChannelTransport();var request={// Background channel test avoids the initial two test calls and decreases
// initial cold start time.
// TODO(dimond): wenboz@ mentioned this might affect use with proxies and
// we should monitor closely for any reports.
backgroundChannelTest:true,// Required for backend stickiness, routing behavior is based on this
// parameter.
httpSessionIdParam:'gsessionid',initMessageHeaders:{},messageUrlParams:{// This param is used to improve routing and project isolation by the
// backend and must be included in every request.
database:"projects/"+this.databaseId.projectId+"/databases/"+this.databaseId.database},sendRawJson:true,supportsCrossDomainXhr:true,internalChannelParams:{// Override the default timeout (randomized between 10-20 seconds) since
// a large write batch on a slow internet connection may take a long
// time to send to the backend. Rather than have WebChannel impose a
// tight timeout which could lead to infinite timeouts and retries, we
// set it very large (5-10 minutes) and rely on the browser's builtin
// timeouts to kick in if the request isn't working.
forwardChannelRequestTimeoutMs:10*60*1000},forceLongPolling:this.forceLongPolling};this.modifyHeadersForRequest(request.initMessageHeaders,token);// Sending the custom headers we just added to request.initMessageHeaders
// (Authorization, etc.) will trigger the browser to make a CORS preflight
// request because the XHR will no longer meet the criteria for a "simple"
// CORS request:
// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests
//
// Therefore to avoid the CORS preflight request (an extra network
// roundtrip), we use the httpHeadersOverwriteParam option to specify that
// the headers should instead be encoded into a special "$httpHeaders" query
// parameter, which is recognized by the webchannel backend. This is
// formally defined here:
// https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L32
//
// But for some unclear reason (see
// https://github.com/firebase/firebase-js-sdk/issues/703), this breaks
// ReactNative and so we exclude it, which just means ReactNative may be
// subject to the extra network roundtrip for CORS preflight.
if(!util.isReactNative()){request['httpHeadersOverwriteParam']='$httpHeaders';}var url=urlParts.join('');debug(LOG_TAG,'Creating WebChannel: '+url+' '+request);// tslint:disable-next-line:no-any Because listen isn't defined on it.
var channel=webchannelTransport.createWebChannel(url,request);// WebChannel supports sending the first message with the handshake - saving
// a network round trip. However, it will have to call send in the same
// JS event loop as open. In order to enforce this, we delay actually
// opening the WebChannel until send is called. Whether we have called
// open is tracked with this variable.
var opened=false;// A flag to determine whether the stream was closed (by us or through an
// error/close event) to avoid delivering multiple close events or sending
// on a closed stream
var closed=false;var streamBridge=new StreamBridge({sendFn:function(msg){if(!closed){if(!opened){debug(LOG_TAG,'Opening WebChannel transport.');channel.open();opened=true;}debug(LOG_TAG,'WebChannel sending:',msg);channel.send(msg);}else{debug(LOG_TAG,'Not sending because WebChannel is closed:',msg);}},closeFn:function(){return channel.close();}});// Closure events are guarded and exceptions are swallowed, so catch any
// exception and rethrow using a setTimeout so they become visible again.
// Note that eventually this function could go away if we are confident
// enough the code is exception free.
var unguardedEventListen=function(type,fn){// TODO(dimond): closure typing seems broken because WebChannel does
// not implement goog.events.Listenable
channel.listen(type,function(param){try{fn(param);}catch(e){setTimeout(function(){throw e;},0);}});};unguardedEventListen(webchannelWrapper.WebChannel.EventType.OPEN,function(){if(!closed){debug(LOG_TAG,'WebChannel transport opened.');}});unguardedEventListen(webchannelWrapper.WebChannel.EventType.CLOSE,function(){if(!closed){closed=true;debug(LOG_TAG,'WebChannel transport closed');streamBridge.callOnClose();}});unguardedEventListen(webchannelWrapper.WebChannel.EventType.ERROR,function(err){if(!closed){closed=true;debug(LOG_TAG,'WebChannel transport errored:',err);streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE,'The operation could not be completed'));}});unguardedEventListen(webchannelWrapper.WebChannel.EventType.MESSAGE,function(msg){if(!closed){var msgData=msg.data[0];assert(!!msgData,'Got a webchannel message without data.');// TODO(b/35143891): There is a bug in One Platform that caused errors
// (and only errors) to be wrapped in an extra array. To be forward
// compatible with the bug we need to check either condition. The latter
// can be removed once the fix has been rolled out.
var error=// tslint:disable-next-line:no-any msgData.error is not typed.
msgData.error||msgData[0]&&msgData[0].error;if(error){debug(LOG_TAG,'WebChannel received error:',error);// error.status will be a string like 'OK' or 'NOT_FOUND'.
var status_2=error.status;var code=mapCodeFromRpcStatus(status_2);var message=error.message;if(code===undefined){code=Code.INTERNAL;message='Unknown error status: '+status_2+' with message '+error.message;}// Mark closed so no further events are propagated
closed=true;streamBridge.callOnClose(new FirestoreError(code,message));channel.close();}else{debug(LOG_TAG,'WebChannel received:',msgData);streamBridge.callOnMessage(msgData);}}});setTimeout(function(){// Technically we could/should wait for the WebChannel opened event,
// but because we want to send the first message with the WebChannel
// handshake we pretend the channel opened here (asynchronously), and
// then delay the actual open until the first message is sent.
streamBridge.callOnOpen();},0);return streamBridge;};// visible for testing
WebChannelConnection.prototype.makeUrl=function(rpcName){var urlRpcName=RPC_NAME_REST_MAPPING[rpcName];assert(urlRpcName!==undefined,'Unknown REST mapping for: '+rpcName);var url=[this.baseUrl,'/',RPC_URL_VERSION];url.push('/projects/');url.push(this.databaseId.projectId);url.push('/databases/');url.push(this.databaseId.database);url.push('/documents');url.push(':');url.push(urlRpcName);return url.join('');};return WebChannelConnection;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var BrowserPlatform=/** @class */function(){function BrowserPlatform(){this.emptyByteString='';this.base64Available=typeof atob!=='undefined';}Object.defineProperty(BrowserPlatform.prototype,"document",{get:function(){return typeof document!=='undefined'?document:null;},enumerable:true,configurable:true});Object.defineProperty(BrowserPlatform.prototype,"window",{get:function(){return typeof window!=='undefined'?window:null;},enumerable:true,configurable:true});BrowserPlatform.prototype.loadConnection=function(databaseInfo){return Promise.resolve(new WebChannelConnection(databaseInfo));};BrowserPlatform.prototype.newSerializer=function(databaseId){return new JsonProtoSerializer(databaseId,{useProto3Json:true});};BrowserPlatform.prototype.formatJSON=function(value){return JSON.stringify(value);};BrowserPlatform.prototype.atob=function(encoded){return atob(encoded);};BrowserPlatform.prototype.btoa=function(raw){return btoa(raw);};return BrowserPlatform;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * This code needs to run before Firestore is used. This can be achieved in
 * several ways:
 *   1) Through the JSCompiler compiling this code and then (automatically)
 *      executing it before exporting the Firestore symbols.
 *   2) Through importing this module first in a Firestore main module
 */PlatformSupport.setPlatform(new BrowserPlatform());/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to
 * exceed. All subsequent calls to next will return increasing values. If provided with a
 * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as
 * well as write out sequence numbers that it produces via `next()`.
 */var ListenSequence=/** @class */function(){function ListenSequence(previousValue,sequenceNumberSyncer){var _this=this;this.previousValue=previousValue;if(sequenceNumberSyncer){sequenceNumberSyncer.sequenceNumberHandler=function(sequenceNumber){return _this.setPreviousValue(sequenceNumber);};this.writeNewSequenceNumber=function(sequenceNumber){return sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);};}}ListenSequence.prototype.setPreviousValue=function(externalPreviousValue){this.previousValue=Math.max(externalPreviousValue,this.previousValue);return this.previousValue;};ListenSequence.prototype.next=function(){var nextValue=++this.previousValue;if(this.writeNewSequenceNumber){this.writeNewSequenceNumber(nextValue);}return nextValue;};ListenSequence.INVALID=-1;return ListenSequence;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Deferred=/** @class */function(){function Deferred(){var _this=this;this.promise=new Promise(function(resolve,reject){_this.resolve=resolve;_this.reject=reject;});}return Deferred;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Wellknown "timer" IDs used when scheduling delayed operations on the
 * AsyncQueue. These IDs can then be used from tests to check for the presence
 * of operations or to run them early.
 *
 * The string values are used when encoding these timer IDs in JSON spec tests.
 */var TimerId;(function(TimerId){/** All can be used with runDelayedOperationsEarly() to run all timers. */TimerId["All"]="all";/**
     * The following 4 timers are used in persistent_stream.ts for the listen and
     * write streams. The "Idle" timer is used to close the stream due to
     * inactivity. The "ConnectionBackoff" timer is used to restart a stream once
     * the appropriate backoff delay has elapsed.
     */TimerId["ListenStreamIdle"]="listen_stream_idle";TimerId["ListenStreamConnectionBackoff"]="listen_stream_connection_backoff";TimerId["WriteStreamIdle"]="write_stream_idle";TimerId["WriteStreamConnectionBackoff"]="write_stream_connection_backoff";/**
     * A timer used in online_state_tracker.ts to transition from
     * OnlineState.Unknown to Offline after a set timeout, rather than waiting
     * indefinitely for success or failure.
     */TimerId["OnlineStateTimeout"]="online_state_timeout";/**
     * A timer used to update the client metadata in IndexedDb, which is used
     * to determine the primary leaseholder.
     */TimerId["ClientMetadataRefresh"]="client_metadata_refresh";/** A timer used to periodically attempt LRU Garbage collection */TimerId["LruGarbageCollection"]="lru_garbage_collection";})(TimerId||(TimerId={}));/**
 * Represents an operation scheduled to be run in the future on an AsyncQueue.
 *
 * It is created via DelayedOperation.createAndSchedule().
 *
 * Supports cancellation (via cancel()) and early execution (via skipDelay()).
 */var DelayedOperation=/** @class */function(){function DelayedOperation(asyncQueue,timerId,targetTimeMs,op,removalCallback){this.asyncQueue=asyncQueue;this.timerId=timerId;this.targetTimeMs=targetTimeMs;this.op=op;this.removalCallback=removalCallback;this.deferred=new Deferred();this.then=this.deferred.promise.then.bind(this.deferred.promise);this.catch=this.deferred.promise.catch.bind(this.deferred.promise);// It's normal for the deferred promise to be canceled (due to cancellation)
// and so we attach a dummy catch callback to avoid
// 'UnhandledPromiseRejectionWarning' log spam.
this.deferred.promise.catch(function(err){});}/**
     * Creates and returns a DelayedOperation that has been scheduled to be
     * executed on the provided asyncQueue after the provided delayMs.
     *
     * @param asyncQueue The queue to schedule the operation on.
     * @param id A Timer ID identifying the type of operation this is.
     * @param delayMs The delay (ms) before the operation should be scheduled.
     * @param op The operation to run.
     * @param removalCallback A callback to be called synchronously once the
     *   operation is executed or canceled, notifying the AsyncQueue to remove it
     *   from its delayedOperations list.
     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
     *   the DelayedOperation class public.
     */DelayedOperation.createAndSchedule=function(asyncQueue,timerId,delayMs,op,removalCallback){var targetTime=Date.now()+delayMs;var delayedOp=new DelayedOperation(asyncQueue,timerId,targetTime,op,removalCallback);delayedOp.start(delayMs);return delayedOp;};/**
     * Starts the timer. This is called immediately after construction by
     * createAndSchedule().
     */DelayedOperation.prototype.start=function(delayMs){var _this=this;this.timerHandle=setTimeout(function(){return _this.handleDelayElapsed();},delayMs);};/**
     * Queues the operation to run immediately (if it hasn't already been run or
     * canceled).
     */DelayedOperation.prototype.skipDelay=function(){return this.handleDelayElapsed();};/**
     * Cancels the operation if it hasn't already been executed or canceled. The
     * promise will be rejected.
     *
     * As long as the operation has not yet been run, calling cancel() provides a
     * guarantee that the operation will not be run.
     */DelayedOperation.prototype.cancel=function(reason){if(this.timerHandle!==null){this.clearTimeout();this.deferred.reject(new FirestoreError(Code.CANCELLED,'Operation cancelled'+(reason?': '+reason:'')));}};DelayedOperation.prototype.handleDelayElapsed=function(){var _this=this;this.asyncQueue.enqueueAndForget(function(){if(_this.timerHandle!==null){_this.clearTimeout();return _this.op().then(function(result){return _this.deferred.resolve(result);});}else{return Promise.resolve();}});};DelayedOperation.prototype.clearTimeout=function(){if(this.timerHandle!==null){this.removalCallback(this);clearTimeout(this.timerHandle);this.timerHandle=null;}};return DelayedOperation;}();var AsyncQueue=/** @class */function(){function AsyncQueue(){// The last promise in the queue.
this.tail=Promise.resolve();// Operations scheduled to be queued in the future. Operations are
// automatically removed after they are run or canceled.
this.delayedOperations=[];// Flag set while there's an outstanding AsyncQueue operation, used for
// assertion sanity-checks.
this.operationInProgress=false;}/**
     * Adds a new operation to the queue without waiting for it to complete (i.e.
     * we ignore the Promise result).
     */AsyncQueue.prototype.enqueueAndForget=function(op){// tslint:disable-next-line:no-floating-promises
this.enqueue(op);};/**
     * Adds a new operation to the queue. Returns a promise that will be resolved
     * when the promise returned by the new operation is (with its value).
     */AsyncQueue.prototype.enqueue=function(op){var _this=this;this.verifyNotFailed();var newTail=this.tail.then(function(){_this.operationInProgress=true;return op().catch(function(error$1){_this.failure=error$1;_this.operationInProgress=false;var message=error$1.stack||error$1.message||'';error('INTERNAL UNHANDLED ERROR: ',message);// Escape the promise chain and throw the error globally so that
// e.g. any global crash reporting library detects and reports it.
// (but not for simulated errors in our tests since this breaks mocha)
if(message.indexOf('Firestore Test Simulated Error')<0){setTimeout(function(){throw error$1;},0);}// Re-throw the error so that this.tail becomes a rejected Promise and
// all further attempts to chain (via .then) will just short-circuit
// and return the rejected Promise.
throw error$1;}).then(function(result){_this.operationInProgress=false;return result;});});this.tail=newTail;return newTail;};/**
     * Schedules an operation to be queued on the AsyncQueue once the specified
     * `delayMs` has elapsed. The returned CancelablePromise can be used to cancel
     * the operation prior to its running.
     */AsyncQueue.prototype.enqueueAfterDelay=function(timerId,delayMs,op){var _this=this;this.verifyNotFailed();assert(delayMs>=0,"Attempted to schedule an operation with a negative delay of "+delayMs);// While not necessarily harmful, we currently don't expect to have multiple
// ops with the same timer id in the queue, so defensively reject them.
assert(!this.containsDelayedOperation(timerId),"Attempted to schedule multiple operations with timer id "+timerId+".");var delayedOp=DelayedOperation.createAndSchedule(this,timerId,delayMs,op,function(op){return _this.removeDelayedOperation(op);});this.delayedOperations.push(delayedOp);return delayedOp;};AsyncQueue.prototype.verifyNotFailed=function(){if(this.failure){fail('AsyncQueue is already failed: '+(this.failure.stack||this.failure.message));}};/**
     * Verifies there's an operation currently in-progress on the AsyncQueue.
     * Unfortunately we can't verify that the running code is in the promise chain
     * of that operation, so this isn't a foolproof check, but it should be enough
     * to catch some bugs.
     */AsyncQueue.prototype.verifyOperationInProgress=function(){assert(this.operationInProgress,'verifyOpInProgress() called when no op in progress on this queue.');};/**
     * Waits until all currently queued tasks are finished executing. Delayed
     * operations are not run.
     */AsyncQueue.prototype.drain=function(){return this.enqueue(function(){return Promise.resolve();});};/**
     * For Tests: Determine if a delayed operation with a particular TimerId
     * exists.
     */AsyncQueue.prototype.containsDelayedOperation=function(timerId){for(var _i=0,_a=this.delayedOperations;_i<_a.length;_i++){var op=_a[_i];if(op.timerId===timerId){return true;}}return false;};/**
     * For Tests: Runs some or all delayed operations early.
     *
     * @param lastTimerId Delayed operations up to and including this TimerId will
     *  be drained. Throws if no such operation exists. Pass TimerId.All to run
     *  all delayed operations.
     * @returns a Promise that resolves once all operations have been run.
     */AsyncQueue.prototype.runDelayedOperationsEarly=function(lastTimerId){var _this=this;// Note that draining may generate more delayed ops, so we do that first.
return this.drain().then(function(){assert(lastTimerId===TimerId.All||_this.containsDelayedOperation(lastTimerId),"Attempted to drain to missing operation "+lastTimerId);// Run ops in the same order they'd run if they ran naturally.
_this.delayedOperations.sort(function(a,b){return a.targetTimeMs-b.targetTimeMs;});for(var _i=0,_a=_this.delayedOperations;_i<_a.length;_i++){var op=_a[_i];op.skipDelay();if(lastTimerId!==TimerId.All&&op.timerId===lastTimerId){break;}}return _this.drain();});};/** Called once a DelayedOperation is run or canceled. */AsyncQueue.prototype.removeDelayedOperation=function(op){// NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.
var index=this.delayedOperations.indexOf(op);assert(index>=0,'Delayed operation not found.');this.delayedOperations.splice(index,1);};return AsyncQueue;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var escapeChar='\u0001';var encodedSeparatorChar='\u0001';var encodedNul='\u0010';var encodedEscape='\u0011';/**
 * Encodes a resource path into a IndexedDb-compatible string form.
 */function encode(path){var result='';for(var i=0;i<path.length;i++){if(result.length>0){result=encodeSeparator(result);}result=encodeSegment(path.get(i),result);}return encodeSeparator(result);}/** Encodes a single segment of a resource path into the given result */function encodeSegment(segment,resultBuf){var result=resultBuf;var length=segment.length;for(var i=0;i<length;i++){var c=segment.charAt(i);switch(c){case'\0':result+=escapeChar+encodedNul;break;case escapeChar:result+=escapeChar+encodedEscape;break;default:result+=c;}}return result;}/** Encodes a path separator into the given result */function encodeSeparator(result){return result+escapeChar+encodedSeparatorChar;}/**
 * Decodes the given IndexedDb-compatible string form of a resource path into
 * a ResourcePath instance. Note that this method is not suitable for use with
 * decoding resource names from the server; those are One Platform format
 * strings.
 */function decode(path){// Event the empty path must encode as a path of at least length 2. A path
// with exactly 2 must be the empty path.
var length=path.length;assert(length>=2,'Invalid path '+path);if(length===2){assert(path.charAt(0)===escapeChar&&path.charAt(1)===encodedSeparatorChar,'Non-empty path '+path+' had length 2');return ResourcePath.EMPTY_PATH;}// Escape characters cannot exist past the second-to-last position in the
// source value.
var lastReasonableEscapeIndex=length-2;var segments=[];var segmentBuilder='';for(var start=0;start<length;){// The last two characters of a valid encoded path must be a separator, so
// there must be an end to this segment.
var end=path.indexOf(escapeChar,start);if(end<0||end>lastReasonableEscapeIndex){fail('Invalid encoded resource path: "'+path+'"');}var next=path.charAt(end+1);switch(next){case encodedSeparatorChar:var currentPiece=path.substring(start,end);var segment=void 0;if(segmentBuilder.length===0){// Avoid copying for the common case of a segment that excludes \0
// and \001
segment=currentPiece;}else{segmentBuilder+=currentPiece;segment=segmentBuilder;segmentBuilder='';}segments.push(segment);break;case encodedNul:segmentBuilder+=path.substring(start,end);segmentBuilder+='\0';break;case encodedEscape:// The escape character can be used in the output to encode itself.
segmentBuilder+=path.substring(start,end+1);break;default:fail('Invalid encoded resource path: "'+path+'"');}start=end+2;}return new ResourcePath(segments);}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var BATCHID_UNKNOWN=-1;/**
 * A batch of mutations that will be sent as one unit to the backend.
 */var MutationBatch=/** @class */function(){/**
     * @param batchId The unique ID of this mutation batch.
     * @param localWriteTime The original write time of this mutation.
     * @param baseMutations Mutations that are used to populate the base
     * values when this mutation is applied locally. This can be used to locally
     * overwrite values that are persisted in the remote document cache. Base
     * mutations are never sent to the backend.
     * @param mutations The user-provided mutations in this mutation batch.
     * User-provided mutations are applied both locally and remotely on the
     * backend.
     */function MutationBatch(batchId,localWriteTime,baseMutations,mutations){this.batchId=batchId;this.localWriteTime=localWriteTime;this.baseMutations=baseMutations;this.mutations=mutations;assert(mutations.length>0,'Cannot create an empty mutation batch');}/**
     * Applies all the mutations in this MutationBatch to the specified document
     * to create a new remote document
     *
     * @param docKey The key of the document to apply mutations to.
     * @param maybeDoc The document to apply mutations to.
     * @param batchResult The result of applying the MutationBatch to the
     * backend.
     */MutationBatch.prototype.applyToRemoteDocument=function(docKey,maybeDoc,batchResult){if(maybeDoc){assert(maybeDoc.key.isEqual(docKey),"applyToRemoteDocument: key "+docKey+" should match maybeDoc key\n        "+maybeDoc.key);}var mutationResults=batchResult.mutationResults;assert(mutationResults.length===this.mutations.length,"Mismatch between mutations length\n      ("+this.mutations.length+") and mutation results length\n      ("+mutationResults.length+").");for(var i=0;i<this.mutations.length;i++){var mutation=this.mutations[i];if(mutation.key.isEqual(docKey)){var mutationResult=mutationResults[i];maybeDoc=mutation.applyToRemoteDocument(maybeDoc,mutationResult);}}return maybeDoc;};/**
     * Computes the local view of a document given all the mutations in this
     * batch.
     *
     * @param docKey The key of the document to apply mutations to.
     * @param maybeDoc The document to apply mutations to.
     */MutationBatch.prototype.applyToLocalView=function(docKey,maybeDoc){if(maybeDoc){assert(maybeDoc.key.isEqual(docKey),"applyToLocalDocument: key "+docKey+" should match maybeDoc key\n        "+maybeDoc.key);}// First, apply the base state. This allows us to apply non-idempotent
// transform against a consistent set of values.
for(var _i=0,_a=this.baseMutations;_i<_a.length;_i++){var mutation=_a[_i];if(mutation.key.isEqual(docKey)){maybeDoc=mutation.applyToLocalView(maybeDoc,maybeDoc,this.localWriteTime);}}var baseDoc=maybeDoc;// Second, apply all user-provided mutations.
for(var _b=0,_c=this.mutations;_b<_c.length;_b++){var mutation=_c[_b];if(mutation.key.isEqual(docKey)){maybeDoc=mutation.applyToLocalView(maybeDoc,baseDoc,this.localWriteTime);}}return maybeDoc;};/**
     * Computes the local view for all provided documents given the mutations in
     * this batch.
     */MutationBatch.prototype.applyToLocalDocumentSet=function(maybeDocs){var _this=this;// TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations
// directly (as done in `applyToLocalView()`), we can reduce the complexity
// to O(n).
var mutatedDocuments=maybeDocs;this.mutations.forEach(function(m){var mutatedDocument=_this.applyToLocalView(m.key,maybeDocs.get(m.key));if(mutatedDocument){mutatedDocuments=mutatedDocuments.insert(m.key,mutatedDocument);}});return mutatedDocuments;};MutationBatch.prototype.keys=function(){return this.mutations.reduce(function(keys,m){return keys.add(m.key);},documentKeySet());};MutationBatch.prototype.isEqual=function(other){return this.batchId===other.batchId&&arrayEquals(this.mutations,other.mutations)&&arrayEquals(this.baseMutations,other.baseMutations);};return MutationBatch;}();/** The result of applying a mutation batch to the backend. */var MutationBatchResult=/** @class */function(){function MutationBatchResult(batch,commitVersion,mutationResults,streamToken,/**
     * A pre-computed mapping from each mutated document to the resulting
     * version.
     */docVersions){this.batch=batch;this.commitVersion=commitVersion;this.mutationResults=mutationResults;this.streamToken=streamToken;this.docVersions=docVersions;}/**
     * Creates a new MutationBatchResult for the given batch and results. There
     * must be one result for each mutation in the batch. This static factory
     * caches a document=>version mapping (docVersions).
     */MutationBatchResult.from=function(batch,commitVersion,results,streamToken){assert(batch.mutations.length===results.length,'Mutations sent '+batch.mutations.length+' must equal results received '+results.length);var versionMap=documentVersionMap();var mutations=batch.mutations;for(var i=0;i<mutations.length;i++){versionMap=versionMap.insert(mutations[i].key,results[i].version);}return new MutationBatchResult(batch,commitVersion,results,streamToken,versionMap);};return MutationBatchResult;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * PersistencePromise<> is essentially a re-implementation of Promise<> except
 * it has a .next() method instead of .then() and .next() and .catch() callbacks
 * are executed synchronously when a PersistencePromise resolves rather than
 * asynchronously (Promise<> implementations use setImmediate() or similar).
 *
 * This is necessary to interoperate with IndexedDB which will automatically
 * commit transactions if control is returned to the event loop without
 * synchronously initiating another operation on the transaction.
 *
 * NOTE: .then() and .catch() only allow a single consumer, unlike normal
 * Promises.
 */var PersistencePromise=/** @class */function(){function PersistencePromise(callback){var _this=this;// NOTE: next/catchCallback will always point to our own wrapper functions,
// not the user's raw next() or catch() callbacks.
// tslint:disable-next-line:no-any Accept any result type for the next call in the Promise chain.
this.nextCallback=null;// tslint:disable-next-line:no-any Accept any result type for the error handler.
this.catchCallback=null;// When the operation resolves, we'll set result or error and mark isDone.
this.result=undefined;this.error=undefined;this.isDone=false;// Set to true when .then() or .catch() are called and prevents additional
// chaining.
this.callbackAttached=false;callback(function(value){_this.isDone=true;_this.result=value;if(_this.nextCallback){// value should be defined unless T is Void, but we can't express
// that in the type system.
_this.nextCallback(value);}},function(error){_this.isDone=true;_this.error=error;if(_this.catchCallback){_this.catchCallback(error);}});}PersistencePromise.prototype.catch=function(fn){return this.next(undefined,fn);};PersistencePromise.prototype.next=function(nextFn,catchFn){var _this=this;if(this.callbackAttached){fail('Called next() or catch() twice for PersistencePromise');}this.callbackAttached=true;if(this.isDone){if(!this.error){return this.wrapSuccess(nextFn,this.result);}else{return this.wrapFailure(catchFn,this.error);}}else{return new PersistencePromise(function(resolve,reject){_this.nextCallback=function(value){_this.wrapSuccess(nextFn,value).next(resolve,reject);};_this.catchCallback=function(error){_this.wrapFailure(catchFn,error).next(resolve,reject);};});}};PersistencePromise.prototype.toPromise=function(){var _this=this;return new Promise(function(resolve,reject){_this.next(resolve,reject);});};PersistencePromise.prototype.wrapUserFunction=function(fn){try{var result=fn();if(result instanceof PersistencePromise){return result;}else{return PersistencePromise.resolve(result);}}catch(e){return PersistencePromise.reject(e);}};PersistencePromise.prototype.wrapSuccess=function(nextFn,value){if(nextFn){return this.wrapUserFunction(function(){return nextFn(value);});}else{// If there's no nextFn, then R must be the same as T but we
// can't express that in the type system.
// tslint:disable-next-line:no-any
return PersistencePromise.resolve(value);}};PersistencePromise.prototype.wrapFailure=function(catchFn,error){if(catchFn){return this.wrapUserFunction(function(){return catchFn(error);});}else{return PersistencePromise.reject(error);}};PersistencePromise.resolve=function(result){return new PersistencePromise(function(resolve,reject){resolve(result);});};PersistencePromise.reject=function(error){return new PersistencePromise(function(resolve,reject){reject(error);});};PersistencePromise.waitFor=function(// tslint:disable-next-line:no-any Accept all Promise types in waitFor().
all){return new PersistencePromise(function(resolve,reject){var expectedCount=0;var resolvedCount=0;var done=false;all.forEach(function(element){++expectedCount;element.next(function(){++resolvedCount;if(done&&resolvedCount===expectedCount){resolve();}},function(err){return reject(err);});});done=true;if(resolvedCount===expectedCount){resolve();}});};/**
     * Given an array of predicate functions that asynchronously evaluate to a
     * boolean, implements a short-circuiting `or` between the results. Predicates
     * will be evaluated until one of them returns `true`, then stop. The final
     * result will be whether any of them returned `true`.
     */PersistencePromise.or=function(predicates){var p=PersistencePromise.resolve(false);var _loop_1=function(predicate){p=p.next(function(isTrue){if(isTrue){return PersistencePromise.resolve(isTrue);}else{return predicate();}});};for(var _i=0,predicates_1=predicates;_i<predicates_1.length;_i++){var predicate=predicates_1[_i];_loop_1(predicate);}return p;};/**
     * Given an iterable, call the given function on each element in the
     * collection and wait for all of the resulting concurrent PersistencePromises
     * to resolve.
     */PersistencePromise.forEach=function(collection,f){var _this=this;var promises=[];collection.forEach(function(r,s){promises.push(f.call(_this,r,s));});return this.waitFor(promises);};return PersistencePromise;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//** A mutation queue for a specific user, backed by IndexedDB. */var IndexedDbMutationQueue=/** @class */function(){function IndexedDbMutationQueue(/**
     * The normalized userId (e.g. null UID => "" userId) used to store /
     * retrieve mutations.
     */userId,serializer,indexManager,referenceDelegate){this.userId=userId;this.serializer=serializer;this.indexManager=indexManager;this.referenceDelegate=referenceDelegate;/**
         * Caches the document keys for pending mutation batches. If the mutation
         * has been removed from IndexedDb, the cached value may continue to
         * be used to retrieve the batch's document keys. To remove a cached value
         * locally, `removeCachedMutationKeys()` should be invoked either directly
         * or through `removeMutationBatches()`.
         *
         * With multi-tab, when the primary client acknowledges or rejects a mutation,
         * this cache is used by secondary clients to invalidate the local
         * view of the documents that were previously affected by the mutation.
         */// PORTING NOTE: Multi-tab only.
this.documentKeysByBatchId={};}/**
     * Creates a new mutation queue for the given user.
     * @param user The user for which to create a mutation queue.
     * @param serializer The serializer to use when persisting to IndexedDb.
     */IndexedDbMutationQueue.forUser=function(user,serializer,indexManager,referenceDelegate){// TODO(mcg): Figure out what constraints there are on userIDs
// In particular, are there any reserved characters? are empty ids allowed?
// For the moment store these together in the same mutations table assuming
// that empty userIDs aren't allowed.
assert(user.uid!=='','UserID must not be an empty string.');var userId=user.isAuthenticated()?user.uid:'';return new IndexedDbMutationQueue(userId,serializer,indexManager,referenceDelegate);};IndexedDbMutationQueue.prototype.checkEmpty=function(transaction){var empty=true;var range=IDBKeyRange.bound([this.userId,Number.NEGATIVE_INFINITY],[this.userId,Number.POSITIVE_INFINITY]);return mutationsStore(transaction).iterate({index:DbMutationBatch.userMutationsIndex,range:range},function(key,value,control){empty=false;control.done();}).next(function(){return empty;});};IndexedDbMutationQueue.prototype.acknowledgeBatch=function(transaction,batch,streamToken){return this.getMutationQueueMetadata(transaction).next(function(metadata){metadata.lastStreamToken=convertStreamToken(streamToken);return mutationQueuesStore(transaction).put(metadata);});};IndexedDbMutationQueue.prototype.getLastStreamToken=function(transaction){return this.getMutationQueueMetadata(transaction).next(function(metadata){return metadata.lastStreamToken;});};IndexedDbMutationQueue.prototype.setLastStreamToken=function(transaction,streamToken){return this.getMutationQueueMetadata(transaction).next(function(metadata){metadata.lastStreamToken=convertStreamToken(streamToken);return mutationQueuesStore(transaction).put(metadata);});};IndexedDbMutationQueue.prototype.addMutationBatch=function(transaction,localWriteTime,baseMutations,mutations){var _this=this;var documentStore=documentMutationsStore(transaction);var mutationStore=mutationsStore(transaction);// The IndexedDb implementation in Chrome (and Firefox) does not handle
// compound indices that include auto-generated keys correctly. To ensure
// that the index entry is added correctly in all browsers, we perform two
// writes: The first write is used to retrieve the next auto-generated Batch
// ID, and the second write populates the index and stores the actual
// mutation batch.
// See: https://bugs.chromium.org/p/chromium/issues/detail?id=701972
// tslint:disable-next-line:no-any We write an empty object to obtain key
return mutationStore.add({}).next(function(batchId){assert(typeof batchId==='number','Auto-generated key is not a number');var batch=new MutationBatch(batchId,localWriteTime,baseMutations,mutations);var dbBatch=_this.serializer.toDbMutationBatch(_this.userId,batch);_this.documentKeysByBatchId[batchId]=batch.keys();var promises=[];for(var _i=0,mutations_1=mutations;_i<mutations_1.length;_i++){var mutation=mutations_1[_i];var indexKey=DbDocumentMutation.key(_this.userId,mutation.key.path,batchId);promises.push(mutationStore.put(dbBatch));promises.push(documentStore.put(indexKey,DbDocumentMutation.PLACEHOLDER));promises.push(_this.indexManager.addToCollectionParentIndex(transaction,mutation.key.path.popLast()));}return PersistencePromise.waitFor(promises).next(function(){return batch;});});};IndexedDbMutationQueue.prototype.lookupMutationBatch=function(transaction,batchId){var _this=this;return mutationsStore(transaction).get(batchId).next(function(dbBatch){if(dbBatch){assert(dbBatch.userId===_this.userId,"Unexpected user '"+dbBatch.userId+"' for mutation batch "+batchId);return _this.serializer.fromDbMutationBatch(dbBatch);}return null;});};IndexedDbMutationQueue.prototype.lookupMutationKeys=function(transaction,batchId){var _this=this;if(this.documentKeysByBatchId[batchId]){return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);}else{return this.lookupMutationBatch(transaction,batchId).next(function(batch){if(batch){var keys=batch.keys();_this.documentKeysByBatchId[batchId]=keys;return keys;}else{return null;}});}};IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId=function(transaction,batchId){var _this=this;return this.getMutationQueueMetadata(transaction).next(function(metadata){var nextBatchId=batchId+1;var range=IDBKeyRange.lowerBound([_this.userId,nextBatchId]);var foundBatch=null;return mutationsStore(transaction).iterate({index:DbMutationBatch.userMutationsIndex,range:range},function(key,dbBatch,control){if(dbBatch.userId===_this.userId){assert(dbBatch.batchId>=nextBatchId,'Should have found mutation after '+nextBatchId);foundBatch=_this.serializer.fromDbMutationBatch(dbBatch);}control.done();}).next(function(){return foundBatch;});});};IndexedDbMutationQueue.prototype.getAllMutationBatches=function(transaction){var _this=this;var range=IDBKeyRange.bound([this.userId,BATCHID_UNKNOWN],[this.userId,Number.POSITIVE_INFINITY]);return mutationsStore(transaction).loadAll(DbMutationBatch.userMutationsIndex,range).next(function(dbBatches){return dbBatches.map(function(dbBatch){return _this.serializer.fromDbMutationBatch(dbBatch);});});};IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey=function(transaction,documentKey){var _this=this;// Scan the document-mutation index starting with a prefix starting with
// the given documentKey.
var indexPrefix=DbDocumentMutation.prefixForPath(this.userId,documentKey.path);var indexStart=IDBKeyRange.lowerBound(indexPrefix);var results=[];return documentMutationsStore(transaction).iterate({range:indexStart},function(indexKey,_,control){var userID=indexKey[0],encodedPath=indexKey[1],batchId=indexKey[2];// Only consider rows matching exactly the specific key of
// interest. Note that because we order by path first, and we
// order terminators before path separators, we'll encounter all
// the index rows for documentKey contiguously. In particular, all
// the rows for documentKey will occur before any rows for
// documents nested in a subcollection beneath documentKey so we
// can stop as soon as we hit any such row.
var path=decode(encodedPath);if(userID!==_this.userId||!documentKey.path.isEqual(path)){control.done();return;}// Look up the mutation batch in the store.
return mutationsStore(transaction).get(batchId).next(function(mutation){if(!mutation){throw fail('Dangling document-mutation reference found: '+indexKey+' which points to '+batchId);}assert(mutation.userId===_this.userId,"Unexpected user '"+mutation.userId+"' for mutation batch "+batchId);results.push(_this.serializer.fromDbMutationBatch(mutation));});}).next(function(){return results;});};IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKeys=function(transaction,documentKeys){var _this=this;var uniqueBatchIDs=new SortedSet(primitiveComparator);var promises=[];documentKeys.forEach(function(documentKey){var indexStart=DbDocumentMutation.prefixForPath(_this.userId,documentKey.path);var range=IDBKeyRange.lowerBound(indexStart);var promise=documentMutationsStore(transaction).iterate({range:range},function(indexKey,_,control){var userID=indexKey[0],encodedPath=indexKey[1],batchID=indexKey[2];// Only consider rows matching exactly the specific key of
// interest. Note that because we order by path first, and we
// order terminators before path separators, we'll encounter all
// the index rows for documentKey contiguously. In particular, all
// the rows for documentKey will occur before any rows for
// documents nested in a subcollection beneath documentKey so we
// can stop as soon as we hit any such row.
var path=decode(encodedPath);if(userID!==_this.userId||!documentKey.path.isEqual(path)){control.done();return;}uniqueBatchIDs=uniqueBatchIDs.add(batchID);});promises.push(promise);});return PersistencePromise.waitFor(promises).next(function(){return _this.lookupMutationBatches(transaction,uniqueBatchIDs);});};IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery=function(transaction,query){var _this=this;assert(!query.isDocumentQuery(),"Document queries shouldn't go down this path");assert(!query.isCollectionGroupQuery(),'CollectionGroup queries should be handled in LocalDocumentsView');var queryPath=query.path;var immediateChildrenLength=queryPath.length+1;// TODO(mcg): Actually implement a single-collection query
//
// This is actually executing an ancestor query, traversing the whole
// subtree below the collection which can be horrifically inefficient for
// some structures. The right way to solve this is to implement the full
// value index, but that's not in the cards in the near future so this is
// the best we can do for the moment.
//
// Since we don't yet index the actual properties in the mutations, our
// current approach is to just return all mutation batches that affect
// documents in the collection being queried.
var indexPrefix=DbDocumentMutation.prefixForPath(this.userId,queryPath);var indexStart=IDBKeyRange.lowerBound(indexPrefix);// Collect up unique batchIDs encountered during a scan of the index. Use a
// SortedSet to accumulate batch IDs so they can be traversed in order in a
// scan of the main table.
var uniqueBatchIDs=new SortedSet(primitiveComparator);return documentMutationsStore(transaction).iterate({range:indexStart},function(indexKey,_,control){var userID=indexKey[0],encodedPath=indexKey[1],batchID=indexKey[2];var path=decode(encodedPath);if(userID!==_this.userId||!queryPath.isPrefixOf(path)){control.done();return;}// Rows with document keys more than one segment longer than the
// query path can't be matches. For example, a query on 'rooms'
// can't match the document /rooms/abc/messages/xyx.
// TODO(mcg): we'll need a different scanner when we implement
// ancestor queries.
if(path.length!==immediateChildrenLength){return;}uniqueBatchIDs=uniqueBatchIDs.add(batchID);}).next(function(){return _this.lookupMutationBatches(transaction,uniqueBatchIDs);});};IndexedDbMutationQueue.prototype.lookupMutationBatches=function(transaction,batchIDs){var _this=this;var results=[];var promises=[];// TODO(rockwood): Implement this using iterate.
batchIDs.forEach(function(batchId){promises.push(mutationsStore(transaction).get(batchId).next(function(mutation){if(mutation===null){throw fail('Dangling document-mutation reference found, '+'which points to '+batchId);}assert(mutation.userId===_this.userId,"Unexpected user '"+mutation.userId+"' for mutation batch "+batchId);results.push(_this.serializer.fromDbMutationBatch(mutation));}));});return PersistencePromise.waitFor(promises).next(function(){return results;});};IndexedDbMutationQueue.prototype.removeMutationBatch=function(transaction,batch){var _this=this;return removeMutationBatch(transaction.simpleDbTransaction,this.userId,batch).next(function(removedDocuments){_this.removeCachedMutationKeys(batch.batchId);return PersistencePromise.forEach(removedDocuments,function(key){return _this.referenceDelegate.removeMutationReference(transaction,key);});});};IndexedDbMutationQueue.prototype.removeCachedMutationKeys=function(batchId){delete this.documentKeysByBatchId[batchId];};IndexedDbMutationQueue.prototype.performConsistencyCheck=function(txn){var _this=this;return this.checkEmpty(txn).next(function(empty){if(!empty){return PersistencePromise.resolve();}// Verify that there are no entries in the documentMutations index if
// the queue is empty.
var startRange=IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));var danglingMutationReferences=[];return documentMutationsStore(txn).iterate({range:startRange},function(key,_,control){var userID=key[0];if(userID!==_this.userId){control.done();return;}else{var path=decode(key[1]);danglingMutationReferences.push(path);}}).next(function(){assert(danglingMutationReferences.length===0,'Document leak -- detected dangling mutation references when queue is empty. '+'Dangling keys: '+danglingMutationReferences.map(function(p){return p.canonicalString();}));});});};IndexedDbMutationQueue.prototype.containsKey=function(txn,key){return mutationQueueContainsKey(txn,this.userId,key);};// PORTING NOTE: Multi-tab only (state is held in memory in other clients).
/** Returns the mutation queue's metadata from IndexedDb. */IndexedDbMutationQueue.prototype.getMutationQueueMetadata=function(transaction){var _this=this;return mutationQueuesStore(transaction).get(this.userId).next(function(metadata){return metadata||new DbMutationQueue(_this.userId,BATCHID_UNKNOWN,/*lastStreamToken=*/'');});};return IndexedDbMutationQueue;}();/**
 * @return true if the mutation queue for the given user contains a pending
 *         mutation for the given key.
 */function mutationQueueContainsKey(txn,userId,key){var indexKey=DbDocumentMutation.prefixForPath(userId,key.path);var encodedPath=indexKey[1];var startRange=IDBKeyRange.lowerBound(indexKey);var containsKey=false;return documentMutationsStore(txn).iterate({range:startRange,keysOnly:true},function(key,value,control){var userID=key[0],keyPath=key[1],/*batchID*/_=key[2];if(userID===userId&&keyPath===encodedPath){containsKey=true;}control.done();}).next(function(){return containsKey;});}/** Returns true if any mutation queue contains the given document. */function mutationQueuesContainKey(txn,docKey){var found=false;return mutationQueuesStore(txn).iterateSerial(function(userId){return mutationQueueContainsKey(txn,userId,docKey).next(function(containsKey){if(containsKey){found=true;}return PersistencePromise.resolve(!containsKey);});}).next(function(){return found;});}/**
 * Delete a mutation batch and the associated document mutations.
 * @return A PersistencePromise of the document mutations that were removed.
 */function removeMutationBatch(txn,userId,batch){var mutationStore=txn.store(DbMutationBatch.store);var indexTxn=txn.store(DbDocumentMutation.store);var promises=[];var range=IDBKeyRange.only(batch.batchId);var numDeleted=0;var removePromise=mutationStore.iterate({range:range},function(key,value,control){numDeleted++;return control.delete();});promises.push(removePromise.next(function(){assert(numDeleted===1,'Dangling document-mutation reference found: Missing batch '+batch.batchId);}));var removedDocuments=[];for(var _i=0,_a=batch.mutations;_i<_a.length;_i++){var mutation=_a[_i];var indexKey=DbDocumentMutation.key(userId,mutation.key.path,batch.batchId);promises.push(indexTxn.delete(indexKey));removedDocuments.push(mutation.key);}return PersistencePromise.waitFor(promises).next(function(){return removedDocuments;});}function convertStreamToken(token){if(token instanceof Uint8Array){// TODO(b/78771403): Convert tokens to strings during deserialization
assert(process.env.USE_MOCK_PERSISTENCE==='YES','Persisting non-string stream tokens is only supported with mock persistence.');return token.toString();}else{return token;}}/**
 * Helper to get a typed SimpleDbStore for the mutations object store.
 */function mutationsStore(txn){return IndexedDbPersistence.getStore(txn,DbMutationBatch.store);}/**
 * Helper to get a typed SimpleDbStore for the mutationQueues object store.
 */function documentMutationsStore(txn){return IndexedDbPersistence.getStore(txn,DbDocumentMutation.store);}/**
 * Helper to get a typed SimpleDbStore for the mutationQueues object store.
 */function mutationQueuesStore(txn){return IndexedDbPersistence.getStore(txn,DbMutationQueue.store);}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var RESERVED_BITS=1;var GeneratorIds;(function(GeneratorIds){GeneratorIds[GeneratorIds["QueryCache"]=0]="QueryCache";GeneratorIds[GeneratorIds["SyncEngine"]=1]="SyncEngine";// The target IDs for limbo detection are odd (end in 1).
})(GeneratorIds||(GeneratorIds={}));/**
 * Generates monotonically increasing target IDs for sending targets to the
 * watch stream.
 *
 * The client constructs two generators, one for the query cache (via
 * forQueryCache()), and one for limbo documents (via forSyncEngine()). These
 * two generators produce non-overlapping IDs (by using even and odd IDs
 * respectively).
 *
 * By separating the target ID space, the query cache can generate target IDs
 * that persist across client restarts, while sync engine can independently
 * generate in-memory target IDs that are transient and can be reused after a
 * restart.
 */// TODO(mrschmidt): Explore removing this class in favor of generating these IDs
// directly in SyncEngine and LocalStore.
var TargetIdGenerator=/** @class */function(){/**
     * Instantiates a new TargetIdGenerator. If a seed is provided, the generator
     * will use the seed value as the next target ID.
     */function TargetIdGenerator(generatorId,seed){this.generatorId=generatorId;assert((generatorId&RESERVED_BITS)===generatorId,"Generator ID "+generatorId+" contains more than "+RESERVED_BITS+" reserved bits");this.seek(seed!==undefined?seed:this.generatorId);}TargetIdGenerator.prototype.next=function(){var nextId=this.nextId;this.nextId+=1<<RESERVED_BITS;return nextId;};/**
     * Returns the ID that follows the given ID. Subsequent calls to `next()`
     * use the newly returned target ID as their base.
     */// PORTING NOTE: Multi-tab only.
TargetIdGenerator.prototype.after=function(targetId){this.seek(targetId+(1<<RESERVED_BITS));return this.next();};TargetIdGenerator.prototype.seek=function(targetId){assert((targetId&RESERVED_BITS)===this.generatorId,'Cannot supply target ID from different generator ID');this.nextId=targetId;};TargetIdGenerator.forQueryCache=function(){// We seed the query cache generator to return '2' as its first ID, as there
// is no differentiation in the protocol layer between an unset number and
// the number '0'. If we were to sent a target with target ID '0', the
// backend would consider it unset and replace it with its own ID.
var targetIdGenerator=new TargetIdGenerator(GeneratorIds.QueryCache,2);return targetIdGenerator;};TargetIdGenerator.forSyncEngine=function(){// Sync engine assigns target IDs for limbo document detection.
return new TargetIdGenerator(GeneratorIds.SyncEngine);};return TargetIdGenerator;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$1='SimpleDb';/**
 * Provides a wrapper around IndexedDb with a simplified interface that uses
 * Promise-like return values to chain operations. Real promises cannot be used
 * since .then() continuations are executed asynchronously (e.g. via
 * .setImmediate), which would cause IndexedDB to end the transaction.
 * See PersistencePromise for more details.
 */var SimpleDb=/** @class */function(){function SimpleDb(db){this.db=db;}/**
     * Opens the specified database, creating or upgrading it if necessary.
     *
     * Note that `version` must not be a downgrade. IndexedDB does not support downgrading the schema
     * version. We currently do not support any way to do versioning outside of IndexedDB's versioning
     * mechanism, as only version-upgrade transactions are allowed to do things like create
     * objectstores.
     */SimpleDb.openOrCreate=function(name,version,schemaConverter){assert(SimpleDb.isAvailable(),'IndexedDB not supported in current environment.');debug(LOG_TAG$1,'Opening database:',name);return new PersistencePromise(function(resolve,reject){// TODO(mikelehen): Investigate browser compatibility.
// https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB
// suggests IE9 and older WebKit browsers handle upgrade
// differently. They expect setVersion, as described here:
// https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion
var request=window.indexedDB.open(name,version);request.onsuccess=function(event){var db=event.target.result;resolve(new SimpleDb(db));};request.onblocked=function(){reject(new FirestoreError(Code.FAILED_PRECONDITION,'Cannot upgrade IndexedDB schema while another tab is open. '+'Close all tabs that access Firestore and reload this page to proceed.'));};request.onerror=function(event){var error=event.target.error;if(error.name==='VersionError'){reject(new FirestoreError(Code.FAILED_PRECONDITION,'A newer version of the Firestore SDK was previously used and so the persisted '+'data is not compatible with the version of the SDK you are now using. The SDK '+'will operate with persistence disabled. If you need persistence, please '+'re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB '+'data for your app to start fresh.'));}else{reject(error);}};request.onupgradeneeded=function(event){debug(LOG_TAG$1,'Database "'+name+'" requires upgrade from version:',event.oldVersion);var db=event.target.result;// We are provided a version upgrade transaction from the request, so
// we wrap that in a SimpleDbTransaction to allow use of our friendlier
// API for schema migration operations.
var txn=new SimpleDbTransaction(request.transaction);schemaConverter.createOrUpgrade(db,txn,event.oldVersion,SCHEMA_VERSION).next(function(){debug(LOG_TAG$1,'Database upgrade to version '+SCHEMA_VERSION+' complete');});};}).toPromise();};/** Deletes the specified database. */SimpleDb.delete=function(name){debug(LOG_TAG$1,'Removing database:',name);return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();};/** Returns true if IndexedDB is available in the current environment. */SimpleDb.isAvailable=function(){if(typeof window==='undefined'||window.indexedDB==null){return false;}// We extensively use indexed array values and compound keys,
// which IE and Edge do not support. However, they still have indexedDB
// defined on the window, so we need to check for them here and make sure
// to return that persistence is not enabled for those browsers.
// For tracking support of this feature, see here:
// https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/
// If we are running in Node using the IndexedDBShim, `window` is defined,
// but `window.navigator` is not. In this case, we support IndexedDB and
// return `true`.
if(window.navigator===undefined){return process.env.USE_MOCK_PERSISTENCE==='YES';}// Check the UA string to find out the browser.
// TODO(mikelehen): Move this logic into packages/util/environment.ts
var ua=window.navigator.userAgent;// IE 10
// ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';
// IE 11
// ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';
// Edge
// ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,
// like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';
// iOS Safari: Disable for users running iOS version < 10.
var iOSVersion=SimpleDb.getIOSVersion(ua);var isUnsupportedIOS=0<iOSVersion&&iOSVersion<10;// Android browser: Disable for userse running version < 4.5.
var androidVersion=SimpleDb.getAndroidVersion(ua);var isUnsupportedAndroid=0<androidVersion&&androidVersion<4.5;if(ua.indexOf('MSIE ')>0||ua.indexOf('Trident/')>0||ua.indexOf('Edge/')>0||isUnsupportedIOS||isUnsupportedAndroid){return false;}else{return true;}};/** Helper to get a typed SimpleDbStore from a transaction. */SimpleDb.getStore=function(txn,store){return txn.store(store);};// visible for testing
/** Parse User Agent to determine iOS version. Returns -1 if not found. */SimpleDb.getIOSVersion=function(ua){var iOSVersionRegex=ua.match(/i(?:phone|pad|pod) os ([\d_]+)/i);var version=iOSVersionRegex?iOSVersionRegex[1].split('_')[0]:'-1';return Number(version);};// visible for testing
/** Parse User Agent to determine Android version. Returns -1 if not found. */SimpleDb.getAndroidVersion=function(ua){var androidVersionRegex=ua.match(/Android ([\d.]+)/i);var version=androidVersionRegex?androidVersionRegex[1].split('.').slice(0,2).join('.'):'-1';return Number(version);};SimpleDb.prototype.runTransaction=function(mode,objectStores,transactionFn){var transaction=SimpleDbTransaction.open(this.db,mode,objectStores);var transactionFnResult=transactionFn(transaction).catch(function(error){// Abort the transaction if there was an error.
transaction.abort(error);// We cannot actually recover, and calling `abort()` will cause the transaction's
// completion promise to be rejected. This in turn means that we won't use
// `transactionFnResult` below. We return a rejection here so that we don't add the
// possibility of returning `void` to the type of `transactionFnResult`.
return PersistencePromise.reject(error);}).toPromise();// As noted above, errors are propagated by aborting the transaction. So
// we swallow any error here to avoid the browser logging it as unhandled.
transactionFnResult.catch(function(){});// Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to
// fire), but still return the original transactionFnResult back to the
// caller.
return transaction.completionPromise.then(function(){return transactionFnResult;});};SimpleDb.prototype.close=function(){this.db.close();};return SimpleDb;}();/**
 * A controller for iterating over a key range or index. It allows an iterate
 * callback to delete the currently-referenced object, or jump to a new key
 * within the key range or index.
 */var IterationController=/** @class */function(){function IterationController(dbCursor){this.dbCursor=dbCursor;this.shouldStop=false;this.nextKey=null;}Object.defineProperty(IterationController.prototype,"isDone",{get:function(){return this.shouldStop;},enumerable:true,configurable:true});Object.defineProperty(IterationController.prototype,"skipToKey",{get:function(){return this.nextKey;},enumerable:true,configurable:true});Object.defineProperty(IterationController.prototype,"cursor",{set:function(value){this.dbCursor=value;},enumerable:true,configurable:true});/**
     * This function can be called to stop iteration at any point.
     */IterationController.prototype.done=function(){this.shouldStop=true;};/**
     * This function can be called to skip to that next key, which could be
     * an index or a primary key.
     */IterationController.prototype.skip=function(key){this.nextKey=key;};/**
     * Delete the current cursor value from the object store.
     *
     * NOTE: You CANNOT do this with a keysOnly query.
     */IterationController.prototype.delete=function(){return wrapRequest(this.dbCursor.delete());};return IterationController;}();/**
 * Wraps an IDBTransaction and exposes a store() method to get a handle to a
 * specific object store.
 */var SimpleDbTransaction=/** @class */function(){function SimpleDbTransaction(transaction){var _this=this;this.transaction=transaction;this.aborted=false;/**
         * A promise that resolves with the result of the IndexedDb transaction.
         */this.completionDeferred=new Deferred();this.transaction.oncomplete=function(){_this.completionDeferred.resolve();};this.transaction.onabort=function(){if(transaction.error){_this.completionDeferred.reject(transaction.error);}else{_this.completionDeferred.resolve();}};this.transaction.onerror=function(event){_this.completionDeferred.reject(event.target.error);};}SimpleDbTransaction.open=function(db,mode,objectStoreNames){return new SimpleDbTransaction(db.transaction(objectStoreNames,mode));};Object.defineProperty(SimpleDbTransaction.prototype,"completionPromise",{get:function(){return this.completionDeferred.promise;},enumerable:true,configurable:true});SimpleDbTransaction.prototype.abort=function(error){if(error){this.completionDeferred.reject(error);}if(!this.aborted){debug(LOG_TAG$1,'Aborting transaction:',error?error.message:'Client-initiated abort');this.aborted=true;this.transaction.abort();}};/**
     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All
     * operations performed on the SimpleDbStore happen within the context of this
     * transaction and it cannot be used anymore once the transaction is
     * completed.
     *
     * Note that we can't actually enforce that the KeyType and ValueType are
     * correct, but they allow type safety through the rest of the consuming code.
     */SimpleDbTransaction.prototype.store=function(storeName){var store=this.transaction.objectStore(storeName);assert(!!store,'Object store not part of transaction: '+storeName);return new SimpleDbStore(store);};return SimpleDbTransaction;}();/**
 * A wrapper around an IDBObjectStore providing an API that:
 *
 * 1) Has generic KeyType / ValueType parameters to provide strongly-typed
 * methods for acting against the object store.
 * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every
 * method return a PersistencePromise instead.
 * 3) Provides a higher-level API to avoid needing to do excessive wrapping of
 * intermediate IndexedDB types (IDBCursorWithValue, etc.)
 */var SimpleDbStore=/** @class */function(){function SimpleDbStore(store){this.store=store;}SimpleDbStore.prototype.put=function(keyOrValue,value){var request;if(value!==undefined){debug(LOG_TAG$1,'PUT',this.store.name,keyOrValue,value);request=this.store.put(value,keyOrValue);}else{debug(LOG_TAG$1,'PUT',this.store.name,'<auto-key>',keyOrValue);request=this.store.put(keyOrValue);}return wrapRequest(request);};/**
     * Adds a new value into an Object Store and returns the new key. Similar to
     * IndexedDb's `add()`, this method will fail on primary key collisions.
     *
     * @param value The object to write.
     * @return The key of the value to add.
     */SimpleDbStore.prototype.add=function(value){debug(LOG_TAG$1,'ADD',this.store.name,value,value);var request=this.store.add(value);return wrapRequest(request);};/**
     * Gets the object with the specified key from the specified store, or null
     * if no object exists with the specified key.
     *
     * @key The key of the object to get.
     * @return The object with the specified key or null if no object exists.
     */SimpleDbStore.prototype.get=function(key){var _this=this;var request=this.store.get(key);// tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.
return wrapRequest(request).next(function(result){// Normalize nonexistence to null.
if(result===undefined){result=null;}debug(LOG_TAG$1,'GET',_this.store.name,key,result);return result;});};SimpleDbStore.prototype.delete=function(key){debug(LOG_TAG$1,'DELETE',this.store.name,key);var request=this.store.delete(key);return wrapRequest(request);};/**
     * If we ever need more of the count variants, we can add overloads. For now,
     * all we need is to count everything in a store.
     *
     * Returns the number of rows in the store.
     */SimpleDbStore.prototype.count=function(){debug(LOG_TAG$1,'COUNT',this.store.name);var request=this.store.count();return wrapRequest(request);};SimpleDbStore.prototype.loadAll=function(indexOrRange,range){var cursor=this.cursor(this.options(indexOrRange,range));var results=[];return this.iterateCursor(cursor,function(key,value){results.push(value);}).next(function(){return results;});};SimpleDbStore.prototype.deleteAll=function(indexOrRange,range){debug(LOG_TAG$1,'DELETE ALL',this.store.name);var options=this.options(indexOrRange,range);options.keysOnly=false;var cursor=this.cursor(options);return this.iterateCursor(cursor,function(key,value,control){// NOTE: Calling delete() on a cursor is documented as more efficient than
// calling delete() on an object store with a single key
// (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),
// however, this requires us *not* to use a keysOnly cursor
// (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We
// may want to compare the performance of each method.
return control.delete();});};SimpleDbStore.prototype.iterate=function(optionsOrCallback,callback){var options;if(!callback){options={};callback=optionsOrCallback;}else{options=optionsOrCallback;}var cursor=this.cursor(options);return this.iterateCursor(cursor,callback);};/**
     * Iterates over a store, but waits for the given callback to complete for
     * each entry before iterating the next entry. This allows the callback to do
     * asynchronous work to determine if this iteration should continue.
     *
     * The provided callback should return `true` to continue iteration, and
     * `false` otherwise.
     */SimpleDbStore.prototype.iterateSerial=function(callback){var cursorRequest=this.cursor({});return new PersistencePromise(function(resolve,reject){cursorRequest.onerror=function(event){reject(event.target.error);};cursorRequest.onsuccess=function(event){var cursor=event.target.result;if(!cursor){resolve();return;}callback(cursor.primaryKey,cursor.value).next(function(shouldContinue){if(shouldContinue){cursor.continue();}else{resolve();}});};});};SimpleDbStore.prototype.iterateCursor=function(cursorRequest,fn){var results=[];return new PersistencePromise(function(resolve,reject){cursorRequest.onerror=function(event){reject(event.target.error);};cursorRequest.onsuccess=function(event){var cursor=event.target.result;if(!cursor){resolve();return;}var controller=new IterationController(cursor);var userResult=fn(cursor.primaryKey,cursor.value,controller);if(userResult instanceof PersistencePromise){var userPromise=userResult.catch(function(err){controller.done();return PersistencePromise.reject(err);});results.push(userPromise);}if(controller.isDone){resolve();}else if(controller.skipToKey===null){cursor.continue();}else{cursor.continue(controller.skipToKey);}};}).next(function(){return PersistencePromise.waitFor(results);});};SimpleDbStore.prototype.options=function(indexOrRange,range){var indexName=undefined;if(indexOrRange!==undefined){if(typeof indexOrRange==='string'){indexName=indexOrRange;}else{assert(range===undefined,'3rd argument must not be defined if 2nd is a range.');range=indexOrRange;}}return{index:indexName,range:range};};SimpleDbStore.prototype.cursor=function(options){var direction='next';if(options.reverse){direction='prev';}if(options.index){var index=this.store.index(options.index);if(options.keysOnly){return index.openKeyCursor(options.range,direction);}else{return index.openCursor(options.range,direction);}}else{return this.store.openCursor(options.range,direction);}};return SimpleDbStore;}();/**
 * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror
 * handlers to resolve / reject the PersistencePromise as appropriate.
 */function wrapRequest(request){return new PersistencePromise(function(resolve,reject){request.onsuccess=function(event){var result=event.target.result;resolve(result);};request.onerror=function(event){reject(event.target.error);};});}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var IndexedDbQueryCache=/** @class */function(){function IndexedDbQueryCache(referenceDelegate,serializer){this.referenceDelegate=referenceDelegate;this.serializer=serializer;// PORTING NOTE: We don't cache global metadata for the query cache, since
// some of it (in particular `highestTargetId`) can be modified by secondary
// tabs. We could perhaps be more granular (and e.g. still cache
// `lastRemoteSnapshotVersion` in memory) but for simplicity we currently go
// to IndexedDb whenever we need to read metadata. We can revisit if it turns
// out to have a meaningful performance impact.
this.targetIdGenerator=TargetIdGenerator.forQueryCache();}IndexedDbQueryCache.prototype.allocateTargetId=function(transaction){var _this=this;return this.retrieveMetadata(transaction).next(function(metadata){metadata.highestTargetId=_this.targetIdGenerator.after(metadata.highestTargetId);return _this.saveMetadata(transaction,metadata).next(function(){return metadata.highestTargetId;});});};IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion=function(transaction){return this.retrieveMetadata(transaction).next(function(metadata){return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds,metadata.lastRemoteSnapshotVersion.nanoseconds));});};IndexedDbQueryCache.prototype.getHighestSequenceNumber=function(transaction){return getHighestListenSequenceNumber(transaction.simpleDbTransaction);};IndexedDbQueryCache.prototype.setTargetsMetadata=function(transaction,highestListenSequenceNumber,lastRemoteSnapshotVersion){var _this=this;return this.retrieveMetadata(transaction).next(function(metadata){metadata.highestListenSequenceNumber=highestListenSequenceNumber;if(lastRemoteSnapshotVersion){metadata.lastRemoteSnapshotVersion=lastRemoteSnapshotVersion.toTimestamp();}if(highestListenSequenceNumber>metadata.highestListenSequenceNumber){metadata.highestListenSequenceNumber=highestListenSequenceNumber;}return _this.saveMetadata(transaction,metadata);});};IndexedDbQueryCache.prototype.addQueryData=function(transaction,queryData){var _this=this;return this.saveQueryData(transaction,queryData).next(function(){return _this.retrieveMetadata(transaction).next(function(metadata){metadata.targetCount+=1;_this.updateMetadataFromQueryData(queryData,metadata);return _this.saveMetadata(transaction,metadata);});});};IndexedDbQueryCache.prototype.updateQueryData=function(transaction,queryData){return this.saveQueryData(transaction,queryData);};IndexedDbQueryCache.prototype.removeQueryData=function(transaction,queryData){var _this=this;return this.removeMatchingKeysForTargetId(transaction,queryData.targetId).next(function(){return targetsStore(transaction).delete(queryData.targetId);}).next(function(){return _this.retrieveMetadata(transaction);}).next(function(metadata){assert(metadata.targetCount>0,'Removing from an empty query cache');metadata.targetCount-=1;return _this.saveMetadata(transaction,metadata);});};/**
     * Drops any targets with sequence number less than or equal to the upper bound, excepting those
     * present in `activeTargetIds`. Document associations for the removed targets are also removed.
     * Returns the number of targets removed.
     */IndexedDbQueryCache.prototype.removeTargets=function(txn,upperBound,activeTargetIds){var _this=this;var count=0;var promises=[];return targetsStore(txn).iterate(function(key,value){var queryData=_this.serializer.fromDbTarget(value);if(queryData.sequenceNumber<=upperBound&&activeTargetIds[queryData.targetId]===undefined){count++;promises.push(_this.removeQueryData(txn,queryData));}}).next(function(){return PersistencePromise.waitFor(promises);}).next(function(){return count;});};/**
     * Call provided function with each `QueryData` that we have cached.
     */IndexedDbQueryCache.prototype.forEachTarget=function(txn,f){var _this=this;return targetsStore(txn).iterate(function(key,value){var queryData=_this.serializer.fromDbTarget(value);f(queryData);});};IndexedDbQueryCache.prototype.retrieveMetadata=function(transaction){return retrieveMetadata(transaction.simpleDbTransaction);};IndexedDbQueryCache.prototype.saveMetadata=function(transaction,metadata){return globalTargetStore(transaction).put(DbTargetGlobal.key,metadata);};IndexedDbQueryCache.prototype.saveQueryData=function(transaction,queryData){return targetsStore(transaction).put(this.serializer.toDbTarget(queryData));};/**
     * In-place updates the provided metadata to account for values in the given
     * QueryData. Saving is done separately. Returns true if there were any
     * changes to the metadata.
     */IndexedDbQueryCache.prototype.updateMetadataFromQueryData=function(queryData,metadata){var updated=false;if(queryData.targetId>metadata.highestTargetId){metadata.highestTargetId=queryData.targetId;updated=true;}if(queryData.sequenceNumber>metadata.highestListenSequenceNumber){metadata.highestListenSequenceNumber=queryData.sequenceNumber;updated=true;}return updated;};IndexedDbQueryCache.prototype.getQueryCount=function(transaction){return this.retrieveMetadata(transaction).next(function(metadata){return metadata.targetCount;});};IndexedDbQueryCache.prototype.getQueryData=function(transaction,query){var _this=this;// Iterating by the canonicalId may yield more than one result because
// canonicalId values are not required to be unique per target. This query
// depends on the queryTargets index to be efficient.
var canonicalId=query.canonicalId();var range=IDBKeyRange.bound([canonicalId,Number.NEGATIVE_INFINITY],[canonicalId,Number.POSITIVE_INFINITY]);var result=null;return targetsStore(transaction).iterate({range:range,index:DbTarget.queryTargetsIndexName},function(key,value,control){var found=_this.serializer.fromDbTarget(value);// After finding a potential match, check that the query is
// actually equal to the requested query.
if(query.isEqual(found.query)){result=found;control.done();}}).next(function(){return result;});};IndexedDbQueryCache.prototype.addMatchingKeys=function(txn,keys,targetId){var _this=this;// PORTING NOTE: The reverse index (documentsTargets) is maintained by
// IndexedDb.
var promises=[];var store=documentTargetStore(txn);keys.forEach(function(key){var path=encode(key.path);promises.push(store.put(new DbTargetDocument(targetId,path)));promises.push(_this.referenceDelegate.addReference(txn,key));});return PersistencePromise.waitFor(promises);};IndexedDbQueryCache.prototype.removeMatchingKeys=function(txn,keys,targetId){var _this=this;// PORTING NOTE: The reverse index (documentsTargets) is maintained by
// IndexedDb.
var store=documentTargetStore(txn);return PersistencePromise.forEach(keys,function(key){var path=encode(key.path);return PersistencePromise.waitFor([store.delete([targetId,path]),_this.referenceDelegate.removeReference(txn,key)]);});};IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId=function(txn,targetId){var store=documentTargetStore(txn);var range=IDBKeyRange.bound([targetId],[targetId+1],/*lowerOpen=*/false,/*upperOpen=*/true);return store.delete(range);};IndexedDbQueryCache.prototype.getMatchingKeysForTargetId=function(txn,targetId){var range=IDBKeyRange.bound([targetId],[targetId+1],/*lowerOpen=*/false,/*upperOpen=*/true);var store=documentTargetStore(txn);var result=documentKeySet();return store.iterate({range:range,keysOnly:true},function(key,_,control){var path=decode(key[1]);var docKey=new DocumentKey(path);result=result.add(docKey);}).next(function(){return result;});};IndexedDbQueryCache.prototype.containsKey=function(txn,key){var path=encode(key.path);var range=IDBKeyRange.bound([path],[immediateSuccessor(path)],/*lowerOpen=*/false,/*upperOpen=*/true);var count=0;return documentTargetStore(txn).iterate({index:DbTargetDocument.documentTargetsIndex,keysOnly:true,range:range},function(_a,_,control){var targetId=_a[0],path=_a[1];// Having a sentinel row for a document does not count as containing that document;
// For the query cache, containing the document means the document is part of some
// target.
if(targetId!==0){count++;control.done();}}).next(function(){return count>0;});};IndexedDbQueryCache.prototype.getQueryDataForTarget=function(transaction,targetId){var _this=this;return targetsStore(transaction).get(targetId).next(function(found){if(found){return _this.serializer.fromDbTarget(found);}else{return null;}});};return IndexedDbQueryCache;}();/**
 * Helper to get a typed SimpleDbStore for the queries object store.
 */function targetsStore(txn){return IndexedDbPersistence.getStore(txn,DbTarget.store);}/**
 * Helper to get a typed SimpleDbStore for the target globals object store.
 */function globalTargetStore(txn){return IndexedDbPersistence.getStore(txn,DbTargetGlobal.store);}function retrieveMetadata(txn){var globalStore=SimpleDb.getStore(txn,DbTargetGlobal.store);return globalStore.get(DbTargetGlobal.key).next(function(metadata){assert(metadata!==null,'Missing metadata row.');return metadata;});}function getHighestListenSequenceNumber(txn){return retrieveMetadata(txn).next(function(targetGlobal){return targetGlobal.highestListenSequenceNumber;});}/**
 * Helper to get a typed SimpleDbStore for the document target object store.
 */function documentTargetStore(txn){return IndexedDbPersistence.getStore(txn,DbTargetDocument.store);}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * A map implementation that uses objects as keys. Objects must implement the
 * Equatable interface and must be immutable. Entries in the map are stored
 * together with the key being produced from the mapKeyFn. This map
 * automatically handles collisions of keys.
 */var ObjectMap=/** @class */function(){function ObjectMap(mapKeyFn){this.mapKeyFn=mapKeyFn;/**
         * The inner map for a key -> value pair. Due to the possibility of
         * collisions we keep a list of entries that we do a linear search through
         * to find an actual match. Note that collisions should be rare, so we still
         * expect near constant time lookups in practice.
         */this.inner={};}/** Get a value for this key, or undefined if it does not exist. */ObjectMap.prototype.get=function(key){var id=this.mapKeyFn(key);var matches=this.inner[id];if(matches===undefined){return undefined;}for(var _i=0,matches_1=matches;_i<matches_1.length;_i++){var _a=matches_1[_i],otherKey=_a[0],value=_a[1];if(otherKey.isEqual(key)){return value;}}return undefined;};ObjectMap.prototype.has=function(key){return this.get(key)!==undefined;};/** Put this key and value in the map. */ObjectMap.prototype.set=function(key,value){var id=this.mapKeyFn(key);var matches=this.inner[id];if(matches===undefined){this.inner[id]=[[key,value]];return;}for(var i=0;i<matches.length;i++){if(matches[i][0].isEqual(key)){matches[i]=[key,value];return;}}matches.push([key,value]);};/**
     * Remove this key from the map. Returns a boolean if anything was deleted.
     */ObjectMap.prototype.delete=function(key){var id=this.mapKeyFn(key);var matches=this.inner[id];if(matches===undefined){return false;}for(var i=0;i<matches.length;i++){if(matches[i][0].isEqual(key)){if(matches.length===1){delete this.inner[id];}else{matches.splice(i,1);}return true;}}return false;};ObjectMap.prototype.forEach=function(fn){forEach(this.inner,function(_,entries){for(var _i=0,entries_1=entries;_i<entries_1.length;_i++){var _a=entries_1[_i],k=_a[0],v=_a[1];fn(k,v);}});};ObjectMap.prototype.isEmpty=function(){return isEmpty(this.inner);};return ObjectMap;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * An in-memory buffer of entries to be written to a RemoteDocumentCache.
 * It can be used to batch up a set of changes to be written to the cache, but
 * additionally supports reading entries back with the `getEntry()` method,
 * falling back to the underlying RemoteDocumentCache if no entry is
 * buffered.
 *
 * Entries added to the cache *must* be read first. This is to facilitate
 * calculating the size delta of the pending changes.
 *
 * PORTING NOTE: This class was implemented then removed from other platforms.
 * If byte-counting ends up being needed on the other platforms, consider
 * porting this class as part of that implementation work.
 */var RemoteDocumentChangeBuffer=/** @class */function(){function RemoteDocumentChangeBuffer(){this.changes=maybeDocumentMap();this.documentSizes=new ObjectMap(function(key){return key.toString();});}/** Buffers a `RemoteDocumentCache.addEntry()` call. */RemoteDocumentChangeBuffer.prototype.addEntry=function(maybeDocument){var changes=this.assertChanges();this.changes=changes.insert(maybeDocument.key,maybeDocument);};// NOTE: removeEntry() is intentionally omitted. If it needs to be added in
// the future it must take byte counting into account.
/**
     * Looks up an entry in the cache. The buffered changes will first be checked,
     * and if no buffered change applies, this will forward to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documentKey The key of the entry to look up.
     * @return The cached Document or NoDocument entry, or null if we have nothing
     * cached.
     */RemoteDocumentChangeBuffer.prototype.getEntry=function(transaction,documentKey){var _this=this;var changes=this.assertChanges();var bufferedEntry=changes.get(documentKey);if(bufferedEntry){return PersistencePromise.resolve(bufferedEntry);}else{// Record the size of everything we load from the cache so we can compute a delta later.
return this.getFromCache(transaction,documentKey).next(function(getResult){if(getResult===null){_this.documentSizes.set(documentKey,0);return null;}else{_this.documentSizes.set(documentKey,getResult.size);return getResult.maybeDocument;}});}};/**
     * Looks up several entries in the cache, forwarding to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documentKeys The keys of the entries to look up.
     * @return A map of cached `Document`s or `NoDocument`s, indexed by key. If an
     *     entry cannot be found, the corresponding key will be mapped to a null
     *     value.
     */RemoteDocumentChangeBuffer.prototype.getEntries=function(transaction,documentKeys){var _this=this;// Record the size of everything we load from the cache so we can compute
// a delta later.
return this.getAllFromCache(transaction,documentKeys).next(function(_a){var maybeDocuments=_a.maybeDocuments,sizeMap=_a.sizeMap;// Note: `getAllFromCache` returns two maps instead of a single map from
// keys to `DocumentSizeEntry`s. This is to allow returning the
// `NullableMaybeDocumentMap` directly, without a conversion.
sizeMap.forEach(function(documentKey,size){_this.documentSizes.set(documentKey,size);});return maybeDocuments;});};/**
     * Applies buffered changes to the underlying RemoteDocumentCache, using
     * the provided transaction.
     */RemoteDocumentChangeBuffer.prototype.apply=function(transaction){var result=this.applyChanges(transaction);// We should not buffer any more changes.
this.changes=null;return result;};/** Helper to assert this.changes is not null and return it. */RemoteDocumentChangeBuffer.prototype.assertChanges=function(){assert(this.changes!==null,'Changes have already been applied.');return this.changes;};return RemoteDocumentChangeBuffer;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var REMOTE_DOCUMENT_CHANGE_MISSING_ERR_MSG='The remote document changelog no longer contains all changes for all '+'local query views. It may be necessary to rebuild these views.';var IndexedDbRemoteDocumentCache=/** @class */function(){/**
     * @param {LocalSerializer} serializer The document serializer.
     * @param {IndexManager} indexManager The query indexes that need to be maintained.
     * @param keepDocumentChangeLog Whether to keep a document change log in
     * IndexedDb. This change log is required for Multi-Tab synchronization, but
     * not needed in clients that don't share access to their remote document
     * cache.
     */function IndexedDbRemoteDocumentCache(serializer,indexManager,keepDocumentChangeLog){this.serializer=serializer;this.indexManager=indexManager;this.keepDocumentChangeLog=keepDocumentChangeLog;/** The last id read by `getNewDocumentChanges()`. */this._lastProcessedDocumentChangeId=0;}Object.defineProperty(IndexedDbRemoteDocumentCache.prototype,"lastProcessedDocumentChangeId",{get:function(){return this._lastProcessedDocumentChangeId;},enumerable:true,configurable:true});/**
     * Starts up the remote document cache.
     *
     * Reads the ID of the last  document change from the documentChanges store.
     * Existing changes will not be returned as part of
     * `getNewDocumentChanges()`.
     */// PORTING NOTE: This is only used for multi-tab synchronization.
IndexedDbRemoteDocumentCache.prototype.start=function(transaction){var store=SimpleDb.getStore(transaction,DbRemoteDocumentChanges.store);return this.synchronizeLastDocumentChangeId(store);};/**
     * Adds the supplied entries to the cache. Adds the given size delta to the cached size.
     */IndexedDbRemoteDocumentCache.prototype.addEntries=function(transaction,entries,sizeDelta){var promises=[];if(entries.length>0){var documentStore=remoteDocumentsStore(transaction);var changedKeys=documentKeySet();for(var _i=0,entries_1=entries;_i<entries_1.length;_i++){var _a=entries_1[_i],key=_a.key,doc=_a.doc;promises.push(documentStore.put(dbKey(key),doc));changedKeys=changedKeys.add(key);promises.push(this.indexManager.addToCollectionParentIndex(transaction,key.path.popLast()));}if(this.keepDocumentChangeLog){promises.push(documentChangesStore(transaction).put({changes:this.serializer.toDbResourcePaths(changedKeys)}));}promises.push(this.updateSize(transaction,sizeDelta));}return PersistencePromise.waitFor(promises);};/**
     * Removes a document from the cache. Note that this method does *not* do any
     * size accounting. It is the responsibility of the caller to count the bytes removed
     * and issue a final updateSize() call after removing documents.
     *
     * @param documentKey The key of the document to remove
     * @return The size of the document that was removed.
     */IndexedDbRemoteDocumentCache.prototype.removeEntry=function(transaction,documentKey){// We don't need to keep changelog for these removals since `removeEntry` is
// only used for garbage collection.
var store=remoteDocumentsStore(transaction);var key=dbKey(documentKey);return store.get(key).next(function(document){if(document){return store.delete(key).next(function(){return dbDocumentSize(document);});}else{return PersistencePromise.resolve(0);}});};IndexedDbRemoteDocumentCache.prototype.getEntry=function(transaction,documentKey){var _this=this;return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc){return dbRemoteDoc?_this.serializer.fromDbRemoteDocument(dbRemoteDoc):null;});};/**
     * Looks up an entry in the cache.
     *
     * @param documentKey The key of the entry to look up.
     * @return The cached MaybeDocument entry and its size, or null if we have nothing cached.
     */IndexedDbRemoteDocumentCache.prototype.getSizedEntry=function(transaction,documentKey){var _this=this;return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc){return dbRemoteDoc?{maybeDocument:_this.serializer.fromDbRemoteDocument(dbRemoteDoc),size:dbDocumentSize(dbRemoteDoc)}:null;});};IndexedDbRemoteDocumentCache.prototype.getEntries=function(transaction,documentKeys){var _this=this;var results=nullableMaybeDocumentMap();return this.forEachDbEntry(transaction,documentKeys,function(key,dbRemoteDoc){if(dbRemoteDoc){results=results.insert(key,_this.serializer.fromDbRemoteDocument(dbRemoteDoc));}else{results=results.insert(key,null);}}).next(function(){return results;});};/**
     * Looks up several entries in the cache.
     *
     * @param documentKeys The set of keys entries to look up.
     * @return A map of MaybeDocuments indexed by key (if a document cannot be
     *     found, the key will be mapped to null) and a map of sizes indexed by
     *     key (zero if the key cannot be found).
     */IndexedDbRemoteDocumentCache.prototype.getSizedEntries=function(transaction,documentKeys){var _this=this;var results=nullableMaybeDocumentMap();var sizeMap=new SortedMap(DocumentKey.comparator);return this.forEachDbEntry(transaction,documentKeys,function(key,dbRemoteDoc){if(dbRemoteDoc){results=results.insert(key,_this.serializer.fromDbRemoteDocument(dbRemoteDoc));sizeMap=sizeMap.insert(key,dbDocumentSize(dbRemoteDoc));}else{results=results.insert(key,null);sizeMap=sizeMap.insert(key,0);}}).next(function(){return{maybeDocuments:results,sizeMap:sizeMap};});};IndexedDbRemoteDocumentCache.prototype.forEachDbEntry=function(transaction,documentKeys,callback){if(documentKeys.isEmpty()){return PersistencePromise.resolve();}var range=IDBKeyRange.bound(documentKeys.first().path.toArray(),documentKeys.last().path.toArray());var keyIter=documentKeys.getIterator();var nextKey=keyIter.getNext();return remoteDocumentsStore(transaction).iterate({range:range},function(potentialKeyRaw,dbRemoteDoc,control){var potentialKey=DocumentKey.fromSegments(potentialKeyRaw);// Go through keys not found in cache.
while(nextKey&&DocumentKey.comparator(nextKey,potentialKey)<0){callback(nextKey,null);nextKey=keyIter.getNext();}if(nextKey&&nextKey.isEqual(potentialKey)){// Key found in cache.
callback(nextKey,dbRemoteDoc);nextKey=keyIter.hasNext()?keyIter.getNext():null;}// Skip to the next key (if there is one).
if(nextKey){control.skip(nextKey.path.toArray());}else{control.done();}}).next(function(){// The rest of the keys are not in the cache. One case where `iterate`
// above won't go through them is when the cache is empty.
while(nextKey){callback(nextKey,null);nextKey=keyIter.hasNext()?keyIter.getNext():null;}});};IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery=function(transaction,query){var _this=this;assert(!query.isCollectionGroupQuery(),'CollectionGroup queries should be handled in LocalDocumentsView');var results=documentMap();var immediateChildrenPathLength=query.path.length+1;// Documents are ordered by key, so we can use a prefix scan to narrow down
// the documents we need to match the query against.
var startKey=query.path.toArray();var range=IDBKeyRange.lowerBound(startKey);return remoteDocumentsStore(transaction).iterate({range:range},function(key,dbRemoteDoc,control){// The query is actually returning any path that starts with the query
// path prefix which may include documents in subcollections. For
// example, a query on 'rooms' will return rooms/abc/messages/xyx but we
// shouldn't match it. Fix this by discarding rows with document keys
// more than one segment longer than the query path.
if(key.length!==immediateChildrenPathLength){return;}var maybeDoc=_this.serializer.fromDbRemoteDocument(dbRemoteDoc);if(!query.path.isPrefixOf(maybeDoc.key.path)){control.done();}else if(maybeDoc instanceof Document&&query.matches(maybeDoc)){results=results.insert(maybeDoc.key,maybeDoc);}}).next(function(){return results;});};IndexedDbRemoteDocumentCache.prototype.getNewDocumentChanges=function(transaction){var _this=this;assert(this.keepDocumentChangeLog,'Can only call getNewDocumentChanges() when document change log is enabled');var changedKeys=documentKeySet();var changedDocs=maybeDocumentMap();var range=IDBKeyRange.lowerBound(this._lastProcessedDocumentChangeId+1);var firstIteration=true;var changesStore=documentChangesStore(transaction);return changesStore.iterate({range:range},function(_,documentChange){if(firstIteration){firstIteration=false;// If our client was throttled for more than 30 minutes, another
// client may have garbage collected the remote document changelog.
if(_this._lastProcessedDocumentChangeId+1!==documentChange.id){// Reset the `lastProcessedDocumentChangeId` to allow further
// invocations to successfully return the changes after this
// rejection.
return _this.synchronizeLastDocumentChangeId(changesStore).next(function(){return PersistencePromise.reject(new FirestoreError(Code.DATA_LOSS,REMOTE_DOCUMENT_CHANGE_MISSING_ERR_MSG));});}}changedKeys=changedKeys.unionWith(_this.serializer.fromDbResourcePaths(documentChange.changes));_this._lastProcessedDocumentChangeId=documentChange.id;}).next(function(){var documentPromises=[];changedKeys.forEach(function(key){documentPromises.push(_this.getEntry(transaction,key).next(function(maybeDocument){var doc=maybeDocument||new NoDocument(key,SnapshotVersion.forDeletedDoc());changedDocs=changedDocs.insert(key,doc);}));});return PersistencePromise.waitFor(documentPromises);}).next(function(){return changedDocs;});};/**
     * Removes all changes in the remote document changelog through `changeId`
     * (inclusive).
     */IndexedDbRemoteDocumentCache.prototype.removeDocumentChangesThroughChangeId=function(transaction,changeId){var range=IDBKeyRange.upperBound(changeId);return documentChangesStore(transaction).delete(range);};IndexedDbRemoteDocumentCache.prototype.synchronizeLastDocumentChangeId=function(documentChangesStore){var _this=this;// If there are no existing changes, we set `lastProcessedDocumentChangeId`
// to 0 since IndexedDb's auto-generated keys start at 1.
this._lastProcessedDocumentChangeId=0;return documentChangesStore.iterate({keysOnly:true,reverse:true},function(key,value,control){_this._lastProcessedDocumentChangeId=key;control.done();});};IndexedDbRemoteDocumentCache.prototype.newChangeBuffer=function(){return new IndexedDbRemoteDocumentChangeBuffer(this);};IndexedDbRemoteDocumentCache.prototype.getSize=function(txn){return this.getMetadata(txn).next(function(metadata){return metadata.byteSize;});};IndexedDbRemoteDocumentCache.prototype.getMetadata=function(txn){return documentGlobalStore(txn).get(DbRemoteDocumentGlobal.key).next(function(metadata){assert(!!metadata,'Missing document cache metadata');return metadata;});};IndexedDbRemoteDocumentCache.prototype.setMetadata=function(txn,metadata){return documentGlobalStore(txn).put(DbRemoteDocumentGlobal.key,metadata);};/**
     * Adds the given delta to the cached current size. Callers to removeEntry *must* call this
     * afterwards to update the size of the cache.
     *
     * @param sizeDelta
     */IndexedDbRemoteDocumentCache.prototype.updateSize=function(txn,sizeDelta){var _this=this;return this.getMetadata(txn).next(function(metadata){metadata.byteSize+=sizeDelta;return _this.setMetadata(txn,metadata);});};return IndexedDbRemoteDocumentCache;}();function documentGlobalStore(txn){return IndexedDbPersistence.getStore(txn,DbRemoteDocumentGlobal.store);}/**
 * Handles the details of adding and updating documents in the IndexedDbRemoteDocumentCache
 */var IndexedDbRemoteDocumentChangeBuffer=/** @class */function(_super){tslib_1.__extends(IndexedDbRemoteDocumentChangeBuffer,_super);function IndexedDbRemoteDocumentChangeBuffer(documentCache){var _this=_super.call(this)||this;_this.documentCache=documentCache;return _this;}IndexedDbRemoteDocumentChangeBuffer.prototype.applyChanges=function(transaction){var _this=this;var changes=this.assertChanges();var delta=0;var toApply=[];changes.forEach(function(key,maybeDocument){var doc=_this.documentCache.serializer.toDbRemoteDocument(maybeDocument);var previousSize=_this.documentSizes.get(key);// NOTE: if we ever decide we need to support doing writes without
// reading first, this assert will need to change to do the read automatically.
assert(previousSize!==undefined,"Attempting to change document "+key.toString()+" without having read it first");var size=dbDocumentSize(doc);delta+=size-previousSize;toApply.push({key:key,doc:doc});});return this.documentCache.addEntries(transaction,toApply,delta);};IndexedDbRemoteDocumentChangeBuffer.prototype.getFromCache=function(transaction,documentKey){return this.documentCache.getSizedEntry(transaction,documentKey);};IndexedDbRemoteDocumentChangeBuffer.prototype.getAllFromCache=function(transaction,documentKeys){return this.documentCache.getSizedEntries(transaction,documentKeys);};return IndexedDbRemoteDocumentChangeBuffer;}(RemoteDocumentChangeBuffer);function isDocumentChangeMissingError(err){return err.code===Code.DATA_LOSS&&err.message===REMOTE_DOCUMENT_CHANGE_MISSING_ERR_MSG;}/**
 * Helper to get a typed SimpleDbStore for the remoteDocuments object store.
 */function remoteDocumentsStore(txn){return IndexedDbPersistence.getStore(txn,DbRemoteDocument.store);}/**
 * Helper to get a typed SimpleDbStore for the remoteDocumentChanges object
 * store.
 */function documentChangesStore(txn){return IndexedDbPersistence.getStore(txn,DbRemoteDocumentChanges.store);}function dbKey(docKey){return docKey.path.toArray();}/**
 * Retrusn an approximate size for the given document.
 */function dbDocumentSize(doc){var value;if(doc.document){value=doc.document;}else if(doc.unknownDocument){value=doc.unknownDocument;}else if(doc.noDocument){value=doc.noDocument;}else{throw fail('Unknown remote document type');}return JSON.stringify(value).length;}/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * An in-memory implementation of IndexManager.
 */var MemoryIndexManager=/** @class */function(){function MemoryIndexManager(){this.collectionParentIndex=new MemoryCollectionParentIndex();}MemoryIndexManager.prototype.addToCollectionParentIndex=function(transaction,collectionPath){this.collectionParentIndex.add(collectionPath);return PersistencePromise.resolve();};MemoryIndexManager.prototype.getCollectionParents=function(transaction,collectionId){return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));};return MemoryIndexManager;}();/**
 * Internal implementation of the collection-parent index exposed by MemoryIndexManager.
 * Also used for in-memory caching by IndexedDbIndexManager and initial index population
 * in indexeddb_schema.ts
 */var MemoryCollectionParentIndex=/** @class */function(){function MemoryCollectionParentIndex(){this.index={};}// Returns false if the entry already existed.
MemoryCollectionParentIndex.prototype.add=function(collectionPath){assert(collectionPath.length%2===1,'Expected a collection path.');var collectionId=collectionPath.lastSegment();var parentPath=collectionPath.popLast();var existingParents=this.index[collectionId]||new SortedSet(ResourcePath.comparator);var added=!existingParents.has(parentPath);this.index[collectionId]=existingParents.add(parentPath);return added;};MemoryCollectionParentIndex.prototype.getEntries=function(collectionId){var parentPaths=this.index[collectionId]||new SortedSet(ResourcePath.comparator);return parentPaths.toArray();};return MemoryCollectionParentIndex;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Schema Version for the Web client:
 * 1. Initial version including Mutation Queue, Query Cache, and Remote Document
 *    Cache
 * 2. Used to ensure a targetGlobal object exists and add targetCount to it. No
 *    longer required because migration 3 unconditionally clears it.
 * 3. Dropped and re-created Query Cache to deal with cache corruption related
 *    to limbo resolution. Addresses
 *    https://github.com/firebase/firebase-ios-sdk/issues/1548
 * 4. Multi-Tab Support.
 * 5. Removal of held write acks.
 * 6. Create document global for tracking document cache size.
 * 7. Ensure every cached document has a sentinel row with a sequence number.
 * 8. Add collection-parent index for Collection Group queries.
 */var SCHEMA_VERSION=8;/** Performs database creation and schema upgrades. */var SchemaConverter=/** @class */function(){function SchemaConverter(serializer){this.serializer=serializer;}/**
     * Performs database creation and schema upgrades.
     *
     * Note that in production, this method is only ever used to upgrade the schema
     * to SCHEMA_VERSION. Different values of toVersion are only used for testing
     * and local feature development.
     */SchemaConverter.prototype.createOrUpgrade=function(db,txn,fromVersion,toVersion){var _this=this;assert(fromVersion<toVersion&&fromVersion>=0&&toVersion<=SCHEMA_VERSION,"Unexpected schema upgrade from v"+fromVersion+" to v{toVersion}.");if(fromVersion<1&&toVersion>=1){createPrimaryClientStore(db);createMutationQueue(db);createQueryCache(db);createRemoteDocumentCache(db);}// Migration 2 to populate the targetGlobal object no longer needed since
// migration 3 unconditionally clears it.
var p=PersistencePromise.resolve();if(fromVersion<3&&toVersion>=3){// Brand new clients don't need to drop and recreate--only clients that
// potentially have corrupt data.
if(fromVersion!==0){dropQueryCache(db);createQueryCache(db);}p=p.next(function(){return writeEmptyTargetGlobalEntry(txn);});}if(fromVersion<4&&toVersion>=4){if(fromVersion!==0){// Schema version 3 uses auto-generated keys to generate globally unique
// mutation batch IDs (this was previously ensured internally by the
// client). To migrate to the new schema, we have to read all mutations
// and write them back out. We preserve the existing batch IDs to guarantee
// consistency with other object stores. Any further mutation batch IDs will
// be auto-generated.
p=p.next(function(){return upgradeMutationBatchSchemaAndMigrateData(db,txn);});}p=p.next(function(){createClientMetadataStore(db);createRemoteDocumentChangesStore(db);});}if(fromVersion<5&&toVersion>=5){p=p.next(function(){return _this.removeAcknowledgedMutations(txn);});}if(fromVersion<6&&toVersion>=6){p=p.next(function(){createDocumentGlobalStore(db);return _this.addDocumentGlobal(txn);});}if(fromVersion<7&&toVersion>=7){p=p.next(function(){return _this.ensureSequenceNumbers(txn);});}if(fromVersion<8&&toVersion>=8){p=p.next(function(){return _this.createCollectionParentIndex(db,txn);});}return p;};SchemaConverter.prototype.addDocumentGlobal=function(txn){var byteCount=0;return txn.store(DbRemoteDocument.store).iterate(function(_,doc){byteCount+=dbDocumentSize(doc);}).next(function(){var metadata=new DbRemoteDocumentGlobal(byteCount);return txn.store(DbRemoteDocumentGlobal.store).put(DbRemoteDocumentGlobal.key,metadata);});};SchemaConverter.prototype.removeAcknowledgedMutations=function(txn){var _this=this;var queuesStore=txn.store(DbMutationQueue.store);var mutationsStore=txn.store(DbMutationBatch.store);return queuesStore.loadAll().next(function(queues){return PersistencePromise.forEach(queues,function(queue){var range=IDBKeyRange.bound([queue.userId,BATCHID_UNKNOWN],[queue.userId,queue.lastAcknowledgedBatchId]);return mutationsStore.loadAll(DbMutationBatch.userMutationsIndex,range).next(function(dbBatches){return PersistencePromise.forEach(dbBatches,function(dbBatch){assert(dbBatch.userId===queue.userId,"Cannot process batch "+dbBatch.batchId+" from unexpected user");var batch=_this.serializer.fromDbMutationBatch(dbBatch);return removeMutationBatch(txn,queue.userId,batch).next(function(){});});});});});};/**
     * Ensures that every document in the remote document cache has a corresponding sentinel row
     * with a sequence number. Missing rows are given the most recently used sequence number.
     */SchemaConverter.prototype.ensureSequenceNumbers=function(txn){var documentTargetStore=txn.store(DbTargetDocument.store);var documentsStore=txn.store(DbRemoteDocument.store);return getHighestListenSequenceNumber(txn).next(function(currentSequenceNumber){var writeSentinelKey=function(path){return documentTargetStore.put(new DbTargetDocument(0,encode(path),currentSequenceNumber));};var promises=[];return documentsStore.iterate(function(key,doc){var path=new ResourcePath(key);var docSentinelKey=sentinelKey(path);promises.push(documentTargetStore.get(docSentinelKey).next(function(maybeSentinel){if(!maybeSentinel){return writeSentinelKey(path);}else{return PersistencePromise.resolve();}}));}).next(function(){return PersistencePromise.waitFor(promises);});});};SchemaConverter.prototype.createCollectionParentIndex=function(db,txn){// Create the index.
db.createObjectStore(DbCollectionParent.store,{keyPath:DbCollectionParent.keyPath});var collectionParentsStore=txn.store(DbCollectionParent.store);// Helper to add an index entry iff we haven't already written it.
var cache=new MemoryCollectionParentIndex();var addEntry=function(collectionPath){if(cache.add(collectionPath)){var collectionId=collectionPath.lastSegment();var parentPath=collectionPath.popLast();return collectionParentsStore.put({collectionId:collectionId,parent:encode(parentPath)});}};// Index existing remote documents.
return txn.store(DbRemoteDocument.store).iterate({keysOnly:true},function(pathSegments,_){var path=new ResourcePath(pathSegments);return addEntry(path.popLast());}).next(function(){// Index existing mutations.
return txn.store(DbDocumentMutation.store).iterate({keysOnly:true},function(_a,_){var userID=_a[0],encodedPath=_a[1],batchId=_a[2];var path=decode(encodedPath);return addEntry(path.popLast());});});};return SchemaConverter;}();function sentinelKey(path){return[0,encode(path)];}/**
 * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.
 */var DbTimestamp=/** @class */function(){function DbTimestamp(seconds,nanoseconds){this.seconds=seconds;this.nanoseconds=nanoseconds;}return DbTimestamp;}();/**
 * A singleton object to be stored in the 'owner' store in IndexedDb.
 *
 * A given database can have a single primary tab assigned at a given time. That
 * tab must validate that it is still holding the primary lease before every
 * operation that requires locked access. The primary tab should regularly
 * write an updated timestamp to this lease to prevent other tabs from
 * "stealing" the primary lease
 */var DbPrimaryClient=/** @class */function(){function DbPrimaryClient(ownerId,/** Whether to allow shared access from multiple tabs. */allowTabSynchronization,leaseTimestampMs){this.ownerId=ownerId;this.allowTabSynchronization=allowTabSynchronization;this.leaseTimestampMs=leaseTimestampMs;}/**
     * Name of the IndexedDb object store.
     *
     * Note that the name 'owner' is chosen to ensure backwards compatibility with
     * older clients that only supported single locked access to the persistence
     * layer.
     */DbPrimaryClient.store='owner';/**
     * The key string used for the single object that exists in the
     * DbPrimaryClient store.
     */DbPrimaryClient.key='owner';return DbPrimaryClient;}();function createPrimaryClientStore(db){db.createObjectStore(DbPrimaryClient.store);}/**
 * An object to be stored in the 'mutationQueues' store in IndexedDb.
 *
 * Each user gets a single queue of MutationBatches to apply to the server.
 * DbMutationQueue tracks the metadata about the queue.
 */var DbMutationQueue=/** @class */function(){function DbMutationQueue(/**
     * The normalized user ID to which this queue belongs.
     */userId,/**
     * An identifier for the highest numbered batch that has been acknowledged
     * by the server. All MutationBatches in this queue with batchIds less
     * than or equal to this value are considered to have been acknowledged by
     * the server.
     *
     * NOTE: this is deprecated and no longer used by the code.
     */lastAcknowledgedBatchId,/**
     * A stream token that was previously sent by the server.
     *
     * See StreamingWriteRequest in datastore.proto for more details about
     * usage.
     *
     * After sending this token, earlier tokens may not be used anymore so
     * only a single stream token is retained.
     */lastStreamToken){this.userId=userId;this.lastAcknowledgedBatchId=lastAcknowledgedBatchId;this.lastStreamToken=lastStreamToken;}/** Name of the IndexedDb object store.  */DbMutationQueue.store='mutationQueues';/** Keys are automatically assigned via the userId property. */DbMutationQueue.keyPath='userId';return DbMutationQueue;}();/**
 * An object to be stored in the 'mutations' store in IndexedDb.
 *
 * Represents a batch of user-level mutations intended to be sent to the server
 * in a single write. Each user-level batch gets a separate DbMutationBatch
 * with a new batchId.
 */var DbMutationBatch=/** @class */function(){function DbMutationBatch(/**
     * The normalized user ID to which this batch belongs.
     */userId,/**
     * An identifier for this batch, allocated using an auto-generated key.
     */batchId,/**
     * The local write time of the batch, stored as milliseconds since the
     * epoch.
     */localWriteTimeMs,/**
     * A list of "mutations" that represent a partial base state from when this
     * write batch was initially created. During local application of the write
     * batch, these baseMutations are applied prior to the real writes in order
     * to override certain document fields from the remote document cache. This
     * is necessary in the case of non-idempotent writes (e.g. `increment()`
     * transforms) to make sure that the local view of the modified documents
     * doesn't flicker if the remote document cache receives the result of the
     * non-idempotent write before the write is removed from the queue.
     *
     * These mutations are never sent to the backend.
     */baseMutations,/**
     * A list of mutations to apply. All mutations will be applied atomically.
     *
     * Mutations are serialized via JsonProtoSerializer.toMutation().
     */mutations){this.userId=userId;this.batchId=batchId;this.localWriteTimeMs=localWriteTimeMs;this.baseMutations=baseMutations;this.mutations=mutations;}/** Name of the IndexedDb object store.  */DbMutationBatch.store='mutations';/** Keys are automatically assigned via the userId, batchId properties. */DbMutationBatch.keyPath='batchId';/** The index name for lookup of mutations by user. */DbMutationBatch.userMutationsIndex='userMutationsIndex';/** The user mutations index is keyed by [userId, batchId] pairs. */DbMutationBatch.userMutationsKeyPath=['userId','batchId'];return DbMutationBatch;}();function createMutationQueue(db){db.createObjectStore(DbMutationQueue.store,{keyPath:DbMutationQueue.keyPath});var mutationBatchesStore=db.createObjectStore(DbMutationBatch.store,{keyPath:DbMutationBatch.keyPath,autoIncrement:true});mutationBatchesStore.createIndex(DbMutationBatch.userMutationsIndex,DbMutationBatch.userMutationsKeyPath,{unique:true});db.createObjectStore(DbDocumentMutation.store);}/**
 * Upgrade function to migrate the 'mutations' store from V1 to V3. Loads
 * and rewrites all data.
 */function upgradeMutationBatchSchemaAndMigrateData(db,txn){var v1MutationsStore=txn.store(DbMutationBatch.store);return v1MutationsStore.loadAll().next(function(existingMutations){db.deleteObjectStore(DbMutationBatch.store);var mutationsStore=db.createObjectStore(DbMutationBatch.store,{keyPath:DbMutationBatch.keyPath,autoIncrement:true});mutationsStore.createIndex(DbMutationBatch.userMutationsIndex,DbMutationBatch.userMutationsKeyPath,{unique:true});var v3MutationsStore=txn.store(DbMutationBatch.store);var writeAll=existingMutations.map(function(mutation){return v3MutationsStore.put(mutation);});return PersistencePromise.waitFor(writeAll);});}/**
 * An object to be stored in the 'documentMutations' store in IndexedDb.
 *
 * A manually maintained index of all the mutation batches that affect a given
 * document key. The rows in this table are references based on the contents of
 * DbMutationBatch.mutations.
 */var DbDocumentMutation=/** @class */function(){function DbDocumentMutation(){}/**
     * Creates a [userId] key for use in the DbDocumentMutations index to iterate
     * over all of a user's document mutations.
     */DbDocumentMutation.prefixForUser=function(userId){return[userId];};/**
     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations
     * index to iterate over all at document mutations for a given path or lower.
     */DbDocumentMutation.prefixForPath=function(userId,path){return[userId,encode(path)];};/**
     * Creates a full index key of [userId, encodedPath, batchId] for inserting
     * and deleting into the DbDocumentMutations index.
     */DbDocumentMutation.key=function(userId,path,batchId){return[userId,encode(path),batchId];};DbDocumentMutation.store='documentMutations';/**
     * Because we store all the useful information for this store in the key,
     * there is no useful information to store as the value. The raw (unencoded)
     * path cannot be stored because IndexedDb doesn't store prototype
     * information.
     */DbDocumentMutation.PLACEHOLDER=new DbDocumentMutation();return DbDocumentMutation;}();function createRemoteDocumentCache(db){db.createObjectStore(DbRemoteDocument.store);}/**
 * Represents the known absence of a document at a particular version.
 * Stored in IndexedDb as part of a DbRemoteDocument object.
 */var DbNoDocument=/** @class */function(){function DbNoDocument(path,readTime){this.path=path;this.readTime=readTime;}return DbNoDocument;}();/**
 * Represents a document that is known to exist but whose data is unknown.
 * Stored in IndexedDb as part of a DbRemoteDocument object.
 */var DbUnknownDocument=/** @class */function(){function DbUnknownDocument(path,version){this.path=path;this.version=version;}return DbUnknownDocument;}();/**
 * An object to be stored in the 'remoteDocuments' store in IndexedDb.
 * It represents either:
 *
 * - A complete document.
 * - A "no document" representing a document that is known not to exist (at
 * some version).
 * - An "unknown document" representing a document that is known to exist (at
 * some version) but whose contents are unknown.
 *
 * Note: This is the persisted equivalent of a MaybeDocument and could perhaps
 * be made more general if necessary.
 */var DbRemoteDocument=/** @class */function(){function DbRemoteDocument(/**
     * Set to an instance of DbUnknownDocument if the data for a document is
     * not known, but it is known that a document exists at the specified
     * version (e.g. it had a successful update applied to it)
     */unknownDocument,/**
     * Set to an instance of a DbNoDocument if it is known that no document
     * exists.
     */noDocument,/**
     * Set to an instance of a Document if there's a cached version of the
     * document.
     */document,/**
     * Documents that were written to the remote document store based on
     * a write acknowledgment are marked with `hasCommittedMutations`. These
     * documents are potentially inconsistent with the backend's copy and use
     * the write's commit version as their document version.
     */hasCommittedMutations){this.unknownDocument=unknownDocument;this.noDocument=noDocument;this.document=document;this.hasCommittedMutations=hasCommittedMutations;}DbRemoteDocument.store='remoteDocuments';return DbRemoteDocument;}();/**
 * Contains a single entry that has metadata about the remote document cache.
 */var DbRemoteDocumentGlobal=/** @class */function(){/**
     * @param byteSize Approximately the total size in bytes of all the documents in the document
     * cache.
     */function DbRemoteDocumentGlobal(byteSize){this.byteSize=byteSize;}DbRemoteDocumentGlobal.store='remoteDocumentGlobal';DbRemoteDocumentGlobal.key='remoteDocumentGlobalKey';return DbRemoteDocumentGlobal;}();function createDocumentGlobalStore(db){db.createObjectStore(DbRemoteDocumentGlobal.store);}/**
 * An object to be stored in the 'targets' store in IndexedDb.
 *
 * This is based on and should be kept in sync with the proto used in the iOS
 * client.
 *
 * Each query the client listens to against the server is tracked on disk so
 * that the query can be efficiently resumed on restart.
 */var DbTarget=/** @class */function(){function DbTarget(/**
     * An auto-generated sequential numeric identifier for the query.
     *
     * Queries are stored using their canonicalId as the key, but these
     * canonicalIds can be quite long so we additionally assign a unique
     * queryId which can be used by referenced data structures (e.g.
     * indexes) to minimize the on-disk cost.
     */targetId,/**
     * The canonical string representing this query. This is not unique.
     */canonicalId,/**
     * The last readTime received from the Watch Service for this query.
     *
     * This is the same value as TargetChange.read_time in the protos.
     */readTime,/**
     * An opaque, server-assigned token that allows watching a query to be
     * resumed after disconnecting without retransmitting all the data
     * that matches the query. The resume token essentially identifies a
     * point in time from which the server should resume sending results.
     *
     * This is related to the snapshotVersion in that the resumeToken
     * effectively also encodes that value, but the resumeToken is opaque
     * and sometimes encodes additional information.
     *
     * A consequence of this is that the resumeToken should be used when
     * asking the server to reason about where this client is in the watch
     * stream, but the client should use the snapshotVersion for its own
     * purposes.
     *
     * This is the same value as TargetChange.resume_token in the protos.
     */resumeToken,/**
     * A sequence number representing the last time this query was
     * listened to, used for garbage collection purposes.
     *
     * Conventionally this would be a timestamp value, but device-local
     * clocks are unreliable and they must be able to create new listens
     * even while disconnected. Instead this should be a monotonically
     * increasing number that's incremented on each listen call.
     *
     * This is different from the queryId since the queryId is an
     * immutable identifier assigned to the Query on first use while
     * lastListenSequenceNumber is updated every time the query is
     * listened to.
     */lastListenSequenceNumber,/**
     * The query for this target.
     *
     * Because canonical ids are not unique we must store the actual query. We
     * use the proto to have an object we can persist without having to
     * duplicate translation logic to and from a `Query` object.
     */query){this.targetId=targetId;this.canonicalId=canonicalId;this.readTime=readTime;this.resumeToken=resumeToken;this.lastListenSequenceNumber=lastListenSequenceNumber;this.query=query;}DbTarget.store='targets';/** Keys are automatically assigned via the targetId property. */DbTarget.keyPath='targetId';/** The name of the queryTargets index. */DbTarget.queryTargetsIndexName='queryTargetsIndex';/**
     * The index of all canonicalIds to the targets that they match. This is not
     * a unique mapping because canonicalId does not promise a unique name for all
     * possible queries, so we append the targetId to make the mapping unique.
     */DbTarget.queryTargetsKeyPath=['canonicalId','targetId'];return DbTarget;}();/**
 * An object representing an association between a target and a document, or a
 * sentinel row marking the last sequence number at which a document was used.
 * Each document cached must have a corresponding sentinel row before lru
 * garbage collection is enabled.
 *
 * The target associations and sentinel rows are co-located so that orphaned
 * documents and their sequence numbers can be identified efficiently via a scan
 * of this store.
 */var DbTargetDocument=/** @class */function(){function DbTargetDocument(/**
     * The targetId identifying a target or 0 for a sentinel row.
     */targetId,/**
     * The path to the document, as encoded in the key.
     */path,/**
     * If this is a sentinel row, this should be the sequence number of the last
     * time the document specified by `path` was used. Otherwise, it should be
     * `undefined`.
     */sequenceNumber){this.targetId=targetId;this.path=path;this.sequenceNumber=sequenceNumber;assert(targetId===0===(sequenceNumber!==undefined),// tslint:disable-next-line:max-line-length
'A target-document row must either have targetId == 0 and a defined sequence number, or a non-zero targetId and no sequence number');}/** Name of the IndexedDb object store.  */DbTargetDocument.store='targetDocuments';/** Keys are automatically assigned via the targetId, path properties. */DbTargetDocument.keyPath=['targetId','path'];/** The index name for the reverse index. */DbTargetDocument.documentTargetsIndex='documentTargetsIndex';/** We also need to create the reverse index for these properties. */DbTargetDocument.documentTargetsKeyPath=['path','targetId'];return DbTargetDocument;}();/**
 * A record of global state tracked across all Targets, tracked separately
 * to avoid the need for extra indexes.
 *
 * This should be kept in-sync with the proto used in the iOS client.
 */var DbTargetGlobal=/** @class */function(){function DbTargetGlobal(/**
     * The highest numbered target id across all targets.
     *
     * See DbTarget.targetId.
     */highestTargetId,/**
     * The highest numbered lastListenSequenceNumber across all targets.
     *
     * See DbTarget.lastListenSequenceNumber.
     */highestListenSequenceNumber,/**
     * A global snapshot version representing the last consistent snapshot we
     * received from the backend. This is monotonically increasing and any
     * snapshots received from the backend prior to this version (e.g. for
     * targets resumed with a resumeToken) should be suppressed (buffered)
     * until the backend has caught up to this snapshot version again. This
     * prevents our cache from ever going backwards in time.
     */lastRemoteSnapshotVersion,/**
     * The number of targets persisted.
     */targetCount){this.highestTargetId=highestTargetId;this.highestListenSequenceNumber=highestListenSequenceNumber;this.lastRemoteSnapshotVersion=lastRemoteSnapshotVersion;this.targetCount=targetCount;}/**
     * The key string used for the single object that exists in the
     * DbTargetGlobal store.
     */DbTargetGlobal.key='targetGlobalKey';DbTargetGlobal.store='targetGlobal';return DbTargetGlobal;}();/**
 * An object representing an association between a Collection id (e.g. 'messages')
 * to a parent path (e.g. '/chats/123') that contains it as a (sub)collection.
 * This is used to efficiently find all collections to query when performing
 * a Collection Group query.
 */var DbCollectionParent=/** @class */function(){function DbCollectionParent(/**
     * The collectionId (e.g. 'messages')
     */collectionId,/**
     * The path to the parent (either a document location or an empty path for
     * a root-level collection).
     */parent){this.collectionId=collectionId;this.parent=parent;}/** Name of the IndexedDb object store. */DbCollectionParent.store='collectionParents';/** Keys are automatically assigned via the collectionId, parent properties. */DbCollectionParent.keyPath=['collectionId','parent'];return DbCollectionParent;}();function createQueryCache(db){var targetDocumentsStore=db.createObjectStore(DbTargetDocument.store,{keyPath:DbTargetDocument.keyPath});targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex,DbTargetDocument.documentTargetsKeyPath,{unique:true});var targetStore=db.createObjectStore(DbTarget.store,{keyPath:DbTarget.keyPath});// NOTE: This is unique only because the TargetId is the suffix.
targetStore.createIndex(DbTarget.queryTargetsIndexName,DbTarget.queryTargetsKeyPath,{unique:true});db.createObjectStore(DbTargetGlobal.store);}function dropQueryCache(db){db.deleteObjectStore(DbTargetDocument.store);db.deleteObjectStore(DbTarget.store);db.deleteObjectStore(DbTargetGlobal.store);}/**
 * Creates the target global singleton row.
 *
 * @param {IDBTransaction} txn The version upgrade transaction for indexeddb
 */function writeEmptyTargetGlobalEntry(txn){var globalStore=txn.store(DbTargetGlobal.store);var metadata=new DbTargetGlobal(/*highestTargetId=*/0,/*lastListenSequenceNumber=*/0,SnapshotVersion.MIN.toTimestamp(),/*targetCount=*/0);return globalStore.put(DbTargetGlobal.key,metadata);}/**
 * An object store to store the keys of changed documents. This is used to
 * facilitate storing document changelogs in the Remote Document Cache.
 *
 * PORTING NOTE: This is used for change propagation during multi-tab syncing
 * and not needed on iOS and Android.
 */var DbRemoteDocumentChanges=/** @class */function(){function DbRemoteDocumentChanges(/** The keys of the changed documents. */changes){this.changes=changes;}/** Name of the IndexedDb object store.  */DbRemoteDocumentChanges.store='remoteDocumentChanges';/** Keys are auto-generated via the `id` property. */DbRemoteDocumentChanges.keyPath='id';return DbRemoteDocumentChanges;}();function createRemoteDocumentChangesStore(db){db.createObjectStore(DbRemoteDocumentChanges.store,{keyPath:'id',autoIncrement:true});}/**
 * A record of the metadata state of each client.
 *
 * PORTING NOTE: This is used to synchronize multi-tab state and does not need
 * to be ported to iOS or Android.
 */var DbClientMetadata=/** @class */function(){function DbClientMetadata(/** The auto-generated client id assigned at client startup. */clientId,/** The last time this state was updated. */updateTimeMs,/** Whether the client's network connection is enabled. */networkEnabled,/** Whether this client is running in a foreground tab. */inForeground,/**
     * The last change read from the DbRemoteDocumentChanges store.
     * Can be undefined for backwards compatibility.
     */lastProcessedDocumentChangeId){this.clientId=clientId;this.updateTimeMs=updateTimeMs;this.networkEnabled=networkEnabled;this.inForeground=inForeground;this.lastProcessedDocumentChangeId=lastProcessedDocumentChangeId;}/** Name of the IndexedDb object store. */DbClientMetadata.store='clientMetadata';/** Keys are automatically assigned via the clientId properties. */DbClientMetadata.keyPath='clientId';return DbClientMetadata;}();function createClientMetadataStore(db){db.createObjectStore(DbClientMetadata.store,{keyPath:DbClientMetadata.keyPath});}// Visible for testing
var V1_STORES=[DbMutationQueue.store,DbMutationBatch.store,DbDocumentMutation.store,DbRemoteDocument.store,DbTarget.store,DbPrimaryClient.store,DbTargetGlobal.store,DbTargetDocument.store];// V2 is no longer usable (see comment at top of file)
// Visible for testing
var V3_STORES=V1_STORES;// Visible for testing
var V4_STORES=V3_STORES.concat([DbClientMetadata.store,DbRemoteDocumentChanges.store]);// V5 does not change the set of stores.
var V6_STORES=V4_STORES.concat([DbRemoteDocumentGlobal.store]);// V7 does not change the set of stores.
var V8_STORES=V6_STORES.concat([DbCollectionParent.store]);/**
 * The list of all default IndexedDB stores used throughout the SDK. This is
 * used when creating transactions so that access across all stores is done
 * atomically.
 */var ALL_STORES=V8_STORES;/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * A persisted implementation of IndexManager.
 */var IndexedDbIndexManager=/** @class */function(){function IndexedDbIndexManager(){/**
         * An in-memory copy of the index entries we've already written since the SDK
         * launched. Used to avoid re-writing the same entry repeatedly.
         *
         * This is *NOT* a complete cache of what's in persistence and so can never be used to
         * satisfy reads.
         */this.collectionParentsCache=new MemoryCollectionParentIndex();}IndexedDbIndexManager.prototype.addToCollectionParentIndex=function(transaction,collectionPath){assert(collectionPath.length%2===1,'Expected a collection path.');if(this.collectionParentsCache.add(collectionPath)){assert(collectionPath.length>=1,'Invalid collection path.');var collectionId=collectionPath.lastSegment();var parentPath=collectionPath.popLast();return collectionParentsStore(transaction).put({collectionId:collectionId,parent:encode(parentPath)});}return PersistencePromise.resolve();};IndexedDbIndexManager.prototype.getCollectionParents=function(transaction,collectionId){var parentPaths=[];var range=IDBKeyRange.bound([collectionId,''],[immediateSuccessor(collectionId),''],/*lowerOpen=*/false,/*upperOpen=*/true);return collectionParentsStore(transaction).loadAll(range).next(function(entries){for(var _i=0,entries_1=entries;_i<entries_1.length;_i++){var entry=entries_1[_i];// This collectionId guard shouldn't be necessary (and isn't as long
// as we're running in a real browser), but there's a bug in
// indexeddbshim that breaks our range in our tests running in node:
// https://github.com/axemclion/IndexedDBShim/issues/334
if(entry.collectionId!==collectionId){break;}parentPaths.push(decode(entry.parent));}return parentPaths;});};return IndexedDbIndexManager;}();/**
 * Helper to get a typed SimpleDbStore for the collectionParents
 * document store.
 */function collectionParentsStore(txn){return IndexedDbPersistence.getStore(txn,DbCollectionParent.store);}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//** Serializer for values stored in the LocalStore. */var LocalSerializer=/** @class */function(){function LocalSerializer(remoteSerializer){this.remoteSerializer=remoteSerializer;}/** Decodes a remote document from storage locally to a Document. */LocalSerializer.prototype.fromDbRemoteDocument=function(remoteDoc){if(remoteDoc.document){return this.remoteSerializer.fromDocument(remoteDoc.document,!!remoteDoc.hasCommittedMutations);}else if(remoteDoc.noDocument){var key=DocumentKey.fromSegments(remoteDoc.noDocument.path);var version=this.fromDbTimestamp(remoteDoc.noDocument.readTime);return new NoDocument(key,version,{hasCommittedMutations:!!remoteDoc.hasCommittedMutations});}else if(remoteDoc.unknownDocument){var key=DocumentKey.fromSegments(remoteDoc.unknownDocument.path);var version=this.fromDbTimestamp(remoteDoc.unknownDocument.version);return new UnknownDocument(key,version);}else{return fail('Unexpected DbRemoteDocument');}};/** Encodes a document for storage locally. */LocalSerializer.prototype.toDbRemoteDocument=function(maybeDoc){if(maybeDoc instanceof Document){var doc=maybeDoc.proto?maybeDoc.proto:this.remoteSerializer.toDocument(maybeDoc);var hasCommittedMutations=maybeDoc.hasCommittedMutations;return new DbRemoteDocument(/* unknownDocument= */null,/* noDocument= */null,doc,hasCommittedMutations);}else if(maybeDoc instanceof NoDocument){var path=maybeDoc.key.path.toArray();var readTime=this.toDbTimestamp(maybeDoc.version);var hasCommittedMutations=maybeDoc.hasCommittedMutations;return new DbRemoteDocument(/* unknownDocument= */null,new DbNoDocument(path,readTime),/* document= */null,hasCommittedMutations);}else if(maybeDoc instanceof UnknownDocument){var path=maybeDoc.key.path.toArray();var readTime=this.toDbTimestamp(maybeDoc.version);return new DbRemoteDocument(new DbUnknownDocument(path,readTime),/* noDocument= */null,/* document= */null,/* hasCommittedMutations= */true);}else{return fail('Unexpected MaybeDocumment');}};LocalSerializer.prototype.toDbTimestamp=function(snapshotVersion){var timestamp=snapshotVersion.toTimestamp();return new DbTimestamp(timestamp.seconds,timestamp.nanoseconds);};LocalSerializer.prototype.fromDbTimestamp=function(dbTimestamp){var timestamp=new Timestamp(dbTimestamp.seconds,dbTimestamp.nanoseconds);return SnapshotVersion.fromTimestamp(timestamp);};/** Encodes a batch of mutations into a DbMutationBatch for local storage. */LocalSerializer.prototype.toDbMutationBatch=function(userId,batch){var _this=this;var serializedBaseMutations=batch.baseMutations.map(function(m){return _this.remoteSerializer.toMutation(m);});var serializedMutations=batch.mutations.map(function(m){return _this.remoteSerializer.toMutation(m);});return new DbMutationBatch(userId,batch.batchId,batch.localWriteTime.toMillis(),serializedBaseMutations,serializedMutations);};/** Decodes a DbMutationBatch into a MutationBatch */LocalSerializer.prototype.fromDbMutationBatch=function(dbBatch){var _this=this;var baseMutations=(dbBatch.baseMutations||[]).map(function(m){return _this.remoteSerializer.fromMutation(m);});var mutations=dbBatch.mutations.map(function(m){return _this.remoteSerializer.fromMutation(m);});var timestamp=Timestamp.fromMillis(dbBatch.localWriteTimeMs);return new MutationBatch(dbBatch.batchId,timestamp,baseMutations,mutations);};/*
     * Encodes a set of document keys into an array of EncodedResourcePaths.
     */LocalSerializer.prototype.toDbResourcePaths=function(keys){var encodedKeys=[];keys.forEach(function(key){encodedKeys.push(encode(key.path));});return encodedKeys;};/** Decodes an array of EncodedResourcePaths into a set of document keys. */LocalSerializer.prototype.fromDbResourcePaths=function(encodedPaths){var keys=documentKeySet();for(var _i=0,encodedPaths_1=encodedPaths;_i<encodedPaths_1.length;_i++){var documentKey=encodedPaths_1[_i];keys=keys.add(new DocumentKey(decode(documentKey)));}return keys;};/** Decodes a DbTarget into QueryData */LocalSerializer.prototype.fromDbTarget=function(dbTarget){var version=this.fromDbTimestamp(dbTarget.readTime);var query;if(isDocumentQuery(dbTarget.query)){query=this.remoteSerializer.fromDocumentsTarget(dbTarget.query);}else{query=this.remoteSerializer.fromQueryTarget(dbTarget.query);}return new QueryData(query,dbTarget.targetId,QueryPurpose.Listen,dbTarget.lastListenSequenceNumber,version,dbTarget.resumeToken);};/** Encodes QueryData into a DbTarget for storage locally. */LocalSerializer.prototype.toDbTarget=function(queryData){assert(QueryPurpose.Listen===queryData.purpose,'Only queries with purpose '+QueryPurpose.Listen+' may be stored, got '+queryData.purpose);var dbTimestamp=this.toDbTimestamp(queryData.snapshotVersion);var queryProto;if(queryData.query.isDocumentQuery()){queryProto=this.remoteSerializer.toDocumentsTarget(queryData.query);}else{queryProto=this.remoteSerializer.toQueryTarget(queryData.query);}var resumeToken;if(queryData.resumeToken instanceof Uint8Array){// TODO(b/78771403): Convert tokens to strings during deserialization
assert(process.env.USE_MOCK_PERSISTENCE==='YES','Persisting non-string stream tokens is only supported with mock persistence .');resumeToken=queryData.resumeToken.toString();}else{resumeToken=queryData.resumeToken;}// lastListenSequenceNumber is always 0 until we do real GC.
return new DbTarget(queryData.targetId,queryData.query.canonicalId(),dbTimestamp,resumeToken,queryData.sequenceNumber,queryProto);};return LocalSerializer;}();/**
 * A helper function for figuring out what kind of query has been stored.
 */function isDocumentQuery(dbQuery){return dbQuery.documents!==undefined;}/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function bufferEntryComparator(_a,_b){var aSequence=_a[0],aIndex=_a[1];var bSequence=_b[0],bIndex=_b[1];var seqCmp=primitiveComparator(aSequence,bSequence);if(seqCmp===0){// This order doesn't matter, but we can bias against churn by sorting
// entries created earlier as less than newer entries.
return primitiveComparator(aIndex,bIndex);}else{return seqCmp;}}/**
 * Used to calculate the nth sequence number. Keeps a rolling buffer of the
 * lowest n values passed to `addElement`, and finally reports the largest of
 * them in `maxValue`.
 */var RollingSequenceNumberBuffer=/** @class */function(){function RollingSequenceNumberBuffer(maxElements){this.maxElements=maxElements;this.buffer=new SortedSet(bufferEntryComparator);this.previousIndex=0;}RollingSequenceNumberBuffer.prototype.nextIndex=function(){return++this.previousIndex;};RollingSequenceNumberBuffer.prototype.addElement=function(sequenceNumber){var entry=[sequenceNumber,this.nextIndex()];if(this.buffer.size<this.maxElements){this.buffer=this.buffer.add(entry);}else{var highestValue=this.buffer.last();if(bufferEntryComparator(entry,highestValue)<0){this.buffer=this.buffer.delete(highestValue).add(entry);}}};Object.defineProperty(RollingSequenceNumberBuffer.prototype,"maxValue",{get:function(){// Guaranteed to be non-empty. If we decide we are not collecting any
// sequence numbers, nthSequenceNumber below short-circuits. If we have
// decided that we are collecting n sequence numbers, it's because n is some
// percentage of the existing sequence numbers. That means we should never
// be in a situation where we are collecting sequence numbers but don't
// actually have any.
return this.buffer.last()[0];},enumerable:true,configurable:true});return RollingSequenceNumberBuffer;}();var GC_DID_NOT_RUN={didRun:false,sequenceNumbersCollected:0,targetsRemoved:0,documentsRemoved:0};var LruParams=/** @class */function(){function LruParams(// When we attempt to collect, we will only do so if the cache size is greater than this
// threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.
cacheSizeCollectionThreshold,// The percentage of sequence numbers that we will attempt to collect
percentileToCollect,// A cap on the total number of sequence numbers that will be collected. This prevents
// us from collecting a huge number of sequence numbers if the cache has grown very large.
maximumSequenceNumbersToCollect){this.cacheSizeCollectionThreshold=cacheSizeCollectionThreshold;this.percentileToCollect=percentileToCollect;this.maximumSequenceNumbersToCollect=maximumSequenceNumbersToCollect;}LruParams.withCacheSize=function(cacheSize){return new LruParams(cacheSize,LruParams.DEFAULT_COLLECTION_PERCENTILE,LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);};LruParams.COLLECTION_DISABLED=-1;LruParams.MINIMUM_CACHE_SIZE_BYTES=1*1024*1024;LruParams.DEFAULT_CACHE_SIZE_BYTES=40*1024*1024;LruParams.DEFAULT_COLLECTION_PERCENTILE=10;LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1000;LruParams.DEFAULT=new LruParams(LruParams.DEFAULT_CACHE_SIZE_BYTES,LruParams.DEFAULT_COLLECTION_PERCENTILE,LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);LruParams.DISABLED=new LruParams(LruParams.COLLECTION_DISABLED,0,0);return LruParams;}();/** How long we wait to try running LRU GC after SDK initialization. */var INITIAL_GC_DELAY_MS=1*60*1000;/** Minimum amount of time between GC checks, after the first one. */var REGULAR_GC_DELAY_MS=5*60*1000;/**
 * This class is responsible for the scheduling of LRU garbage collection. It handles checking
 * whether or not GC is enabled, as well as which delay to use before the next run.
 */var LruScheduler=/** @class */function(){function LruScheduler(garbageCollector,asyncQueue,localStore){this.garbageCollector=garbageCollector;this.asyncQueue=asyncQueue;this.localStore=localStore;this.gcTask=null;}LruScheduler.prototype.start=function(){assert(this.gcTask===null,'Cannot start an already started LruScheduler');if(this.garbageCollector.params.cacheSizeCollectionThreshold!==LruParams.COLLECTION_DISABLED){this.scheduleGC();}};LruScheduler.prototype.stop=function(){if(this.gcTask){this.gcTask.cancel();this.gcTask=null;}};Object.defineProperty(LruScheduler.prototype,"started",{get:function(){return this.gcTask!==null;},enumerable:true,configurable:true});LruScheduler.prototype.scheduleGC=function(){var _this=this;assert(this.gcTask===null,'Cannot schedule GC while a task is pending');var delay=this.hasRun?REGULAR_GC_DELAY_MS:INITIAL_GC_DELAY_MS;debug('LruGarbageCollector',"Garbage collection scheduled in "+delay+"ms");this.gcTask=this.asyncQueue.enqueueAfterDelay(TimerId.LruGarbageCollection,delay,function(){_this.gcTask=null;_this.hasRun=true;return _this.localStore.collectGarbage(_this.garbageCollector).then(function(){return _this.scheduleGC();}).catch(ignoreIfPrimaryLeaseLoss);});};return LruScheduler;}();/** Implements the steps for LRU garbage collection. */var LruGarbageCollector=/** @class */function(){function LruGarbageCollector(delegate,params){this.delegate=delegate;this.params=params;}/** Given a percentile of target to collect, returns the number of targets to collect. */LruGarbageCollector.prototype.calculateTargetCount=function(txn,percentile){return this.delegate.getSequenceNumberCount(txn).next(function(targetCount){return Math.floor(percentile/100.0*targetCount);});};/** Returns the nth sequence number, counting in order from the smallest. */LruGarbageCollector.prototype.nthSequenceNumber=function(txn,n){var _this=this;if(n===0){return PersistencePromise.resolve(ListenSequence.INVALID);}var buffer=new RollingSequenceNumberBuffer(n);return this.delegate.forEachTarget(txn,function(target){return buffer.addElement(target.sequenceNumber);}).next(function(){return _this.delegate.forEachOrphanedDocumentSequenceNumber(txn,function(sequenceNumber){return buffer.addElement(sequenceNumber);});}).next(function(){return buffer.maxValue;});};/**
     * Removes targets with a sequence number equal to or less than the given upper bound, and removes
     * document associations with those targets.
     */LruGarbageCollector.prototype.removeTargets=function(txn,upperBound,activeTargetIds){return this.delegate.removeTargets(txn,upperBound,activeTargetIds);};/**
     * Removes documents that have a sequence number equal to or less than the upper bound and are not
     * otherwise pinned.
     */LruGarbageCollector.prototype.removeOrphanedDocuments=function(txn,upperBound){return this.delegate.removeOrphanedDocuments(txn,upperBound);};LruGarbageCollector.prototype.collect=function(txn,activeTargetIds){var _this=this;if(this.params.cacheSizeCollectionThreshold===LruParams.COLLECTION_DISABLED){debug('LruGarbageCollector','Garbage collection skipped; disabled');return PersistencePromise.resolve(GC_DID_NOT_RUN);}return this.getCacheSize(txn).next(function(cacheSize){if(cacheSize<_this.params.cacheSizeCollectionThreshold){debug('LruGarbageCollector',"Garbage collection skipped; Cache size "+cacheSize+" "+("is lower than threshold "+_this.params.cacheSizeCollectionThreshold));return GC_DID_NOT_RUN;}else{return _this.runGarbageCollection(txn,activeTargetIds);}});};LruGarbageCollector.prototype.getCacheSize=function(txn){return this.delegate.getCacheSize(txn);};LruGarbageCollector.prototype.runGarbageCollection=function(txn,activeTargetIds){var _this=this;var upperBoundSequenceNumber;var sequenceNumbersToCollect,targetsRemoved;// Timestamps for various pieces of the process
var startTs,countedTargetsTs,foundUpperBoundTs,removedTargetsTs,removedDocumentsTs;startTs=Date.now();return this.calculateTargetCount(txn,this.params.percentileToCollect).next(function(sequenceNumbers){// Cap at the configured max
if(sequenceNumbers>_this.params.maximumSequenceNumbersToCollect){debug('LruGarbageCollector','Capping sequence numbers to collect down '+("to the maximum of "+_this.params.maximumSequenceNumbersToCollect+" ")+("from "+sequenceNumbers));sequenceNumbersToCollect=_this.params.maximumSequenceNumbersToCollect;}else{sequenceNumbersToCollect=sequenceNumbers;}countedTargetsTs=Date.now();return _this.nthSequenceNumber(txn,sequenceNumbersToCollect);}).next(function(upperBound){upperBoundSequenceNumber=upperBound;foundUpperBoundTs=Date.now();return _this.removeTargets(txn,upperBoundSequenceNumber,activeTargetIds);}).next(function(numTargetsRemoved){targetsRemoved=numTargetsRemoved;removedTargetsTs=Date.now();return _this.removeOrphanedDocuments(txn,upperBoundSequenceNumber);}).next(function(documentsRemoved){removedDocumentsTs=Date.now();if(getLogLevel()<=LogLevel.DEBUG){var desc='LRU Garbage Collection\n'+("\tCounted targets in "+(countedTargetsTs-startTs)+"ms\n")+("\tDetermined least recently used "+sequenceNumbersToCollect+" in ")+(foundUpperBoundTs-countedTargetsTs+"ms\n")+("\tRemoved "+targetsRemoved+" targets in ")+(removedTargetsTs-foundUpperBoundTs+"ms\n")+("\tRemoved "+documentsRemoved+" documents in ")+(removedDocumentsTs-removedTargetsTs+"ms\n")+("Total Duration: "+(removedDocumentsTs-startTs)+"ms");debug('LruGarbageCollector',desc);}return PersistencePromise.resolve({didRun:true,sequenceNumbersCollected:sequenceNumbersToCollect,targetsRemoved:targetsRemoved,documentsRemoved:documentsRemoved});});};return LruGarbageCollector;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Opaque interface representing a persistence transaction.
 *
 * When you call Persistence.runTransaction(), it will create a transaction and
 * pass it to your callback. You then pass it to any method that operates
 * on persistence.
 */var PersistenceTransaction=/** @class */function(){function PersistenceTransaction(){}return PersistenceTransaction;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$2='IndexedDbPersistence';/**
 * Oldest acceptable age in milliseconds for client metadata before the client
 * is considered inactive and its associated data (such as the remote document
 * cache changelog) is garbage collected.
 */var MAX_CLIENT_AGE_MS=30*60*1000;// 30 minutes
/**
 * Oldest acceptable metadata age for clients that may participate in the
 * primary lease election. Clients that have not updated their client metadata
 * within 5 seconds are not eligible to receive a primary lease.
 */var MAX_PRIMARY_ELIGIBLE_AGE_MS=5000;/**
 * The interval at which clients will update their metadata, including
 * refreshing their primary lease if held or potentially trying to acquire it if
 * not held.
 *
 * Primary clients may opportunistically refresh their metadata earlier
 * if they're already performing an IndexedDB operation.
 */var CLIENT_METADATA_REFRESH_INTERVAL_MS=4000;/** User-facing error when the primary lease is required but not available. */var PRIMARY_LEASE_LOST_ERROR_MSG='The current tab is not in the required state to perform this operation. '+'It might be necessary to refresh the browser tab.';var PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG='Another tab has exclusive access to the persistence layer. '+'To allow shared access, make sure to invoke '+'`enablePersistence()` with `experimentalTabSynchronization:true` in all tabs.';var UNSUPPORTED_PLATFORM_ERROR_MSG='This platform is either missing'+' IndexedDB or is known to have an incomplete implementation. Offline'+' persistence has been disabled.';// The format of the LocalStorage key that stores zombied client is:
//     firestore_zombie_<persistence_prefix>_<instance_key>
var ZOMBIED_CLIENTS_KEY_PREFIX='firestore_zombie';var IndexedDbTransaction=/** @class */function(_super){tslib_1.__extends(IndexedDbTransaction,_super);function IndexedDbTransaction(simpleDbTransaction,currentSequenceNumber){var _this=_super.call(this)||this;_this.simpleDbTransaction=simpleDbTransaction;_this.currentSequenceNumber=currentSequenceNumber;return _this;}return IndexedDbTransaction;}(PersistenceTransaction);var IndexedDbPersistence=/** @class */function(){// Note that `multiClientParams` must be present to enable multi-client support while multi-tab
// is still experimental. When multi-client is switched to always on, `multiClientParams` will
// no longer be optional.
function IndexedDbPersistence(persistenceKey,clientId,platform,queue,serializer,lruParams,multiClientParams){this.persistenceKey=persistenceKey;this.clientId=clientId;this.queue=queue;this.multiClientParams=multiClientParams;this._started=false;this.isPrimary=false;this.networkEnabled=true;this.inForeground=false;/** The last time we garbage collected the Remote Document Changelog. */this.lastGarbageCollectionTime=Number.NEGATIVE_INFINITY;/** A listener to notify on primary state changes. */this.primaryStateListener=function(_){return Promise.resolve();};if(!IndexedDbPersistence.isAvailable()){throw new FirestoreError(Code.UNIMPLEMENTED,UNSUPPORTED_PLATFORM_ERROR_MSG);}this.referenceDelegate=new IndexedDbLruDelegate(this,lruParams);this.dbName=persistenceKey+IndexedDbPersistence.MAIN_DATABASE;this.serializer=new LocalSerializer(serializer);this.document=platform.document;this.allowTabSynchronization=multiClientParams!==undefined;this.queryCache=new IndexedDbQueryCache(this.referenceDelegate,this.serializer);this.indexManager=new IndexedDbIndexManager();this.remoteDocumentCache=new IndexedDbRemoteDocumentCache(this.serializer,this.indexManager,/*keepDocumentChangeLog=*/this.allowTabSynchronization);if(platform.window&&platform.window.localStorage){this.window=platform.window;this.webStorage=this.window.localStorage;}else{throw new FirestoreError(Code.UNIMPLEMENTED,'IndexedDB persistence is only available on platforms that support LocalStorage.');}}IndexedDbPersistence.getStore=function(txn,store){if(txn instanceof IndexedDbTransaction){return SimpleDb.getStore(txn.simpleDbTransaction,store);}else{throw fail('IndexedDbPersistence must use instances of IndexedDbTransaction');}};IndexedDbPersistence.createIndexedDbPersistence=function(persistenceKey,clientId,platform,queue,serializer,lruParams){return tslib_1.__awaiter(this,void 0,void 0,function(){var persistence;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:persistence=new IndexedDbPersistence(persistenceKey,clientId,platform,queue,serializer,lruParams);return[4/*yield*/,persistence.start()];case 1:_a.sent();return[2/*return*/,persistence];}});});};IndexedDbPersistence.createMultiClientIndexedDbPersistence=function(persistenceKey,clientId,platform,queue,serializer,lruParams,multiClientParams){return tslib_1.__awaiter(this,void 0,void 0,function(){var persistence;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:persistence=new IndexedDbPersistence(persistenceKey,clientId,platform,queue,serializer,lruParams,multiClientParams);return[4/*yield*/,persistence.start()];case 1:_a.sent();return[2/*return*/,persistence];}});});};/**
     * Attempt to start IndexedDb persistence.
     *
     * @return {Promise<void>} Whether persistence was enabled.
     */IndexedDbPersistence.prototype.start=function(){var _this=this;assert(!this.started,'IndexedDbPersistence double-started!');assert(this.window!==null,"Expected 'window' to be defined");return SimpleDb.openOrCreate(this.dbName,SCHEMA_VERSION,new SchemaConverter(this.serializer)).then(function(db){_this.simpleDb=db;// NOTE: This is expected to fail sometimes (in the case of another tab already
// having the persistence lock), so it's the first thing we should do.
return _this.updateClientMetadataAndTryBecomePrimary();}).then(function(){_this.attachVisibilityHandler();_this.attachWindowUnloadHook();_this.scheduleClientMetadataAndPrimaryLeaseRefreshes();return _this.startRemoteDocumentCache();}).then(function(){return _this.simpleDb.runTransaction('readonly',[DbTargetGlobal.store],function(txn){return getHighestListenSequenceNumber(txn).next(function(highestListenSequenceNumber){var sequenceNumberSyncer=_this.multiClientParams?_this.multiClientParams.sequenceNumberSyncer:undefined;_this.listenSequence=new ListenSequence(highestListenSequenceNumber,sequenceNumberSyncer);});});}).then(function(){_this._started=true;}).catch(function(reason){_this.simpleDb&&_this.simpleDb.close();return Promise.reject(reason);});};IndexedDbPersistence.prototype.startRemoteDocumentCache=function(){var _this=this;return this.simpleDb.runTransaction('readonly',ALL_STORES,function(txn){return _this.remoteDocumentCache.start(txn);});};IndexedDbPersistence.prototype.setPrimaryStateListener=function(primaryStateListener){var _this=this;this.primaryStateListener=function(primaryState){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){if(this.started){return[2/*return*/,primaryStateListener(primaryState)];}return[2/*return*/];});});};return primaryStateListener(this.isPrimary);};IndexedDbPersistence.prototype.setNetworkEnabled=function(networkEnabled){var _this=this;if(this.networkEnabled!==networkEnabled){this.networkEnabled=networkEnabled;// Schedule a primary lease refresh for immediate execution. The eventual
// lease update will be propagated via `primaryStateListener`.
this.queue.enqueueAndForget(function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(!this.started)return[3/*break*/,2];return[4/*yield*/,this.updateClientMetadataAndTryBecomePrimary()];case 1:_a.sent();_a.label=2;case 2:return[2/*return*/];}});});});}};/**
     * Updates the client metadata in IndexedDb and attempts to either obtain or
     * extend the primary lease for the local client. Asynchronously notifies the
     * primary state listener if the client either newly obtained or released its
     * primary lease.
     */IndexedDbPersistence.prototype.updateClientMetadataAndTryBecomePrimary=function(){var _this=this;return this.simpleDb.runTransaction('readwrite',ALL_STORES,function(txn){var metadataStore=clientMetadataStore(txn);return metadataStore.put(new DbClientMetadata(_this.clientId,Date.now(),_this.networkEnabled,_this.inForeground,_this.remoteDocumentCache.lastProcessedDocumentChangeId)).next(function(){if(_this.isPrimary){return _this.verifyPrimaryLease(txn).next(function(success){if(!success){_this.isPrimary=false;_this.queue.enqueueAndForget(function(){return _this.primaryStateListener(false);});}});}}).next(function(){return _this.canActAsPrimary(txn);}).next(function(canActAsPrimary){var wasPrimary=_this.isPrimary;_this.isPrimary=canActAsPrimary;if(wasPrimary!==_this.isPrimary){_this.queue.enqueueAndForget(function(){return _this.primaryStateListener(_this.isPrimary);});}if(wasPrimary&&!_this.isPrimary){return _this.releasePrimaryLeaseIfHeld(txn);}else if(_this.isPrimary){return _this.acquireOrExtendPrimaryLease(txn);}});});};IndexedDbPersistence.prototype.verifyPrimaryLease=function(txn){var _this=this;var store=primaryClientStore(txn);return store.get(DbPrimaryClient.key).next(function(primaryClient){return PersistencePromise.resolve(_this.isLocalClient(primaryClient));});};IndexedDbPersistence.prototype.removeClientMetadata=function(txn){var metadataStore=clientMetadataStore(txn);return metadataStore.delete(this.clientId);};/**
     * If the garbage collection threshold has passed, prunes the
     * RemoteDocumentChanges and the ClientMetadata store based on the last update
     * time of all clients.
     */IndexedDbPersistence.prototype.maybeGarbageCollectMultiClientState=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){var activeClients_1,inactiveClients_1;var _this=this;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(!(this.isPrimary&&!this.isWithinAge(this.lastGarbageCollectionTime,MAX_CLIENT_AGE_MS)))return[3/*break*/,2];this.lastGarbageCollectionTime=Date.now();inactiveClients_1=[];return[4/*yield*/,this.runTransaction('maybeGarbageCollectMultiClientState','readwrite-primary',function(txn){var metadataStore=IndexedDbPersistence.getStore(txn,DbClientMetadata.store);return metadataStore.loadAll().next(function(existingClients){activeClients_1=_this.filterActiveClients(existingClients,MAX_CLIENT_AGE_MS);inactiveClients_1=existingClients.filter(function(client){return activeClients_1.indexOf(client)===-1;});}).next(function(){// Delete metadata for clients that are no longer considered active.
return PersistencePromise.forEach(inactiveClients_1,function(inactiveClient){return metadataStore.delete(inactiveClient.clientId);});}).next(function(){// Retrieve the minimum change ID from the set of active clients.
// The primary client doesn't read from the document change log,
// and hence we exclude it when we determine the minimum
// `lastProcessedDocumentChangeId`.
activeClients_1=activeClients_1.filter(function(client){return client.clientId!==_this.clientId;});if(activeClients_1.length>0){var processedChangeIds=activeClients_1.map(function(client){return client.lastProcessedDocumentChangeId||0;});var oldestChangeId=Math.min.apply(Math,processedChangeIds);return _this.remoteDocumentCache.removeDocumentChangesThroughChangeId(txn,oldestChangeId);}});})];case 1:_a.sent();// Delete potential leftover entries that may continue to mark the
// inactive clients as zombied in LocalStorage.
// Ideally we'd delete the IndexedDb and LocalStorage zombie entries for
// the client atomically, but we can't. So we opt to delete the IndexedDb
// entries first to avoid potentially reviving a zombied client.
inactiveClients_1.forEach(function(inactiveClient){_this.window.localStorage.removeItem(_this.zombiedClientLocalStorageKey(inactiveClient.clientId));});_a.label=2;case 2:return[2/*return*/];}});});};/**
     * Schedules a recurring timer to update the client metadata and to either
     * extend or acquire the primary lease if the client is eligible.
     */IndexedDbPersistence.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes=function(){var _this=this;this.clientMetadataRefresher=this.queue.enqueueAfterDelay(TimerId.ClientMetadataRefresh,CLIENT_METADATA_REFRESH_INTERVAL_MS,function(){return _this.updateClientMetadataAndTryBecomePrimary().then(function(){return _this.maybeGarbageCollectMultiClientState();}).then(function(){return _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();});});};/** Checks whether `client` is the local client. */IndexedDbPersistence.prototype.isLocalClient=function(client){return client?client.ownerId===this.clientId:false;};/**
     * Evaluate the state of all active clients and determine whether the local
     * client is or can act as the holder of the primary lease. Returns whether
     * the client is eligible for the lease, but does not actually acquire it.
     * May return 'false' even if there is no active leaseholder and another
     * (foreground) client should become leaseholder instead.
     */IndexedDbPersistence.prototype.canActAsPrimary=function(txn){var _this=this;var store=primaryClientStore(txn);return store.get(DbPrimaryClient.key).next(function(currentPrimary){var currentLeaseIsValid=currentPrimary!==null&&_this.isWithinAge(currentPrimary.leaseTimestampMs,MAX_PRIMARY_ELIGIBLE_AGE_MS)&&!_this.isClientZombied(currentPrimary.ownerId);// A client is eligible for the primary lease if:
// - its network is enabled and the client's tab is in the foreground.
// - its network is enabled and no other client's tab is in the
//   foreground.
// - every clients network is disabled and the client's tab is in the
//   foreground.
// - every clients network is disabled and no other client's tab is in
//   the foreground.
if(currentLeaseIsValid){if(_this.isLocalClient(currentPrimary)&&_this.networkEnabled){return true;}if(!_this.isLocalClient(currentPrimary)){if(!currentPrimary.allowTabSynchronization){// Fail the `canActAsPrimary` check if the current leaseholder has
// not opted into multi-tab synchronization. If this happens at
// client startup, we reject the Promise returned by
// `enablePersistence()` and the user can continue to use Firestore
// with in-memory persistence.
// If this fails during a lease refresh, we will instead block the
// AsyncQueue from executing further operations. Note that this is
// acceptable since mixing & matching different `synchronizeTabs`
// settings is not supported.
//
// TODO(b/114226234): Remove this check when `synchronizeTabs` can
// no longer be turned off.
throw new FirestoreError(Code.FAILED_PRECONDITION,PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);}return false;}}if(_this.networkEnabled&&_this.inForeground){return true;}return clientMetadataStore(txn).loadAll().next(function(existingClients){// Process all existing clients and determine whether at least one of
// them is better suited to obtain the primary lease.
var preferredCandidate=_this.filterActiveClients(existingClients,MAX_PRIMARY_ELIGIBLE_AGE_MS).find(function(otherClient){if(_this.clientId!==otherClient.clientId){var otherClientHasBetterNetworkState=!_this.networkEnabled&&otherClient.networkEnabled;var otherClientHasBetterVisibility=!_this.inForeground&&otherClient.inForeground;var otherClientHasSameNetworkState=_this.networkEnabled===otherClient.networkEnabled;if(otherClientHasBetterNetworkState||otherClientHasBetterVisibility&&otherClientHasSameNetworkState){return true;}}return false;});return preferredCandidate===undefined;});}).next(function(canActAsPrimary){if(_this.isPrimary!==canActAsPrimary){debug(LOG_TAG$2,"Client "+(canActAsPrimary?'is':'is not')+" eligible for a primary lease.");}return canActAsPrimary;});};IndexedDbPersistence.prototype.shutdown=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){var _this=this;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:// The shutdown() operations are idempotent and can be called even when
// start() aborted (e.g. because it couldn't acquire the persistence lease).
this._started=false;this.markClientZombied();if(this.clientMetadataRefresher){this.clientMetadataRefresher.cancel();}this.detachVisibilityHandler();this.detachWindowUnloadHook();return[4/*yield*/,this.simpleDb.runTransaction('readwrite',[DbPrimaryClient.store,DbClientMetadata.store],function(txn){return _this.releasePrimaryLeaseIfHeld(txn).next(function(){return _this.removeClientMetadata(txn);});})];case 1:_a.sent();this.simpleDb.close();// Remove the entry marking the client as zombied from LocalStorage since
// we successfully deleted its metadata from IndexedDb.
this.removeClientZombiedEntry();return[2/*return*/];}});});};/**
     * Returns clients that are not zombied and have an updateTime within the
     * provided threshold.
     */IndexedDbPersistence.prototype.filterActiveClients=function(clients,activityThresholdMs){var _this=this;return clients.filter(function(client){return _this.isWithinAge(client.updateTimeMs,activityThresholdMs)&&!_this.isClientZombied(client.clientId);});};IndexedDbPersistence.prototype.getActiveClients=function(){var _this=this;return this.simpleDb.runTransaction('readonly',[DbClientMetadata.store],function(txn){return clientMetadataStore(txn).loadAll().next(function(clients){return _this.filterActiveClients(clients,MAX_CLIENT_AGE_MS).map(function(clientMetadata){return clientMetadata.clientId;});});});};IndexedDbPersistence.clearPersistence=function(persistenceKey){return tslib_1.__awaiter(this,void 0,void 0,function(){var dbName;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(!IndexedDbPersistence.isAvailable()){return[2/*return*/,Promise.resolve()];}dbName=persistenceKey+IndexedDbPersistence.MAIN_DATABASE;return[4/*yield*/,SimpleDb.delete(dbName)];case 1:_a.sent();return[2/*return*/];}});});};Object.defineProperty(IndexedDbPersistence.prototype,"started",{get:function(){return this._started;},enumerable:true,configurable:true});IndexedDbPersistence.prototype.getMutationQueue=function(user){assert(this.started,'Cannot initialize MutationQueue before persistence is started.');return IndexedDbMutationQueue.forUser(user,this.serializer,this.indexManager,this.referenceDelegate);};IndexedDbPersistence.prototype.getQueryCache=function(){assert(this.started,'Cannot initialize QueryCache before persistence is started.');return this.queryCache;};IndexedDbPersistence.prototype.getRemoteDocumentCache=function(){assert(this.started,'Cannot initialize RemoteDocumentCache before persistence is started.');return this.remoteDocumentCache;};IndexedDbPersistence.prototype.getIndexManager=function(){assert(this.started,'Cannot initialize IndexManager before persistence is started.');return this.indexManager;};IndexedDbPersistence.prototype.runTransaction=function(action,mode,transactionOperation){var _this=this;debug(LOG_TAG$2,'Starting transaction:',action);// Do all transactions as readwrite against all object stores, since we
// are the only reader/writer.
return this.simpleDb.runTransaction(mode==='readonly'?'readonly':'readwrite',ALL_STORES,function(simpleDbTxn){if(mode==='readwrite-primary'){// While we merely verify that we have (or can acquire) the lease
// immediately, we wait to extend the primary lease until after
// executing transactionOperation(). This ensures that even if the
// transactionOperation takes a long time, we'll use a recent
// leaseTimestampMs in the extended (or newly acquired) lease.
return _this.verifyPrimaryLease(simpleDbTxn).next(function(success){if(!success){error("Failed to obtain primary lease for action '"+action+"'.");_this.isPrimary=false;_this.queue.enqueueAndForget(function(){return _this.primaryStateListener(false);});throw new FirestoreError(Code.FAILED_PRECONDITION,PRIMARY_LEASE_LOST_ERROR_MSG);}return transactionOperation(new IndexedDbTransaction(simpleDbTxn,_this.listenSequence.next()));}).next(function(result){return _this.acquireOrExtendPrimaryLease(simpleDbTxn).next(function(){return result;});});}else{return _this.verifyAllowTabSynchronization(simpleDbTxn).next(function(){return transactionOperation(new IndexedDbTransaction(simpleDbTxn,_this.listenSequence.next()));});}});};/**
     * Verifies that the current tab is the primary leaseholder or alternatively
     * that the leaseholder has opted into multi-tab synchronization.
     */// TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer
// be turned off.
IndexedDbPersistence.prototype.verifyAllowTabSynchronization=function(txn){var _this=this;var store=primaryClientStore(txn);return store.get(DbPrimaryClient.key).next(function(currentPrimary){var currentLeaseIsValid=currentPrimary!==null&&_this.isWithinAge(currentPrimary.leaseTimestampMs,MAX_PRIMARY_ELIGIBLE_AGE_MS)&&!_this.isClientZombied(currentPrimary.ownerId);if(currentLeaseIsValid&&!_this.isLocalClient(currentPrimary)){if(!currentPrimary.allowTabSynchronization){throw new FirestoreError(Code.FAILED_PRECONDITION,PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);}}});};/**
     * Obtains or extends the new primary lease for the local client. This
     * method does not verify that the client is eligible for this lease.
     */IndexedDbPersistence.prototype.acquireOrExtendPrimaryLease=function(txn){var newPrimary=new DbPrimaryClient(this.clientId,this.allowTabSynchronization,Date.now());return primaryClientStore(txn).put(DbPrimaryClient.key,newPrimary);};IndexedDbPersistence.isAvailable=function(){return SimpleDb.isAvailable();};/**
     * Generates a string used as a prefix when storing data in IndexedDB and
     * LocalStorage.
     */IndexedDbPersistence.buildStoragePrefix=function(databaseInfo){// Use two different prefix formats:
//
//   * firestore / persistenceKey / projectID . databaseID / ...
//   * firestore / persistenceKey / projectID / ...
//
// projectIDs are DNS-compatible names and cannot contain dots
// so there's no danger of collisions.
var database=databaseInfo.databaseId.projectId;if(!databaseInfo.databaseId.isDefaultDatabase){database+='.'+databaseInfo.databaseId.database;}return'firestore/'+databaseInfo.persistenceKey+'/'+database+'/';};/** Checks the primary lease and removes it if we are the current primary. */IndexedDbPersistence.prototype.releasePrimaryLeaseIfHeld=function(txn){var _this=this;var store=primaryClientStore(txn);return store.get(DbPrimaryClient.key).next(function(primaryClient){if(_this.isLocalClient(primaryClient)){debug(LOG_TAG$2,'Releasing primary lease.');return store.delete(DbPrimaryClient.key);}else{return PersistencePromise.resolve();}});};/** Verifies that `updateTimeMs` is within `maxAgeMs`. */IndexedDbPersistence.prototype.isWithinAge=function(updateTimeMs,maxAgeMs){var now=Date.now();var minAcceptable=now-maxAgeMs;var maxAcceptable=now;if(updateTimeMs<minAcceptable){return false;}else if(updateTimeMs>maxAcceptable){error("Detected an update time that is in the future: "+updateTimeMs+" > "+maxAcceptable);return false;}return true;};IndexedDbPersistence.prototype.attachVisibilityHandler=function(){var _this=this;if(this.document!==null&&typeof this.document.addEventListener==='function'){this.documentVisibilityHandler=function(){_this.queue.enqueueAndForget(function(){_this.inForeground=_this.document.visibilityState==='visible';return _this.updateClientMetadataAndTryBecomePrimary();});};this.document.addEventListener('visibilitychange',this.documentVisibilityHandler);this.inForeground=this.document.visibilityState==='visible';}};IndexedDbPersistence.prototype.detachVisibilityHandler=function(){if(this.documentVisibilityHandler){assert(this.document!==null&&typeof this.document.addEventListener==='function',"Expected 'document.addEventListener' to be a function");this.document.removeEventListener('visibilitychange',this.documentVisibilityHandler);this.documentVisibilityHandler=null;}};/**
     * Attaches a window.unload handler that will synchronously write our
     * clientId to a "zombie client id" location in LocalStorage. This can be used
     * by tabs trying to acquire the primary lease to determine that the lease
     * is no longer valid even if the timestamp is recent. This is particularly
     * important for the refresh case (so the tab correctly re-acquires the
     * primary lease). LocalStorage is used for this rather than IndexedDb because
     * it is a synchronous API and so can be used reliably from  an unload
     * handler.
     */IndexedDbPersistence.prototype.attachWindowUnloadHook=function(){var _this=this;if(typeof this.window.addEventListener==='function'){this.windowUnloadHandler=function(){// Note: In theory, this should be scheduled on the AsyncQueue since it
// accesses internal state. We execute this code directly during shutdown
// to make sure it gets a chance to run.
_this.markClientZombied();_this.queue.enqueueAndForget(function(){// Attempt graceful shutdown (including releasing our primary lease),
// but there's no guarantee it will complete.
return _this.shutdown();});};this.window.addEventListener('unload',this.windowUnloadHandler);}};IndexedDbPersistence.prototype.detachWindowUnloadHook=function(){if(this.windowUnloadHandler){assert(typeof this.window.removeEventListener==='function',"Expected 'window.removeEventListener' to be a function");this.window.removeEventListener('unload',this.windowUnloadHandler);this.windowUnloadHandler=null;}};/**
     * Returns whether a client is "zombied" based on its LocalStorage entry.
     * Clients become zombied when their tab closes without running all of the
     * cleanup logic in `shutdown()`.
     */IndexedDbPersistence.prototype.isClientZombied=function(clientId){try{var isZombied=this.webStorage.getItem(this.zombiedClientLocalStorageKey(clientId))!==null;debug(LOG_TAG$2,"Client '"+clientId+"' "+(isZombied?'is':'is not')+" zombied in LocalStorage");return isZombied;}catch(e){// Gracefully handle if LocalStorage isn't working.
error(LOG_TAG$2,'Failed to get zombied client id.',e);return false;}};/**
     * Record client as zombied (a client that had its tab closed). Zombied
     * clients are ignored during primary tab selection.
     */IndexedDbPersistence.prototype.markClientZombied=function(){try{this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId),String(Date.now()));}catch(e){// Gracefully handle if LocalStorage isn't available / working.
error('Failed to set zombie client id.',e);}};/** Removes the zombied client entry if it exists. */IndexedDbPersistence.prototype.removeClientZombiedEntry=function(){try{this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));}catch(e){// Ignore
}};IndexedDbPersistence.prototype.zombiedClientLocalStorageKey=function(clientId){return ZOMBIED_CLIENTS_KEY_PREFIX+"_"+this.persistenceKey+"_"+clientId;};/**
     * The name of the main (and currently only) IndexedDB database. this name is
     * appended to the prefix provided to the IndexedDbPersistence constructor.
     */IndexedDbPersistence.MAIN_DATABASE='main';return IndexedDbPersistence;}();function isPrimaryLeaseLostError(err){return err.code===Code.FAILED_PRECONDITION&&err.message===PRIMARY_LEASE_LOST_ERROR_MSG;}/**
 * Verifies the error thrown by a LocalStore operation. If a LocalStore
 * operation fails because the primary lease has been taken by another client,
 * we ignore the error (the persistence layer will immediately call
 * `applyPrimaryLease` to propagate the primary state change). All other errors
 * are re-thrown.
 *
 * @param err An error returned by a LocalStore operation.
 * @return A Promise that resolves after we recovered, or the original error.
 */function ignoreIfPrimaryLeaseLoss(err){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){if(isPrimaryLeaseLostError(err)){debug(LOG_TAG$2,'Unexpectedly lost primary lease');}else{throw err;}return[2/*return*/];});});}/**
 * Helper to get a typed SimpleDbStore for the primary client object store.
 */function primaryClientStore(txn){return txn.store(DbPrimaryClient.store);}/**
 * Helper to get a typed SimpleDbStore for the client metadata object store.
 */function clientMetadataStore(txn){return txn.store(DbClientMetadata.store);}/** Provides LRU functionality for IndexedDB persistence. */var IndexedDbLruDelegate=/** @class */function(){function IndexedDbLruDelegate(db,params){this.db=db;this.garbageCollector=new LruGarbageCollector(this,params);}IndexedDbLruDelegate.prototype.getSequenceNumberCount=function(txn){var docCountPromise=this.orphanedDocmentCount(txn);var targetCountPromise=this.db.getQueryCache().getQueryCount(txn);return targetCountPromise.next(function(targetCount){return docCountPromise.next(function(docCount){return targetCount+docCount;});});};IndexedDbLruDelegate.prototype.orphanedDocmentCount=function(txn){var orphanedCount=0;return this.forEachOrphanedDocumentSequenceNumber(txn,function(_){orphanedCount++;}).next(function(){return orphanedCount;});};IndexedDbLruDelegate.prototype.forEachTarget=function(txn,f){return this.db.getQueryCache().forEachTarget(txn,f);};IndexedDbLruDelegate.prototype.forEachOrphanedDocumentSequenceNumber=function(txn,f){return this.forEachOrphanedDocument(txn,function(docKey,sequenceNumber){return f(sequenceNumber);});};IndexedDbLruDelegate.prototype.setInMemoryPins=function(inMemoryPins){this.inMemoryPins=inMemoryPins;};IndexedDbLruDelegate.prototype.addReference=function(txn,key){return writeSentinelKey(txn,key);};IndexedDbLruDelegate.prototype.removeReference=function(txn,key){return writeSentinelKey(txn,key);};IndexedDbLruDelegate.prototype.removeTargets=function(txn,upperBound,activeTargetIds){return this.db.getQueryCache().removeTargets(txn,upperBound,activeTargetIds);};IndexedDbLruDelegate.prototype.removeMutationReference=function(txn,key){return writeSentinelKey(txn,key);};/**
     * Returns true if anything would prevent this document from being garbage
     * collected, given that the document in question is not present in any
     * targets and has a sequence number less than or equal to the upper bound for
     * the collection run.
     */IndexedDbLruDelegate.prototype.isPinned=function(txn,docKey){if(this.inMemoryPins.containsKey(docKey)){return PersistencePromise.resolve(true);}else{return mutationQueuesContainKey(txn,docKey);}};IndexedDbLruDelegate.prototype.removeOrphanedDocuments=function(txn,upperBound){var _this=this;var count=0;var bytesRemoved=0;var promises=[];var iteration=this.forEachOrphanedDocument(txn,function(docKey,sequenceNumber){if(sequenceNumber<=upperBound){var p=_this.isPinned(txn,docKey).next(function(isPinned){if(!isPinned){count++;return _this.removeOrphanedDocument(txn,docKey).next(function(documentBytes){bytesRemoved+=documentBytes;});}});promises.push(p);}});// Wait for iteration first to make sure we have a chance to add all of the
// removal promises to the array.
return iteration.next(function(){return PersistencePromise.waitFor(promises);}).next(function(){return _this.db.getRemoteDocumentCache().updateSize(txn,-bytesRemoved);}).next(function(){return count;});};/**
     * Clears a document from the cache. The document is assumed to be orphaned, so target-document
     * associations are not queried. We remove it from the remote document cache, as well as remove
     * its sentinel row.
     */IndexedDbLruDelegate.prototype.removeOrphanedDocument=function(txn,docKey){var totalBytesRemoved=0;var documentCache=this.db.getRemoteDocumentCache();return PersistencePromise.waitFor([documentTargetStore(txn).delete(sentinelKey$1(docKey)),documentCache.removeEntry(txn,docKey).next(function(bytesRemoved){totalBytesRemoved+=bytesRemoved;})]).next(function(){return totalBytesRemoved;});};IndexedDbLruDelegate.prototype.removeTarget=function(txn,queryData){var updated=queryData.copy({sequenceNumber:txn.currentSequenceNumber});return this.db.getQueryCache().updateQueryData(txn,updated);};IndexedDbLruDelegate.prototype.updateLimboDocument=function(txn,key){return writeSentinelKey(txn,key);};/**
     * Call provided function for each document in the cache that is 'orphaned'. Orphaned
     * means not a part of any target, so the only entry in the target-document index for
     * that document will be the sentinel row (targetId 0), which will also have the sequence
     * number for the last time the document was accessed.
     */IndexedDbLruDelegate.prototype.forEachOrphanedDocument=function(txn,f){var store=documentTargetStore(txn);var nextToReport=ListenSequence.INVALID;var nextPath;return store.iterate({index:DbTargetDocument.documentTargetsIndex},function(_a,_b){var targetId=_a[0],docKey=_a[1];var path=_b.path,sequenceNumber=_b.sequenceNumber;if(targetId===0){// if nextToReport is valid, report it, this is a new key so the
// last one must not be a member of any targets.
if(nextToReport!==ListenSequence.INVALID){f(new DocumentKey(decode(nextPath)),nextToReport);}// set nextToReport to be this sequence number. It's the next one we
// might report, if we don't find any targets for this document.
// Note that the sequence number must be defined when the targetId
// is 0.
nextToReport=sequenceNumber;nextPath=path;}else{// set nextToReport to be invalid, we know we don't need to report
// this one since we found a target for it.
nextToReport=ListenSequence.INVALID;}}).next(function(){// Since we report sequence numbers after getting to the next key, we
// need to check if the last key we iterated over was an orphaned
// document and report it.
if(nextToReport!==ListenSequence.INVALID){f(new DocumentKey(decode(nextPath)),nextToReport);}});};IndexedDbLruDelegate.prototype.getCacheSize=function(txn){return this.db.getRemoteDocumentCache().getSize(txn);};return IndexedDbLruDelegate;}();function sentinelKey$1(key){return[0,encode(key.path)];}/**
 * @return A value suitable for writing a sentinel row in the target-document
 * store.
 */function sentinelRow(key,sequenceNumber){return new DbTargetDocument(0,encode(key.path),sequenceNumber);}function writeSentinelKey(txn,key){return documentTargetStore(txn).put(sentinelRow(key,txn.currentSequenceNumber));}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * A readonly view of the local state of all documents we're tracking (i.e. we
 * have a cached version in remoteDocumentCache or local mutations for the
 * document). The view is computed by applying the mutations in the
 * MutationQueue to the RemoteDocumentCache.
 */var LocalDocumentsView=/** @class */function(){function LocalDocumentsView(remoteDocumentCache,mutationQueue,indexManager){this.remoteDocumentCache=remoteDocumentCache;this.mutationQueue=mutationQueue;this.indexManager=indexManager;}/**
     * Get the local view of the document identified by `key`.
     *
     * @return Local view of the document or null if we don't have any cached
     * state for it.
     */LocalDocumentsView.prototype.getDocument=function(transaction,key){var _this=this;return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction,key).next(function(batches){return _this.getDocumentInternal(transaction,key,batches);});};/** Internal version of `getDocument` that allows reusing batches. */LocalDocumentsView.prototype.getDocumentInternal=function(transaction,key,inBatches){return this.remoteDocumentCache.getEntry(transaction,key).next(function(doc){for(var _i=0,inBatches_1=inBatches;_i<inBatches_1.length;_i++){var batch=inBatches_1[_i];doc=batch.applyToLocalView(key,doc);}return doc;});};// Returns the view of the given `docs` as they would appear after applying
// all mutations in the given `batches`.
LocalDocumentsView.prototype.applyLocalMutationsToDocuments=function(transaction,docs,batches){var results=nullableMaybeDocumentMap();docs.forEach(function(key,localView){for(var _i=0,batches_1=batches;_i<batches_1.length;_i++){var batch=batches_1[_i];localView=batch.applyToLocalView(key,localView);}results=results.insert(key,localView);});return results;};/**
     * Gets the local view of the documents identified by `keys`.
     *
     * If we don't have cached state for a document in `keys`, a NoDocument will
     * be stored for that key in the resulting set.
     */LocalDocumentsView.prototype.getDocuments=function(transaction,keys){var _this=this;return this.remoteDocumentCache.getEntries(transaction,keys).next(function(docs){return _this.getLocalViewOfDocuments(transaction,docs);});};/**
     * Similar to `getDocuments`, but creates the local view from the given
     * `baseDocs` without retrieving documents from the local store.
     */LocalDocumentsView.prototype.getLocalViewOfDocuments=function(transaction,baseDocs){var _this=this;return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(transaction,baseDocs).next(function(batches){var docs=_this.applyLocalMutationsToDocuments(transaction,baseDocs,batches);var results=maybeDocumentMap();docs.forEach(function(key,maybeDoc){// TODO(http://b/32275378): Don't conflate missing / deleted.
if(!maybeDoc){maybeDoc=new NoDocument(key,SnapshotVersion.forDeletedDoc());}results=results.insert(key,maybeDoc);});return results;});};/** Performs a query against the local view of all documents. */LocalDocumentsView.prototype.getDocumentsMatchingQuery=function(transaction,query){if(query.isDocumentQuery()){return this.getDocumentsMatchingDocumentQuery(transaction,query.path);}else if(query.isCollectionGroupQuery()){return this.getDocumentsMatchingCollectionGroupQuery(transaction,query);}else{return this.getDocumentsMatchingCollectionQuery(transaction,query);}};LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery=function(transaction,docPath){// Just do a simple document lookup.
return this.getDocument(transaction,new DocumentKey(docPath)).next(function(maybeDoc){var result=documentMap();if(maybeDoc instanceof Document){result=result.insert(maybeDoc.key,maybeDoc);}return result;});};LocalDocumentsView.prototype.getDocumentsMatchingCollectionGroupQuery=function(transaction,query){var _this=this;assert(query.path.isEmpty(),'Currently we only support collection group queries at the root.');var collectionId=query.collectionGroup;var results=documentMap();return this.indexManager.getCollectionParents(transaction,collectionId).next(function(parents){// Perform a collection query against each parent that contains the
// collectionId and aggregate the results.
return PersistencePromise.forEach(parents,function(parent){var collectionQuery=query.asCollectionQueryAtPath(parent.child(collectionId));return _this.getDocumentsMatchingCollectionQuery(transaction,collectionQuery).next(function(r){r.forEach(function(key,doc){results=results.insert(key,doc);});});}).next(function(){return results;});});};LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery=function(transaction,query){var _this=this;// Query the remote documents and overlay mutations.
var results;return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction,query).next(function(queryResults){results=queryResults;return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction,query);}).next(function(matchingMutationBatches){for(var _i=0,matchingMutationBatches_1=matchingMutationBatches;_i<matchingMutationBatches_1.length;_i++){var batch=matchingMutationBatches_1[_i];for(var _a=0,_b=batch.mutations;_a<_b.length;_a++){var mutation=_b[_a];var key=mutation.key;// Only process documents belonging to the collection.
if(!query.path.isImmediateParentOf(key.path)){continue;}var baseDoc=results.get(key);var mutatedDoc=mutation.applyToLocalView(baseDoc,baseDoc,batch.localWriteTime);if(mutatedDoc instanceof Document){results=results.insert(key,mutatedDoc);}else{results=results.remove(key);}}}}).next(function(){// Finally, filter out any documents that don't actually match
// the query.
results.forEach(function(key,doc){if(!query.matches(doc)){results=results.remove(key);}});return results;});};return LocalDocumentsView;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * A collection of references to a document from some kind of numbered entity
 * (either a target ID or batch ID). As references are added to or removed from
 * the set corresponding events are emitted to a registered garbage collector.
 *
 * Each reference is represented by a DocumentReference object. Each of them
 * contains enough information to uniquely identify the reference. They are all
 * stored primarily in a set sorted by key. A document is considered garbage if
 * there's no references in that set (this can be efficiently checked thanks to
 * sorting by key).
 *
 * ReferenceSet also keeps a secondary set that contains references sorted by
 * IDs. This one is used to efficiently implement removal of all references by
 * some target ID.
 */var ReferenceSet=/** @class */function(){function ReferenceSet(){// A set of outstanding references to a document sorted by key.
this.refsByKey=new SortedSet(DocReference.compareByKey);// A set of outstanding references to a document sorted by target id.
this.refsByTarget=new SortedSet(DocReference.compareByTargetId);}/** Returns true if the reference set contains no references. */ReferenceSet.prototype.isEmpty=function(){return this.refsByKey.isEmpty();};/** Adds a reference to the given document key for the given ID. */ReferenceSet.prototype.addReference=function(key,id){var ref=new DocReference(key,id);this.refsByKey=this.refsByKey.add(ref);this.refsByTarget=this.refsByTarget.add(ref);};/** Add references to the given document keys for the given ID. */ReferenceSet.prototype.addReferences=function(keys,id){var _this=this;keys.forEach(function(key){return _this.addReference(key,id);});};/**
     * Removes a reference to the given document key for the given
     * ID.
     */ReferenceSet.prototype.removeReference=function(key,id){this.removeRef(new DocReference(key,id));};ReferenceSet.prototype.removeReferences=function(keys,id){var _this=this;keys.forEach(function(key){return _this.removeReference(key,id);});};/**
     * Clears all references with a given ID. Calls removeRef() for each key
     * removed.
     */ReferenceSet.prototype.removeReferencesForId=function(id){var _this=this;var emptyKey=DocumentKey.EMPTY;var startRef=new DocReference(emptyKey,id);var endRef=new DocReference(emptyKey,id+1);var keys=[];this.refsByTarget.forEachInRange([startRef,endRef],function(ref){_this.removeRef(ref);keys.push(ref.key);});return keys;};ReferenceSet.prototype.removeAllReferences=function(){var _this=this;this.refsByKey.forEach(function(ref){return _this.removeRef(ref);});};ReferenceSet.prototype.removeRef=function(ref){this.refsByKey=this.refsByKey.delete(ref);this.refsByTarget=this.refsByTarget.delete(ref);};ReferenceSet.prototype.referencesForId=function(id){var emptyKey=DocumentKey.EMPTY;var startRef=new DocReference(emptyKey,id);var endRef=new DocReference(emptyKey,id+1);var keys=documentKeySet();this.refsByTarget.forEachInRange([startRef,endRef],function(ref){keys=keys.add(ref.key);});return keys;};ReferenceSet.prototype.containsKey=function(key){var ref=new DocReference(key,0);var firstRef=this.refsByKey.firstAfterOrEqual(ref);return firstRef!==null&&key.isEqual(firstRef.key);};return ReferenceSet;}();var DocReference=/** @class */function(){function DocReference(key,targetOrBatchId){this.key=key;this.targetOrBatchId=targetOrBatchId;}/** Compare by key then by ID */DocReference.compareByKey=function(left,right){return DocumentKey.comparator(left.key,right.key)||primitiveComparator(left.targetOrBatchId,right.targetOrBatchId);};/** Compare by ID then by key */DocReference.compareByTargetId=function(left,right){return primitiveComparator(left.targetOrBatchId,right.targetOrBatchId)||DocumentKey.comparator(left.key,right.key);};return DocReference;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$3='LocalStore';/**
 * Local storage in the Firestore client. Coordinates persistence components
 * like the mutation queue and remote document cache to present a
 * latency-compensated view of stored data.
 *
 * The LocalStore is responsible for accepting mutations from the Sync Engine.
 * Writes from the client are put into a queue as provisional Mutations until
 * they are processed by the RemoteStore and confirmed as having been written
 * to the server.
 *
 * The local store provides the local version of documents that have been
 * modified locally. It maintains the constraint:
 *
 *   LocalDocument = RemoteDocument + Active(LocalMutations)
 *
 * (Active mutations are those that are enqueued and have not been previously
 * acknowledged or rejected).
 *
 * The RemoteDocument ("ground truth") state is provided via the
 * applyChangeBatch method. It will be some version of a server-provided
 * document OR will be a server-provided document PLUS acknowledged mutations:
 *
 *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)
 *
 * Note that this "dirty" version of a RemoteDocument will not be identical to a
 * server base version, since it has LocalMutations added to it pending getting
 * an authoritative copy from the server.
 *
 * Since LocalMutations can be rejected by the server, we have to be able to
 * revert a LocalMutation that has already been applied to the LocalDocument
 * (typically done by replaying all remaining LocalMutations to the
 * RemoteDocument to re-apply).
 *
 * The LocalStore is responsible for the garbage collection of the documents it
 * contains. For now, it every doc referenced by a view, the mutation queue, or
 * the RemoteStore.
 *
 * It also maintains the persistence of mapping queries to resume tokens and
 * target ids. It needs to know this data about queries to properly know what
 * docs it would be allowed to garbage collect.
 *
 * The LocalStore must be able to efficiently execute queries against its local
 * cache of the documents, to provide the initial set of results before any
 * remote changes have been received.
 *
 * Note: In TypeScript, most methods return Promises since the implementation
 * may rely on fetching data from IndexedDB which is async.
 * These Promises will only be rejected on an I/O error or other internal
 * (unexpected) failure (e.g. failed assert) and always represent an
 * unrecoverable error (should be caught / reported by the async_queue).
 */var LocalStore=/** @class */function(){function LocalStore(/** Manages our in-memory or durable persistence. */persistence,initialUser){this.persistence=persistence;/**
         * The set of document references maintained by any local views.
         */this.localViewReferences=new ReferenceSet();/** Maps a targetID to data about its query. */this.queryDataByTarget={};assert(persistence.started,'LocalStore was passed an unstarted persistence implementation');this.persistence.referenceDelegate.setInMemoryPins(this.localViewReferences);this.mutationQueue=persistence.getMutationQueue(initialUser);this.remoteDocuments=persistence.getRemoteDocumentCache();this.queryCache=persistence.getQueryCache();this.localDocuments=new LocalDocumentsView(this.remoteDocuments,this.mutationQueue,this.persistence.getIndexManager());}/**
     * Tells the LocalStore that the currently authenticated user has changed.
     *
     * In response the local store switches the mutation queue to the new user and
     * returns any resulting document changes.
     */// PORTING NOTE: Android and iOS only return the documents affected by the
// change.
LocalStore.prototype.handleUserChange=function(user){var _this=this;return this.persistence.runTransaction('Handle user change','readonly',function(txn){// Swap out the mutation queue, grabbing the pending mutation batches
// before and after.
var oldBatches;return _this.mutationQueue.getAllMutationBatches(txn).next(function(promisedOldBatches){oldBatches=promisedOldBatches;_this.mutationQueue=_this.persistence.getMutationQueue(user);// Recreate our LocalDocumentsView using the new
// MutationQueue.
_this.localDocuments=new LocalDocumentsView(_this.remoteDocuments,_this.mutationQueue,_this.persistence.getIndexManager());return _this.mutationQueue.getAllMutationBatches(txn);}).next(function(newBatches){var removedBatchIds=[];var addedBatchIds=[];// Union the old/new changed keys.
var changedKeys=documentKeySet();for(var _i=0,oldBatches_1=oldBatches;_i<oldBatches_1.length;_i++){var batch=oldBatches_1[_i];removedBatchIds.push(batch.batchId);for(var _a=0,_b=batch.mutations;_a<_b.length;_a++){var mutation=_b[_a];changedKeys=changedKeys.add(mutation.key);}}for(var _c=0,newBatches_1=newBatches;_c<newBatches_1.length;_c++){var batch=newBatches_1[_c];addedBatchIds.push(batch.batchId);for(var _d=0,_e=batch.mutations;_d<_e.length;_d++){var mutation=_e[_d];changedKeys=changedKeys.add(mutation.key);}}// Return the set of all (potentially) changed documents and the list
// of mutation batch IDs that were affected by change.
return _this.localDocuments.getDocuments(txn,changedKeys).next(function(affectedDocuments){return{affectedDocuments:affectedDocuments,removedBatchIds:removedBatchIds,addedBatchIds:addedBatchIds};});});});};/* Accept locally generated Mutations and commit them to storage. */LocalStore.prototype.localWrite=function(mutations){var _this=this;var localWriteTime=Timestamp.now();var keys=mutations.reduce(function(keys,m){return keys.add(m.key);},documentKeySet());return this.persistence.runTransaction('Locally write mutations','readwrite',function(txn){// Load and apply all existing mutations. This lets us compute the
// current base state for all non-idempotent transforms before applying
// any additional user-provided writes.
return _this.localDocuments.getDocuments(txn,keys).next(function(existingDocs){// For non-idempotent mutations (such as `FieldValue.increment()`),
// we record the base state in a separate patch mutation. This is
// later used to guarantee consistent values and prevents flicker
// even if the backend sends us an update that already includes our
// transform.
var baseMutations=[];for(var _i=0,mutations_1=mutations;_i<mutations_1.length;_i++){var mutation=mutations_1[_i];var maybeDoc=existingDocs.get(mutation.key);if(!mutation.isIdempotent){// Theoretically, we should only include non-idempotent fields
// in this field mask as this mask is used to populate the base
// state for all DocumentTransforms.  By  including all fields,
// we incorrectly prevent rebasing of idempotent transforms
// (such as `arrayUnion()`) when any non-idempotent transforms
// are present.
var fieldMask=mutation.fieldMask;if(fieldMask){var baseValues=maybeDoc instanceof Document?fieldMask.applyTo(maybeDoc.data):ObjectValue.EMPTY;// NOTE: The base state should only be applied if there's some
// existing document to override, so use a Precondition of
// exists=true
baseMutations.push(new PatchMutation(mutation.key,baseValues,fieldMask,Precondition.exists(true)));}}}return _this.mutationQueue.addMutationBatch(txn,localWriteTime,baseMutations,mutations).next(function(batch){var changes=batch.applyToLocalDocumentSet(existingDocs);return{batchId:batch.batchId,changes:changes};});});});};/** Returns the local view of the documents affected by a mutation batch. */// PORTING NOTE: Multi-tab only.
LocalStore.prototype.lookupMutationDocuments=function(batchId){var _this=this;return this.persistence.runTransaction('Lookup mutation documents','readonly',function(txn){return _this.mutationQueue.lookupMutationKeys(txn,batchId).next(function(keys){if(keys){return _this.localDocuments.getDocuments(txn,keys);}else{return PersistencePromise.resolve(null);}});});};/**
     * Acknowledge the given batch.
     *
     * On the happy path when a batch is acknowledged, the local store will
     *
     *  + remove the batch from the mutation queue;
     *  + apply the changes to the remote document cache;
     *  + recalculate the latency compensated view implied by those changes (there
     *    may be mutations in the queue that affect the documents but haven't been
     *    acknowledged yet); and
     *  + give the changed documents back the sync engine
     *
     * @returns The resulting (modified) documents.
     */LocalStore.prototype.acknowledgeBatch=function(batchResult){var _this=this;return this.persistence.runTransaction('Acknowledge batch','readwrite-primary',function(txn){var affected=batchResult.batch.keys();var documentBuffer=_this.remoteDocuments.newChangeBuffer();return _this.mutationQueue.acknowledgeBatch(txn,batchResult.batch,batchResult.streamToken).next(function(){return _this.applyWriteToRemoteDocuments(txn,batchResult,documentBuffer);}).next(function(){return documentBuffer.apply(txn);}).next(function(){return _this.mutationQueue.performConsistencyCheck(txn);}).next(function(){return _this.localDocuments.getDocuments(txn,affected);});});};/**
     * Remove mutations from the MutationQueue for the specified batch;
     * LocalDocuments will be recalculated.
     *
     * @returns The resulting modified documents.
     */LocalStore.prototype.rejectBatch=function(batchId){var _this=this;return this.persistence.runTransaction('Reject batch','readwrite-primary',function(txn){var affectedKeys;return _this.mutationQueue.lookupMutationBatch(txn,batchId).next(function(batch){assert(batch!==null,'Attempt to reject nonexistent batch!');affectedKeys=batch.keys();return _this.mutationQueue.removeMutationBatch(txn,batch);}).next(function(){return _this.mutationQueue.performConsistencyCheck(txn);}).next(function(){return _this.localDocuments.getDocuments(txn,affectedKeys);});});};/** Returns the last recorded stream token for the current user. */LocalStore.prototype.getLastStreamToken=function(){var _this=this;return this.persistence.runTransaction('Get last stream token','readonly',function(txn){return _this.mutationQueue.getLastStreamToken(txn);});};/**
     * Sets the stream token for the current user without acknowledging any
     * mutation batch. This is usually only useful after a stream handshake or in
     * response to an error that requires clearing the stream token.
     */LocalStore.prototype.setLastStreamToken=function(streamToken){var _this=this;return this.persistence.runTransaction('Set last stream token','readwrite-primary',function(txn){return _this.mutationQueue.setLastStreamToken(txn,streamToken);});};/**
     * Returns the last consistent snapshot processed (used by the RemoteStore to
     * determine whether to buffer incoming snapshots from the backend).
     */LocalStore.prototype.getLastRemoteSnapshotVersion=function(){var _this=this;return this.persistence.runTransaction('Get last remote snapshot version','readonly',function(txn){return _this.queryCache.getLastRemoteSnapshotVersion(txn);});};/**
     * Update the "ground-state" (remote) documents. We assume that the remote
     * event reflects any write batches that have been acknowledged or rejected
     * (i.e. we do not re-apply local mutations to updates from this event).
     *
     * LocalDocuments are re-calculated if there are remaining mutations in the
     * queue.
     */LocalStore.prototype.applyRemoteEvent=function(remoteEvent){var _this=this;var documentBuffer=this.remoteDocuments.newChangeBuffer();return this.persistence.runTransaction('Apply remote event','readwrite-primary',function(txn){var promises=[];var authoritativeUpdates=documentKeySet();forEachNumber(remoteEvent.targetChanges,function(targetId,change){// Do not ref/unref unassigned targetIds - it may lead to leaks.
var queryData=_this.queryDataByTarget[targetId];if(!queryData)return;// When a global snapshot contains updates (either add or modify) we
// can completely trust these updates as authoritative and blindly
// apply them to our cache (as a defensive measure to promote
// self-healing in the unfortunate case that our cache is ever somehow
// corrupted / out-of-sync).
//
// If the document is only updated while removing it from a target
// then watch isn't obligated to send the absolute latest version: it
// can send the first version that caused the document not to match.
change.addedDocuments.forEach(function(key){authoritativeUpdates=authoritativeUpdates.add(key);});change.modifiedDocuments.forEach(function(key){authoritativeUpdates=authoritativeUpdates.add(key);});promises.push(_this.queryCache.removeMatchingKeys(txn,change.removedDocuments,targetId).next(function(){return _this.queryCache.addMatchingKeys(txn,change.addedDocuments,targetId);}));// Update the resume token if the change includes one. Don't clear
// any preexisting value.
var resumeToken=change.resumeToken;if(resumeToken.length>0){var oldQueryData=queryData;queryData=queryData.copy({resumeToken:resumeToken,snapshotVersion:remoteEvent.snapshotVersion});_this.queryDataByTarget[targetId]=queryData;if(LocalStore.shouldPersistQueryData(oldQueryData,queryData,change)){promises.push(_this.queryCache.updateQueryData(txn,queryData));}}});var changedDocs=maybeDocumentMap();var updatedKeys=documentKeySet();remoteEvent.documentUpdates.forEach(function(key,doc){updatedKeys=updatedKeys.add(key);});// Each loop iteration only affects its "own" doc, so it's safe to get all the remote
// documents in advance in a single call.
promises.push(documentBuffer.getEntries(txn,updatedKeys).next(function(existingDocs){remoteEvent.documentUpdates.forEach(function(key,doc){var existingDoc=existingDocs.get(key);// If a document update isn't authoritative, make sure we don't
// apply an old document version to the remote cache. We make an
// exception for SnapshotVersion.MIN which can happen for
// manufactured events (e.g. in the case of a limbo document
// resolution failing).
if(existingDoc==null||doc.version.isEqual(SnapshotVersion.MIN)||authoritativeUpdates.has(doc.key)&&!existingDoc.hasPendingWrites||doc.version.compareTo(existingDoc.version)>=0){documentBuffer.addEntry(doc);changedDocs=changedDocs.insert(key,doc);}else{debug(LOG_TAG$3,'Ignoring outdated watch update for ',key,'. Current version:',existingDoc.version,' Watch version:',doc.version);}if(remoteEvent.resolvedLimboDocuments.has(key)){promises.push(_this.persistence.referenceDelegate.updateLimboDocument(txn,key));}});}));// HACK: The only reason we allow a null snapshot version is so that we
// can synthesize remote events when we get permission denied errors while
// trying to resolve the state of a locally cached document that is in
// limbo.
var remoteVersion=remoteEvent.snapshotVersion;if(!remoteVersion.isEqual(SnapshotVersion.MIN)){var updateRemoteVersion=_this.queryCache.getLastRemoteSnapshotVersion(txn).next(function(lastRemoteVersion){assert(remoteVersion.compareTo(lastRemoteVersion)>=0,'Watch stream reverted to previous snapshot?? '+remoteVersion+' < '+lastRemoteVersion);return _this.queryCache.setTargetsMetadata(txn,txn.currentSequenceNumber,remoteVersion);});promises.push(updateRemoteVersion);}return PersistencePromise.waitFor(promises).next(function(){return documentBuffer.apply(txn);}).next(function(){return _this.localDocuments.getLocalViewOfDocuments(txn,changedDocs);});});};/**
     * Returns true if the newQueryData should be persisted during an update of
     * an active target. QueryData should always be persisted when a target is
     * being released and should not call this function.
     *
     * While the target is active, QueryData updates can be omitted when nothing
     * about the target has changed except metadata like the resume token or
     * snapshot version. Occasionally it's worth the extra write to prevent these
     * values from getting too stale after a crash, but this doesn't have to be
     * too frequent.
     */LocalStore.shouldPersistQueryData=function(oldQueryData,newQueryData,change){// Avoid clearing any existing value
if(newQueryData.resumeToken.length===0)return false;// Any resume token is interesting if there isn't one already.
if(oldQueryData.resumeToken.length===0)return true;// Don't allow resume token changes to be buffered indefinitely. This
// allows us to be reasonably up-to-date after a crash and avoids needing
// to loop over all active queries on shutdown. Especially in the browser
// we may not get time to do anything interesting while the current tab is
// closing.
var timeDelta=newQueryData.snapshotVersion.toMicroseconds()-oldQueryData.snapshotVersion.toMicroseconds();if(timeDelta>=this.RESUME_TOKEN_MAX_AGE_MICROS)return true;// Otherwise if the only thing that has changed about a target is its resume
// token it's not worth persisting. Note that the RemoteStore keeps an
// in-memory view of the currently active targets which includes the current
// resume token, so stream failure or user changes will still use an
// up-to-date resume token regardless of what we do here.
var changes=change.addedDocuments.size+change.modifiedDocuments.size+change.removedDocuments.size;return changes>0;};/**
     * Notify local store of the changed views to locally pin documents.
     */LocalStore.prototype.notifyLocalViewChanges=function(viewChanges){var _this=this;return this.persistence.runTransaction('notifyLocalViewChanges','readwrite',function(txn){return PersistencePromise.forEach(viewChanges,function(viewChange){_this.localViewReferences.addReferences(viewChange.addedKeys,viewChange.targetId);_this.localViewReferences.removeReferences(viewChange.removedKeys,viewChange.targetId);return PersistencePromise.forEach(viewChange.removedKeys,function(key){return _this.persistence.referenceDelegate.removeReference(txn,key);});});});};/**
     * Gets the mutation batch after the passed in batchId in the mutation queue
     * or null if empty.
     * @param afterBatchId If provided, the batch to search after.
     * @returns The next mutation or null if there wasn't one.
     */LocalStore.prototype.nextMutationBatch=function(afterBatchId){var _this=this;return this.persistence.runTransaction('Get next mutation batch','readonly',function(txn){if(afterBatchId===undefined){afterBatchId=BATCHID_UNKNOWN;}return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn,afterBatchId);});};/**
     * Read the current value of a Document with a given key or null if not
     * found - used for testing.
     */LocalStore.prototype.readDocument=function(key){var _this=this;return this.persistence.runTransaction('read document','readonly',function(txn){return _this.localDocuments.getDocument(txn,key);});};/**
     * Assigns the given query an internal ID so that its results can be pinned so
     * they don't get GC'd. A query must be allocated in the local store before
     * the store can be used to manage its view.
     */LocalStore.prototype.allocateQuery=function(query){var _this=this;return this.persistence.runTransaction('Allocate query','readwrite',function(txn){var queryData;return _this.queryCache.getQueryData(txn,query).next(function(cached){if(cached){// This query has been listened to previously, so reuse the
// previous targetID.
// TODO(mcg): freshen last accessed date?
queryData=cached;return PersistencePromise.resolve();}else{return _this.queryCache.allocateTargetId(txn).next(function(targetId){queryData=new QueryData(query,targetId,QueryPurpose.Listen,txn.currentSequenceNumber);return _this.queryCache.addQueryData(txn,queryData);});}}).next(function(){assert(!_this.queryDataByTarget[queryData.targetId],'Tried to allocate an already allocated query: '+query);_this.queryDataByTarget[queryData.targetId]=queryData;return queryData;});});};/**
     * Unpin all the documents associated with the given query. If
     * `keepPersistedQueryData` is set to false and Eager GC enabled, the method
     * directly removes the associated query data from the query cache.
     */// PORTING NOTE: `keepPersistedQueryData` is multi-tab only.
LocalStore.prototype.releaseQuery=function(query,keepPersistedQueryData){var _this=this;var mode=keepPersistedQueryData?'readwrite':'readwrite-primary';return this.persistence.runTransaction('Release query',mode,function(txn){return _this.queryCache.getQueryData(txn,query).next(function(queryData){assert(queryData!=null,'Tried to release nonexistent query: '+query);var targetId=queryData.targetId;var cachedQueryData=_this.queryDataByTarget[targetId];// References for documents sent via Watch are automatically removed when we delete a
// query's target data from the reference delegate. Since this does not remove references
// for locally mutated documents, we have to remove the target associations for these
// documents manually.
var removed=_this.localViewReferences.removeReferencesForId(targetId);delete _this.queryDataByTarget[targetId];if(!keepPersistedQueryData){return PersistencePromise.forEach(removed,function(key){return _this.persistence.referenceDelegate.removeReference(txn,key);}).next(function(){return _this.persistence.referenceDelegate.removeTarget(txn,cachedQueryData);});}else{return PersistencePromise.resolve();}});});};/**
     * Runs the specified query against all the documents in the local store and
     * returns the results.
     */LocalStore.prototype.executeQuery=function(query){var _this=this;return this.persistence.runTransaction('Execute query','readonly',function(txn){return _this.localDocuments.getDocumentsMatchingQuery(txn,query);});};/**
     * Returns the keys of the documents that are associated with the given
     * target id in the remote table.
     */LocalStore.prototype.remoteDocumentKeys=function(targetId){var _this=this;return this.persistence.runTransaction('Remote document keys','readonly',function(txn){return _this.queryCache.getMatchingKeysForTargetId(txn,targetId);});};// PORTING NOTE: Multi-tab only.
LocalStore.prototype.getActiveClients=function(){return this.persistence.getActiveClients();};// PORTING NOTE: Multi-tab only.
LocalStore.prototype.removeCachedMutationBatchMetadata=function(batchId){this.mutationQueue.removeCachedMutationKeys(batchId);};// PORTING NOTE: Multi-tab only.
LocalStore.prototype.setNetworkEnabled=function(networkEnabled){this.persistence.setNetworkEnabled(networkEnabled);};LocalStore.prototype.applyWriteToRemoteDocuments=function(txn,batchResult,documentBuffer){var _this=this;var batch=batchResult.batch;var docKeys=batch.keys();var promiseChain=PersistencePromise.resolve();docKeys.forEach(function(docKey){promiseChain=promiseChain.next(function(){return documentBuffer.getEntry(txn,docKey);}).next(function(remoteDoc){var doc=remoteDoc;var ackVersion=batchResult.docVersions.get(docKey);assert(ackVersion!==null,'ackVersions should contain every doc in the write.');if(!doc||doc.version.compareTo(ackVersion)<0){doc=batch.applyToRemoteDocument(docKey,doc,batchResult);if(!doc){assert(!remoteDoc,'Mutation batch '+batch+' applied to document '+remoteDoc+' resulted in null');}else{documentBuffer.addEntry(doc);}}});});return promiseChain.next(function(){return _this.mutationQueue.removeMutationBatch(txn,batch);});};LocalStore.prototype.collectGarbage=function(garbageCollector){var _this=this;return this.persistence.runTransaction('Collect garbage','readwrite-primary',function(txn){return garbageCollector.collect(txn,_this.queryDataByTarget);});};// PORTING NOTE: Multi-tab only.
LocalStore.prototype.getQueryForTarget=function(targetId){var _this=this;if(this.queryDataByTarget[targetId]){return Promise.resolve(this.queryDataByTarget[targetId].query);}else{return this.persistence.runTransaction('Get query data','readonly',function(txn){return _this.queryCache.getQueryDataForTarget(txn,targetId).next(function(queryData){return queryData?queryData.query:null;});});}};// PORTING NOTE: Multi-tab only.
LocalStore.prototype.getNewDocumentChanges=function(){var _this=this;return this.persistence.runTransaction('Get new document changes','readonly',function(txn){return _this.remoteDocuments.getNewDocumentChanges(txn);});};/**
     * The maximum time to leave a resume token buffered without writing it out.
     * This value is arbitrary: it's long enough to avoid several writes
     * (possibly indefinitely if updates come more frequently than this) but
     * short enough that restarting after crashing will still have a pretty
     * recent resume token.
     */LocalStore.RESUME_TOKEN_MAX_AGE_MICROS=5*60*1e6;return LocalStore;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var MemoryMutationQueue=/** @class */function(){function MemoryMutationQueue(indexManager,referenceDelegate){this.indexManager=indexManager;this.referenceDelegate=referenceDelegate;/**
         * The set of all mutations that have been sent but not yet been applied to
         * the backend.
         */this.mutationQueue=[];/** Next value to use when assigning sequential IDs to each mutation batch. */this.nextBatchId=1;/** The last received stream token from the server, used to acknowledge which
         * responses the client has processed. Stream tokens are opaque checkpoint
         * markers whose only real value is their inclusion in the next request.
         */this.lastStreamToken=emptyByteString();/** An ordered mapping between documents and the mutations batch IDs. */this.batchesByDocumentKey=new SortedSet(DocReference.compareByKey);}MemoryMutationQueue.prototype.checkEmpty=function(transaction){return PersistencePromise.resolve(this.mutationQueue.length===0);};MemoryMutationQueue.prototype.acknowledgeBatch=function(transaction,batch,streamToken){var batchId=batch.batchId;var batchIndex=this.indexOfExistingBatchId(batchId,'acknowledged');assert(batchIndex===0,'Can only acknowledge the first batch in the mutation queue');// Verify that the batch in the queue is the one to be acknowledged.
var check=this.mutationQueue[batchIndex];assert(batchId===check.batchId,'Queue ordering failure: expected batch '+batchId+', got batch '+check.batchId);this.lastStreamToken=streamToken;return PersistencePromise.resolve();};MemoryMutationQueue.prototype.getLastStreamToken=function(transaction){return PersistencePromise.resolve(this.lastStreamToken);};MemoryMutationQueue.prototype.setLastStreamToken=function(transaction,streamToken){this.lastStreamToken=streamToken;return PersistencePromise.resolve();};MemoryMutationQueue.prototype.addMutationBatch=function(transaction,localWriteTime,baseMutations,mutations){assert(mutations.length!==0,'Mutation batches should not be empty');var batchId=this.nextBatchId;this.nextBatchId++;if(this.mutationQueue.length>0){var prior=this.mutationQueue[this.mutationQueue.length-1];assert(prior.batchId<batchId,'Mutation batchIDs must be monotonically increasing order');}var batch=new MutationBatch(batchId,localWriteTime,baseMutations,mutations);this.mutationQueue.push(batch);// Track references by document key and index collection parents.
for(var _i=0,mutations_1=mutations;_i<mutations_1.length;_i++){var mutation=mutations_1[_i];this.batchesByDocumentKey=this.batchesByDocumentKey.add(new DocReference(mutation.key,batchId));this.indexManager.addToCollectionParentIndex(transaction,mutation.key.path.popLast());}return PersistencePromise.resolve(batch);};MemoryMutationQueue.prototype.lookupMutationBatch=function(transaction,batchId){return PersistencePromise.resolve(this.findMutationBatch(batchId));};MemoryMutationQueue.prototype.lookupMutationKeys=function(transaction,batchId){var mutationBatch=this.findMutationBatch(batchId);assert(mutationBatch!=null,'Failed to find local mutation batch.');return PersistencePromise.resolve(mutationBatch.keys());};MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId=function(transaction,batchId){var nextBatchId=batchId+1;// The requested batchId may still be out of range so normalize it to the
// start of the queue.
var rawIndex=this.indexOfBatchId(nextBatchId);var index=rawIndex<0?0:rawIndex;return PersistencePromise.resolve(this.mutationQueue.length>index?this.mutationQueue[index]:null);};MemoryMutationQueue.prototype.getAllMutationBatches=function(transaction){return PersistencePromise.resolve(this.mutationQueue.slice());};MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey=function(transaction,documentKey){var _this=this;var start=new DocReference(documentKey,0);var end=new DocReference(documentKey,Number.POSITIVE_INFINITY);var result=[];this.batchesByDocumentKey.forEachInRange([start,end],function(ref){assert(documentKey.isEqual(ref.key),"Should only iterate over a single key's batches");var batch=_this.findMutationBatch(ref.targetOrBatchId);assert(batch!==null,'Batches in the index must exist in the main table');result.push(batch);});return PersistencePromise.resolve(result);};MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKeys=function(transaction,documentKeys){var _this=this;var uniqueBatchIDs=new SortedSet(primitiveComparator);documentKeys.forEach(function(documentKey){var start=new DocReference(documentKey,0);var end=new DocReference(documentKey,Number.POSITIVE_INFINITY);_this.batchesByDocumentKey.forEachInRange([start,end],function(ref){assert(documentKey.isEqual(ref.key),"For each key, should only iterate over a single key's batches");uniqueBatchIDs=uniqueBatchIDs.add(ref.targetOrBatchId);});});return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));};MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery=function(transaction,query){assert(!query.isCollectionGroupQuery(),'CollectionGroup queries should be handled in LocalDocumentsView');// Use the query path as a prefix for testing if a document matches the
// query.
var prefix=query.path;var immediateChildrenPathLength=prefix.length+1;// Construct a document reference for actually scanning the index. Unlike
// the prefix the document key in this reference must have an even number of
// segments. The empty segment can be used a suffix of the query path
// because it precedes all other segments in an ordered traversal.
var startPath=prefix;if(!DocumentKey.isDocumentKey(startPath)){startPath=startPath.child('');}var start=new DocReference(new DocumentKey(startPath),0);// Find unique batchIDs referenced by all documents potentially matching the
// query.
var uniqueBatchIDs=new SortedSet(primitiveComparator);this.batchesByDocumentKey.forEachWhile(function(ref){var rowKeyPath=ref.key.path;if(!prefix.isPrefixOf(rowKeyPath)){return false;}else{// Rows with document keys more than one segment longer than the query
// path can't be matches. For example, a query on 'rooms' can't match
// the document /rooms/abc/messages/xyx.
// TODO(mcg): we'll need a different scanner when we implement
// ancestor queries.
if(rowKeyPath.length===immediateChildrenPathLength){uniqueBatchIDs=uniqueBatchIDs.add(ref.targetOrBatchId);}return true;}},start);return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));};MemoryMutationQueue.prototype.findMutationBatches=function(batchIDs){var _this=this;// Construct an array of matching batches, sorted by batchID to ensure that
// multiple mutations affecting the same document key are applied in order.
var result=[];batchIDs.forEach(function(batchId){var batch=_this.findMutationBatch(batchId);if(batch!==null){result.push(batch);}});return result;};MemoryMutationQueue.prototype.removeMutationBatch=function(transaction,batch){var _this=this;// Find the position of the first batch for removal. This need not be the
// first entry in the queue.
var batchIndex=this.indexOfExistingBatchId(batch.batchId,'removed');assert(batchIndex===0,'Can only remove the first entry of the mutation queue');this.mutationQueue.shift();var references=this.batchesByDocumentKey;return PersistencePromise.forEach(batch.mutations,function(mutation){var ref=new DocReference(mutation.key,batch.batchId);references=references.delete(ref);return _this.referenceDelegate.removeMutationReference(transaction,mutation.key);}).next(function(){_this.batchesByDocumentKey=references;});};MemoryMutationQueue.prototype.removeCachedMutationKeys=function(batchId){// No-op since the memory mutation queue does not maintain a separate cache.
};MemoryMutationQueue.prototype.containsKey=function(txn,key){var ref=new DocReference(key,0);var firstRef=this.batchesByDocumentKey.firstAfterOrEqual(ref);return PersistencePromise.resolve(key.isEqual(firstRef&&firstRef.key));};MemoryMutationQueue.prototype.performConsistencyCheck=function(txn){if(this.mutationQueue.length===0){assert(this.batchesByDocumentKey.isEmpty(),'Document leak -- detected dangling mutation references when queue is empty.');}return PersistencePromise.resolve();};/**
     * Finds the index of the given batchId in the mutation queue and asserts that
     * the resulting index is within the bounds of the queue.
     *
     * @param batchId The batchId to search for
     * @param action A description of what the caller is doing, phrased in passive
     * form (e.g. "acknowledged" in a routine that acknowledges batches).
     */MemoryMutationQueue.prototype.indexOfExistingBatchId=function(batchId,action){var index=this.indexOfBatchId(batchId);assert(index>=0&&index<this.mutationQueue.length,'Batches must exist to be '+action);return index;};/**
     * Finds the index of the given batchId in the mutation queue. This operation
     * is O(1).
     *
     * @return The computed index of the batch with the given batchId, based on
     * the state of the queue. Note this index can be negative if the requested
     * batchId has already been remvoed from the queue or past the end of the
     * queue if the batchId is larger than the last added batch.
     */MemoryMutationQueue.prototype.indexOfBatchId=function(batchId){if(this.mutationQueue.length===0){// As an index this is past the end of the queue
return 0;}// Examine the front of the queue to figure out the difference between the
// batchId and indexes in the array. Note that since the queue is ordered
// by batchId, if the first batch has a larger batchId then the requested
// batchId doesn't exist in the queue.
var firstBatchId=this.mutationQueue[0].batchId;return batchId-firstBatchId;};/**
     * A version of lookupMutationBatch that doesn't return a promise, this makes
     * other functions that uses this code easier to read and more efficent.
     */MemoryMutationQueue.prototype.findMutationBatch=function(batchId){var index=this.indexOfBatchId(batchId);if(index<0||index>=this.mutationQueue.length){return null;}var batch=this.mutationQueue[index];assert(batch.batchId===batchId,'If found batch must match');return batch;};return MemoryMutationQueue;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var MemoryQueryCache=/** @class */function(){function MemoryQueryCache(persistence){this.persistence=persistence;/**
         * Maps a query to the data about that query
         */this.queries=new ObjectMap(function(q){return q.canonicalId();});/** The last received snapshot version. */this.lastRemoteSnapshotVersion=SnapshotVersion.MIN;/** The highest numbered target ID encountered. */this.highestTargetId=0;/** The highest sequence number encountered. */this.highestSequenceNumber=0;/**
         * A ordered bidirectional mapping between documents and the remote target
         * IDs.
         */this.references=new ReferenceSet();this.targetCount=0;this.targetIdGenerator=TargetIdGenerator.forQueryCache();}MemoryQueryCache.prototype.getTargetCount=function(txn){return PersistencePromise.resolve(this.targetCount);};MemoryQueryCache.prototype.forEachTarget=function(txn,f){this.queries.forEach(function(_,queryData){return f(queryData);});return PersistencePromise.resolve();};MemoryQueryCache.prototype.getLastRemoteSnapshotVersion=function(transaction){return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);};MemoryQueryCache.prototype.getHighestSequenceNumber=function(transaction){return PersistencePromise.resolve(this.highestSequenceNumber);};MemoryQueryCache.prototype.allocateTargetId=function(transaction){var nextTargetId=this.targetIdGenerator.after(this.highestTargetId);this.highestTargetId=nextTargetId;return PersistencePromise.resolve(nextTargetId);};MemoryQueryCache.prototype.setTargetsMetadata=function(transaction,highestListenSequenceNumber,lastRemoteSnapshotVersion){if(lastRemoteSnapshotVersion){this.lastRemoteSnapshotVersion=lastRemoteSnapshotVersion;}if(highestListenSequenceNumber>this.highestSequenceNumber){this.highestSequenceNumber=highestListenSequenceNumber;}return PersistencePromise.resolve();};MemoryQueryCache.prototype.saveQueryData=function(queryData){this.queries.set(queryData.query,queryData);var targetId=queryData.targetId;if(targetId>this.highestTargetId){this.highestTargetId=targetId;}if(queryData.sequenceNumber>this.highestSequenceNumber){this.highestSequenceNumber=queryData.sequenceNumber;}};MemoryQueryCache.prototype.addQueryData=function(transaction,queryData){assert(!this.queries.has(queryData.query),'Adding a query that already exists');this.saveQueryData(queryData);this.targetCount+=1;return PersistencePromise.resolve();};MemoryQueryCache.prototype.updateQueryData=function(transaction,queryData){assert(this.queries.has(queryData.query),'Updating a non-existent query');this.saveQueryData(queryData);return PersistencePromise.resolve();};MemoryQueryCache.prototype.removeQueryData=function(transaction,queryData){assert(this.targetCount>0,'Removing a target from an empty cache');assert(this.queries.has(queryData.query),'Removing a non-existent target from the cache');this.queries.delete(queryData.query);this.references.removeReferencesForId(queryData.targetId);this.targetCount-=1;return PersistencePromise.resolve();};MemoryQueryCache.prototype.removeTargets=function(transaction,upperBound,activeTargetIds){var _this=this;var count=0;var removals=[];this.queries.forEach(function(key,queryData){if(queryData.sequenceNumber<=upperBound&&!activeTargetIds[queryData.targetId]){_this.queries.delete(key);removals.push(_this.removeMatchingKeysForTargetId(transaction,queryData.targetId));count++;}});return PersistencePromise.waitFor(removals).next(function(){return count;});};MemoryQueryCache.prototype.getQueryCount=function(transaction){return PersistencePromise.resolve(this.targetCount);};MemoryQueryCache.prototype.getQueryData=function(transaction,query){var queryData=this.queries.get(query)||null;return PersistencePromise.resolve(queryData);};MemoryQueryCache.prototype.getQueryDataForTarget=function(transaction,targetId){// This method is only needed for multi-tab and we can't implement it
// efficiently without additional data structures.
return fail('Not yet implemented.');};MemoryQueryCache.prototype.addMatchingKeys=function(txn,keys,targetId){this.references.addReferences(keys,targetId);var referenceDelegate=this.persistence.referenceDelegate;var promises=[];if(referenceDelegate){keys.forEach(function(key){promises.push(referenceDelegate.addReference(txn,key));});}return PersistencePromise.waitFor(promises);};MemoryQueryCache.prototype.removeMatchingKeys=function(txn,keys,targetId){this.references.removeReferences(keys,targetId);var referenceDelegate=this.persistence.referenceDelegate;var promises=[];if(referenceDelegate){keys.forEach(function(key){promises.push(referenceDelegate.removeReference(txn,key));});}return PersistencePromise.waitFor(promises);};MemoryQueryCache.prototype.removeMatchingKeysForTargetId=function(txn,targetId){this.references.removeReferencesForId(targetId);return PersistencePromise.resolve();};MemoryQueryCache.prototype.getMatchingKeysForTargetId=function(txn,targetId){var matchingKeys=this.references.referencesForId(targetId);return PersistencePromise.resolve(matchingKeys);};MemoryQueryCache.prototype.containsKey=function(txn,key){return PersistencePromise.resolve(this.references.containsKey(key));};return MemoryQueryCache;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function documentSizeMap(){return new SortedMap(DocumentKey.comparator);}var MemoryRemoteDocumentCache=/** @class */function(){/**
     * @param sizer Used to assess the size of a document. For eager GC, this is expected to just
     * return 0 to avoid unnecessarily doing the work of calculating the size.
     */function MemoryRemoteDocumentCache(indexManager,sizer){this.indexManager=indexManager;this.sizer=sizer;this.docs=documentSizeMap();this.newDocumentChanges=documentKeySet();this.size=0;}/**
     * Adds the supplied entries to the cache. Adds the given size delta to the cached size.
     */MemoryRemoteDocumentCache.prototype.addEntries=function(transaction,entries,sizeDelta){var promises=[];for(var _i=0,entries_1=entries;_i<entries_1.length;_i++){var entry=entries_1[_i];var key=entry.maybeDocument.key;this.docs=this.docs.insert(key,entry);this.newDocumentChanges=this.newDocumentChanges.add(key);promises.push(this.indexManager.addToCollectionParentIndex(transaction,key.path.popLast()));}this.size+=sizeDelta;return PersistencePromise.waitFor(promises);};/**
     * Removes the specified entry from the cache and updates the size as appropriate.
     */MemoryRemoteDocumentCache.prototype.removeEntry=function(transaction,documentKey){var entry=this.docs.get(documentKey);if(entry){this.docs=this.docs.remove(documentKey);this.size-=entry.size;return PersistencePromise.resolve(entry.size);}else{return PersistencePromise.resolve(0);}};MemoryRemoteDocumentCache.prototype.getEntry=function(transaction,documentKey){var entry=this.docs.get(documentKey);return PersistencePromise.resolve(entry?entry.maybeDocument:null);};/**
     * Looks up an entry in the cache.
     *
     * @param documentKey The key of the entry to look up.
     * @return The cached MaybeDocument entry and its size, or null if we have nothing cached.
     */MemoryRemoteDocumentCache.prototype.getSizedEntry=function(transaction,documentKey){return PersistencePromise.resolve(this.docs.get(documentKey));};MemoryRemoteDocumentCache.prototype.getEntries=function(transaction,documentKeys){var _this=this;var results=nullableMaybeDocumentMap();documentKeys.forEach(function(documentKey){var entry=_this.docs.get(documentKey);results=results.insert(documentKey,entry?entry.maybeDocument:null);});return PersistencePromise.resolve(results);};/**
     * Looks up several entries in the cache.
     *
     * @param documentKeys The set of keys entries to look up.
     * @return A map of MaybeDocuments indexed by key (if a document cannot be
     *     found, the key will be mapped to null) and a map of sizes indexed by
     *     key (zero if the key cannot be found).
     */MemoryRemoteDocumentCache.prototype.getSizedEntries=function(transaction,documentKeys){var _this=this;var results=nullableMaybeDocumentMap();var sizeMap=new SortedMap(DocumentKey.comparator);documentKeys.forEach(function(documentKey){var entry=_this.docs.get(documentKey);results=results.insert(documentKey,entry?entry.maybeDocument:null);sizeMap=sizeMap.insert(documentKey,entry?entry.size:0);});return PersistencePromise.resolve({maybeDocuments:results,sizeMap:sizeMap});};MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery=function(transaction,query){assert(!query.isCollectionGroupQuery(),'CollectionGroup queries should be handled in LocalDocumentsView');var results=documentMap();// Documents are ordered by key, so we can use a prefix scan to narrow down
// the documents we need to match the query against.
var prefix=new DocumentKey(query.path.child(''));var iterator=this.docs.getIteratorFrom(prefix);while(iterator.hasNext()){var _a=iterator.getNext(),key=_a.key,maybeDocument=_a.value.maybeDocument;if(!query.path.isPrefixOf(key.path)){break;}if(maybeDocument instanceof Document&&query.matches(maybeDocument)){results=results.insert(maybeDocument.key,maybeDocument);}}return PersistencePromise.resolve(results);};MemoryRemoteDocumentCache.prototype.forEachDocumentKey=function(transaction,f){return PersistencePromise.forEach(this.docs,function(key){return f(key);});};MemoryRemoteDocumentCache.prototype.getNewDocumentChanges=function(transaction){var _this=this;var changedDocs=maybeDocumentMap();this.newDocumentChanges.forEach(function(key){var entry=_this.docs.get(key);var changedDoc=entry?entry.maybeDocument:new NoDocument(key,SnapshotVersion.forDeletedDoc());changedDocs=changedDocs.insert(key,changedDoc);});this.newDocumentChanges=documentKeySet();return PersistencePromise.resolve(changedDocs);};MemoryRemoteDocumentCache.prototype.newChangeBuffer=function(){return new MemoryRemoteDocumentChangeBuffer(this.sizer,this);};MemoryRemoteDocumentCache.prototype.getSize=function(txn){return PersistencePromise.resolve(this.size);};return MemoryRemoteDocumentCache;}();/**
 * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.
 */var MemoryRemoteDocumentChangeBuffer=/** @class */function(_super){tslib_1.__extends(MemoryRemoteDocumentChangeBuffer,_super);function MemoryRemoteDocumentChangeBuffer(sizer,documentCache){var _this=_super.call(this)||this;_this.sizer=sizer;_this.documentCache=documentCache;return _this;}MemoryRemoteDocumentChangeBuffer.prototype.applyChanges=function(transaction){var _this=this;var changes=this.assertChanges();var delta=0;var docs=[];changes.forEach(function(key,maybeDocument){var previousSize=_this.documentSizes.get(key);assert(previousSize!==undefined,"Attempting to change document "+key.toString()+" without having read it first");var size=_this.sizer(maybeDocument);delta+=size-previousSize;docs.push({maybeDocument:maybeDocument,size:size});});return this.documentCache.addEntries(transaction,docs,delta);};MemoryRemoteDocumentChangeBuffer.prototype.getFromCache=function(transaction,documentKey){return this.documentCache.getSizedEntry(transaction,documentKey);};MemoryRemoteDocumentChangeBuffer.prototype.getAllFromCache=function(transaction,documentKeys){return this.documentCache.getSizedEntries(transaction,documentKeys);};return MemoryRemoteDocumentChangeBuffer;}(RemoteDocumentChangeBuffer);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$4='MemoryPersistence';/**
 * A memory-backed instance of Persistence. Data is stored only in RAM and
 * not persisted across sessions.
 */var MemoryPersistence=/** @class */function(){/**
     * The constructor accepts a factory for creating a reference delegate. This
     * allows both the delegate and this instance to have strong references to
     * each other without having nullable fields that would then need to be
     * checked or asserted on every access.
     */function MemoryPersistence(clientId,referenceDelegateFactory){var _this=this;this.clientId=clientId;this.mutationQueues={};this.listenSequence=new ListenSequence(0);this._started=false;this._started=true;this.referenceDelegate=referenceDelegateFactory(this);this.queryCache=new MemoryQueryCache(this);var sizer=function(doc){return _this.referenceDelegate.documentSize(doc);};this.indexManager=new MemoryIndexManager();this.remoteDocumentCache=new MemoryRemoteDocumentCache(this.indexManager,sizer);}MemoryPersistence.createLruPersistence=function(clientId,serializer,params){var factory=function(p){return new MemoryLruDelegate(p,new LocalSerializer(serializer),params);};return new MemoryPersistence(clientId,factory);};MemoryPersistence.createEagerPersistence=function(clientId){var factory=function(p){return new MemoryEagerDelegate(p);};return new MemoryPersistence(clientId,factory);};MemoryPersistence.prototype.shutdown=function(){// No durable state to ensure is closed on shutdown.
this._started=false;return Promise.resolve();};Object.defineProperty(MemoryPersistence.prototype,"started",{get:function(){return this._started;},enumerable:true,configurable:true});MemoryPersistence.prototype.getActiveClients=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){return[2/*return*/,[this.clientId]];});});};MemoryPersistence.prototype.setPrimaryStateListener=function(primaryStateListener){// All clients using memory persistence act as primary.
return primaryStateListener(true);};MemoryPersistence.prototype.setNetworkEnabled=function(networkEnabled){// No op.
};MemoryPersistence.prototype.getIndexManager=function(){return this.indexManager;};MemoryPersistence.prototype.getMutationQueue=function(user){var queue=this.mutationQueues[user.toKey()];if(!queue){queue=new MemoryMutationQueue(this.indexManager,this.referenceDelegate);this.mutationQueues[user.toKey()]=queue;}return queue;};MemoryPersistence.prototype.getQueryCache=function(){return this.queryCache;};MemoryPersistence.prototype.getRemoteDocumentCache=function(){return this.remoteDocumentCache;};MemoryPersistence.prototype.runTransaction=function(action,mode,transactionOperation){var _this=this;debug(LOG_TAG$4,'Starting transaction:',action);var txn=new MemoryTransaction(this.listenSequence.next());this.referenceDelegate.onTransactionStarted();return transactionOperation(txn).next(function(result){return _this.referenceDelegate.onTransactionCommitted(txn).next(function(){return result;});}).toPromise();};MemoryPersistence.prototype.mutationQueuesContainKey=function(transaction,key){return PersistencePromise.or(values(this.mutationQueues).map(function(queue){return function(){return queue.containsKey(transaction,key);};}));};return MemoryPersistence;}();/**
 * Memory persistence is not actually transactional, but future implementations
 * may have transaction-scoped state.
 */var MemoryTransaction=/** @class */function(){function MemoryTransaction(currentSequenceNumber){this.currentSequenceNumber=currentSequenceNumber;}return MemoryTransaction;}();var MemoryEagerDelegate=/** @class */function(){function MemoryEagerDelegate(persistence){this.persistence=persistence;}MemoryEagerDelegate.prototype.setInMemoryPins=function(inMemoryPins){this.inMemoryPins=inMemoryPins;};MemoryEagerDelegate.prototype.addReference=function(txn,key){this.orphanedDocuments.delete(key);return PersistencePromise.resolve();};MemoryEagerDelegate.prototype.removeReference=function(txn,key){this.orphanedDocuments.add(key);return PersistencePromise.resolve();};MemoryEagerDelegate.prototype.removeMutationReference=function(txn,key){this.orphanedDocuments.add(key);return PersistencePromise.resolve();};MemoryEagerDelegate.prototype.removeTarget=function(txn,queryData){var _this=this;var cache=this.persistence.getQueryCache();return cache.getMatchingKeysForTargetId(txn,queryData.targetId).next(function(keys){keys.forEach(function(key){return _this.orphanedDocuments.add(key);});}).next(function(){return cache.removeQueryData(txn,queryData);});};MemoryEagerDelegate.prototype.onTransactionStarted=function(){this.orphanedDocuments=new Set();};MemoryEagerDelegate.prototype.onTransactionCommitted=function(txn){var _this=this;var cache=this.persistence.getRemoteDocumentCache();return PersistencePromise.forEach(this.orphanedDocuments,function(key){return _this.isReferenced(txn,key).next(function(isReferenced){if(!isReferenced){// Since this is the eager delegate and memory persistence,
// we don't care about the size of documents. We don't track
// the size of the cache for eager GC.
return cache.removeEntry(txn,key).next(function(){});}return PersistencePromise.resolve();});});};MemoryEagerDelegate.prototype.updateLimboDocument=function(txn,key){var _this=this;return this.isReferenced(txn,key).next(function(isReferenced){if(isReferenced){_this.orphanedDocuments.delete(key);}else{_this.orphanedDocuments.add(key);}});};MemoryEagerDelegate.prototype.documentSize=function(doc){// For eager GC, we don't care about the document size, there are no size thresholds.
return 0;};MemoryEagerDelegate.prototype.isReferenced=function(txn,key){var _this=this;return PersistencePromise.or([function(){return _this.persistence.getQueryCache().containsKey(txn,key);},function(){return _this.persistence.mutationQueuesContainKey(txn,key);},function(){return PersistencePromise.resolve(_this.inMemoryPins.containsKey(key));}]);};return MemoryEagerDelegate;}();var MemoryLruDelegate=/** @class */function(){function MemoryLruDelegate(persistence,serializer,lruParams){this.persistence=persistence;this.serializer=serializer;this.orphanedSequenceNumbers=new ObjectMap(function(k){return encode(k.path);});this.garbageCollector=new LruGarbageCollector(this,lruParams);}// No-ops, present so memory persistence doesn't have to care which delegate
// it has.
MemoryLruDelegate.prototype.onTransactionStarted=function(){};MemoryLruDelegate.prototype.onTransactionCommitted=function(txn){return PersistencePromise.resolve();};MemoryLruDelegate.prototype.forEachTarget=function(txn,f){return this.persistence.getQueryCache().forEachTarget(txn,f);};MemoryLruDelegate.prototype.getSequenceNumberCount=function(txn){var docCountPromise=this.orphanedDocumentCount(txn);var targetCountPromise=this.persistence.getQueryCache().getTargetCount(txn);return targetCountPromise.next(function(targetCount){return docCountPromise.next(function(docCount){return targetCount+docCount;});});};MemoryLruDelegate.prototype.orphanedDocumentCount=function(txn){var orphanedCount=0;return this.forEachOrphanedDocumentSequenceNumber(txn,function(_){orphanedCount++;}).next(function(){return orphanedCount;});};MemoryLruDelegate.prototype.forEachOrphanedDocumentSequenceNumber=function(txn,f){var _this=this;return PersistencePromise.forEach(this.orphanedSequenceNumbers,function(key,sequenceNumber){// Pass in the exact sequence number as the upper bound so we know it won't be pinned by
// being too recent.
return _this.isPinned(txn,key,sequenceNumber).next(function(isPinned){if(!isPinned){return f(sequenceNumber);}else{return PersistencePromise.resolve();}});});};MemoryLruDelegate.prototype.setInMemoryPins=function(inMemoryPins){this.inMemoryPins=inMemoryPins;};MemoryLruDelegate.prototype.removeTargets=function(txn,upperBound,activeTargetIds){return this.persistence.getQueryCache().removeTargets(txn,upperBound,activeTargetIds);};MemoryLruDelegate.prototype.removeOrphanedDocuments=function(txn,upperBound){var _this=this;var count=0;var cache=this.persistence.getRemoteDocumentCache();var p=cache.forEachDocumentKey(txn,function(key){return _this.isPinned(txn,key,upperBound).next(function(isPinned){if(isPinned){return PersistencePromise.resolve();}else{count++;// The memory remote document cache does its own byte
// accounting on removal. This is ok because updating the size
// for memory persistence does not incur IO.
return cache.removeEntry(txn,key).next();}});});return p.next(function(){return count;});};MemoryLruDelegate.prototype.removeMutationReference=function(txn,key){this.orphanedSequenceNumbers.set(key,txn.currentSequenceNumber);return PersistencePromise.resolve();};MemoryLruDelegate.prototype.removeTarget=function(txn,queryData){var updated=queryData.copy({sequenceNumber:txn.currentSequenceNumber});return this.persistence.getQueryCache().updateQueryData(txn,updated);};MemoryLruDelegate.prototype.addReference=function(txn,key){this.orphanedSequenceNumbers.set(key,txn.currentSequenceNumber);return PersistencePromise.resolve();};MemoryLruDelegate.prototype.removeReference=function(txn,key){this.orphanedSequenceNumbers.set(key,txn.currentSequenceNumber);return PersistencePromise.resolve();};MemoryLruDelegate.prototype.updateLimboDocument=function(txn,key){this.orphanedSequenceNumbers.set(key,txn.currentSequenceNumber);return PersistencePromise.resolve();};MemoryLruDelegate.prototype.documentSize=function(maybeDoc){var remoteDocument=this.serializer.toDbRemoteDocument(maybeDoc);var value;if(remoteDocument.document){value=remoteDocument.document;}else if(remoteDocument.unknownDocument){value=remoteDocument.unknownDocument;}else if(remoteDocument.noDocument){value=remoteDocument.noDocument;}else{throw fail('Unknown remote document type');}return JSON.stringify(value).length;};MemoryLruDelegate.prototype.isPinned=function(txn,key,upperBound){var _this=this;return PersistencePromise.or([function(){return _this.persistence.mutationQueuesContainKey(txn,key);},function(){return PersistencePromise.resolve(_this.inMemoryPins.containsKey(key));},function(){return _this.persistence.getQueryCache().containsKey(txn,key);},function(){var orphanedAt=_this.orphanedSequenceNumbers.get(key);return PersistencePromise.resolve(orphanedAt!==undefined&&orphanedAt>upperBound);}]);};MemoryLruDelegate.prototype.getCacheSize=function(txn){return this.persistence.getRemoteDocumentCache().getSize(txn);};return MemoryLruDelegate;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$5='ExponentialBackoff';/**
 * A helper for running delayed tasks following an exponential backoff curve
 * between attempts.
 *
 * Each delay is made up of a "base" delay which follows the exponential
 * backoff curve, and a +/- 50% "jitter" that is calculated and added to the
 * base delay. This prevents clients from accidentally synchronizing their
 * delays causing spikes of load to the backend.
 */var ExponentialBackoff=/** @class */function(){function ExponentialBackoff(/**
     * The AsyncQueue to run backoff operations on.
     */queue,/**
     * The ID to use when scheduling backoff operations on the AsyncQueue.
     */timerId,/**
     * The initial delay (used as the base delay on the first retry attempt).
     * Note that jitter will still be applied, so the actual delay could be as
     * little as 0.5*initialDelayMs.
     */initialDelayMs,/**
     * The multiplier to use to determine the extended base delay after each
     * attempt.
     */backoffFactor,/**
     * The maximum base delay after which no further backoff is performed.
     * Note that jitter will still be applied, so the actual delay could be as
     * much as 1.5*maxDelayMs.
     */maxDelayMs){this.queue=queue;this.timerId=timerId;this.initialDelayMs=initialDelayMs;this.backoffFactor=backoffFactor;this.maxDelayMs=maxDelayMs;this.timerPromise=null;/** The last backoff attempt, as epoch milliseconds. */this.lastAttemptTime=Date.now();this.reset();}/**
     * Resets the backoff delay.
     *
     * The very next backoffAndWait() will have no delay. If it is called again
     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
     * subsequent ones will increase according to the backoffFactor.
     */ExponentialBackoff.prototype.reset=function(){this.currentBaseMs=0;};/**
     * Resets the backoff delay to the maximum delay (e.g. for use after a
     * RESOURCE_EXHAUSTED error).
     */ExponentialBackoff.prototype.resetToMax=function(){this.currentBaseMs=this.maxDelayMs;};/**
     * Returns a promise that resolves after currentDelayMs, and increases the
     * delay for any subsequent attempts. If there was a pending backoff operation
     * already, it will be canceled.
     */ExponentialBackoff.prototype.backoffAndRun=function(op){var _this=this;// Cancel any pending backoff operation.
this.cancel();// First schedule using the current base (which may be 0 and should be
// honored as such).
var desiredDelayWithJitterMs=Math.floor(this.currentBaseMs+this.jitterDelayMs());// Guard against lastAttemptTime being in the future due to a clock change.
var delaySoFarMs=Math.max(0,Date.now()-this.lastAttemptTime);// Guard against the backoff delay already being past.
var remainingDelayMs=Math.max(0,desiredDelayWithJitterMs-delaySoFarMs);if(this.currentBaseMs>0){debug(LOG_TAG$5,"Backing off for "+remainingDelayMs+" ms "+("(base delay: "+this.currentBaseMs+" ms, ")+("delay with jitter: "+desiredDelayWithJitterMs+" ms, ")+("last attempt: "+delaySoFarMs+" ms ago)"));}this.timerPromise=this.queue.enqueueAfterDelay(this.timerId,remainingDelayMs,function(){_this.lastAttemptTime=Date.now();return op();});// Apply backoff factor to determine next delay and ensure it is within
// bounds.
this.currentBaseMs*=this.backoffFactor;if(this.currentBaseMs<this.initialDelayMs){this.currentBaseMs=this.initialDelayMs;}if(this.currentBaseMs>this.maxDelayMs){this.currentBaseMs=this.maxDelayMs;}};ExponentialBackoff.prototype.cancel=function(){if(this.timerPromise!==null){this.timerPromise.cancel();this.timerPromise=null;}};/** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */ExponentialBackoff.prototype.jitterDelayMs=function(){return(Math.random()-0.5)*this.currentBaseMs;};return ExponentialBackoff;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$6='PersistentStream';/**
 * PersistentStream can be in one of 5 states (each described in detail below)
 * based on the following state transition diagram:
 *
 *          start() called             auth & connection succeeded
 * INITIAL ----------------> STARTING -----------------------------> OPEN
 *                             ^  |                                   |
 *                             |  |                    error occurred |
 *                             |  \-----------------------------v-----/
 *                             |                                |
 *                    backoff  |                                |
 *                    elapsed  |              start() called    |
 *                             \--- BACKOFF <---------------- ERROR
 *
 * [any state] --------------------------> INITIAL
 *               stop() called or
 *               idle timer expired
 */var PersistentStreamState;(function(PersistentStreamState){/**
     * The streaming RPC is not yet running and there's no error condition.
     * Calling start() will start the stream immediately without backoff.
     * While in this state isStarted() will return false.
     */PersistentStreamState[PersistentStreamState["Initial"]=0]="Initial";/**
     * The stream is starting, either waiting for an auth token or for the stream
     * to successfully open. While in this state, isStarted() will return true but
     * isOpen() will return false.
     */PersistentStreamState[PersistentStreamState["Starting"]=1]="Starting";/**
     * The streaming RPC is up and running. Requests and responses can flow
     * freely. Both isStarted() and isOpen() will return true.
     */PersistentStreamState[PersistentStreamState["Open"]=2]="Open";/**
     * The stream encountered an error. The next start attempt will back off.
     * While in this state isStarted() will return false.
     */PersistentStreamState[PersistentStreamState["Error"]=3]="Error";/**
     * An in-between state after an error where the stream is waiting before
     * re-starting. After waiting is complete, the stream will try to open.
     * While in this state isStarted() will return true but isOpen() will return
     * false.
     */PersistentStreamState[PersistentStreamState["Backoff"]=4]="Backoff";})(PersistentStreamState||(PersistentStreamState={}));/**
 * Initial backoff time in milliseconds after an error.
 * Set to 1s according to https://cloud.google.com/apis/design/errors.
 */var BACKOFF_INITIAL_DELAY_MS=1000;/** Maximum backoff time in milliseconds */var BACKOFF_MAX_DELAY_MS=60*1000;var BACKOFF_FACTOR=1.5;/** The time a stream stays open after it is marked idle. */var IDLE_TIMEOUT_MS=60*1000;/**
 * A PersistentStream is an abstract base class that represents a streaming RPC
 * to the Firestore backend. It's built on top of the connections own support
 * for streaming RPCs, and adds several critical features for our clients:
 *
 *   - Exponential backoff on failure
 *   - Authentication via CredentialsProvider
 *   - Dispatching all callbacks into the shared worker queue
 *   - Closing idle streams after 60 seconds of inactivity
 *
 * Subclasses of PersistentStream implement serialization of models to and
 * from the JSON representation of the protocol buffers for a specific
 * streaming RPC.
 *
 * ## Starting and Stopping
 *
 * Streaming RPCs are stateful and need to be start()ed before messages can
 * be sent and received. The PersistentStream will call the onOpen() function
 * of the listener once the stream is ready to accept requests.
 *
 * Should a start() fail, PersistentStream will call the registered onClose()
 * listener with a FirestoreError indicating what went wrong.
 *
 * A PersistentStream can be started and stopped repeatedly.
 *
 * Generic types:
 *  SendType: The type of the outgoing message of the underlying
 *    connection stream
 *  ReceiveType: The type of the incoming message of the underlying
 *    connection stream
 *  ListenerType: The type of the listener that will be used for callbacks
 */var PersistentStream=/** @class */function(){function PersistentStream(queue,connectionTimerId,idleTimerId,connection,credentialsProvider,listener){this.queue=queue;this.idleTimerId=idleTimerId;this.connection=connection;this.credentialsProvider=credentialsProvider;this.listener=listener;this.state=PersistentStreamState.Initial;/**
         * A close count that's incremented every time the stream is closed; used by
         * getCloseGuardedDispatcher() to invalidate callbacks that happen after
         * close.
         */this.closeCount=0;this.idleTimer=null;this.stream=null;this.backoff=new ExponentialBackoff(queue,connectionTimerId,BACKOFF_INITIAL_DELAY_MS,BACKOFF_FACTOR,BACKOFF_MAX_DELAY_MS);}/**
     * Returns true if start() has been called and no error has occurred. True
     * indicates the stream is open or in the process of opening (which
     * encompasses respecting backoff, getting auth tokens, and starting the
     * actual RPC). Use isOpen() to determine if the stream is open and ready for
     * outbound requests.
     */PersistentStream.prototype.isStarted=function(){return this.state===PersistentStreamState.Starting||this.state===PersistentStreamState.Open||this.state===PersistentStreamState.Backoff;};/**
     * Returns true if the underlying RPC is open (the onOpen() listener has been
     * called) and the stream is ready for outbound requests.
     */PersistentStream.prototype.isOpen=function(){return this.state===PersistentStreamState.Open;};/**
     * Starts the RPC. Only allowed if isStarted() returns false. The stream is
     * not immediately ready for use: onOpen() will be invoked when the RPC is
     * ready for outbound requests, at which point isOpen() will return true.
     *
     * When start returns, isStarted() will return true.
     */PersistentStream.prototype.start=function(){if(this.state===PersistentStreamState.Error){this.performBackoff();return;}assert(this.state===PersistentStreamState.Initial,'Already started');this.auth();};/**
     * Stops the RPC. This call is idempotent and allowed regardless of the
     * current isStarted() state.
     *
     * When stop returns, isStarted() and isOpen() will both return false.
     */PersistentStream.prototype.stop=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(!this.isStarted())return[3/*break*/,2];return[4/*yield*/,this.close(PersistentStreamState.Initial)];case 1:_a.sent();_a.label=2;case 2:return[2/*return*/];}});});};/**
     * After an error the stream will usually back off on the next attempt to
     * start it. If the error warrants an immediate restart of the stream, the
     * sender can use this to indicate that the receiver should not back off.
     *
     * Each error will call the onClose() listener. That function can decide to
     * inhibit backoff if required.
     */PersistentStream.prototype.inhibitBackoff=function(){assert(!this.isStarted(),'Can only inhibit backoff in a stopped state');this.state=PersistentStreamState.Initial;this.backoff.reset();};/**
     * Marks this stream as idle. If no further actions are performed on the
     * stream for one minute, the stream will automatically close itself and
     * notify the stream's onClose() handler with Status.OK. The stream will then
     * be in a !isStarted() state, requiring the caller to start the stream again
     * before further use.
     *
     * Only streams that are in state 'Open' can be marked idle, as all other
     * states imply pending network operations.
     */PersistentStream.prototype.markIdle=function(){var _this=this;// Starts the idle time if we are in state 'Open' and are not yet already
// running a timer (in which case the previous idle timeout still applies).
if(this.isOpen()&&this.idleTimer===null){this.idleTimer=this.queue.enqueueAfterDelay(this.idleTimerId,IDLE_TIMEOUT_MS,function(){return _this.handleIdleCloseTimer();});}};/** Sends a message to the underlying stream. */PersistentStream.prototype.sendRequest=function(msg){this.cancelIdleCheck();this.stream.send(msg);};/** Called by the idle timer when the stream should close due to inactivity. */PersistentStream.prototype.handleIdleCloseTimer=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){if(this.isOpen()){// When timing out an idle stream there's no reason to force the stream into backoff when
// it restarts so set the stream state to Initial instead of Error.
return[2/*return*/,this.close(PersistentStreamState.Initial)];}return[2/*return*/];});});};/** Marks the stream as active again. */PersistentStream.prototype.cancelIdleCheck=function(){if(this.idleTimer){this.idleTimer.cancel();this.idleTimer=null;}};/**
     * Closes the stream and cleans up as necessary:
     *
     * * closes the underlying GRPC stream;
     * * calls the onClose handler with the given 'error';
     * * sets internal stream state to 'finalState';
     * * adjusts the backoff timer based on the error
     *
     * A new stream can be opened by calling start().
     *
     * @param finalState the intended state of the stream after closing.
     * @param error the error the connection was closed with.
     */PersistentStream.prototype.close=function(finalState,error$1){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:assert(this.isStarted(),'Only started streams should be closed.');assert(finalState===PersistentStreamState.Error||isNullOrUndefined(error$1),"Can't provide an error when not in an error state.");// Cancel any outstanding timers (they're guaranteed not to execute).
this.cancelIdleCheck();this.backoff.cancel();// Invalidates any stream-related callbacks (e.g. from auth or the
// underlying stream), guaranteeing they won't execute.
this.closeCount++;if(finalState!==PersistentStreamState.Error){// If this is an intentional close ensure we don't delay our next connection attempt.
this.backoff.reset();}else if(error$1&&error$1.code===Code.RESOURCE_EXHAUSTED){// Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
error(error$1.toString());error('Using maximum backoff delay to prevent overloading the backend.');this.backoff.resetToMax();}else if(error$1&&error$1.code===Code.UNAUTHENTICATED){// "unauthenticated" error means the token was rejected. Try force refreshing it in case it
// just expired.
this.credentialsProvider.invalidateToken();}// Clean up the underlying stream because we are no longer interested in events.
if(this.stream!==null){this.tearDown();this.stream.close();this.stream=null;}// This state must be assigned before calling onClose() to allow the callback to
// inhibit backoff or otherwise manipulate the state in its non-started state.
this.state=finalState;// Notify the listener that the stream closed.
return[4/*yield*/,this.listener.onClose(error$1)];case 1:// Notify the listener that the stream closed.
_a.sent();return[2/*return*/];}});});};/**
     * Can be overridden to perform additional cleanup before the stream is closed.
     * Calling super.tearDown() is not required.
     */PersistentStream.prototype.tearDown=function(){};PersistentStream.prototype.auth=function(){var _this=this;assert(this.state===PersistentStreamState.Initial,'Must be in initial state to auth');this.state=PersistentStreamState.Starting;var dispatchIfNotClosed=this.getCloseGuardedDispatcher(this.closeCount);// TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.
var closeCount=this.closeCount;this.credentialsProvider.getToken().then(function(token){// Stream can be stopped while waiting for authentication.
// TODO(mikelehen): We really should just use dispatchIfNotClosed
// and let this dispatch onto the queue, but that opened a spec test can
// of worms that I don't want to deal with in this PR.
if(_this.closeCount===closeCount){// Normally we'd have to schedule the callback on the AsyncQueue.
// However, the following calls are safe to be called outside the
// AsyncQueue since they don't chain asynchronous calls
_this.startStream(token);}},function(error){dispatchIfNotClosed(function(){var rpcError=new FirestoreError(Code.UNKNOWN,'Fetching auth token failed: '+error.message);return _this.handleStreamClose(rpcError);});});};PersistentStream.prototype.startStream=function(token){var _this=this;assert(this.state===PersistentStreamState.Starting,'Trying to start stream in a non-starting state');var dispatchIfNotClosed=this.getCloseGuardedDispatcher(this.closeCount);this.stream=this.startRpc(token);this.stream.onOpen(function(){dispatchIfNotClosed(function(){assert(_this.state===PersistentStreamState.Starting,'Expected stream to be in state Starting, but was '+_this.state);_this.state=PersistentStreamState.Open;return _this.listener.onOpen();});});this.stream.onClose(function(error){dispatchIfNotClosed(function(){return _this.handleStreamClose(error);});});this.stream.onMessage(function(msg){dispatchIfNotClosed(function(){return _this.onMessage(msg);});});};PersistentStream.prototype.performBackoff=function(){var _this=this;assert(this.state===PersistentStreamState.Error,'Should only perform backoff when in Error state');this.state=PersistentStreamState.Backoff;this.backoff.backoffAndRun(function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){assert(this.state===PersistentStreamState.Backoff,'Backoff elapsed but state is now: '+this.state);this.state=PersistentStreamState.Initial;this.start();assert(this.isStarted(),'PersistentStream should have started');return[2/*return*/];});});});};// Visible for tests
PersistentStream.prototype.handleStreamClose=function(error){assert(this.isStarted(),"Can't handle server close on non-started stream");debug(LOG_TAG$6,"close with error: "+error);this.stream=null;// In theory the stream could close cleanly, however, in our current model
// we never expect this to happen because if we stop a stream ourselves,
// this callback will never be called. To prevent cases where we retry
// without a backoff accidentally, we set the stream to error in all cases.
return this.close(PersistentStreamState.Error,error);};/**
     * Returns a "dispatcher" function that dispatches operations onto the
     * AsyncQueue but only runs them if closeCount remains unchanged. This allows
     * us to turn auth / stream callbacks into no-ops if the stream is closed /
     * re-opened, etc.
     */PersistentStream.prototype.getCloseGuardedDispatcher=function(startCloseCount){var _this=this;return function(fn){_this.queue.enqueueAndForget(function(){if(_this.closeCount===startCloseCount){return fn();}else{debug(LOG_TAG$6,'stream callback skipped by getCloseGuardedDispatcher.');return Promise.resolve();}});};};return PersistentStream;}();/**
 * A PersistentStream that implements the Listen RPC.
 *
 * Once the Listen stream has called the onOpen() listener, any number of
 * listen() and unlisten() calls can be made to control what changes will be
 * sent from the server for ListenResponses.
 */var PersistentListenStream=/** @class */function(_super){tslib_1.__extends(PersistentListenStream,_super);function PersistentListenStream(queue,connection,credentials,serializer,listener){var _this=_super.call(this,queue,TimerId.ListenStreamConnectionBackoff,TimerId.ListenStreamIdle,connection,credentials,listener)||this;_this.serializer=serializer;return _this;}PersistentListenStream.prototype.startRpc=function(token){return this.connection.openStream('Listen',token);};PersistentListenStream.prototype.onMessage=function(watchChangeProto){// A successful response means the stream is healthy
this.backoff.reset();var watchChange=this.serializer.fromWatchChange(watchChangeProto);var snapshot=this.serializer.versionFromListenResponse(watchChangeProto);return this.listener.onWatchChange(watchChange,snapshot);};/**
     * Registers interest in the results of the given query. If the query
     * includes a resumeToken it will be included in the request. Results that
     * affect the query will be streamed back as WatchChange messages that
     * reference the targetId.
     */PersistentListenStream.prototype.watch=function(queryData){var request={};request.database=this.serializer.encodedDatabaseId;request.addTarget=this.serializer.toTarget(queryData);var labels=this.serializer.toListenRequestLabels(queryData);if(labels){request.labels=labels;}this.sendRequest(request);};/**
     * Unregisters interest in the results of the query associated with the
     * given targetId.
     */PersistentListenStream.prototype.unwatch=function(targetId){var request={};request.database=this.serializer.encodedDatabaseId;request.removeTarget=targetId;this.sendRequest(request);};return PersistentListenStream;}(PersistentStream);/**
 * A Stream that implements the Write RPC.
 *
 * The Write RPC requires the caller to maintain special streamToken
 * state in between calls, to help the server understand which responses the
 * client has processed by the time the next request is made. Every response
 * will contain a streamToken; this value must be passed to the next
 * request.
 *
 * After calling start() on this stream, the next request must be a handshake,
 * containing whatever streamToken is on hand. Once a response to this
 * request is received, all pending mutations may be submitted. When
 * submitting multiple batches of mutations at the same time, it's
 * okay to use the same streamToken for the calls to writeMutations.
 *
 * TODO(b/33271235): Use proto types
 */var PersistentWriteStream=/** @class */function(_super){tslib_1.__extends(PersistentWriteStream,_super);function PersistentWriteStream(queue,connection,credentials,serializer,listener){var _this=_super.call(this,queue,TimerId.WriteStreamConnectionBackoff,TimerId.WriteStreamIdle,connection,credentials,listener)||this;_this.serializer=serializer;_this.handshakeComplete_=false;return _this;}Object.defineProperty(PersistentWriteStream.prototype,"handshakeComplete",{/**
         * Tracks whether or not a handshake has been successfully exchanged and
         * the stream is ready to accept mutations.
         */get:function(){return this.handshakeComplete_;},enumerable:true,configurable:true});// Override of PersistentStream.start
PersistentWriteStream.prototype.start=function(){this.handshakeComplete_=false;_super.prototype.start.call(this);};PersistentWriteStream.prototype.tearDown=function(){if(this.handshakeComplete_){this.writeMutations([]);}};PersistentWriteStream.prototype.startRpc=function(token){return this.connection.openStream('Write',token);};PersistentWriteStream.prototype.onMessage=function(responseProto){// Always capture the last stream token.
assert(!!responseProto.streamToken,'Got a write response without a stream token');this.lastStreamToken=responseProto.streamToken;if(!this.handshakeComplete_){// The first response is always the handshake response
assert(!responseProto.writeResults||responseProto.writeResults.length===0,'Got mutation results for handshake');this.handshakeComplete_=true;return this.listener.onHandshakeComplete();}else{// A successful first write response means the stream is healthy,
// Note, that we could consider a successful handshake healthy, however,
// the write itself might be causing an error we want to back off from.
this.backoff.reset();var results=this.serializer.fromWriteResults(responseProto.writeResults,responseProto.commitTime);var commitVersion=this.serializer.fromVersion(responseProto.commitTime);return this.listener.onMutationResult(commitVersion,results);}};/**
     * Sends an initial streamToken to the server, performing the handshake
     * required to make the StreamingWrite RPC work. Subsequent
     * calls should wait until onHandshakeComplete was called.
     */PersistentWriteStream.prototype.writeHandshake=function(){assert(this.isOpen(),'Writing handshake requires an opened stream');assert(!this.handshakeComplete_,'Handshake already completed');// TODO(dimond): Support stream resumption. We intentionally do not set the
// stream token on the handshake, ignoring any stream token we might have.
var request={};request.database=this.serializer.encodedDatabaseId;this.sendRequest(request);};/** Sends a group of mutations to the Firestore backend to apply. */PersistentWriteStream.prototype.writeMutations=function(mutations){var _this=this;assert(this.isOpen(),'Writing mutations requires an opened stream');assert(this.handshakeComplete_,'Handshake must be complete before writing mutations');assert(this.lastStreamToken.length>0,'Trying to write mutation without a token');var request={// Protos are typed with string, but we support UInt8Array on Node
// tslint:disable-next-line:no-any
streamToken:this.lastStreamToken,writes:mutations.map(function(mutation){return _this.serializer.toMutation(mutation);})};this.sendRequest(request);};return PersistentWriteStream;}(PersistentStream);/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Datastore is a wrapper around the external Google Cloud Datastore grpc API,
 * which provides an interface that is more convenient for the rest of the
 * client SDK architecture to consume.
 */var Datastore=/** @class */function(){function Datastore(queue,connection,credentials,serializer){this.queue=queue;this.connection=connection;this.credentials=credentials;this.serializer=serializer;}Datastore.prototype.newPersistentWriteStream=function(listener){return new PersistentWriteStream(this.queue,this.connection,this.credentials,this.serializer,listener);};Datastore.prototype.newPersistentWatchStream=function(listener){return new PersistentListenStream(this.queue,this.connection,this.credentials,this.serializer,listener);};Datastore.prototype.commit=function(mutations){var _this=this;var params={database:this.serializer.encodedDatabaseId,writes:mutations.map(function(m){return _this.serializer.toMutation(m);})};return this.invokeRPC('Commit',params).then(function(response){return _this.serializer.fromWriteResults(response.writeResults,response.commitTime);});};Datastore.prototype.lookup=function(keys){var _this=this;var params={database:this.serializer.encodedDatabaseId,documents:keys.map(function(k){return _this.serializer.toName(k);})};return this.invokeStreamingRPC('BatchGetDocuments',params).then(function(response){var docs=maybeDocumentMap();response.forEach(function(proto){var doc=_this.serializer.fromMaybeDocument(proto);docs=docs.insert(doc.key,doc);});var result=[];keys.forEach(function(key){var doc=docs.get(key);assert(!!doc,'Missing entity in write response for '+key);result.push(doc);});return result;});};/** Gets an auth token and invokes the provided RPC. */Datastore.prototype.invokeRPC=function(rpcName,request){var _this=this;return this.credentials.getToken().then(function(token){return _this.connection.invokeRPC(rpcName,request,token);}).catch(function(error){if(error.code===Code.UNAUTHENTICATED){_this.credentials.invalidateToken();}throw error;});};/** Gets an auth token and invokes the provided RPC with streamed results. */Datastore.prototype.invokeStreamingRPC=function(rpcName,request){var _this=this;return this.credentials.getToken().then(function(token){return _this.connection.invokeStreamingRPC(rpcName,request,token);}).catch(function(error){if(error.code===Code.UNAUTHENTICATED){_this.credentials.invalidateToken();}throw error;});};return Datastore;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Internal transaction object responsible for accumulating the mutations to
 * perform and the base versions for any documents read.
 */var Transaction=/** @class */function(){function Transaction(datastore){this.datastore=datastore;// The version of each document that was read during this transaction.
this.readVersions=documentVersionMap();this.mutations=[];this.committed=false;}Transaction.prototype.recordVersion=function(doc){var docVersion;if(doc instanceof Document){docVersion=doc.version;}else if(doc instanceof NoDocument){// For deleted docs, we must use baseVersion 0 when we overwrite them.
docVersion=SnapshotVersion.forDeletedDoc();}else{throw fail('Document in a transaction was a '+doc.constructor.name);}var existingVersion=this.readVersions.get(doc.key);if(existingVersion!==null){if(!docVersion.isEqual(existingVersion)){// This transaction will fail no matter what.
throw new FirestoreError(Code.ABORTED,'Document version changed between two reads.');}}else{this.readVersions=this.readVersions.insert(doc.key,docVersion);}};Transaction.prototype.lookup=function(keys){var _this=this;if(this.committed){return Promise.reject('Transaction has already completed.');}if(this.mutations.length>0){return Promise.reject('Transactions lookups are invalid after writes.');}return this.datastore.lookup(keys).then(function(docs){docs.forEach(function(doc){if(doc instanceof NoDocument||doc instanceof Document){_this.recordVersion(doc);}else{fail('Document in a transaction was a '+doc.constructor.name);}});return docs;});};Transaction.prototype.write=function(mutations){if(this.committed){throw new FirestoreError(Code.FAILED_PRECONDITION,'Transaction has already completed.');}this.mutations=this.mutations.concat(mutations);};/**
     * Returns the version of this document when it was read in this transaction,
     * as a precondition, or no precondition if it was not read.
     */Transaction.prototype.precondition=function(key){var version=this.readVersions.get(key);if(version){return Precondition.updateTime(version);}else{return Precondition.NONE;}};/**
     * Returns the precondition for a document if the operation is an update.
     */Transaction.prototype.preconditionForUpdate=function(key){var version=this.readVersions.get(key);if(version&&version.isEqual(SnapshotVersion.forDeletedDoc())){// The document doesn't exist, so fail the transaction.
throw new FirestoreError(Code.FAILED_PRECONDITION,"Can't update a document that doesn't exist.");}else if(version){// Document exists, base precondition on document update time.
return Precondition.updateTime(version);}else{// Document was not read, so we just use the preconditions for a blind
// update.
return Precondition.exists(true);}};Transaction.prototype.set=function(key,data){this.write(data.toMutations(key,this.precondition(key)));};Transaction.prototype.update=function(key,data){this.write(data.toMutations(key,this.preconditionForUpdate(key)));};Transaction.prototype.delete=function(key){this.write([new DeleteMutation(key,this.precondition(key))]);// Since the delete will be applied before all following writes, we need to
// ensure that the precondition for the next write will be exists: false.
this.readVersions=this.readVersions.insert(key,SnapshotVersion.forDeletedDoc());};Transaction.prototype.commit=function(){var _this=this;var unwritten=this.readVersions;// For each mutation, note that the doc was written.
this.mutations.forEach(function(mutation){unwritten=unwritten.remove(mutation.key);});if(!unwritten.isEmpty()){return Promise.reject(Error('Every document read in a transaction must also be written.'));}return this.datastore.commit(this.mutations).then(function(){_this.committed=true;});};return Transaction;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Describes the online state of the Firestore client. Note that this does not
 * indicate whether or not the remote store is trying to connect or not. This is
 * primarily used by the View / EventManager code to change their behavior while
 * offline (e.g. get() calls shouldn't wait for data from the server and
 * snapshot events should set metadata.isFromCache=true).
 */var OnlineState;(function(OnlineState){/**
     * The Firestore client is in an unknown online state. This means the client
     * is either not actively trying to establish a connection or it is currently
     * trying to establish a connection, but it has not succeeded or failed yet.
     * Higher-level components should not operate in offline mode.
     */OnlineState[OnlineState["Unknown"]=0]="Unknown";/**
     * The client is connected and the connections are healthy. This state is
     * reached after a successful connection and there has been at least one
     * successful message received from the backends.
     */OnlineState[OnlineState["Online"]=1]="Online";/**
     * The client is either trying to establish a connection but failing, or it
     * has been explicitly marked offline via a call to disableNetwork().
     * Higher-level components should operate in offline mode.
     */OnlineState[OnlineState["Offline"]=2]="Offline";})(OnlineState||(OnlineState={}));/** The source of an online state event. */var OnlineStateSource;(function(OnlineStateSource){OnlineStateSource[OnlineStateSource["RemoteStore"]=0]="RemoteStore";OnlineStateSource[OnlineStateSource["SharedClientState"]=1]="SharedClientState";})(OnlineStateSource||(OnlineStateSource={}));/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$7='OnlineStateTracker';// To deal with transient failures, we allow multiple stream attempts before
// giving up and transitioning from OnlineState.Unknown to Offline.
// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.
// @jdimond thinks that bug is sufficiently fixed so that we can set this back
// to 1. If that works okay, we could potentially remove this logic entirely.
var MAX_WATCH_STREAM_FAILURES=1;// To deal with stream attempts that don't succeed or fail in a timely manner,
// we have a timeout for OnlineState to reach Online or Offline.
// If the timeout is reached, we transition to Offline rather than waiting
// indefinitely.
var ONLINE_STATE_TIMEOUT_MS=10*1000;/**
 * A component used by the RemoteStore to track the OnlineState (that is,
 * whether or not the client as a whole should be considered to be online or
 * offline), implementing the appropriate heuristics.
 *
 * In particular, when the client is trying to connect to the backend, we
 * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for
 * a connection to succeed. If we have too many failures or the timeout elapses,
 * then we set the OnlineState to Offline, and the client will behave as if
 * it is offline (get()s will return cached data, etc.).
 */var OnlineStateTracker=/** @class */function(){function OnlineStateTracker(asyncQueue,onlineStateHandler){this.asyncQueue=asyncQueue;this.onlineStateHandler=onlineStateHandler;/** The current OnlineState. */this.state=OnlineState.Unknown;/**
         * A count of consecutive failures to open the stream. If it reaches the
         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
         * Offline.
         */this.watchStreamFailures=0;/**
         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
         * transition from OnlineState.Unknown to OnlineState.Offline without waiting
         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
         */this.onlineStateTimer=null;/**
         * Whether the client should log a warning message if it fails to connect to
         * the backend (initially true, cleared after a successful stream, or if we've
         * logged the message already).
         */this.shouldWarnClientIsOffline=true;}/**
     * Called by RemoteStore when a watch stream is started (including on each
     * backoff attempt).
     *
     * If this is the first attempt, it sets the OnlineState to Unknown and starts
     * the onlineStateTimer.
     */OnlineStateTracker.prototype.handleWatchStreamStart=function(){var _this=this;if(this.watchStreamFailures===0){this.setAndBroadcast(OnlineState.Unknown);assert(this.onlineStateTimer===null,"onlineStateTimer shouldn't be started yet");this.onlineStateTimer=this.asyncQueue.enqueueAfterDelay(TimerId.OnlineStateTimeout,ONLINE_STATE_TIMEOUT_MS,function(){_this.onlineStateTimer=null;assert(_this.state===OnlineState.Unknown,'Timer should be canceled if we transitioned to a different state.');_this.logClientOfflineWarningIfNecessary("Backend didn't respond within "+ONLINE_STATE_TIMEOUT_MS/1000+" "+"seconds.");_this.setAndBroadcast(OnlineState.Offline);// NOTE: handleWatchStreamFailure() will continue to increment
// watchStreamFailures even though we are already marked Offline,
// but this is non-harmful.
return Promise.resolve();});}};/**
     * Updates our OnlineState as appropriate after the watch stream reports a
     * failure. The first failure moves us to the 'Unknown' state. We then may
     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
     * actually transition to the 'Offline' state.
     */OnlineStateTracker.prototype.handleWatchStreamFailure=function(error){if(this.state===OnlineState.Online){this.setAndBroadcast(OnlineState.Unknown);// To get to OnlineState.Online, set() must have been called which would
// have reset our heuristics.
assert(this.watchStreamFailures===0,'watchStreamFailures must be 0');assert(this.onlineStateTimer===null,'onlineStateTimer must be null');}else{this.watchStreamFailures++;if(this.watchStreamFailures>=MAX_WATCH_STREAM_FAILURES){this.clearOnlineStateTimer();this.logClientOfflineWarningIfNecessary("Connection failed "+MAX_WATCH_STREAM_FAILURES+" "+("times. Most recent error: "+error.toString()));this.setAndBroadcast(OnlineState.Offline);}}};/**
     * Explicitly sets the OnlineState to the specified state.
     *
     * Note that this resets our timers / failure counters, etc. used by our
     * Offline heuristics, so must not be used in place of
     * handleWatchStreamStart() and handleWatchStreamFailure().
     */OnlineStateTracker.prototype.set=function(newState){this.clearOnlineStateTimer();this.watchStreamFailures=0;if(newState===OnlineState.Online){// We've connected to watch at least once. Don't warn the developer
// about being offline going forward.
this.shouldWarnClientIsOffline=false;}this.setAndBroadcast(newState);};OnlineStateTracker.prototype.setAndBroadcast=function(newState){if(newState!==this.state){this.state=newState;this.onlineStateHandler(newState);}};OnlineStateTracker.prototype.logClientOfflineWarningIfNecessary=function(details){var message="Could not reach Cloud Firestore backend. "+details+"\n"+"This typically indicates that your device does not have a healthy "+"Internet connection at the moment. The client will operate in offline "+"mode until it is able to successfully connect to the backend.";if(this.shouldWarnClientIsOffline){error(message);this.shouldWarnClientIsOffline=false;}else{debug(LOG_TAG$7,message);}};OnlineStateTracker.prototype.clearOnlineStateTimer=function(){if(this.onlineStateTimer!==null){this.onlineStateTimer.cancel();this.onlineStateTimer=null;}};return OnlineStateTracker;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$8='RemoteStore';// TODO(b/35853402): Negotiate this with the stream.
var MAX_PENDING_WRITES=10;/**
 * RemoteStore - An interface to remotely stored data, basically providing a
 * wrapper around the Datastore that is more reliable for the rest of the
 * system.
 *
 * RemoteStore is responsible for maintaining the connection to the server.
 * - maintaining a list of active listens.
 * - reconnecting when the connection is dropped.
 * - resuming all the active listens on reconnect.
 *
 * RemoteStore handles all incoming events from the Datastore.
 * - listening to the watch stream and repackaging the events as RemoteEvents
 * - notifying SyncEngine of any changes to the active listens.
 *
 * RemoteStore takes writes from other components and handles them reliably.
 * - pulling pending mutations from LocalStore and sending them to Datastore.
 * - retrying mutations that failed because of network problems.
 * - acking mutations to the SyncEngine once they are accepted or rejected.
 */var RemoteStore=/** @class */function(){function RemoteStore(/**
     * The local store, used to fill the write pipeline with outbound mutations.
     */localStore,/** The client-side proxy for interacting with the backend. */datastore,asyncQueue,onlineStateHandler){this.localStore=localStore;this.datastore=datastore;/**
         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
         * LocalStore via fillWritePipeline() and have or will send to the write
         * stream.
         *
         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
         * restart the write stream. When the stream is established the writes in the
         * pipeline will be sent in order.
         *
         * Writes remain in writePipeline until they are acknowledged by the backend
         * and thus will automatically be re-sent if the stream is interrupted /
         * restarted before they're acknowledged.
         *
         * Write responses from the backend are linked to their originating request
         * purely based on order, and so we can just shift() writes from the front of
         * the writePipeline as we receive responses.
         */this.writePipeline=[];/**
         * A mapping of watched targets that the client cares about tracking and the
         * user has explicitly called a 'listen' for this target.
         *
         * These targets may or may not have been sent to or acknowledged by the
         * server. On re-establishing the listen stream, these targets should be sent
         * to the server. The targets removed with unlistens are removed eagerly
         * without waiting for confirmation from the listen stream.
         */this.listenTargets={};this.watchChangeAggregator=null;/**
         * Set to true by enableNetwork() and false by disableNetwork() and indicates
         * the user-preferred network state.
         */this.networkEnabled=false;this.isPrimary=false;this.onlineStateTracker=new OnlineStateTracker(asyncQueue,onlineStateHandler);// Create streams (but note they're not started yet).
this.watchStream=this.datastore.newPersistentWatchStream({onOpen:this.onWatchStreamOpen.bind(this),onClose:this.onWatchStreamClose.bind(this),onWatchChange:this.onWatchStreamChange.bind(this)});this.writeStream=this.datastore.newPersistentWriteStream({onOpen:this.onWriteStreamOpen.bind(this),onClose:this.onWriteStreamClose.bind(this),onHandshakeComplete:this.onWriteHandshakeComplete.bind(this),onMutationResult:this.onMutationResult.bind(this)});}/**
     * Starts up the remote store, creating streams, restoring state from
     * LocalStore, etc.
     */RemoteStore.prototype.start=function(){return this.enableNetwork();};/** Re-enables the network. Idempotent. */RemoteStore.prototype.enableNetwork=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){var _a;return tslib_1.__generator(this,function(_b){switch(_b.label){case 0:this.networkEnabled=true;if(!this.canUseNetwork())return[3/*break*/,3];_a=this.writeStream;return[4/*yield*/,this.localStore.getLastStreamToken()];case 1:_a.lastStreamToken=_b.sent();if(this.shouldStartWatchStream()){this.startWatchStream();}else{this.onlineStateTracker.set(OnlineState.Unknown);}// This will start the write stream if necessary.
return[4/*yield*/,this.fillWritePipeline()];case 2:// This will start the write stream if necessary.
_b.sent();_b.label=3;case 3:return[2/*return*/];}});});};/**
     * Temporarily disables the network. The network can be re-enabled using
     * enableNetwork().
     */RemoteStore.prototype.disableNetwork=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:this.networkEnabled=false;return[4/*yield*/,this.disableNetworkInternal()];case 1:_a.sent();// Set the OnlineState to Offline so get()s return from cache, etc.
this.onlineStateTracker.set(OnlineState.Offline);return[2/*return*/];}});});};RemoteStore.prototype.disableNetworkInternal=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.writeStream.stop()];case 1:_a.sent();return[4/*yield*/,this.watchStream.stop()];case 2:_a.sent();if(this.writePipeline.length>0){debug(LOG_TAG$8,"Stopping write stream with "+this.writePipeline.length+" pending writes");this.writePipeline=[];}this.cleanUpWatchStreamState();return[2/*return*/];}});});};RemoteStore.prototype.shutdown=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:debug(LOG_TAG$8,'RemoteStore shutting down.');this.networkEnabled=false;return[4/*yield*/,this.disableNetworkInternal()];case 1:_a.sent();// Set the OnlineState to Unknown (rather than Offline) to avoid potentially
// triggering spurious listener events with cached data, etc.
this.onlineStateTracker.set(OnlineState.Unknown);return[2/*return*/];}});});};/** Starts new listen for the given query. Uses resume token if provided */RemoteStore.prototype.listen=function(queryData){assert(!contains(this.listenTargets,queryData.targetId),'listen called with duplicate targetId!');// Mark this as something the client is currently listening for.
this.listenTargets[queryData.targetId]=queryData;if(this.shouldStartWatchStream()){// The listen will be sent in onWatchStreamOpen
this.startWatchStream();}else if(this.watchStream.isOpen()){this.sendWatchRequest(queryData);}};/** Removes the listen from server */RemoteStore.prototype.unlisten=function(targetId){assert(contains(this.listenTargets,targetId),'unlisten called without assigned target ID!');delete this.listenTargets[targetId];if(this.watchStream.isOpen()){this.sendUnwatchRequest(targetId);}if(isEmpty(this.listenTargets)){if(this.watchStream.isOpen()){this.watchStream.markIdle();}else if(this.canUseNetwork()){// Revert to OnlineState.Unknown if the watch stream is not open and we
// have no listeners, since without any listens to send we cannot
// confirm if the stream is healthy and upgrade to OnlineState.Online.
this.onlineStateTracker.set(OnlineState.Unknown);}}};/** {@link TargetMetadataProvider.getQueryDataForTarget} */RemoteStore.prototype.getQueryDataForTarget=function(targetId){return this.listenTargets[targetId]||null;};/** {@link TargetMetadataProvider.getRemoteKeysForTarget} */RemoteStore.prototype.getRemoteKeysForTarget=function(targetId){return this.syncEngine.getRemoteKeysForTarget(targetId);};/**
     * We need to increment the the expected number of pending responses we're due
     * from watch so we wait for the ack to process any messages from this target.
     */RemoteStore.prototype.sendWatchRequest=function(queryData){this.watchChangeAggregator.recordPendingTargetRequest(queryData.targetId);this.watchStream.watch(queryData);};/**
     * We need to increment the expected number of pending responses we're due
     * from watch so we wait for the removal on the server before we process any
     * messages from this target.
     */RemoteStore.prototype.sendUnwatchRequest=function(targetId){this.watchChangeAggregator.recordPendingTargetRequest(targetId);this.watchStream.unwatch(targetId);};RemoteStore.prototype.startWatchStream=function(){assert(this.shouldStartWatchStream(),'startWatchStream() called when shouldStartWatchStream() is false.');this.watchChangeAggregator=new WatchChangeAggregator(this);this.watchStream.start();this.onlineStateTracker.handleWatchStreamStart();};/**
     * Returns whether the watch stream should be started because it's necessary
     * and has not yet been started.
     */RemoteStore.prototype.shouldStartWatchStream=function(){return this.canUseNetwork()&&!this.watchStream.isStarted()&&!isEmpty(this.listenTargets);};RemoteStore.prototype.canUseNetwork=function(){return this.isPrimary&&this.networkEnabled;};RemoteStore.prototype.cleanUpWatchStreamState=function(){this.watchChangeAggregator=null;};RemoteStore.prototype.onWatchStreamOpen=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){var _this=this;return tslib_1.__generator(this,function(_a){forEachNumber(this.listenTargets,function(targetId,queryData){_this.sendWatchRequest(queryData);});return[2/*return*/];});});};RemoteStore.prototype.onWatchStreamClose=function(error){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){if(error===undefined){// Graceful stop (due to stop() or idle timeout). Make sure that's
// desirable.
assert(!this.shouldStartWatchStream(),'Watch stream was stopped gracefully while still needed.');}this.cleanUpWatchStreamState();// If we still need the watch stream, retry the connection.
if(this.shouldStartWatchStream()){this.onlineStateTracker.handleWatchStreamFailure(error);this.startWatchStream();}else{// No need to restart watch stream because there are no active targets.
// The online state is set to unknown because there is no active attempt
// at establishing a connection
this.onlineStateTracker.set(OnlineState.Unknown);}return[2/*return*/];});});};RemoteStore.prototype.onWatchStreamChange=function(watchChange,snapshotVersion){return tslib_1.__awaiter(this,void 0,void 0,function(){var lastRemoteSnapshotVersion;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:// Mark the client as online since we got a message from the server
this.onlineStateTracker.set(OnlineState.Online);if(watchChange instanceof WatchTargetChange&&watchChange.state===WatchTargetChangeState.Removed&&watchChange.cause){// There was an error on a target, don't wait for a consistent snapshot
// to raise events
return[2/*return*/,this.handleTargetError(watchChange)];}if(watchChange instanceof DocumentWatchChange){this.watchChangeAggregator.handleDocumentChange(watchChange);}else if(watchChange instanceof ExistenceFilterChange){this.watchChangeAggregator.handleExistenceFilter(watchChange);}else{assert(watchChange instanceof WatchTargetChange,'Expected watchChange to be an instance of WatchTargetChange');this.watchChangeAggregator.handleTargetChange(watchChange);}if(!!snapshotVersion.isEqual(SnapshotVersion.MIN))return[3/*break*/,3];return[4/*yield*/,this.localStore.getLastRemoteSnapshotVersion()];case 1:lastRemoteSnapshotVersion=_a.sent();if(!(snapshotVersion.compareTo(lastRemoteSnapshotVersion)>=0))return[3/*break*/,3];// We have received a target change with a global snapshot if the snapshot
// version is not equal to SnapshotVersion.MIN.
return[4/*yield*/,this.raiseWatchSnapshot(snapshotVersion)];case 2:// We have received a target change with a global snapshot if the snapshot
// version is not equal to SnapshotVersion.MIN.
_a.sent();_a.label=3;case 3:return[2/*return*/];}});});};/**
     * Takes a batch of changes from the Datastore, repackages them as a
     * RemoteEvent, and passes that on to the listener, which is typically the
     * SyncEngine.
     */RemoteStore.prototype.raiseWatchSnapshot=function(snapshotVersion){var _this=this;assert(!snapshotVersion.isEqual(SnapshotVersion.MIN),"Can't raise event for unknown SnapshotVersion");var remoteEvent=this.watchChangeAggregator.createRemoteEvent(snapshotVersion);// Update in-memory resume tokens. LocalStore will update the
// persistent view of these when applying the completed RemoteEvent.
forEachNumber(remoteEvent.targetChanges,function(targetId,change){if(change.resumeToken.length>0){var queryData=_this.listenTargets[targetId];// A watched target might have been removed already.
if(queryData){_this.listenTargets[targetId]=queryData.copy({resumeToken:change.resumeToken,snapshotVersion:snapshotVersion});}}});// Re-establish listens for the targets that have been invalidated by
// existence filter mismatches.
remoteEvent.targetMismatches.forEach(function(targetId){var queryData=_this.listenTargets[targetId];if(!queryData){// A watched target might have been removed already.
return;}// Clear the resume token for the query, since we're in a known mismatch
// state.
_this.listenTargets[targetId]=queryData.copy({resumeToken:emptyByteString()});// Cause a hard reset by unwatching and rewatching immediately, but
// deliberately don't send a resume token so that we get a full update.
_this.sendUnwatchRequest(targetId);// Mark the query we send as being on behalf of an existence filter
// mismatch, but don't actually retain that in listenTargets. This ensures
// that we flag the first re-listen this way without impacting future
// listens of this target (that might happen e.g. on reconnect).
var requestQueryData=new QueryData(queryData.query,targetId,QueryPurpose.ExistenceFilterMismatch,queryData.sequenceNumber);_this.sendWatchRequest(requestQueryData);});// Finally raise remote event
return this.syncEngine.applyRemoteEvent(remoteEvent);};/** Handles an error on a target */RemoteStore.prototype.handleTargetError=function(watchChange){var _this=this;assert(!!watchChange.cause,'Handling target error without a cause');var error=watchChange.cause;var promiseChain=Promise.resolve();watchChange.targetIds.forEach(function(targetId){promiseChain=promiseChain.then(function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){// A watched target might have been removed already.
if(contains(this.listenTargets,targetId)){delete this.listenTargets[targetId];this.watchChangeAggregator.removeTarget(targetId);return[2/*return*/,this.syncEngine.rejectListen(targetId,error)];}return[2/*return*/];});});});});return promiseChain;};/**
     * Attempts to fill our write pipeline with writes from the LocalStore.
     *
     * Called internally to bootstrap or refill the write pipeline and by
     * SyncEngine whenever there are new mutations to process.
     *
     * Starts the write stream if necessary.
     */RemoteStore.prototype.fillWritePipeline=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){var lastBatchIdRetrieved,batch;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(!this.canAddToWritePipeline())return[3/*break*/,4];lastBatchIdRetrieved=this.writePipeline.length>0?this.writePipeline[this.writePipeline.length-1].batchId:BATCHID_UNKNOWN;return[4/*yield*/,this.localStore.nextMutationBatch(lastBatchIdRetrieved)];case 1:batch=_a.sent();if(!(batch===null))return[3/*break*/,2];if(this.writePipeline.length===0){this.writeStream.markIdle();}return[3/*break*/,4];case 2:this.addToWritePipeline(batch);return[4/*yield*/,this.fillWritePipeline()];case 3:_a.sent();_a.label=4;case 4:if(this.shouldStartWriteStream()){this.startWriteStream();}return[2/*return*/];}});});};/**
     * Returns true if we can add to the write pipeline (i.e. the network is
     * enabled and the write pipeline is not full).
     */RemoteStore.prototype.canAddToWritePipeline=function(){return this.canUseNetwork()&&this.writePipeline.length<MAX_PENDING_WRITES;};// For testing
RemoteStore.prototype.outstandingWrites=function(){return this.writePipeline.length;};/**
     * Queues additional writes to be sent to the write stream, sending them
     * immediately if the write stream is established.
     */RemoteStore.prototype.addToWritePipeline=function(batch){assert(this.canAddToWritePipeline(),'addToWritePipeline called when pipeline is full');this.writePipeline.push(batch);if(this.writeStream.isOpen()&&this.writeStream.handshakeComplete){this.writeStream.writeMutations(batch.mutations);}};RemoteStore.prototype.shouldStartWriteStream=function(){return this.canUseNetwork()&&!this.writeStream.isStarted()&&this.writePipeline.length>0;};RemoteStore.prototype.startWriteStream=function(){assert(this.shouldStartWriteStream(),'startWriteStream() called when shouldStartWriteStream() is false.');this.writeStream.start();};RemoteStore.prototype.onWriteStreamOpen=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){this.writeStream.writeHandshake();return[2/*return*/];});});};RemoteStore.prototype.onWriteHandshakeComplete=function(){var _this=this;// Record the stream token.
return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function(){// Send the write pipeline now that the stream is established.
for(var _i=0,_a=_this.writePipeline;_i<_a.length;_i++){var batch=_a[_i];_this.writeStream.writeMutations(batch.mutations);}}).catch(ignoreIfPrimaryLeaseLoss);};RemoteStore.prototype.onMutationResult=function(commitVersion,results){var _this=this;// This is a response to a write containing mutations and should be
// correlated to the first write in our write pipeline.
assert(this.writePipeline.length>0,'Got result for empty write pipeline');var batch=this.writePipeline.shift();var success=MutationBatchResult.from(batch,commitVersion,results,this.writeStream.lastStreamToken);return this.syncEngine.applySuccessfulWrite(success).then(function(){// It's possible that with the completion of this mutation another
// slot has freed up.
return _this.fillWritePipeline();});};RemoteStore.prototype.onWriteStreamClose=function(error){return tslib_1.__awaiter(this,void 0,void 0,function(){var errorHandling;var _this=this;return tslib_1.__generator(this,function(_a){if(error===undefined){// Graceful stop (due to stop() or idle timeout). Make sure that's
// desirable.
assert(!this.shouldStartWriteStream(),'Write stream was stopped gracefully while still needed.');}// If the write stream closed due to an error, invoke the error callbacks if
// there are pending writes.
if(error&&this.writePipeline.length>0){errorHandling=void 0;if(this.writeStream.handshakeComplete){// This error affects the actual write.
errorHandling=this.handleWriteError(error);}else{// If there was an error before the handshake has finished, it's
// possible that the server is unable to process the stream token
// we're sending. (Perhaps it's too old?)
errorHandling=this.handleHandshakeError(error);}return[2/*return*/,errorHandling.then(function(){// The write stream might have been started by refilling the write
// pipeline for failed writes
if(_this.shouldStartWriteStream()){_this.startWriteStream();}})];}return[2/*return*/];});});};RemoteStore.prototype.handleHandshakeError=function(error){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){// Reset the token if it's a permanent error, signaling the write stream is
// no longer valid. Note that the handshake does not count as a write: see
// comments on isPermanentWriteError for details.
if(isPermanentError(error.code)){debug(LOG_TAG$8,'RemoteStore error before completed handshake; resetting stream token: ',this.writeStream.lastStreamToken);this.writeStream.lastStreamToken=emptyByteString();return[2/*return*/,this.localStore.setLastStreamToken(emptyByteString()).catch(ignoreIfPrimaryLeaseLoss)];}return[2/*return*/];});});};RemoteStore.prototype.handleWriteError=function(error){return tslib_1.__awaiter(this,void 0,void 0,function(){var batch;var _this=this;return tslib_1.__generator(this,function(_a){// Only handle permanent errors here. If it's transient, just let the retry
// logic kick in.
if(isPermanentWriteError(error.code)){batch=this.writePipeline.shift();// In this case it's also unlikely that the server itself is melting
// down -- this was just a bad request so inhibit backoff on the next
// restart.
this.writeStream.inhibitBackoff();return[2/*return*/,this.syncEngine.rejectFailedWrite(batch.batchId,error).then(function(){// It's possible that with the completion of this mutation
// another slot has freed up.
return _this.fillWritePipeline();})];}return[2/*return*/];});});};RemoteStore.prototype.createTransaction=function(){return new Transaction(this.datastore);};RemoteStore.prototype.handleCredentialChange=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(!this.canUseNetwork())return[3/*break*/,3];// Tear down and re-create our network streams. This will ensure we get a fresh auth token
// for the new user and re-fill the write pipeline with new mutations from the LocalStore
// (since mutations are per-user).
debug(LOG_TAG$8,'RemoteStore restarting streams for new credential');this.networkEnabled=false;return[4/*yield*/,this.disableNetworkInternal()];case 1:_a.sent();this.onlineStateTracker.set(OnlineState.Unknown);return[4/*yield*/,this.enableNetwork()];case 2:_a.sent();_a.label=3;case 3:return[2/*return*/];}});});};/**
     * Toggles the network state when the client gains or loses its primary lease.
     */RemoteStore.prototype.applyPrimaryState=function(isPrimary){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:this.isPrimary=isPrimary;if(!(isPrimary&&this.networkEnabled))return[3/*break*/,2];return[4/*yield*/,this.enableNetwork()];case 1:_a.sent();return[3/*break*/,4];case 2:if(!!isPrimary)return[3/*break*/,4];return[4/*yield*/,this.disableNetworkInternal()];case 3:_a.sent();this.onlineStateTracker.set(OnlineState.Unknown);_a.label=4;case 4:return[2/*return*/];}});});};return RemoteStore;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Holds the listeners and the last received ViewSnapshot for a query being
 * tracked by EventManager.
 */var QueryListenersInfo=/** @class */function(){function QueryListenersInfo(){this.listeners=[];}return QueryListenersInfo;}();/**
 * EventManager is responsible for mapping queries to query event emitters.
 * It handles "fan-out". -- Identical queries will re-use the same watch on the
 * backend.
 */var EventManager=/** @class */function(){function EventManager(syncEngine){this.syncEngine=syncEngine;this.queries=new ObjectMap(function(q){return q.canonicalId();});this.onlineState=OnlineState.Unknown;this.syncEngine.subscribe(this);}EventManager.prototype.listen=function(listener){var query=listener.query;var firstListen=false;var queryInfo=this.queries.get(query);if(!queryInfo){firstListen=true;queryInfo=new QueryListenersInfo();this.queries.set(query,queryInfo);}queryInfo.listeners.push(listener);listener.applyOnlineStateChange(this.onlineState);if(queryInfo.viewSnap)listener.onViewSnapshot(queryInfo.viewSnap);if(firstListen){return this.syncEngine.listen(query).then(function(targetId){queryInfo.targetId=targetId;return targetId;});}else{return Promise.resolve(queryInfo.targetId);}};EventManager.prototype.unlisten=function(listener){return tslib_1.__awaiter(this,void 0,void 0,function(){var query,lastListen,queryInfo,i;return tslib_1.__generator(this,function(_a){query=listener.query;lastListen=false;queryInfo=this.queries.get(query);if(queryInfo){i=queryInfo.listeners.indexOf(listener);if(i>=0){queryInfo.listeners.splice(i,1);lastListen=queryInfo.listeners.length===0;}}if(lastListen){this.queries.delete(query);return[2/*return*/,this.syncEngine.unlisten(query)];}return[2/*return*/];});});};EventManager.prototype.onWatchChange=function(viewSnaps){for(var _i=0,viewSnaps_1=viewSnaps;_i<viewSnaps_1.length;_i++){var viewSnap=viewSnaps_1[_i];var query=viewSnap.query;var queryInfo=this.queries.get(query);if(queryInfo){for(var _a=0,_b=queryInfo.listeners;_a<_b.length;_a++){var listener=_b[_a];listener.onViewSnapshot(viewSnap);}queryInfo.viewSnap=viewSnap;}}};EventManager.prototype.onWatchError=function(query,error){var queryInfo=this.queries.get(query);if(queryInfo){for(var _i=0,_a=queryInfo.listeners;_i<_a.length;_i++){var listener=_a[_i];listener.onError(error);}}// Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()
// after an error.
this.queries.delete(query);};EventManager.prototype.onOnlineStateChange=function(onlineState){this.onlineState=onlineState;this.queries.forEach(function(_,queryInfo){for(var _i=0,_a=queryInfo.listeners;_i<_a.length;_i++){var listener=_a[_i];listener.applyOnlineStateChange(onlineState);}});};return EventManager;}();/**
 * QueryListener takes a series of internal view snapshots and determines
 * when to raise the event.
 *
 * It uses an Observer to dispatch events.
 */var QueryListener=/** @class */function(){function QueryListener(query,queryObserver,options){this.query=query;this.queryObserver=queryObserver;/**
         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
         * observer. This flag is set to true once we've actually raised an event.
         */this.raisedInitialEvent=false;this.onlineState=OnlineState.Unknown;this.options=options||{};}QueryListener.prototype.onViewSnapshot=function(snap){assert(snap.docChanges.length>0||snap.syncStateChanged,'We got a new snapshot with no changes?');if(!this.options.includeMetadataChanges){// Remove the metadata only changes.
var docChanges=[];for(var _i=0,_a=snap.docChanges;_i<_a.length;_i++){var docChange=_a[_i];if(docChange.type!==ChangeType.Metadata){docChanges.push(docChange);}}snap=new ViewSnapshot(snap.query,snap.docs,snap.oldDocs,docChanges,snap.mutatedKeys,snap.fromCache,snap.syncStateChanged,/* excludesMetadataChanges= */true);}if(!this.raisedInitialEvent){if(this.shouldRaiseInitialEvent(snap,this.onlineState)){this.raiseInitialEvent(snap);}}else if(this.shouldRaiseEvent(snap)){this.queryObserver.next(snap);}this.snap=snap;};QueryListener.prototype.onError=function(error){this.queryObserver.error(error);};QueryListener.prototype.applyOnlineStateChange=function(onlineState){this.onlineState=onlineState;if(this.snap&&!this.raisedInitialEvent&&this.shouldRaiseInitialEvent(this.snap,onlineState)){this.raiseInitialEvent(this.snap);}};QueryListener.prototype.shouldRaiseInitialEvent=function(snap,onlineState){assert(!this.raisedInitialEvent,'Determining whether to raise first event but already had first event');// Always raise the first event when we're synced
if(!snap.fromCache){return true;}// NOTE: We consider OnlineState.Unknown as online (it should become Offline
// or Online if we wait long enough).
var maybeOnline=onlineState!==OnlineState.Offline;// Don't raise the event if we're online, aren't synced yet (checked
// above) and are waiting for a sync.
if(this.options.waitForSyncWhenOnline&&maybeOnline){assert(snap.fromCache,'Waiting for sync, but snapshot is not from cache');return false;}// Raise data from cache if we have any documents or we are offline
return!snap.docs.isEmpty()||onlineState===OnlineState.Offline;};QueryListener.prototype.shouldRaiseEvent=function(snap){// We don't need to handle includeDocumentMetadataChanges here because
// the Metadata only changes have already been stripped out if needed.
// At this point the only changes we will see are the ones we should
// propagate.
if(snap.docChanges.length>0){return true;}var hasPendingWritesChanged=this.snap&&this.snap.hasPendingWrites!==snap.hasPendingWrites;if(snap.syncStateChanged||hasPendingWritesChanged){return this.options.includeMetadataChanges===true;}// Generally we should have hit one of the cases above, but it's possible
// to get here if there were only metadata docChanges and they got
// stripped out.
return false;};QueryListener.prototype.raiseInitialEvent=function(snap){assert(!this.raisedInitialEvent,'Trying to raise initial events for second time');snap=ViewSnapshot.fromInitialDocuments(snap.query,snap.docs,snap.mutatedKeys,snap.fromCache);this.raisedInitialEvent=true;this.queryObserver.next(snap);};return QueryListener;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * A set of changes to what documents are currently in view and out of view for
 * a given query. These changes are sent to the LocalStore by the View (via
 * the SyncEngine) and are used to pin / unpin documents as appropriate.
 */var LocalViewChanges=/** @class */function(){function LocalViewChanges(targetId,addedKeys,removedKeys){this.targetId=targetId;this.addedKeys=addedKeys;this.removedKeys=removedKeys;}LocalViewChanges.fromSnapshot=function(targetId,viewSnapshot){var addedKeys=documentKeySet();var removedKeys=documentKeySet();for(var _i=0,_a=viewSnapshot.docChanges;_i<_a.length;_i++){var docChange=_a[_i];switch(docChange.type){case ChangeType.Added:addedKeys=addedKeys.add(docChange.doc.key);break;case ChangeType.Removed:removedKeys=removedKeys.add(docChange.doc.key);break;default:// do nothing
}}return new LocalViewChanges(targetId,addedKeys,removedKeys);};return LocalViewChanges;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var AddedLimboDocument=/** @class */function(){function AddedLimboDocument(key){this.key=key;}return AddedLimboDocument;}();var RemovedLimboDocument=/** @class */function(){function RemovedLimboDocument(key){this.key=key;}return RemovedLimboDocument;}();/**
 * View is responsible for computing the final merged truth of what docs are in
 * a query. It gets notified of local and remote changes to docs, and applies
 * the query filters and limits to determine the most correct possible results.
 */var View=/** @class */function(){function View(query,/** Documents included in the remote target */_syncedDocuments){this.query=query;this._syncedDocuments=_syncedDocuments;this.syncState=null;/**
         * A flag whether the view is current with the backend. A view is considered
         * current after it has seen the current flag from the backend and did not
         * lose consistency within the watch stream (e.g. because of an existence
         * filter mismatch).
         */this.current=false;/** Documents in the view but not in the remote target */this.limboDocuments=documentKeySet();/** Document Keys that have local changes */this.mutatedKeys=documentKeySet();this.documentSet=new DocumentSet(query.docComparator.bind(query));}Object.defineProperty(View.prototype,"syncedDocuments",{/**
         * The set of remote documents that the server has told us belongs to the target associated with
         * this view.
         */get:function(){return this._syncedDocuments;},enumerable:true,configurable:true});/**
     * Iterates over a set of doc changes, applies the query limit, and computes
     * what the new results should be, what the changes were, and whether we may
     * need to go back to the local cache for more results. Does not make any
     * changes to the view.
     * @param docChanges The doc changes to apply to this view.
     * @param previousChanges If this is being called with a refill, then start
     *        with this set of docs and changes instead of the current view.
     * @return a new set of docs, changes, and refill flag.
     */View.prototype.computeDocChanges=function(docChanges,previousChanges){var _this=this;var changeSet=previousChanges?previousChanges.changeSet:new DocumentChangeSet();var oldDocumentSet=previousChanges?previousChanges.documentSet:this.documentSet;var newMutatedKeys=previousChanges?previousChanges.mutatedKeys:this.mutatedKeys;var newDocumentSet=oldDocumentSet;var needsRefill=false;// Track the last doc in a (full) limit. This is necessary, because some
// update (a delete, or an update moving a doc past the old limit) might
// mean there is some other document in the local cache that either should
// come (1) between the old last limit doc and the new last document, in the
// case of updates, or (2) after the new last document, in the case of
// deletes. So we keep this doc at the old limit to compare the updates to.
//
// Note that this should never get used in a refill (when previousChanges is
// set), because there will only be adds -- no deletes or updates.
var lastDocInLimit=this.query.hasLimit()&&oldDocumentSet.size===this.query.limit?oldDocumentSet.last():null;docChanges.inorderTraversal(function(key,newMaybeDoc){var oldDoc=oldDocumentSet.get(key);var newDoc=newMaybeDoc instanceof Document?newMaybeDoc:null;if(newDoc){assert(key.isEqual(newDoc.key),'Mismatching keys found in document changes: '+key+' != '+newDoc.key);newDoc=_this.query.matches(newDoc)?newDoc:null;}var oldDocHadPendingMutations=oldDoc?_this.mutatedKeys.has(oldDoc.key):false;var newDocHasPendingMutations=newDoc?newDoc.hasLocalMutations||// We only consider committed mutations for documents that were
// mutated during the lifetime of the view.
_this.mutatedKeys.has(newDoc.key)&&newDoc.hasCommittedMutations:false;var changeApplied=false;// Calculate change
if(oldDoc&&newDoc){var docsEqual=oldDoc.data.isEqual(newDoc.data);if(!docsEqual){if(!_this.shouldWaitForSyncedDocument(oldDoc,newDoc)){changeSet.track({type:ChangeType.Modified,doc:newDoc});changeApplied=true;if(lastDocInLimit&&_this.query.docComparator(newDoc,lastDocInLimit)>0){// This doc moved from inside the limit to after the limit.
// That means there may be some doc in the local cache that's
// actually less than this one.
needsRefill=true;}}}else if(oldDocHadPendingMutations!==newDocHasPendingMutations){changeSet.track({type:ChangeType.Metadata,doc:newDoc});changeApplied=true;}}else if(!oldDoc&&newDoc){changeSet.track({type:ChangeType.Added,doc:newDoc});changeApplied=true;}else if(oldDoc&&!newDoc){changeSet.track({type:ChangeType.Removed,doc:oldDoc});changeApplied=true;if(lastDocInLimit){// A doc was removed from a full limit query. We'll need to
// requery from the local cache to see if we know about some other
// doc that should be in the results.
needsRefill=true;}}if(changeApplied){if(newDoc){newDocumentSet=newDocumentSet.add(newDoc);if(newDocHasPendingMutations){newMutatedKeys=newMutatedKeys.add(key);}else{newMutatedKeys=newMutatedKeys.delete(key);}}else{newDocumentSet=newDocumentSet.delete(key);newMutatedKeys=newMutatedKeys.delete(key);}}});if(this.query.hasLimit()){while(newDocumentSet.size>this.query.limit){var oldDoc=newDocumentSet.last();newDocumentSet=newDocumentSet.delete(oldDoc.key);newMutatedKeys=newMutatedKeys.delete(oldDoc.key);changeSet.track({type:ChangeType.Removed,doc:oldDoc});}}assert(!needsRefill||!previousChanges,'View was refilled using docs that themselves needed refilling.');return{documentSet:newDocumentSet,changeSet:changeSet,needsRefill:needsRefill,mutatedKeys:newMutatedKeys};};View.prototype.shouldWaitForSyncedDocument=function(oldDoc,newDoc){// We suppress the initial change event for documents that were modified as
// part of a write acknowledgment (e.g. when the value of a server transform
// is applied) as Watch will send us the same document again.
// By suppressing the event, we only raise two user visible events (one with
// `hasPendingWrites` and the final state of the document) instead of three
// (one with `hasPendingWrites`, the modified document with
// `hasPendingWrites` and the final state of the document).
return oldDoc.hasLocalMutations&&newDoc.hasCommittedMutations&&!newDoc.hasLocalMutations;};/**
     * Updates the view with the given ViewDocumentChanges and optionally updates
     * limbo docs and sync state from the provided target change.
     * @param docChanges The set of changes to make to the view's docs.
     * @param updateLimboDocuments Whether to update limbo documents based on this
     *        change.
     * @param targetChange A target change to apply for computing limbo docs and
     *        sync state.
     * @return A new ViewChange with the given docs, changes, and sync state.
     */// PORTING NOTE: The iOS/Android clients always compute limbo document changes.
View.prototype.applyChanges=function(docChanges,updateLimboDocuments,targetChange){var _this=this;assert(!docChanges.needsRefill,'Cannot apply changes that need a refill');var oldDocs=this.documentSet;this.documentSet=docChanges.documentSet;this.mutatedKeys=docChanges.mutatedKeys;// Sort changes based on type and query comparator
var changes=docChanges.changeSet.getChanges();changes.sort(function(c1,c2){return compareChangeType(c1.type,c2.type)||_this.query.docComparator(c1.doc,c2.doc);});this.applyTargetChange(targetChange);var limboChanges=updateLimboDocuments?this.updateLimboDocuments():[];var synced=this.limboDocuments.size===0&&this.current;var newSyncState=synced?SyncState.Synced:SyncState.Local;var syncStateChanged=newSyncState!==this.syncState;this.syncState=newSyncState;if(changes.length===0&&!syncStateChanged){// no changes
return{limboChanges:limboChanges};}else{var snap=new ViewSnapshot(this.query,docChanges.documentSet,oldDocs,changes,docChanges.mutatedKeys,newSyncState===SyncState.Local,syncStateChanged,/* excludesMetadataChanges= */false);return{snapshot:snap,limboChanges:limboChanges};}};/**
     * Applies an OnlineState change to the view, potentially generating a
     * ViewChange if the view's syncState changes as a result.
     */View.prototype.applyOnlineStateChange=function(onlineState){if(this.current&&onlineState===OnlineState.Offline){// If we're offline, set `current` to false and then call applyChanges()
// to refresh our syncState and generate a ViewChange as appropriate. We
// are guaranteed to get a new TargetChange that sets `current` back to
// true once the client is back online.
this.current=false;return this.applyChanges({documentSet:this.documentSet,changeSet:new DocumentChangeSet(),mutatedKeys:this.mutatedKeys,needsRefill:false},/* updateLimboDocuments= */false);}else{// No effect, just return a no-op ViewChange.
return{limboChanges:[]};}};/**
     * Returns whether the doc for the given key should be in limbo.
     */View.prototype.shouldBeInLimbo=function(key){// If the remote end says it's part of this query, it's not in limbo.
if(this._syncedDocuments.has(key)){return false;}// The local store doesn't think it's a result, so it shouldn't be in limbo.
if(!this.documentSet.has(key)){return false;}// If there are local changes to the doc, they might explain why the server
// doesn't know that it's part of the query. So don't put it in limbo.
// TODO(klimt): Ideally, we would only consider changes that might actually
// affect this specific query.
if(this.documentSet.get(key).hasLocalMutations){return false;}// Everything else is in limbo.
return true;};/**
     * Updates syncedDocuments, current, and limbo docs based on the given change.
     * Returns the list of changes to which docs are in limbo.
     */View.prototype.applyTargetChange=function(targetChange){var _this=this;if(targetChange){targetChange.addedDocuments.forEach(function(key){return _this._syncedDocuments=_this._syncedDocuments.add(key);});targetChange.modifiedDocuments.forEach(function(key){return assert(_this._syncedDocuments.has(key),"Modified document "+key+" not found in view.");});targetChange.removedDocuments.forEach(function(key){return _this._syncedDocuments=_this._syncedDocuments.delete(key);});this.current=targetChange.current;}};View.prototype.updateLimboDocuments=function(){var _this=this;// We can only determine limbo documents when we're in-sync with the server.
if(!this.current){return[];}// TODO(klimt): Do this incrementally so that it's not quadratic when
// updating many documents.
var oldLimboDocuments=this.limboDocuments;this.limboDocuments=documentKeySet();this.documentSet.forEach(function(doc){if(_this.shouldBeInLimbo(doc.key)){_this.limboDocuments=_this.limboDocuments.add(doc.key);}});// Diff the new limbo docs with the old limbo docs.
var changes=[];oldLimboDocuments.forEach(function(key){if(!_this.limboDocuments.has(key)){changes.push(new RemovedLimboDocument(key));}});this.limboDocuments.forEach(function(key){if(!oldLimboDocuments.has(key)){changes.push(new AddedLimboDocument(key));}});return changes;};/**
     * Update the in-memory state of the current view with the state read from
     * persistence.
     *
     * We update the query view whenever a client's primary status changes:
     * - When a client transitions from primary to secondary, it can miss
     *   LocalStorage updates and its query views may temporarily not be
     *   synchronized with the state on disk.
     * - For secondary to primary transitions, the client needs to update the list
     *   of `syncedDocuments` since secondary clients update their query views
     *   based purely on synthesized RemoteEvents.
     *
     * @param localDocs - The documents that match the query according to the
     * LocalStore.
     * @param remoteKeys - The keys of the documents that match the query
     * according to the backend.
     *
     * @return The ViewChange that resulted from this synchronization.
     */// PORTING NOTE: Multi-tab only.
View.prototype.synchronizeWithPersistedState=function(localDocs,remoteKeys){this._syncedDocuments=remoteKeys;this.limboDocuments=documentKeySet();var docChanges=this.computeDocChanges(localDocs);return this.applyChanges(docChanges,/*updateLimboDocuments=*/true);};/**
     * Returns a view snapshot as if this query was just listened to. Contains
     * a document add for every existing document and the `fromCache` and
     * `hasPendingWrites` status of the already established view.
     */// PORTING NOTE: Multi-tab only.
View.prototype.computeInitialSnapshot=function(){return ViewSnapshot.fromInitialDocuments(this.query,this.documentSet,this.mutatedKeys,this.syncState===SyncState.Local);};return View;}();function compareChangeType(c1,c2){var order=function(change){switch(change){case ChangeType.Added:return 1;case ChangeType.Modified:return 2;case ChangeType.Metadata:// A metadata change is converted to a modified change at the public
// api layer.  Since we sort by document key and then change type,
// metadata and modified changes must be sorted equivalently.
return 2;case ChangeType.Removed:return 0;default:return fail('Unknown ChangeType: '+change);}};return order(c1)-order(c2);}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$9='SyncEngine';/**
 * QueryView contains all of the data that SyncEngine needs to keep track of for
 * a particular query.
 */var QueryView=/** @class */function(){function QueryView(/**
     * The query itself.
     */query,/**
     * The target number created by the client that is used in the watch
     * stream to identify this query.
     */targetId,/**
     * The view is responsible for computing the final merged truth of what
     * docs are in the query. It gets notified of local and remote changes,
     * and applies the query filters and limits to determine the most correct
     * possible results.
     */view){this.query=query;this.targetId=targetId;this.view=view;}return QueryView;}();/** Tracks a limbo resolution. */var LimboResolution=/** @class */function(){function LimboResolution(key){this.key=key;}return LimboResolution;}();/**
 * SyncEngine is the central controller in the client SDK architecture. It is
 * the glue code between the EventManager, LocalStore, and RemoteStore. Some of
 * SyncEngine's responsibilities include:
 * 1. Coordinating client requests and remote events between the EventManager
 *    and the local and remote data stores.
 * 2. Managing a View object for each query, providing the unified view between
 *    the local and remote data stores.
 * 3. Notifying the RemoteStore when the LocalStore has new mutations in its
 *    queue that need sending to the backend.
 *
 * The SyncEngine’s methods should only ever be called by methods running in the
 * global async queue.
 */var SyncEngine=/** @class */function(){function SyncEngine(localStore,remoteStore,// PORTING NOTE: Manages state synchronization in multi-tab environments.
sharedClientState,currentUser){this.localStore=localStore;this.remoteStore=remoteStore;this.sharedClientState=sharedClientState;this.currentUser=currentUser;this.syncEngineListener=null;this.queryViewsByQuery=new ObjectMap(function(q){return q.canonicalId();});this.queryViewsByTarget={};this.limboTargetsByKey=new SortedMap(DocumentKey.comparator);this.limboResolutionsByTarget={};this.limboDocumentRefs=new ReferenceSet();/** Stores user completion handlers, indexed by User and BatchId. */this.mutationUserCallbacks={};this.limboTargetIdGenerator=TargetIdGenerator.forSyncEngine();// The primary state is set to `true` or `false` immediately after Firestore
// startup. In the interim, a client should only be considered primary if
// `isPrimary` is true.
this.isPrimary=undefined;this.onlineState=OnlineState.Unknown;}Object.defineProperty(SyncEngine.prototype,"isPrimaryClient",{// Only used for testing.
get:function(){return this.isPrimary===true;},enumerable:true,configurable:true});/** Subscribes to SyncEngine notifications. Has to be called exactly once. */SyncEngine.prototype.subscribe=function(syncEngineListener){assert(syncEngineListener!==null,'SyncEngine listener cannot be null');assert(this.syncEngineListener===null,'SyncEngine already has a subscriber.');this.syncEngineListener=syncEngineListener;};/**
     * Initiates the new listen, resolves promise when listen enqueued to the
     * server. All the subsequent view snapshots or errors are sent to the
     * subscribed handlers. Returns the targetId of the query.
     */SyncEngine.prototype.listen=function(query){return tslib_1.__awaiter(this,void 0,void 0,function(){var targetId,viewSnapshot,queryView,queryData,status_1;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:this.assertSubscribed('listen()');queryView=this.queryViewsByQuery.get(query);if(!queryView)return[3/*break*/,1];// PORTING NOTE: With Multi-Tab Web, it is possible that a query view
// already exists when EventManager calls us for the first time. This
// happens when the primary tab is already listening to this query on
// behalf of another tab and the user of the primary also starts listening
// to the query. EventManager will not have an assigned target ID in this
// case and calls `listen` to obtain this ID.
targetId=queryView.targetId;this.sharedClientState.addLocalQueryTarget(targetId);viewSnapshot=queryView.view.computeInitialSnapshot();return[3/*break*/,4];case 1:return[4/*yield*/,this.localStore.allocateQuery(query)];case 2:queryData=_a.sent();status_1=this.sharedClientState.addLocalQueryTarget(queryData.targetId);targetId=queryData.targetId;return[4/*yield*/,this.initializeViewAndComputeSnapshot(queryData,status_1==='current')];case 3:viewSnapshot=_a.sent();if(this.isPrimary){this.remoteStore.listen(queryData);}_a.label=4;case 4:this.syncEngineListener.onWatchChange([viewSnapshot]);return[2/*return*/,targetId];}});});};/**
     * Registers a view for a previously unknown query and computes its initial
     * snapshot.
     */SyncEngine.prototype.initializeViewAndComputeSnapshot=function(queryData,current){var _this=this;var query=queryData.query;return this.localStore.executeQuery(query).then(function(docs){return _this.localStore.remoteDocumentKeys(queryData.targetId).then(function(remoteKeys){var view=new View(query,remoteKeys);var viewDocChanges=view.computeDocChanges(docs);// tslint:disable-next-line:max-line-length Prettier formats this exceed 100 characters.
var synthesizedTargetChange=TargetChange.createSynthesizedTargetChangeForCurrentChange(queryData.targetId,current&&_this.onlineState!==OnlineState.Offline);var viewChange=view.applyChanges(viewDocChanges,/* updateLimboDocuments= */_this.isPrimary===true,synthesizedTargetChange);assert(viewChange.limboChanges.length===0,'View returned limbo docs before target ack from the server.');assert(!!viewChange.snapshot,'applyChanges for new view should always return a snapshot');var data=new QueryView(query,queryData.targetId,view);_this.queryViewsByQuery.set(query,data);_this.queryViewsByTarget[queryData.targetId]=data;return viewChange.snapshot;});});};/**
     * Reconcile the list of synced documents in an existing view with those
     * from persistence.
     */// PORTING NOTE: Multi-tab only.
SyncEngine.prototype.synchronizeViewAndComputeSnapshot=function(queryView){var _this=this;return this.localStore.executeQuery(queryView.query).then(function(docs){return _this.localStore.remoteDocumentKeys(queryView.targetId).then(function(remoteKeys){return tslib_1.__awaiter(_this,void 0,void 0,function(){var viewSnapshot;return tslib_1.__generator(this,function(_a){viewSnapshot=queryView.view.synchronizeWithPersistedState(docs,remoteKeys);if(this.isPrimary){this.updateTrackedLimbos(queryView.targetId,viewSnapshot.limboChanges);}return[2/*return*/,viewSnapshot];});});});});};/** Stops listening to the query. */SyncEngine.prototype.unlisten=function(query){return tslib_1.__awaiter(this,void 0,void 0,function(){var queryView,targetRemainsActive;var _this=this;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:this.assertSubscribed('unlisten()');queryView=this.queryViewsByQuery.get(query);assert(!!queryView,'Trying to unlisten on query not found:'+query);if(!this.isPrimary)return[3/*break*/,3];// We need to remove the local query target first to allow us to verify
// whether any other client is still interested in this target.
this.sharedClientState.removeLocalQueryTarget(queryView.targetId);targetRemainsActive=this.sharedClientState.isActiveQueryTarget(queryView.targetId);if(!!targetRemainsActive)return[3/*break*/,2];return[4/*yield*/,this.localStore.releaseQuery(query,/*keepPersistedQueryData=*/false).then(function(){_this.sharedClientState.clearQueryState(queryView.targetId);_this.remoteStore.unlisten(queryView.targetId);_this.removeAndCleanupQuery(queryView);}).catch(ignoreIfPrimaryLeaseLoss)];case 1:_a.sent();_a.label=2;case 2:return[3/*break*/,5];case 3:this.removeAndCleanupQuery(queryView);return[4/*yield*/,this.localStore.releaseQuery(query,/*keepPersistedQueryData=*/true)];case 4:_a.sent();_a.label=5;case 5:return[2/*return*/];}});});};/**
     * Initiates the write of local mutation batch which involves adding the
     * writes to the mutation queue, notifying the remote store about new
     * mutations and raising events for any changes this write caused.
     *
     * The promise returned by this call is resolved when the above steps
     * have completed, *not* when the write was acked by the backend. The
     * userCallback is resolved once the write was acked/rejected by the
     * backend (or failed locally for any other reason).
     */SyncEngine.prototype.write=function(batch,userCallback){var _this=this;this.assertSubscribed('write()');return this.localStore.localWrite(batch).then(function(result){_this.sharedClientState.addPendingMutation(result.batchId);_this.addMutationCallback(result.batchId,userCallback);return _this.emitNewSnapsAndNotifyLocalStore(result.changes);}).then(function(){return _this.remoteStore.fillWritePipeline();});};// TODO(klimt): Wrap the given error in a standard Firestore error object.
SyncEngine.prototype.wrapUpdateFunctionError=function(error){return error;};/**
     * Takes an updateFunction in which a set of reads and writes can be performed
     * atomically. In the updateFunction, the client can read and write values
     * using the supplied transaction object. After the updateFunction, all
     * changes will be committed. If some other client has changed any of the data
     * referenced, then the updateFunction will be called again. If the
     * updateFunction still fails after the given number of retries, then the
     * transaction will be rejection.
     *
     * The transaction object passed to the updateFunction contains methods for
     * accessing documents and collections. Unlike other datastore access, data
     * accessed with the transaction will not reflect local changes that have not
     * been committed. For this reason, it is required that all reads are
     * performed before any writes. Transactions must be performed while online.
     *
     * The promise returned is resolved when the transaction is fully committed.
     */SyncEngine.prototype.runTransaction=function(updateFunction,retries){var _this=this;if(retries===void 0){retries=5;}assert(retries>=0,'Got negative number of retries for transaction.');var transaction=this.remoteStore.createTransaction();var wrappedUpdateFunction=function(){try{var userPromise=updateFunction(transaction);if(isNullOrUndefined(userPromise)||!userPromise.catch||!userPromise.then){return Promise.reject(Error('Transaction callback must return a Promise'));}return userPromise.catch(function(e){return Promise.reject(_this.wrapUpdateFunctionError(e));});}catch(e){return Promise.reject(_this.wrapUpdateFunctionError(e));}};return wrappedUpdateFunction().then(function(result){return transaction.commit().then(function(){return result;}).catch(function(error){if(retries===0){return Promise.reject(error);}// TODO(klimt): Put in a retry delay?
return _this.runTransaction(updateFunction,retries-1);});});};SyncEngine.prototype.applyRemoteEvent=function(remoteEvent){var _this=this;this.assertSubscribed('applyRemoteEvent()');return this.localStore.applyRemoteEvent(remoteEvent).then(function(changes){// Update `receivedDocument` as appropriate for any limbo targets.
forEach(remoteEvent.targetChanges,function(targetId,targetChange){var limboResolution=_this.limboResolutionsByTarget[targetId];if(limboResolution){// Since this is a limbo resolution lookup, it's for a single document
// and it could be added, modified, or removed, but not a combination.
assert(targetChange.addedDocuments.size+targetChange.modifiedDocuments.size+targetChange.removedDocuments.size<=1,'Limbo resolution for single document contains multiple changes.');if(targetChange.addedDocuments.size>0){limboResolution.receivedDocument=true;}else if(targetChange.modifiedDocuments.size>0){assert(limboResolution.receivedDocument,'Received change for limbo target document without add.');}else if(targetChange.removedDocuments.size>0){assert(limboResolution.receivedDocument,'Received remove for limbo target document without add.');limboResolution.receivedDocument=false;}}});return _this.emitNewSnapsAndNotifyLocalStore(changes,remoteEvent);}).catch(ignoreIfPrimaryLeaseLoss);};/**
     * Applies an OnlineState change to the sync engine and notifies any views of
     * the change.
     */SyncEngine.prototype.applyOnlineStateChange=function(onlineState,source){// If we are the secondary client, we explicitly ignore the remote store's
// online state (the local client may go offline, even though the primary
// tab remains online) and only apply the primary tab's online state from
// SharedClientState.
if(this.isPrimary&&source===OnlineStateSource.RemoteStore||!this.isPrimary&&source===OnlineStateSource.SharedClientState){var newViewSnapshots_1=[];this.queryViewsByQuery.forEach(function(query,queryView){var viewChange=queryView.view.applyOnlineStateChange(onlineState);assert(viewChange.limboChanges.length===0,'OnlineState should not affect limbo documents.');if(viewChange.snapshot){newViewSnapshots_1.push(viewChange.snapshot);}});this.syncEngineListener.onOnlineStateChange(onlineState);this.syncEngineListener.onWatchChange(newViewSnapshots_1);this.onlineState=onlineState;if(this.isPrimary){this.sharedClientState.setOnlineState(onlineState);}}};SyncEngine.prototype.rejectListen=function(targetId,err){return tslib_1.__awaiter(this,void 0,void 0,function(){var limboResolution,limboKey,documentUpdates,resolvedLimboDocuments,event_1,queryView_1;var _this=this;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:this.assertSubscribed('rejectListens()');// PORTING NOTE: Multi-tab only.
this.sharedClientState.updateQueryState(targetId,'rejected',err);limboResolution=this.limboResolutionsByTarget[targetId];limboKey=limboResolution&&limboResolution.key;if(!limboKey)return[3/*break*/,1];// Since this query failed, we won't want to manually unlisten to it.
// So go ahead and remove it from bookkeeping.
this.limboTargetsByKey=this.limboTargetsByKey.remove(limboKey);delete this.limboResolutionsByTarget[targetId];documentUpdates=new SortedMap(DocumentKey.comparator);documentUpdates=documentUpdates.insert(limboKey,new NoDocument(limboKey,SnapshotVersion.forDeletedDoc()));resolvedLimboDocuments=documentKeySet().add(limboKey);event_1=new RemoteEvent(SnapshotVersion.MIN,/* targetChanges= */{},/* targetMismatches= */new SortedSet(primitiveComparator),documentUpdates,resolvedLimboDocuments);return[2/*return*/,this.applyRemoteEvent(event_1)];case 1:queryView_1=this.queryViewsByTarget[targetId];assert(!!queryView_1,'Unknown targetId: '+targetId);return[4/*yield*/,this.localStore.releaseQuery(queryView_1.query,/* keepPersistedQueryData */false).then(function(){return _this.removeAndCleanupQuery(queryView_1);}).catch(ignoreIfPrimaryLeaseLoss)];case 2:_a.sent();this.syncEngineListener.onWatchError(queryView_1.query,err);_a.label=3;case 3:return[2/*return*/];}});});};// PORTING NOTE: Multi-tab only
SyncEngine.prototype.applyBatchState=function(batchId,batchState,error){return tslib_1.__awaiter(this,void 0,void 0,function(){var documents;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:this.assertSubscribed('applyBatchState()');return[4/*yield*/,this.localStore.lookupMutationDocuments(batchId)];case 1:documents=_a.sent();if(documents===null){// A throttled tab may not have seen the mutation before it was completed
// and removed from the mutation queue, in which case we won't have cached
// the affected documents. In this case we can safely ignore the update
// since that means we didn't apply the mutation locally at all (if we
// had, we would have cached the affected documents), and so we will just
// see any resulting document changes via normal remote document updates
// as applicable.
debug(LOG_TAG$9,'Cannot apply mutation batch with id: '+batchId);return[2/*return*/];}if(!(batchState==='pending'))return[3/*break*/,3];// If we are the primary client, we need to send this write to the
// backend. Secondary clients will ignore these writes since their remote
// connection is disabled.
return[4/*yield*/,this.remoteStore.fillWritePipeline()];case 2:// If we are the primary client, we need to send this write to the
// backend. Secondary clients will ignore these writes since their remote
// connection is disabled.
_a.sent();return[3/*break*/,4];case 3:if(batchState==='acknowledged'||batchState==='rejected'){// NOTE: Both these methods are no-ops for batches that originated from
// other clients.
this.processUserCallback(batchId,error?error:null);this.localStore.removeCachedMutationBatchMetadata(batchId);}else{fail("Unknown batchState: "+batchState);}_a.label=4;case 4:return[4/*yield*/,this.emitNewSnapsAndNotifyLocalStore(documents)];case 5:_a.sent();return[2/*return*/];}});});};SyncEngine.prototype.applySuccessfulWrite=function(mutationBatchResult){var _this=this;this.assertSubscribed('applySuccessfulWrite()');var batchId=mutationBatchResult.batch.batchId;// The local store may or may not be able to apply the write result and
// raise events immediately (depending on whether the watcher is caught
// up), so we raise user callbacks first so that they consistently happen
// before listen events.
this.processUserCallback(batchId,/*error=*/null);return this.localStore.acknowledgeBatch(mutationBatchResult).then(function(changes){_this.sharedClientState.updateMutationState(batchId,'acknowledged');return _this.emitNewSnapsAndNotifyLocalStore(changes);}).catch(ignoreIfPrimaryLeaseLoss);};SyncEngine.prototype.rejectFailedWrite=function(batchId,error){var _this=this;this.assertSubscribed('rejectFailedWrite()');// The local store may or may not be able to apply the write result and
// raise events immediately (depending on whether the watcher is caught up),
// so we raise user callbacks first so that they consistently happen before
// listen events.
this.processUserCallback(batchId,error);return this.localStore.rejectBatch(batchId).then(function(changes){_this.sharedClientState.updateMutationState(batchId,'rejected',error);return _this.emitNewSnapsAndNotifyLocalStore(changes);}).catch(ignoreIfPrimaryLeaseLoss);};SyncEngine.prototype.addMutationCallback=function(batchId,callback){var newCallbacks=this.mutationUserCallbacks[this.currentUser.toKey()];if(!newCallbacks){newCallbacks=new SortedMap(primitiveComparator);}newCallbacks=newCallbacks.insert(batchId,callback);this.mutationUserCallbacks[this.currentUser.toKey()]=newCallbacks;};/**
     * Resolves or rejects the user callback for the given batch and then discards
     * it.
     */SyncEngine.prototype.processUserCallback=function(batchId,error){var newCallbacks=this.mutationUserCallbacks[this.currentUser.toKey()];// NOTE: Mutations restored from persistence won't have callbacks, so it's
// okay for there to be no callback for this ID.
if(newCallbacks){var callback=newCallbacks.get(batchId);if(callback){assert(batchId===newCallbacks.minKey(),'Mutation callbacks processed out-of-order?');if(error){callback.reject(error);}else{callback.resolve();}newCallbacks=newCallbacks.remove(batchId);}this.mutationUserCallbacks[this.currentUser.toKey()]=newCallbacks;}};SyncEngine.prototype.removeAndCleanupQuery=function(queryView){var _this=this;this.sharedClientState.removeLocalQueryTarget(queryView.targetId);this.queryViewsByQuery.delete(queryView.query);delete this.queryViewsByTarget[queryView.targetId];if(this.isPrimary){var limboKeys=this.limboDocumentRefs.referencesForId(queryView.targetId);this.limboDocumentRefs.removeReferencesForId(queryView.targetId);limboKeys.forEach(function(limboKey){var isReferenced=_this.limboDocumentRefs.containsKey(limboKey);if(!isReferenced){// We removed the last reference for this key
_this.removeLimboTarget(limboKey);}});}};SyncEngine.prototype.removeLimboTarget=function(key){// It's possible that the target already got removed because the query failed. In that case,
// the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.
var limboTargetId=this.limboTargetsByKey.get(key);if(limboTargetId===null){// This target already got removed, because the query failed.
return;}this.remoteStore.unlisten(limboTargetId);this.limboTargetsByKey=this.limboTargetsByKey.remove(key);delete this.limboResolutionsByTarget[limboTargetId];};SyncEngine.prototype.updateTrackedLimbos=function(targetId,limboChanges){for(var _i=0,limboChanges_1=limboChanges;_i<limboChanges_1.length;_i++){var limboChange=limboChanges_1[_i];if(limboChange instanceof AddedLimboDocument){this.limboDocumentRefs.addReference(limboChange.key,targetId);this.trackLimboChange(limboChange);}else if(limboChange instanceof RemovedLimboDocument){debug(LOG_TAG$9,'Document no longer in limbo: '+limboChange.key);this.limboDocumentRefs.removeReference(limboChange.key,targetId);var isReferenced=this.limboDocumentRefs.containsKey(limboChange.key);if(!isReferenced){// We removed the last reference for this key
this.removeLimboTarget(limboChange.key);}}else{fail('Unknown limbo change: '+JSON.stringify(limboChange));}}};SyncEngine.prototype.trackLimboChange=function(limboChange){var key=limboChange.key;if(!this.limboTargetsByKey.get(key)){debug(LOG_TAG$9,'New document in limbo: '+key);var limboTargetId=this.limboTargetIdGenerator.next();var query=Query.atPath(key.path);this.limboResolutionsByTarget[limboTargetId]=new LimboResolution(key);this.remoteStore.listen(new QueryData(query,limboTargetId,QueryPurpose.LimboResolution,ListenSequence.INVALID));this.limboTargetsByKey=this.limboTargetsByKey.insert(key,limboTargetId);}};// Visible for testing
SyncEngine.prototype.currentLimboDocs=function(){return this.limboTargetsByKey;};SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore=function(changes,remoteEvent){return tslib_1.__awaiter(this,void 0,void 0,function(){var newSnaps,docChangesInAllViews,queriesProcessed;var _this=this;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:newSnaps=[];docChangesInAllViews=[];queriesProcessed=[];this.queryViewsByQuery.forEach(function(_,queryView){queriesProcessed.push(Promise.resolve().then(function(){var viewDocChanges=queryView.view.computeDocChanges(changes);if(!viewDocChanges.needsRefill){return viewDocChanges;}// The query has a limit and some docs were removed, so we need
// to re-run the query against the local store to make sure we
// didn't lose any good docs that had been past the limit.
return _this.localStore.executeQuery(queryView.query).then(function(docs){return queryView.view.computeDocChanges(docs,viewDocChanges);});}).then(function(viewDocChanges){var targetChange=remoteEvent&&remoteEvent.targetChanges[queryView.targetId];var viewChange=queryView.view.applyChanges(viewDocChanges,/* updateLimboDocuments= */_this.isPrimary===true,targetChange);_this.updateTrackedLimbos(queryView.targetId,viewChange.limboChanges);if(viewChange.snapshot){if(_this.isPrimary){_this.sharedClientState.updateQueryState(queryView.targetId,viewChange.snapshot.fromCache?'not-current':'current');}newSnaps.push(viewChange.snapshot);var docChanges=LocalViewChanges.fromSnapshot(queryView.targetId,viewChange.snapshot);docChangesInAllViews.push(docChanges);}}));});return[4/*yield*/,Promise.all(queriesProcessed)];case 1:_a.sent();this.syncEngineListener.onWatchChange(newSnaps);return[4/*yield*/,this.localStore.notifyLocalViewChanges(docChangesInAllViews)];case 2:_a.sent();return[2/*return*/];}});});};SyncEngine.prototype.assertSubscribed=function(fnName){assert(this.syncEngineListener!==null,'Trying to call '+fnName+' before calling subscribe().');};SyncEngine.prototype.handleCredentialChange=function(user){return tslib_1.__awaiter(this,void 0,void 0,function(){var userChanged,result;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:userChanged=!this.currentUser.isEqual(user);this.currentUser=user;if(!userChanged)return[3/*break*/,3];return[4/*yield*/,this.localStore.handleUserChange(user)];case 1:result=_a.sent();// TODO(b/114226417): Consider calling this only in the primary tab.
this.sharedClientState.handleUserChange(user,result.removedBatchIds,result.addedBatchIds);return[4/*yield*/,this.emitNewSnapsAndNotifyLocalStore(result.affectedDocuments)];case 2:_a.sent();_a.label=3;case 3:return[4/*yield*/,this.remoteStore.handleCredentialChange()];case 4:_a.sent();return[2/*return*/];}});});};// PORTING NOTE: Multi-tab only
SyncEngine.prototype.applyPrimaryState=function(isPrimary){return tslib_1.__awaiter(this,void 0,void 0,function(){var activeTargets,activeQueries,_i,activeQueries_1,queryData,activeTargets_1,p_1;var _this=this;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(!(isPrimary===true&&this.isPrimary!==true))return[3/*break*/,3];this.isPrimary=true;return[4/*yield*/,this.remoteStore.applyPrimaryState(true)];case 1:_a.sent();activeTargets=this.sharedClientState.getAllActiveQueryTargets();return[4/*yield*/,this.synchronizeQueryViewsAndRaiseSnapshots(activeTargets.toArray())];case 2:activeQueries=_a.sent();for(_i=0,activeQueries_1=activeQueries;_i<activeQueries_1.length;_i++){queryData=activeQueries_1[_i];this.remoteStore.listen(queryData);}return[3/*break*/,7];case 3:if(!(isPrimary===false&&this.isPrimary!==false))return[3/*break*/,7];this.isPrimary=false;activeTargets_1=[];p_1=Promise.resolve();forEachNumber(this.queryViewsByTarget,function(targetId,queryView){if(_this.sharedClientState.isLocalQueryTarget(targetId)){activeTargets_1.push(targetId);}else{p_1=p_1.then(function(){return _this.unlisten(queryView.query);});}_this.remoteStore.unlisten(queryView.targetId);});return[4/*yield*/,p_1];case 4:_a.sent();return[4/*yield*/,this.synchronizeQueryViewsAndRaiseSnapshots(activeTargets_1)];case 5:_a.sent();this.resetLimboDocuments();return[4/*yield*/,this.remoteStore.applyPrimaryState(false)];case 6:_a.sent();_a.label=7;case 7:return[2/*return*/];}});});};// PORTING NOTE: Multi-tab only.
SyncEngine.prototype.resetLimboDocuments=function(){var _this=this;forEachNumber(this.limboResolutionsByTarget,function(targetId){_this.remoteStore.unlisten(targetId);});this.limboDocumentRefs.removeAllReferences();this.limboResolutionsByTarget=[];this.limboTargetsByKey=new SortedMap(DocumentKey.comparator);};/**
     * Reconcile the query views of the provided query targets with the state from
     * persistence. Raises snapshots for any changes that affect the local
     * client and returns the updated state of all target's query data.
     */// PORTING NOTE: Multi-tab only.
SyncEngine.prototype.synchronizeQueryViewsAndRaiseSnapshots=function(targets){var _this=this;var p=Promise.resolve();var activeQueries=[];var newViewSnapshots=[];var _loop_1=function(targetId){p=p.then(function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){var queryData,queryView,viewChange,query;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:queryView=this.queryViewsByTarget[targetId];if(!queryView)return[3/*break*/,4];// For queries that have a local View, we need to update their state
// in LocalStore (as the resume token and the snapshot version
// might have changed) and reconcile their views with the persisted
// state (the list of syncedDocuments may have gotten out of sync).
return[4/*yield*/,this.localStore.releaseQuery(queryView.query,/*keepPersistedQueryData=*/true)];case 1:// For queries that have a local View, we need to update their state
// in LocalStore (as the resume token and the snapshot version
// might have changed) and reconcile their views with the persisted
// state (the list of syncedDocuments may have gotten out of sync).
_a.sent();return[4/*yield*/,this.localStore.allocateQuery(queryView.query)];case 2:queryData=_a.sent();return[4/*yield*/,this.synchronizeViewAndComputeSnapshot(queryView)];case 3:viewChange=_a.sent();if(viewChange.snapshot){newViewSnapshots.push(viewChange.snapshot);}return[3/*break*/,8];case 4:assert(this.isPrimary===true,'A secondary tab should never have an active query without an active view.');return[4/*yield*/,this.localStore.getQueryForTarget(targetId)];case 5:query=_a.sent();assert(!!query,"Query data for target "+targetId+" not found");return[4/*yield*/,this.localStore.allocateQuery(query)];case 6:queryData=_a.sent();return[4/*yield*/,this.initializeViewAndComputeSnapshot(queryData,/*current=*/false)];case 7:_a.sent();_a.label=8;case 8:activeQueries.push(queryData);return[2/*return*/];}});});});};for(var _i=0,targets_1=targets;_i<targets_1.length;_i++){var targetId=targets_1[_i];_loop_1(targetId);}return p.then(function(){_this.syncEngineListener.onWatchChange(newViewSnapshots);return activeQueries;});};// PORTING NOTE: Multi-tab only
SyncEngine.prototype.getActiveClients=function(){return this.localStore.getActiveClients();};// PORTING NOTE: Multi-tab only
SyncEngine.prototype.applyTargetState=function(targetId,state,error){return tslib_1.__awaiter(this,void 0,void 0,function(){var _a,queryView;var _this=this;return tslib_1.__generator(this,function(_b){switch(_b.label){case 0:if(this.isPrimary){// If we receive a target state notification via WebStorage, we are
// either already secondary or another tab has taken the primary lease.
debug(LOG_TAG$9,'Ignoring unexpected query state notification.');return[2/*return*/];}if(!this.queryViewsByTarget[targetId])return[3/*break*/,5];_a=state;switch(_a){case'current':return[3/*break*/,1];case'not-current':return[3/*break*/,1];case'rejected':return[3/*break*/,2];}return[3/*break*/,4];case 1:{return[2/*return*/,this.localStore.getNewDocumentChanges().then(function(changes){return tslib_1.__awaiter(_this,void 0,void 0,function(){var synthesizedRemoteEvent;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:synthesizedRemoteEvent=RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId,state==='current');return[4/*yield*/,this.emitNewSnapsAndNotifyLocalStore(changes,synthesizedRemoteEvent)];case 1:_a.sent();return[2/*return*/];}});});},function(err){return tslib_1.__awaiter(_this,void 0,void 0,function(){var activeTargets_2;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(!isDocumentChangeMissingError(err))return[3/*break*/,2];activeTargets_2=[];forEachNumber(this.queryViewsByTarget,function(target){return activeTargets_2.push(target);});return[4/*yield*/,this.synchronizeQueryViewsAndRaiseSnapshots(activeTargets_2)];case 1:_a.sent();return[3/*break*/,3];case 2:throw err;case 3:return[2/*return*/];}});});})];}_b.label=2;case 2:queryView=this.queryViewsByTarget[targetId];this.removeAndCleanupQuery(queryView);return[4/*yield*/,this.localStore.releaseQuery(queryView.query,/*keepPersistedQueryData=*/true)];case 3:_b.sent();this.syncEngineListener.onWatchError(queryView.query,error);return[3/*break*/,5];case 4:fail('Unexpected target state: '+state);_b.label=5;case 5:return[2/*return*/];}});});};// PORTING NOTE: Multi-tab only
SyncEngine.prototype.applyActiveTargetsChange=function(added,removed){return tslib_1.__awaiter(this,void 0,void 0,function(){var _i,added_1,targetId,query,queryData,_loop_2,this_1,_a,removed_1,targetId;var _this=this;return tslib_1.__generator(this,function(_b){switch(_b.label){case 0:if(!this.isPrimary){return[2/*return*/];}_i=0,added_1=added;_b.label=1;case 1:if(!(_i<added_1.length))return[3/*break*/,6];targetId=added_1[_i];assert(!this.queryViewsByTarget[targetId],'Trying to add an already active target');return[4/*yield*/,this.localStore.getQueryForTarget(targetId)];case 2:query=_b.sent();assert(!!query,"Query data for active target "+targetId+" not found");return[4/*yield*/,this.localStore.allocateQuery(query)];case 3:queryData=_b.sent();return[4/*yield*/,this.initializeViewAndComputeSnapshot(queryData,/*current=*/false)];case 4:_b.sent();this.remoteStore.listen(queryData);_b.label=5;case 5:_i++;return[3/*break*/,1];case 6:_loop_2=function(targetId){var queryView;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:queryView=this_1.queryViewsByTarget[targetId];if(!queryView)return[3/*break*/,2];return[4/*yield*/,this_1.localStore.releaseQuery(queryView.query,/*keepPersistedQueryData=*/false).then(function(){_this.remoteStore.unlisten(targetId);_this.removeAndCleanupQuery(queryView);}).catch(ignoreIfPrimaryLeaseLoss)];case 1:_a.sent();_a.label=2;case 2:return[2/*return*/];}});};this_1=this;_a=0,removed_1=removed;_b.label=7;case 7:if(!(_a<removed_1.length))return[3/*break*/,10];targetId=removed_1[_a];return[5/*yield**/,_loop_2(targetId)];case 8:_b.sent();_b.label=9;case 9:_a++;return[3/*break*/,7];case 10:return[2/*return*/];}});});};// PORTING NOTE: Multi-tab only. In other clients, LocalStore is unaware of
// the online state.
SyncEngine.prototype.enableNetwork=function(){this.localStore.setNetworkEnabled(true);return this.remoteStore.enableNetwork();};// PORTING NOTE: Multi-tab only. In other clients, LocalStore is unaware of
// the online state.
SyncEngine.prototype.disableNetwork=function(){this.localStore.setNetworkEnabled(false);return this.remoteStore.disableNetwork();};SyncEngine.prototype.getRemoteKeysForTarget=function(targetId){var limboResolution=this.limboResolutionsByTarget[targetId];if(limboResolution&&limboResolution.receivedDocument){return documentKeySet().add(limboResolution.key);}else{return this.queryViewsByTarget[targetId]?this.queryViewsByTarget[targetId].view.syncedDocuments:documentKeySet();}};return SyncEngine;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * Simple wrapper around a nullable UID. Mostly exists to make code more
 * readable.
 */var User=/** @class */function(){function User(uid){this.uid=uid;}User.prototype.isAuthenticated=function(){return this.uid!=null;};/**
     * Returns a key representing this user, suitable for inclusion in a
     * dictionary.
     */User.prototype.toKey=function(){if(this.isAuthenticated()){return'uid:'+this.uid;}else{return'anonymous-user';}};User.prototype.isEqual=function(otherUser){return otherUser.uid===this.uid;};/** A user with a null UID. */User.UNAUTHENTICATED=new User(null);// TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
User.GOOGLE_CREDENTIALS=new User('google-credentials-uid');User.FIRST_PARTY=new User('first-party-uid');return User;}();/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$a='SharedClientState';// The format of the LocalStorage key that stores the client state is:
//     firestore_clients_<persistence_prefix>_<instance_key>
var CLIENT_STATE_KEY_PREFIX='firestore_clients';// The format of the WebStorage key that stores the mutation state is:
//     firestore_mutations_<persistence_prefix>_<batch_id>
//     (for unauthenticated users)
// or: firestore_mutations_<persistence_prefix>_<batch_id>_<user_uid>
//
// 'user_uid' is last to avoid needing to escape '_' characters that it might
// contain.
var MUTATION_BATCH_KEY_PREFIX='firestore_mutations';// The format of the WebStorage key that stores a query target's metadata is:
//     firestore_targets_<persistence_prefix>_<target_id>
var QUERY_TARGET_KEY_PREFIX='firestore_targets';// The WebStorage prefix that stores the primary tab's online state. The
// format of the key is:
//     firestore_online_state_<persistence_prefix>
var ONLINE_STATE_KEY_PREFIX='firestore_online_state';// The WebStorage key prefix for the key that stores the last sequence number allocated. The key
// looks like 'firestore_sequence_number_<persistence_prefix>'.
var SEQUENCE_NUMBER_KEY_PREFIX='firestore_sequence_number';/**
 * Holds the state of a mutation batch, including its user ID, batch ID and
 * whether the batch is 'pending', 'acknowledged' or 'rejected'.
 */// Visible for testing
var MutationMetadata=/** @class */function(){function MutationMetadata(user,batchId,state,error){this.user=user;this.batchId=batchId;this.state=state;this.error=error;assert(error!==undefined===(state==='rejected'),"MutationMetadata must contain an error iff state is 'rejected'");}/**
     * Parses a MutationMetadata from its JSON representation in WebStorage.
     * Logs a warning and returns null if the format of the data is not valid.
     */MutationMetadata.fromWebStorageEntry=function(user,batchId,value){var mutationBatch=JSON.parse(value);var validData=typeof mutationBatch==='object'&&['pending','acknowledged','rejected'].indexOf(mutationBatch.state)!==-1&&(mutationBatch.error===undefined||typeof mutationBatch.error==='object');var firestoreError=undefined;if(validData&&mutationBatch.error){validData=typeof mutationBatch.error.message==='string'&&typeof mutationBatch.error.code==='string';if(validData){firestoreError=new FirestoreError(mutationBatch.error.code,mutationBatch.error.message);}}if(validData){return new MutationMetadata(user,batchId,mutationBatch.state,firestoreError);}else{error(LOG_TAG$a,"Failed to parse mutation state for ID '"+batchId+"': "+value);return null;}};MutationMetadata.prototype.toWebStorageJSON=function(){var batchMetadata={state:this.state,updateTimeMs:Date.now()// Modify the existing value to trigger update.
};if(this.error){batchMetadata.error={code:this.error.code,message:this.error.message};}return JSON.stringify(batchMetadata);};return MutationMetadata;}();/**
 * Holds the state of a query target, including its target ID and whether the
 * target is 'not-current', 'current' or 'rejected'.
 */// Visible for testing
var QueryTargetMetadata=/** @class */function(){function QueryTargetMetadata(targetId,state,error){this.targetId=targetId;this.state=state;this.error=error;assert(error!==undefined===(state==='rejected'),"QueryTargetMetadata must contain an error iff state is 'rejected'");}/**
     * Parses a QueryTargetMetadata from its JSON representation in WebStorage.
     * Logs a warning and returns null if the format of the data is not valid.
     */QueryTargetMetadata.fromWebStorageEntry=function(targetId,value){var targetState=JSON.parse(value);var validData=typeof targetState==='object'&&['not-current','current','rejected'].indexOf(targetState.state)!==-1&&(targetState.error===undefined||typeof targetState.error==='object');var firestoreError=undefined;if(validData&&targetState.error){validData=typeof targetState.error.message==='string'&&typeof targetState.error.code==='string';if(validData){firestoreError=new FirestoreError(targetState.error.code,targetState.error.message);}}if(validData){return new QueryTargetMetadata(targetId,targetState.state,firestoreError);}else{error(LOG_TAG$a,"Failed to parse target state for ID '"+targetId+"': "+value);return null;}};QueryTargetMetadata.prototype.toWebStorageJSON=function(){var targetState={state:this.state,updateTimeMs:Date.now()// Modify the existing value to trigger update.
};if(this.error){targetState.error={code:this.error.code,message:this.error.message};}return JSON.stringify(targetState);};return QueryTargetMetadata;}();/**
 * This class represents the immutable ClientState for a client read from
 * WebStorage, containing the list of active query targets.
 */var RemoteClientState=/** @class */function(){function RemoteClientState(clientId,activeTargetIds){this.clientId=clientId;this.activeTargetIds=activeTargetIds;}/**
     * Parses a RemoteClientState from the JSON representation in WebStorage.
     * Logs a warning and returns null if the format of the data is not valid.
     */RemoteClientState.fromWebStorageEntry=function(clientId,value){var clientState=JSON.parse(value);var validData=typeof clientState==='object'&&clientState.activeTargetIds instanceof Array;var activeTargetIdsSet=targetIdSet();for(var i=0;validData&&i<clientState.activeTargetIds.length;++i){validData=isSafeInteger(clientState.activeTargetIds[i]);activeTargetIdsSet=activeTargetIdsSet.add(clientState.activeTargetIds[i]);}if(validData){return new RemoteClientState(clientId,activeTargetIdsSet);}else{error(LOG_TAG$a,"Failed to parse client data for instance '"+clientId+"': "+value);return null;}};return RemoteClientState;}();/**
 * This class represents the online state for all clients participating in
 * multi-tab. The online state is only written to by the primary client, and
 * used in secondary clients to update their query views.
 */var SharedOnlineState=/** @class */function(){function SharedOnlineState(clientId,onlineState){this.clientId=clientId;this.onlineState=onlineState;}/**
     * Parses a SharedOnlineState from its JSON representation in WebStorage.
     * Logs a warning and returns null if the format of the data is not valid.
     */SharedOnlineState.fromWebStorageEntry=function(value){var onlineState=JSON.parse(value);var validData=typeof onlineState==='object'&&OnlineState[onlineState.onlineState]!==undefined&&typeof onlineState.clientId==='string';if(validData){return new SharedOnlineState(onlineState.clientId,OnlineState[onlineState.onlineState]);}else{error(LOG_TAG$a,"Failed to parse online state: "+value);return null;}};return SharedOnlineState;}();/**
 * Metadata state of the local client. Unlike `RemoteClientState`, this class is
 * mutable and keeps track of all pending mutations, which allows us to
 * update the range of pending mutation batch IDs as new mutations are added or
 * removed.
 *
 * The data in `LocalClientState` is not read from WebStorage and instead
 * updated via its instance methods. The updated state can be serialized via
 * `toWebStorageJSON()`.
 */// Visible for testing.
var LocalClientState=/** @class */function(){function LocalClientState(){this.activeTargetIds=targetIdSet();}LocalClientState.prototype.addQueryTarget=function(targetId){assert(!this.activeTargetIds.has(targetId),"Target with ID '"+targetId+"' already active.");this.activeTargetIds=this.activeTargetIds.add(targetId);};LocalClientState.prototype.removeQueryTarget=function(targetId){this.activeTargetIds=this.activeTargetIds.delete(targetId);};/**
     * Converts this entry into a JSON-encoded format we can use for WebStorage.
     * Does not encode `clientId` as it is part of the key in WebStorage.
     */LocalClientState.prototype.toWebStorageJSON=function(){var data={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()// Modify the existing value to trigger update.
};return JSON.stringify(data);};return LocalClientState;}();/**
 * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the
 * backing store for the SharedClientState. It keeps track of all active
 * clients and supports modifications of the local client's data.
 */var WebStorageSharedClientState=/** @class */function(){function WebStorageSharedClientState(queue,platform,persistenceKey,localClientId,initialUser){this.queue=queue;this.platform=platform;this.persistenceKey=persistenceKey;this.localClientId=localClientId;this.syncEngine=null;this.onlineStateHandler=null;this.sequenceNumberHandler=null;this.activeClients={};this.storageListener=this.handleWebStorageEvent.bind(this);this.started=false;/**
         * Captures WebStorage events that occur before `start()` is called. These
         * events are replayed once `WebStorageSharedClientState` is started.
         */this.earlyEvents=[];if(!WebStorageSharedClientState.isAvailable(this.platform)){throw new FirestoreError(Code.UNIMPLEMENTED,'LocalStorage is not available on this platform.');}// Escape the special characters mentioned here:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
var escapedPersistenceKey=persistenceKey.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');this.storage=this.platform.window.localStorage;this.currentUser=initialUser;this.localClientStorageKey=this.toWebStorageClientStateKey(this.localClientId);this.sequenceNumberKey=SEQUENCE_NUMBER_KEY_PREFIX+"_"+persistenceKey;this.activeClients[this.localClientId]=new LocalClientState();this.clientStateKeyRe=new RegExp("^"+CLIENT_STATE_KEY_PREFIX+"_"+escapedPersistenceKey+"_([^_]*)$");this.mutationBatchKeyRe=new RegExp("^"+MUTATION_BATCH_KEY_PREFIX+"_"+escapedPersistenceKey+"_(\\d+)(?:_(.*))?$");this.queryTargetKeyRe=new RegExp("^"+QUERY_TARGET_KEY_PREFIX+"_"+escapedPersistenceKey+"_(\\d+)$");this.onlineStateKey=ONLINE_STATE_KEY_PREFIX+"_"+persistenceKey;// Rather than adding the storage observer during start(), we add the
// storage observer during initialization. This ensures that we collect
// events before other components populate their initial state (during their
// respective start() calls). Otherwise, we might for example miss a
// mutation that is added after LocalStore's start() processed the existing
// mutations but before we observe WebStorage events.
this.platform.window.addEventListener('storage',this.storageListener);}/** Returns 'true' if WebStorage is available in the current environment. */WebStorageSharedClientState.isAvailable=function(platform){return!!(platform.window&&platform.window.localStorage!=null);};WebStorageSharedClientState.prototype.start=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){var existingClients,_i,existingClients_1,clientId,storageItem,clientState,onlineStateJSON,onlineState,_a,_b,event_1;var _this=this;return tslib_1.__generator(this,function(_c){switch(_c.label){case 0:assert(!this.started,'WebStorageSharedClientState already started');assert(this.syncEngine!==null,'syncEngine property must be set before calling start()');assert(this.onlineStateHandler!==null,'onlineStateHandler property must be set before calling start()');return[4/*yield*/,this.syncEngine.getActiveClients()];case 1:existingClients=_c.sent();for(_i=0,existingClients_1=existingClients;_i<existingClients_1.length;_i++){clientId=existingClients_1[_i];if(clientId===this.localClientId){continue;}storageItem=this.getItem(this.toWebStorageClientStateKey(clientId));if(storageItem){clientState=RemoteClientState.fromWebStorageEntry(clientId,storageItem);if(clientState){this.activeClients[clientState.clientId]=clientState;}}}this.persistClientState();onlineStateJSON=this.storage.getItem(this.onlineStateKey);if(onlineStateJSON){onlineState=this.fromWebStorageOnlineState(onlineStateJSON);if(onlineState){this.handleOnlineStateEvent(onlineState);}}for(_a=0,_b=this.earlyEvents;_a<_b.length;_a++){event_1=_b[_a];this.handleWebStorageEvent(event_1);}this.earlyEvents=[];// Register a window unload hook to remove the client metadata entry from
// WebStorage even if `shutdown()` was not called.
this.platform.window.addEventListener('unload',function(){return _this.shutdown();});this.started=true;return[2/*return*/];}});});};WebStorageSharedClientState.prototype.writeSequenceNumber=function(sequenceNumber){this.setItem(this.sequenceNumberKey,JSON.stringify(sequenceNumber));};WebStorageSharedClientState.prototype.getAllActiveQueryTargets=function(){var activeTargets=targetIdSet();forEach(this.activeClients,function(key,value){activeTargets=activeTargets.unionWith(value.activeTargetIds);});return activeTargets;};WebStorageSharedClientState.prototype.isActiveQueryTarget=function(targetId){// This is not using `obj.forEach` since `forEach` doesn't support early
// return.
for(var clientId in this.activeClients){if(this.activeClients.hasOwnProperty(clientId)){if(this.activeClients[clientId].activeTargetIds.has(targetId)){return true;}}}return false;};WebStorageSharedClientState.prototype.addPendingMutation=function(batchId){this.persistMutationState(batchId,'pending');};WebStorageSharedClientState.prototype.updateMutationState=function(batchId,state,error){this.persistMutationState(batchId,state,error);// Once a final mutation result is observed by other clients, they no longer
// access the mutation's metadata entry. Since WebStorage replays events
// in order, it is safe to delete the entry right after updating it.
this.removeMutationState(batchId);};WebStorageSharedClientState.prototype.addLocalQueryTarget=function(targetId){var queryState='not-current';// Lookup an existing query state if the target ID was already registered
// by another tab
if(this.isActiveQueryTarget(targetId)){var storageItem=this.storage.getItem(this.toWebStorageQueryTargetMetadataKey(targetId));if(storageItem){var metadata=QueryTargetMetadata.fromWebStorageEntry(targetId,storageItem);if(metadata){queryState=metadata.state;}}}this.localClientState.addQueryTarget(targetId);this.persistClientState();return queryState;};WebStorageSharedClientState.prototype.removeLocalQueryTarget=function(targetId){this.localClientState.removeQueryTarget(targetId);this.persistClientState();};WebStorageSharedClientState.prototype.isLocalQueryTarget=function(targetId){return this.localClientState.activeTargetIds.has(targetId);};WebStorageSharedClientState.prototype.clearQueryState=function(targetId){this.removeItem(this.toWebStorageQueryTargetMetadataKey(targetId));};WebStorageSharedClientState.prototype.updateQueryState=function(targetId,state,error){this.persistQueryTargetState(targetId,state,error);};WebStorageSharedClientState.prototype.handleUserChange=function(user,removedBatchIds,addedBatchIds){var _this=this;removedBatchIds.forEach(function(batchId){_this.removeMutationState(batchId);});this.currentUser=user;addedBatchIds.forEach(function(batchId){_this.addPendingMutation(batchId);});};WebStorageSharedClientState.prototype.setOnlineState=function(onlineState){this.persistOnlineState(onlineState);};WebStorageSharedClientState.prototype.shutdown=function(){if(this.started){this.platform.window.removeEventListener('storage',this.storageListener);this.removeItem(this.localClientStorageKey);this.started=false;}};WebStorageSharedClientState.prototype.getItem=function(key){var value=this.storage.getItem(key);debug(LOG_TAG$a,'READ',key,value);return value;};WebStorageSharedClientState.prototype.setItem=function(key,value){debug(LOG_TAG$a,'SET',key,value);this.storage.setItem(key,value);};WebStorageSharedClientState.prototype.removeItem=function(key){debug(LOG_TAG$a,'REMOVE',key);this.storage.removeItem(key);};WebStorageSharedClientState.prototype.handleWebStorageEvent=function(event){var _this=this;if(event.storageArea===this.storage){debug(LOG_TAG$a,'EVENT',event.key,event.newValue);if(event.key===this.localClientStorageKey){error('Received WebStorage notification for local change. Another client might have '+'garbage-collected our state');return;}this.queue.enqueueAndForget(function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){var clientState,clientId,mutationMetadata,queryTargetMetadata,onlineState,sequenceNumber;return tslib_1.__generator(this,function(_a){if(!this.started){this.earlyEvents.push(event);return[2/*return*/];}if(event.key===null){return[2/*return*/];}if(this.clientStateKeyRe.test(event.key)){if(event.newValue!=null){clientState=this.fromWebStorageClientState(event.key,event.newValue);if(clientState){return[2/*return*/,this.handleClientStateEvent(clientState.clientId,clientState)];}}else{clientId=this.fromWebStorageClientStateKey(event.key);return[2/*return*/,this.handleClientStateEvent(clientId,null)];}}else if(this.mutationBatchKeyRe.test(event.key)){if(event.newValue!==null){mutationMetadata=this.fromWebStorageMutationMetadata(event.key,event.newValue);if(mutationMetadata){return[2/*return*/,this.handleMutationBatchEvent(mutationMetadata)];}}}else if(this.queryTargetKeyRe.test(event.key)){if(event.newValue!==null){queryTargetMetadata=this.fromWebStorageQueryTargetMetadata(event.key,event.newValue);if(queryTargetMetadata){return[2/*return*/,this.handleQueryTargetEvent(queryTargetMetadata)];}}}else if(event.key===this.onlineStateKey){if(event.newValue!==null){onlineState=this.fromWebStorageOnlineState(event.newValue);if(onlineState){return[2/*return*/,this.handleOnlineStateEvent(onlineState)];}}}else if(event.key===this.sequenceNumberKey){assert(!!this.sequenceNumberHandler,'Missing sequenceNumberHandler');sequenceNumber=fromWebStorageSequenceNumber(event.newValue);if(sequenceNumber!==ListenSequence.INVALID){this.sequenceNumberHandler(sequenceNumber);}}return[2/*return*/];});});});}};Object.defineProperty(WebStorageSharedClientState.prototype,"localClientState",{get:function(){return this.activeClients[this.localClientId];},enumerable:true,configurable:true});WebStorageSharedClientState.prototype.persistClientState=function(){this.setItem(this.localClientStorageKey,this.localClientState.toWebStorageJSON());};WebStorageSharedClientState.prototype.persistMutationState=function(batchId,state,error){var mutationState=new MutationMetadata(this.currentUser,batchId,state,error);var mutationKey=this.toWebStorageMutationBatchKey(batchId);this.setItem(mutationKey,mutationState.toWebStorageJSON());};WebStorageSharedClientState.prototype.removeMutationState=function(batchId){var mutationKey=this.toWebStorageMutationBatchKey(batchId);this.removeItem(mutationKey);};WebStorageSharedClientState.prototype.persistOnlineState=function(onlineState){var entry={clientId:this.localClientId,onlineState:OnlineState[onlineState]};this.storage.setItem(this.onlineStateKey,JSON.stringify(entry));};WebStorageSharedClientState.prototype.persistQueryTargetState=function(targetId,state,error){var targetKey=this.toWebStorageQueryTargetMetadataKey(targetId);var targetMetadata=new QueryTargetMetadata(targetId,state,error);this.setItem(targetKey,targetMetadata.toWebStorageJSON());};/** Assembles the key for a client state in WebStorage */WebStorageSharedClientState.prototype.toWebStorageClientStateKey=function(clientId){assert(clientId.indexOf('_')===-1,"Client key cannot contain '_', but was '"+clientId+"'");return CLIENT_STATE_KEY_PREFIX+"_"+this.persistenceKey+"_"+clientId;};/** Assembles the key for a query state in WebStorage */WebStorageSharedClientState.prototype.toWebStorageQueryTargetMetadataKey=function(targetId){return QUERY_TARGET_KEY_PREFIX+"_"+this.persistenceKey+"_"+targetId;};/** Assembles the key for a mutation batch in WebStorage */WebStorageSharedClientState.prototype.toWebStorageMutationBatchKey=function(batchId){var mutationKey=MUTATION_BATCH_KEY_PREFIX+"_"+this.persistenceKey+"_"+batchId;if(this.currentUser.isAuthenticated()){mutationKey+="_"+this.currentUser.uid;}return mutationKey;};/**
     * Parses a client state key in WebStorage. Returns null if the key does not
     * match the expected key format.
     */WebStorageSharedClientState.prototype.fromWebStorageClientStateKey=function(key){var match=this.clientStateKeyRe.exec(key);return match?match[1]:null;};/**
     * Parses a client state in WebStorage. Returns 'null' if the value could not
     * be parsed.
     */WebStorageSharedClientState.prototype.fromWebStorageClientState=function(key,value){var clientId=this.fromWebStorageClientStateKey(key);assert(clientId!==null,"Cannot parse client state key '"+key+"'");return RemoteClientState.fromWebStorageEntry(clientId,value);};/**
     * Parses a mutation batch state in WebStorage. Returns 'null' if the value
     * could not be parsed.
     */WebStorageSharedClientState.prototype.fromWebStorageMutationMetadata=function(key,value){var match=this.mutationBatchKeyRe.exec(key);assert(match!==null,"Cannot parse mutation batch key '"+key+"'");var batchId=Number(match[1]);var userId=match[2]!==undefined?match[2]:null;return MutationMetadata.fromWebStorageEntry(new User(userId),batchId,value);};/**
     * Parses a query target state from WebStorage. Returns 'null' if the value
     * could not be parsed.
     */WebStorageSharedClientState.prototype.fromWebStorageQueryTargetMetadata=function(key,value){var match=this.queryTargetKeyRe.exec(key);assert(match!==null,"Cannot parse query target key '"+key+"'");var targetId=Number(match[1]);return QueryTargetMetadata.fromWebStorageEntry(targetId,value);};/**
     * Parses an online state from WebStorage. Returns 'null' if the value
     * could not be parsed.
     */WebStorageSharedClientState.prototype.fromWebStorageOnlineState=function(value){return SharedOnlineState.fromWebStorageEntry(value);};WebStorageSharedClientState.prototype.handleMutationBatchEvent=function(mutationBatch){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){if(mutationBatch.user.uid!==this.currentUser.uid){debug(LOG_TAG$a,"Ignoring mutation for non-active user "+mutationBatch.user.uid);return[2/*return*/];}return[2/*return*/,this.syncEngine.applyBatchState(mutationBatch.batchId,mutationBatch.state,mutationBatch.error)];});});};WebStorageSharedClientState.prototype.handleQueryTargetEvent=function(targetMetadata){return this.syncEngine.applyTargetState(targetMetadata.targetId,targetMetadata.state,targetMetadata.error);};WebStorageSharedClientState.prototype.handleClientStateEvent=function(clientId,clientState){var _this=this;var existingTargets=this.getAllActiveQueryTargets();if(clientState){this.activeClients[clientId]=clientState;}else{delete this.activeClients[clientId];}var newTargets=this.getAllActiveQueryTargets();var addedTargets=[];var removedTargets=[];newTargets.forEach(function(targetId){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){if(!existingTargets.has(targetId)){addedTargets.push(targetId);}return[2/*return*/];});});});existingTargets.forEach(function(targetId){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){if(!newTargets.has(targetId)){removedTargets.push(targetId);}return[2/*return*/];});});});return this.syncEngine.applyActiveTargetsChange(addedTargets,removedTargets);};WebStorageSharedClientState.prototype.handleOnlineStateEvent=function(onlineState){// We check whether the client that wrote this online state is still active
// by comparing its client ID to the list of clients kept active in
// IndexedDb. If a client does not update their IndexedDb client state
// within 5 seconds, it is considered inactive and we don't emit an online
// state event.
if(this.activeClients[onlineState.clientId]){this.onlineStateHandler(onlineState.onlineState);}};return WebStorageSharedClientState;}();function fromWebStorageSequenceNumber(seqString){var sequenceNumber=ListenSequence.INVALID;if(seqString!=null){try{var parsed=JSON.parse(seqString);assert(typeof parsed==='number','Found non-numeric sequence number');sequenceNumber=parsed;}catch(e){error(LOG_TAG$a,'Failed to read sequence number from WebStorage',e);}}return sequenceNumber;}/**
 * `MemorySharedClientState` is a simple implementation of SharedClientState for
 * clients using memory persistence. The state in this class remains fully
 * isolated and no synchronization is performed.
 */var MemorySharedClientState=/** @class */function(){function MemorySharedClientState(){this.localState=new LocalClientState();this.queryState={};this.syncEngine=null;this.onlineStateHandler=null;this.sequenceNumberHandler=null;}MemorySharedClientState.prototype.addPendingMutation=function(batchId){// No op.
};MemorySharedClientState.prototype.updateMutationState=function(batchId,state,error){// No op.
};MemorySharedClientState.prototype.addLocalQueryTarget=function(targetId){this.localState.addQueryTarget(targetId);return this.queryState[targetId]||'not-current';};MemorySharedClientState.prototype.updateQueryState=function(targetId,state,error){this.queryState[targetId]=state;};MemorySharedClientState.prototype.removeLocalQueryTarget=function(targetId){this.localState.removeQueryTarget(targetId);};MemorySharedClientState.prototype.isLocalQueryTarget=function(targetId){return this.localState.activeTargetIds.has(targetId);};MemorySharedClientState.prototype.clearQueryState=function(targetId){delete this.queryState[targetId];};MemorySharedClientState.prototype.getAllActiveQueryTargets=function(){return this.localState.activeTargetIds;};MemorySharedClientState.prototype.isActiveQueryTarget=function(targetId){return this.localState.activeTargetIds.has(targetId);};MemorySharedClientState.prototype.start=function(){this.localState=new LocalClientState();return Promise.resolve();};MemorySharedClientState.prototype.handleUserChange=function(user,removedBatchIds,addedBatchIds){// No op.
};MemorySharedClientState.prototype.setOnlineState=function(onlineState){// No op.
};MemorySharedClientState.prototype.shutdown=function(){};MemorySharedClientState.prototype.writeSequenceNumber=function(sequenceNumber){};return MemorySharedClientState;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$b='FirestoreClient';/** The DOMException code for an aborted operation. */var DOM_EXCEPTION_ABORTED=20;/** The DOMException code for quota exceeded. */var DOM_EXCEPTION_QUOTA_EXCEEDED=22;var IndexedDbPersistenceSettings=/** @class */function(){function IndexedDbPersistenceSettings(cacheSizeBytes,experimentalTabSynchronization){this.cacheSizeBytes=cacheSizeBytes;this.experimentalTabSynchronization=experimentalTabSynchronization;}IndexedDbPersistenceSettings.prototype.lruParams=function(){return LruParams.withCacheSize(this.cacheSizeBytes);};return IndexedDbPersistenceSettings;}();var MemoryPersistenceSettings=/** @class */function(){function MemoryPersistenceSettings(){}return MemoryPersistenceSettings;}();/**
 * FirestoreClient is a top-level class that constructs and owns all of the
 * pieces of the client SDK architecture. It is responsible for creating the
 * async queue that is shared by all of the other components in the system.
 */var FirestoreClient=/** @class */function(){function FirestoreClient(platform,databaseInfo,credentials,/**
     * Asynchronous queue responsible for all of our internal processing. When
     * we get incoming work from the user (via public API) or the network
     * (incoming GRPC messages), we should always schedule onto this queue.
     * This ensures all of our work is properly serialized (e.g. we don't
     * start processing a new operation while the previous one is waiting for
     * an async I/O to complete).
     */asyncQueue){this.platform=platform;this.databaseInfo=databaseInfo;this.credentials=credentials;this.asyncQueue=asyncQueue;this.clientId=AutoId.newId();this.isShutdown=false;}/**
     * Starts up the FirestoreClient, returning only whether or not enabling
     * persistence succeeded.
     *
     * The intent here is to "do the right thing" as far as users are concerned.
     * Namely, in cases where offline persistence is requested and possible,
     * enable it, but otherwise fall back to persistence disabled. For the most
     * part we expect this to succeed one way or the other so we don't expect our
     * users to actually wait on the firestore.enablePersistence Promise since
     * they generally won't care.
     *
     * Of course some users actually do care about whether or not persistence
     * was successfully enabled, so the Promise returned from this method
     * indicates this outcome.
     *
     * This presents a problem though: even before enablePersistence resolves or
     * rejects, users may have made calls to e.g. firestore.collection() which
     * means that the FirestoreClient in there will be available and will be
     * enqueuing actions on the async queue.
     *
     * Meanwhile any failure of an operation on the async queue causes it to
     * panic and reject any further work, on the premise that unhandled errors
     * are fatal.
     *
     * Consequently the fallback is handled internally here in start, and if the
     * fallback succeeds we signal success to the async queue even though the
     * start() itself signals failure.
     *
     * @param persistenceSettings Settings object to configure offline
     *     persistence.
     * @returns A deferred result indicating the user-visible result of enabling
     *     offline persistence. This method will reject this if IndexedDB fails to
     *     start for any reason. If usePersistence is false this is
     *     unconditionally resolved.
     */FirestoreClient.prototype.start=function(persistenceSettings){var _this=this;this.verifyNotShutdown();// We defer our initialization until we get the current user from
// setChangeListener(). We block the async queue until we got the initial
// user and the initialization is completed. This will prevent any scheduled
// work from happening before initialization is completed.
//
// If initializationDone resolved then the FirestoreClient is in a usable
// state.
var initializationDone=new Deferred();// If usePersistence is true, certain classes of errors while starting are
// recoverable but only by falling back to persistence disabled.
//
// If there's an error in the first case but not in recovery we cannot
// reject the promise blocking the async queue because this will cause the
// async queue to panic.
var persistenceResult=new Deferred();var initialized=false;this.credentials.setChangeListener(function(user){if(!initialized){initialized=true;_this.initializePersistence(persistenceSettings,persistenceResult,user).then(function(maybeLruGc){return _this.initializeRest(user,maybeLruGc);}).then(initializationDone.resolve,initializationDone.reject);}else{_this.asyncQueue.enqueueAndForget(function(){return _this.handleCredentialChange(user);});}});// Block the async queue until initialization is done
this.asyncQueue.enqueueAndForget(function(){return initializationDone.promise;});// Return only the result of enabling persistence. Note that this does not
// need to await the completion of initializationDone because the result of
// this method should not reflect any other kind of failure to start.
return persistenceResult.promise;};/** Enables the network connection and requeues all pending operations. */FirestoreClient.prototype.enableNetwork=function(){var _this=this;this.verifyNotShutdown();return this.asyncQueue.enqueue(function(){return _this.syncEngine.enableNetwork();});};/**
     * Initializes persistent storage, attempting to use IndexedDB if
     * usePersistence is true or memory-only if false.
     *
     * If IndexedDB fails because it's already open in another tab or because the
     * platform can't possibly support our implementation then this method rejects
     * the persistenceResult and falls back on memory-only persistence.
     *
     * @param persistenceSettings Settings object to configure offline persistence
     * @param persistenceResult A deferred result indicating the user-visible
     *     result of enabling offline persistence. This method will reject this if
     *     IndexedDB fails to start for any reason. If usePersistence is false
     *     this is unconditionally resolved.
     * @returns a Promise indicating whether or not initialization should
     *     continue, i.e. that one of the persistence implementations actually
     *     succeeded.
     */FirestoreClient.prototype.initializePersistence=function(persistenceSettings,persistenceResult,user){var _this=this;if(persistenceSettings instanceof IndexedDbPersistenceSettings){return this.startIndexedDbPersistence(user,persistenceSettings).then(function(maybeLruGc){persistenceResult.resolve();return maybeLruGc;}).catch(function(error){// Regardless of whether or not the retry succeeds, from an user
// perspective, offline persistence has failed.
persistenceResult.reject(error);// An unknown failure on the first stage shuts everything down.
if(!_this.canFallback(error)){throw error;}console.warn('Error enabling offline storage. Falling back to'+' storage disabled: '+error);return _this.startMemoryPersistence();});}else{// When usePersistence == false, enabling offline persistence is defined
// to unconditionally succeed. This allows start() to have the same
// signature for both cases, despite the fact that the returned promise
// is only used in the enablePersistence call.
persistenceResult.resolve();return this.startMemoryPersistence();}};/**
     * Decides whether the provided error allows us to gracefully disable
     * persistence (as opposed to crashing the client).
     */FirestoreClient.prototype.canFallback=function(error){if(error instanceof FirestoreError){return error.code===Code.FAILED_PRECONDITION||error.code===Code.UNIMPLEMENTED;}else if(typeof DOMException!=='undefined'&&error instanceof DOMException){// We fall back to memory persistence if we cannot write the primary
// lease. This can happen can during a schema migration, or if we run out
// of quota when we try to write the primary lease.
// For both the `QuotaExceededError` and the  `AbortError`, it is safe to
// fall back to memory persistence since all modifications to IndexedDb
// failed to commit.
return error.code===DOM_EXCEPTION_QUOTA_EXCEEDED||error.code===DOM_EXCEPTION_ABORTED;}return true;};/**
     * Checks that the client has not been shutdown. Ensures that other methods on
     * this class cannot be called after the client is shutdown.
     */FirestoreClient.prototype.verifyNotShutdown=function(){if(this.isShutdown){throw new FirestoreError(Code.FAILED_PRECONDITION,'The client has already been shutdown.');}};/**
     * Starts IndexedDB-based persistence.
     *
     * @returns A promise indicating success or failure.
     */FirestoreClient.prototype.startIndexedDbPersistence=function(user,settings){var _this=this;// TODO(http://b/33384523): For now we just disable garbage collection
// when persistence is enabled.
var storagePrefix=IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);// Opt to use proto3 JSON in case the platform doesn't support Uint8Array.
var serializer=new JsonProtoSerializer(this.databaseInfo.databaseId,{useProto3Json:true});return Promise.resolve().then(function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){var persistence,lruParams;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(settings.experimentalTabSynchronization&&!WebStorageSharedClientState.isAvailable(this.platform)){throw new FirestoreError(Code.UNIMPLEMENTED,'IndexedDB persistence is only available on platforms that support LocalStorage.');}lruParams=settings.lruParams();if(!settings.experimentalTabSynchronization)return[3/*break*/,2];this.sharedClientState=new WebStorageSharedClientState(this.asyncQueue,this.platform,storagePrefix,this.clientId,user);return[4/*yield*/,IndexedDbPersistence.createMultiClientIndexedDbPersistence(storagePrefix,this.clientId,this.platform,this.asyncQueue,serializer,lruParams,{sequenceNumberSyncer:this.sharedClientState})];case 1:persistence=_a.sent();return[3/*break*/,4];case 2:this.sharedClientState=new MemorySharedClientState();return[4/*yield*/,IndexedDbPersistence.createIndexedDbPersistence(storagePrefix,this.clientId,this.platform,this.asyncQueue,serializer,lruParams)];case 3:persistence=_a.sent();_a.label=4;case 4:this.persistence=persistence;return[2/*return*/,persistence.referenceDelegate.garbageCollector];}});});});};/**
     * Starts Memory-backed persistence. In practice this cannot fail.
     *
     * @returns A promise that will successfully resolve.
     */FirestoreClient.prototype.startMemoryPersistence=function(){this.persistence=MemoryPersistence.createEagerPersistence(this.clientId);this.sharedClientState=new MemorySharedClientState();return Promise.resolve(null);};/**
     * Initializes the rest of the FirestoreClient, assuming the initial user
     * has been obtained from the credential provider and some persistence
     * implementation is available in this.persistence.
     */FirestoreClient.prototype.initializeRest=function(user,maybeLruGc){var _this=this;debug(LOG_TAG$b,'Initializing. user=',user.uid);return this.platform.loadConnection(this.databaseInfo).then(function(connection){return tslib_1.__awaiter(_this,void 0,void 0,function(){var serializer,datastore,remoteStoreOnlineStateChangedHandler,sharedClientStateOnlineStateChangedHandler;var _this=this;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:this.localStore=new LocalStore(this.persistence,user);if(maybeLruGc){// We're running LRU Garbage collection. Set up the scheduler.
this.lruScheduler=new LruScheduler(maybeLruGc,this.asyncQueue,this.localStore);}serializer=this.platform.newSerializer(this.databaseInfo.databaseId);datastore=new Datastore(this.asyncQueue,connection,this.credentials,serializer);remoteStoreOnlineStateChangedHandler=function(onlineState){return _this.syncEngine.applyOnlineStateChange(onlineState,OnlineStateSource.RemoteStore);};sharedClientStateOnlineStateChangedHandler=function(onlineState){return _this.syncEngine.applyOnlineStateChange(onlineState,OnlineStateSource.SharedClientState);};this.remoteStore=new RemoteStore(this.localStore,datastore,this.asyncQueue,remoteStoreOnlineStateChangedHandler);this.syncEngine=new SyncEngine(this.localStore,this.remoteStore,this.sharedClientState,user);this.sharedClientState.onlineStateHandler=sharedClientStateOnlineStateChangedHandler;// Set up wiring between sync engine and other components
this.remoteStore.syncEngine=this.syncEngine;this.sharedClientState.syncEngine=this.syncEngine;this.eventMgr=new EventManager(this.syncEngine);// PORTING NOTE: LocalStore doesn't need an explicit start() on the Web.
return[4/*yield*/,this.sharedClientState.start()];case 1:// PORTING NOTE: LocalStore doesn't need an explicit start() on the Web.
_a.sent();return[4/*yield*/,this.remoteStore.start()];case 2:_a.sent();// NOTE: This will immediately call the listener, so we make sure to
// set it after localStore / remoteStore are started.
return[4/*yield*/,this.persistence.setPrimaryStateListener(function(isPrimary){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.syncEngine.applyPrimaryState(isPrimary)];case 1:_a.sent();if(this.lruScheduler){if(isPrimary&&!this.lruScheduler.started){this.lruScheduler.start();}else if(!isPrimary){this.lruScheduler.stop();}}return[2/*return*/];}});});})];case 3:// NOTE: This will immediately call the listener, so we make sure to
// set it after localStore / remoteStore are started.
_a.sent();return[2/*return*/];}});});});};FirestoreClient.prototype.handleCredentialChange=function(user){this.asyncQueue.verifyOperationInProgress();debug(LOG_TAG$b,'Credential Changed. Current user: '+user.uid);return this.syncEngine.handleCredentialChange(user);};/** Disables the network connection. Pending operations will not complete. */FirestoreClient.prototype.disableNetwork=function(){var _this=this;this.verifyNotShutdown();return this.asyncQueue.enqueue(function(){return _this.syncEngine.disableNetwork();});};FirestoreClient.prototype.shutdown=function(){var _this=this;if(this.isShutdown===true){return Promise.resolve();}return this.asyncQueue.enqueue(function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:// PORTING NOTE: LocalStore does not need an explicit shutdown on web.
if(this.lruScheduler){this.lruScheduler.stop();}return[4/*yield*/,this.remoteStore.shutdown()];case 1:_a.sent();return[4/*yield*/,this.sharedClientState.shutdown()];case 2:_a.sent();return[4/*yield*/,this.persistence.shutdown()];case 3:_a.sent();// `removeChangeListener` must be called after shutting down the
// RemoteStore as it will prevent the RemoteStore from retrieving
// auth tokens.
this.credentials.removeChangeListener();this.isShutdown=true;return[2/*return*/];}});});});};FirestoreClient.prototype.listen=function(query,observer,options){var _this=this;this.verifyNotShutdown();var listener=new QueryListener(query,observer,options);this.asyncQueue.enqueueAndForget(function(){return _this.eventMgr.listen(listener);});return listener;};FirestoreClient.prototype.unlisten=function(listener){var _this=this;this.verifyNotShutdown();this.asyncQueue.enqueueAndForget(function(){return _this.eventMgr.unlisten(listener);});};FirestoreClient.prototype.getDocumentFromLocalCache=function(docKey){var _this=this;this.verifyNotShutdown();return this.asyncQueue.enqueue(function(){return _this.localStore.readDocument(docKey);}).then(function(maybeDoc){if(maybeDoc instanceof Document){return maybeDoc;}else if(maybeDoc instanceof NoDocument){return null;}else{throw new FirestoreError(Code.UNAVAILABLE,'Failed to get document from cache. (However, this document may '+"exist on the server. Run again without setting 'source' in "+'the GetOptions to attempt to retrieve the document from the '+'server.)');}});};FirestoreClient.prototype.getDocumentsFromLocalCache=function(query){var _this=this;this.verifyNotShutdown();return this.asyncQueue.enqueue(function(){return _this.localStore.executeQuery(query);}).then(function(docs){var remoteKeys=documentKeySet();var view=new View(query,remoteKeys);var viewDocChanges=view.computeDocChanges(docs);return view.applyChanges(viewDocChanges,/* updateLimboDocuments= */false).snapshot;});};FirestoreClient.prototype.write=function(mutations){var _this=this;this.verifyNotShutdown();var deferred=new Deferred();this.asyncQueue.enqueueAndForget(function(){return _this.syncEngine.write(mutations,deferred);});return deferred.promise;};FirestoreClient.prototype.databaseId=function(){return this.databaseInfo.databaseId;};FirestoreClient.prototype.transaction=function(updateFunction){var _this=this;this.verifyNotShutdown();// We have to wait for the async queue to be sure syncEngine is initialized.
return this.asyncQueue.enqueue(function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){return[2/*return*/];});});}).then(function(){return _this.syncEngine.runTransaction(updateFunction);});};return FirestoreClient;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//*
 * A wrapper implementation of Observer<T> that will dispatch events
 * asynchronously. To allow immediate silencing, a mute call is added which
 * causes events scheduled to no longer be raised.
 */var AsyncObserver=/** @class */function(){function AsyncObserver(observer){this.observer=observer;/**
         * When set to true, will not raise future events. Necessary to deal with
         * async detachment of listener.
         */this.muted=false;}AsyncObserver.prototype.next=function(value){this.scheduleEvent(this.observer.next,value);};AsyncObserver.prototype.error=function(error){this.scheduleEvent(this.observer.error,error);};AsyncObserver.prototype.mute=function(){this.muted=true;};AsyncObserver.prototype.scheduleEvent=function(eventHandler,event){var _this=this;if(!this.muted){setTimeout(function(){if(!_this.muted){eventHandler(event);}},0);}};return AsyncObserver;}();/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */// The objects that are a part of this API are exposed to third-parties as
// compiled javascript so we want to flag our private members with a leading
// underscore to discourage their use.
// tslint:disable:strip-private-property-underscore
/**
 * A FieldPath refers to a field in a document. The path may consist of a single
 * field name (referring to a top-level field in the document), or a list of
 * field names (referring to a nested field in the document).
 */var FieldPath$1=/** @class */function(){/**
     * Creates a FieldPath from the provided field names. If more than one field
     * name is provided, the path will point to a nested field in a document.
     *
     * @param fieldNames A list of field names.
     */function FieldPath$1(){var fieldNames=[];for(var _i=0;_i<arguments.length;_i++){fieldNames[_i]=arguments[_i];}validateNamedArrayAtLeastNumberOfElements('FieldPath',fieldNames,'fieldNames',1);for(var i=0;i<fieldNames.length;++i){validateArgType('FieldPath','string',i,fieldNames[i]);if(fieldNames[i].length===0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). "+'Field names must not be empty.');}}this._internalPath=new FieldPath(fieldNames);}FieldPath$1.documentId=function(){return FieldPath$1._DOCUMENT_ID;};FieldPath$1.prototype.isEqual=function(other){if(!(other instanceof FieldPath$1)){throw invalidClassError('isEqual','FieldPath',1,other);}return this._internalPath.isEqual(other._internalPath);};/**
     * Internal Note: The backend doesn't technically support querying by
     * document ID. Instead it queries by the entire document name (full path
     * included), but in the cases we currently support documentId(), the net
     * effect is the same.
     */FieldPath$1._DOCUMENT_ID=new FieldPath$1(FieldPath.keyField().canonicalString());return FieldPath$1;}();/**
 * Matches any characters in a field path string that are reserved.
 */var RESERVED=new RegExp('[~\\*/\\[\\]]');/**
 * Parses a field path string into a FieldPath, treating dots as separators.
 */function fromDotSeparatedString(path){var found=path.search(RESERVED);if(found>=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid field path ("+path+"). Paths must not contain "+"'~', '*', '/', '[', or ']'");}try{return new(FieldPath$1.bind.apply(FieldPath$1,[void 0].concat(path.split('.'))))();}catch(e){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid field path ("+path+"). Paths must not be empty, "+"begin with '.', end with '.', or contain '..'");}}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var OAuthToken=/** @class */function(){function OAuthToken(value,user){this.user=user;this.type='OAuth';this.authHeaders={Authorization:"Bearer "+value};}return OAuthToken;}();/** A CredentialsProvider that always yields an empty token. */var EmptyCredentialsProvider=/** @class */function(){function EmptyCredentialsProvider(){/**
         * Stores the listener registered with setChangeListener()
         * This isn't actually necessary since the UID never changes, but we use this
         * to verify the listen contract is adhered to in tests.
         */this.changeListener=null;}EmptyCredentialsProvider.prototype.getToken=function(){return Promise.resolve(null);};EmptyCredentialsProvider.prototype.invalidateToken=function(){};EmptyCredentialsProvider.prototype.setChangeListener=function(changeListener){assert(!this.changeListener,'Can only call setChangeListener() once.');this.changeListener=changeListener;// Fire with initial user.
changeListener(User.UNAUTHENTICATED);};EmptyCredentialsProvider.prototype.removeChangeListener=function(){assert(this.changeListener!==null,'removeChangeListener() when no listener registered');this.changeListener=null;};return EmptyCredentialsProvider;}();var FirebaseCredentialsProvider=/** @class */function(){function FirebaseCredentialsProvider(app){var _this=this;this.app=app;/**
         * The auth token listener registered with FirebaseApp, retained here so we
         * can unregister it.
         */this.tokenListener=null;/**
         * Counter used to detect if the token changed while a getToken request was
         * outstanding.
         */this.tokenCounter=0;/** The listener registered with setChangeListener(). */this.changeListener=null;this.forceRefresh=false;this.tokenListener=function(){_this.tokenCounter++;_this.currentUser=_this.getUser();if(_this.changeListener){_this.changeListener(_this.currentUser);}};this.tokenCounter=0;// Will fire at least once where we set this.currentUser
this.app.INTERNAL.addAuthTokenListener(this.tokenListener);}FirebaseCredentialsProvider.prototype.getToken=function(){var _this=this;assert(this.tokenListener!=null,'getToken cannot be called after listener removed.');// Take note of the current value of the tokenCounter so that this method
// can fail (with an ABORTED error) if there is a token change while the
// request is outstanding.
var initialTokenCounter=this.tokenCounter;var forceRefresh=this.forceRefresh;this.forceRefresh=false;return this.app.INTERNAL.getToken(forceRefresh).then(function(tokenData){// Cancel the request since the token changed while the request was
// outstanding so the response is potentially for a previous user (which
// user, we can't be sure).
if(_this.tokenCounter!==initialTokenCounter){throw new FirestoreError(Code.ABORTED,'getToken aborted due to token change.');}else{if(tokenData){assert(typeof tokenData.accessToken==='string','Invalid tokenData returned from getToken():'+tokenData);return new OAuthToken(tokenData.accessToken,_this.currentUser);}else{return null;}}});};FirebaseCredentialsProvider.prototype.invalidateToken=function(){this.forceRefresh=true;};FirebaseCredentialsProvider.prototype.setChangeListener=function(changeListener){assert(!this.changeListener,'Can only call setChangeListener() once.');this.changeListener=changeListener;// Fire the initial event, but only if we received the initial user
if(this.currentUser){changeListener(this.currentUser);}};FirebaseCredentialsProvider.prototype.removeChangeListener=function(){assert(this.tokenListener!=null,'removeChangeListener() called twice');assert(this.changeListener!==null,'removeChangeListener() called when no listener registered');this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);this.tokenListener=null;this.changeListener=null;};FirebaseCredentialsProvider.prototype.getUser=function(){var currentUid=this.app.INTERNAL.getUid();assert(currentUid===null||typeof currentUid==='string','Received invalid UID: '+currentUid);return new User(currentUid);};return FirebaseCredentialsProvider;}();/*
 * FirstPartyToken provides a fresh token each time its value
 * is requested, because if the token is too old, requests will be rejected.
 * Technically this may no longer be necessary since the SDK should gracefully
 * recover from unauthenticated errors (see b/33147818 for context), but it's
 * safer to keep the implementation as-is.
 */var FirstPartyToken=/** @class */function(){function FirstPartyToken(gapi,sessionIndex){this.gapi=gapi;this.sessionIndex=sessionIndex;this.type='FirstParty';this.user=User.FIRST_PARTY;}Object.defineProperty(FirstPartyToken.prototype,"authHeaders",{get:function(){var headers={'X-Goog-AuthUser':this.sessionIndex};var authHeader=this.gapi.auth.getAuthHeaderValueForFirstParty([]);if(authHeader){headers['Authorization']=authHeader;}return headers;},enumerable:true,configurable:true});return FirstPartyToken;}();/*
 * Provides user credentials required for the Firestore JavaScript SDK
 * to authenticate the user, using technique that is only available
 * to applications hosted by Google.
 */var FirstPartyCredentialsProvider=/** @class */function(){function FirstPartyCredentialsProvider(gapi,sessionIndex){this.gapi=gapi;this.sessionIndex=sessionIndex;}FirstPartyCredentialsProvider.prototype.getToken=function(){return Promise.resolve(new FirstPartyToken(this.gapi,this.sessionIndex));};FirstPartyCredentialsProvider.prototype.setChangeListener=function(changeListener){// Fire with initial uid.
changeListener(User.FIRST_PARTY);};FirstPartyCredentialsProvider.prototype.removeChangeListener=function(){};FirstPartyCredentialsProvider.prototype.invalidateToken=function(){};return FirstPartyCredentialsProvider;}();/**
 * Builds a CredentialsProvider depending on the type of
 * the credentials passed in.
 */function makeCredentialsProvider(credentials){if(!credentials){return new EmptyCredentialsProvider();}switch(credentials.type){case'gapi':var client=credentials.client;// Make sure this is a Gapi client.
assert(!!(typeof client==='object'&&client!==null&&client['auth']&&client['auth']['getAuthHeaderValueForFirstParty']),'unexpected gapi interface');return new FirstPartyCredentialsProvider(client,credentials.sessionIndex||'0');case'provider':return credentials.client;default:throw new FirestoreError(Code.INVALID_ARGUMENT,'makeCredentialsProvider failed due to invalid credential type');}}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function isPartialObserver(obj){return implementsAnyMethods(obj,['next','error','complete']);}/**
 * Returns true if obj is an object and contains at least one of the specified
 * methods.
 */function implementsAnyMethods(obj,methods){if(typeof obj!=='object'||obj===null){return false;}var object=obj;for(var _i=0,methods_1=methods;_i<methods_1.length;_i++){var method=methods_1[_i];if(method in object&&typeof object[method]==='function'){return true;}}return false;}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * An opaque base class for FieldValue sentinel objects in our public API,
 * with public static methods for creating said sentinel objects.
 */// tslint:disable-next-line:class-as-namespace  We use this as a base class.
var FieldValueImpl=/** @class */function(){function FieldValueImpl(_methodName){this._methodName=_methodName;}FieldValueImpl.delete=function(){validateNoArgs('FieldValue.delete',arguments);return DeleteFieldValueImpl.instance;};FieldValueImpl.serverTimestamp=function(){validateNoArgs('FieldValue.serverTimestamp',arguments);return ServerTimestampFieldValueImpl.instance;};FieldValueImpl.arrayUnion=function(){var elements=[];for(var _i=0;_i<arguments.length;_i++){elements[_i]=arguments[_i];}validateAtLeastNumberOfArgs('FieldValue.arrayUnion',arguments,1);// NOTE: We don't actually parse the data until it's used in set() or
// update() since we need access to the Firestore instance.
return new ArrayUnionFieldValueImpl(elements);};FieldValueImpl.arrayRemove=function(){var elements=[];for(var _i=0;_i<arguments.length;_i++){elements[_i]=arguments[_i];}validateAtLeastNumberOfArgs('FieldValue.arrayRemove',arguments,1);// NOTE: We don't actually parse the data until it's used in set() or
// update() since we need access to the Firestore instance.
return new ArrayRemoveFieldValueImpl(elements);};FieldValueImpl.increment=function(n){validateArgType('FieldValue.increment','number',1,n);validateExactNumberOfArgs('FieldValue.increment',arguments,1);return new NumericIncrementFieldValueImpl(n);};FieldValueImpl.prototype.isEqual=function(other){return this===other;};return FieldValueImpl;}();var DeleteFieldValueImpl=/** @class */function(_super){tslib_1.__extends(DeleteFieldValueImpl,_super);function DeleteFieldValueImpl(){return _super.call(this,'FieldValue.delete')||this;}/** Singleton instance. */DeleteFieldValueImpl.instance=new DeleteFieldValueImpl();return DeleteFieldValueImpl;}(FieldValueImpl);var ServerTimestampFieldValueImpl=/** @class */function(_super){tslib_1.__extends(ServerTimestampFieldValueImpl,_super);function ServerTimestampFieldValueImpl(){return _super.call(this,'FieldValue.serverTimestamp')||this;}/** Singleton instance. */ServerTimestampFieldValueImpl.instance=new ServerTimestampFieldValueImpl();return ServerTimestampFieldValueImpl;}(FieldValueImpl);var ArrayUnionFieldValueImpl=/** @class */function(_super){tslib_1.__extends(ArrayUnionFieldValueImpl,_super);function ArrayUnionFieldValueImpl(_elements){var _this=_super.call(this,'FieldValue.arrayUnion')||this;_this._elements=_elements;return _this;}return ArrayUnionFieldValueImpl;}(FieldValueImpl);var ArrayRemoveFieldValueImpl=/** @class */function(_super){tslib_1.__extends(ArrayRemoveFieldValueImpl,_super);function ArrayRemoveFieldValueImpl(_elements){var _this=_super.call(this,'FieldValue.arrayRemove')||this;_this._elements=_elements;return _this;}return ArrayRemoveFieldValueImpl;}(FieldValueImpl);var NumericIncrementFieldValueImpl=/** @class */function(_super){tslib_1.__extends(NumericIncrementFieldValueImpl,_super);function NumericIncrementFieldValueImpl(_operand){var _this=_super.call(this,'FieldValue.increment')||this;_this._operand=_operand;return _this;}return NumericIncrementFieldValueImpl;}(FieldValueImpl);// Public instance that disallows construction at runtime. This constructor is
// used when exporting FieldValueImpl on firebase.firestore.FieldValue and will
// be called FieldValue publicly. Internally we still use FieldValueImpl which
// has a type-checked private constructor. Note that FieldValueImpl and
// PublicFieldValue can be used interchangeably in instanceof checks.
// For our internal TypeScript code PublicFieldValue doesn't exist as a type,
// and so we need to use FieldValueImpl as type and export it too.
// tslint:disable-next-line:variable-name  We treat this as a class name.
var PublicFieldValue=makeConstructorPrivate(FieldValueImpl,'Use FieldValue.<field>() instead.');/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var RESERVED_FIELD_REGEX=/^__.*__$/;/** The result of parsing document data (e.g. for a setData call). */var ParsedSetData=/** @class */function(){function ParsedSetData(data,fieldMask,fieldTransforms){this.data=data;this.fieldMask=fieldMask;this.fieldTransforms=fieldTransforms;}ParsedSetData.prototype.toMutations=function(key,precondition){var mutations=[];if(this.fieldMask!==null){mutations.push(new PatchMutation(key,this.data,this.fieldMask,precondition));}else{mutations.push(new SetMutation(key,this.data,precondition));}if(this.fieldTransforms.length>0){mutations.push(new TransformMutation(key,this.fieldTransforms));}return mutations;};return ParsedSetData;}();/** The result of parsing "update" data (i.e. for an updateData call). */var ParsedUpdateData=/** @class */function(){function ParsedUpdateData(data,fieldMask,fieldTransforms){this.data=data;this.fieldMask=fieldMask;this.fieldTransforms=fieldTransforms;}ParsedUpdateData.prototype.toMutations=function(key,precondition){var mutations=[new PatchMutation(key,this.data,this.fieldMask,precondition)];if(this.fieldTransforms.length>0){mutations.push(new TransformMutation(key,this.fieldTransforms));}return mutations;};return ParsedUpdateData;}();/*
 * Represents what type of API method provided the data being parsed; useful
 * for determining which error conditions apply during parsing and providing
 * better error messages.
 */var UserDataSource;(function(UserDataSource){UserDataSource[UserDataSource["Set"]=0]="Set";UserDataSource[UserDataSource["Update"]=1]="Update";UserDataSource[UserDataSource["MergeSet"]=2]="MergeSet";/**
     * Indicates the source is a where clause, cursor bound, arrayUnion()
     * element, etc. Of note, isWrite(source) will return false.
     */UserDataSource[UserDataSource["Argument"]=3]="Argument";})(UserDataSource||(UserDataSource={}));function isWrite(dataSource){switch(dataSource){case UserDataSource.Set:// fall through
case UserDataSource.MergeSet:// fall through
case UserDataSource.Update:return true;case UserDataSource.Argument:return false;default:throw fail("Unexpected case for UserDataSource: "+dataSource);}}/** A "context" object passed around while parsing user data. */var ParseContext=/** @class */function(){/**
     * Initializes a ParseContext with the given source and path.
     *
     * @param dataSource Indicates what kind of API method this data came from.
     * @param methodName The name of the method the user called to create this
     *     ParseContext.
     * @param path A path within the object being parsed. This could be an empty
     *     path (in which case the context represents the root of the data being
     *     parsed), or a nonempty path (indicating the context represents a nested
     *     location within the data).
     * @param arrayElement Whether or not this context corresponds to an element
     *     of an array.
     * @param fieldTransforms A mutable list of field transforms encountered while
     *     parsing the data.
     * @param fieldMask A mutable list of field paths encountered while parsing
     *     the data.
     *
     * TODO(b/34871131): We don't support array paths right now, so path can be
     * null to indicate the context represents any location within an array (in
     * which case certain features will not work and errors will be somewhat
     * compromised).
     */function ParseContext(dataSource,methodName,path,arrayElement,fieldTransforms,fieldMask){this.dataSource=dataSource;this.methodName=methodName;this.path=path;this.arrayElement=arrayElement;// Minor hack: If fieldTransforms is undefined, we assume this is an
// external call and we need to validate the entire path.
if(fieldTransforms===undefined){this.validatePath();}this.arrayElement=arrayElement!==undefined?arrayElement:false;this.fieldTransforms=fieldTransforms||[];this.fieldMask=fieldMask||[];}ParseContext.prototype.childContextForField=function(field){var childPath=this.path==null?null:this.path.child(field);var context=new ParseContext(this.dataSource,this.methodName,childPath,/*arrayElement=*/false,this.fieldTransforms,this.fieldMask);context.validatePathSegment(field);return context;};ParseContext.prototype.childContextForFieldPath=function(field){var childPath=this.path==null?null:this.path.child(field);var context=new ParseContext(this.dataSource,this.methodName,childPath,/*arrayElement=*/false,this.fieldTransforms,this.fieldMask);context.validatePath();return context;};ParseContext.prototype.childContextForArray=function(index){// TODO(b/34871131): We don't support array paths right now; so make path
// null.
return new ParseContext(this.dataSource,this.methodName,/*path=*/null,/*arrayElement=*/true,this.fieldTransforms,this.fieldMask);};ParseContext.prototype.createError=function(reason){var fieldDescription=this.path===null||this.path.isEmpty()?'':" (found in field "+this.path.toString()+")";return new FirestoreError(Code.INVALID_ARGUMENT,"Function "+this.methodName+"() called with invalid data. "+reason+fieldDescription);};/** Returns 'true' if 'fieldPath' was traversed when creating this context. */ParseContext.prototype.contains=function(fieldPath){return this.fieldMask.find(function(field){return fieldPath.isPrefixOf(field);})!==undefined||this.fieldTransforms.find(function(transform){return fieldPath.isPrefixOf(transform.field);})!==undefined;};ParseContext.prototype.validatePath=function(){// TODO(b/34871131): Remove null check once we have proper paths for fields
// within arrays.
if(this.path===null){return;}for(var i=0;i<this.path.length;i++){this.validatePathSegment(this.path.get(i));}};ParseContext.prototype.validatePathSegment=function(segment){if(isWrite(this.dataSource)&&RESERVED_FIELD_REGEX.test(segment)){throw this.createError('Document fields cannot begin and end with __');}};return ParseContext;}();/**
 * A placeholder object for DocumentReferences in this file, in order to
 * avoid a circular dependency. See the comments for `DataPreConverter` for
 * the full context.
 */var DocumentKeyReference=/** @class */function(){function DocumentKeyReference(databaseId,key){this.databaseId=databaseId;this.key=key;}return DocumentKeyReference;}();/**
 * Helper for parsing raw user input (provided via the API) into internal model
 * classes.
 */var UserDataConverter=/** @class */function(){function UserDataConverter(preConverter){this.preConverter=preConverter;}/** Parse document data from a non-merge set() call. */UserDataConverter.prototype.parseSetData=function(methodName,input){var context=new ParseContext(UserDataSource.Set,methodName,FieldPath.EMPTY_PATH);validatePlainObject('Data must be an object, but it was:',context,input);var updateData=this.parseData(input,context);return new ParsedSetData(updateData,/* fieldMask= */null,context.fieldTransforms);};/** Parse document data from a set() call with '{merge:true}'. */UserDataConverter.prototype.parseMergeData=function(methodName,input,fieldPaths){var context=new ParseContext(UserDataSource.MergeSet,methodName,FieldPath.EMPTY_PATH);validatePlainObject('Data must be an object, but it was:',context,input);var updateData=this.parseData(input,context);var fieldMask;var fieldTransforms;if(!fieldPaths){fieldMask=FieldMask.fromArray(context.fieldMask);fieldTransforms=context.fieldTransforms;}else{var validatedFieldPaths=new SortedSet(FieldPath.comparator);for(var _i=0,fieldPaths_1=fieldPaths;_i<fieldPaths_1.length;_i++){var stringOrFieldPath=fieldPaths_1[_i];var fieldPath=void 0;if(stringOrFieldPath instanceof FieldPath$1){fieldPath=stringOrFieldPath._internalPath;}else if(typeof stringOrFieldPath==='string'){fieldPath=fieldPathFromDotSeparatedString(methodName,stringOrFieldPath);}else{throw fail('Expected stringOrFieldPath to be a string or a FieldPath');}if(!context.contains(fieldPath)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Field '"+fieldPath+"' is specified in your field mask but missing from your input data.");}validatedFieldPaths=validatedFieldPaths.add(fieldPath);}fieldMask=FieldMask.fromSet(validatedFieldPaths);fieldTransforms=context.fieldTransforms.filter(function(transform){return fieldMask.covers(transform.field);});}return new ParsedSetData(updateData,fieldMask,fieldTransforms);};/** Parse update data from an update() call. */UserDataConverter.prototype.parseUpdateData=function(methodName,input){var _this=this;var context=new ParseContext(UserDataSource.Update,methodName,FieldPath.EMPTY_PATH);validatePlainObject('Data must be an object, but it was:',context,input);var fieldMaskPaths=new SortedSet(FieldPath.comparator);var updateData=ObjectValue.EMPTY;forEach(input,function(key,value){var path=fieldPathFromDotSeparatedString(methodName,key);var childContext=context.childContextForFieldPath(path);value=_this.runPreConverter(value,childContext);if(value instanceof DeleteFieldValueImpl){// Add it to the field mask, but don't add anything to updateData.
fieldMaskPaths=fieldMaskPaths.add(path);}else{var parsedValue=_this.parseData(value,childContext);if(parsedValue!=null){fieldMaskPaths=fieldMaskPaths.add(path);updateData=updateData.set(path,parsedValue);}}});var mask=FieldMask.fromSet(fieldMaskPaths);return new ParsedUpdateData(updateData,mask,context.fieldTransforms);};/** Parse update data from a list of field/value arguments. */UserDataConverter.prototype.parseUpdateVarargs=function(methodName,field,value,moreFieldsAndValues){var context=new ParseContext(UserDataSource.Update,methodName,FieldPath.EMPTY_PATH);var keys=[fieldPathFromArgument(methodName,field)];var values=[value];if(moreFieldsAndValues.length%2!==0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+methodName+"() needs to be called with an even number "+'of arguments that alternate between field names and values.');}for(var i=0;i<moreFieldsAndValues.length;i+=2){keys.push(fieldPathFromArgument(methodName,moreFieldsAndValues[i]));values.push(moreFieldsAndValues[i+1]);}var fieldMaskPaths=new SortedSet(FieldPath.comparator);var updateData=ObjectValue.EMPTY;for(var i=0;i<keys.length;++i){var path=keys[i];var childContext=context.childContextForFieldPath(path);var value_1=this.runPreConverter(values[i],childContext);if(value_1 instanceof DeleteFieldValueImpl){// Add it to the field mask, but don't add anything to updateData.
fieldMaskPaths=fieldMaskPaths.add(path);}else{var parsedValue=this.parseData(value_1,childContext);if(parsedValue!=null){fieldMaskPaths=fieldMaskPaths.add(path);updateData=updateData.set(path,parsedValue);}}}var mask=FieldMask.fromSet(fieldMaskPaths);return new ParsedUpdateData(updateData,mask,context.fieldTransforms);};/**
     * Parse a "query value" (e.g. value in a where filter or a value in a cursor
     * bound).
     */UserDataConverter.prototype.parseQueryValue=function(methodName,input){var context=new ParseContext(UserDataSource.Argument,methodName,FieldPath.EMPTY_PATH);var parsed=this.parseData(input,context);assert(parsed!=null,'Parsed data should not be null.');assert(context.fieldTransforms.length===0,'Field transforms should have been disallowed.');return parsed;};/** Sends data through this.preConverter, handling any thrown errors. */UserDataConverter.prototype.runPreConverter=function(input,context){try{return this.preConverter(input);}catch(e){var message=errorMessage(e);throw context.createError(message);}};/**
     * Internal helper for parsing user data.
     *
     * @param input Data to be parsed.
     * @param context A context object representing the current path being parsed,
     * the source of the data being parsed, etc.
     * @return The parsed value, or null if the value was a FieldValue sentinel
     * that should not be included in the resulting parsed data.
     */UserDataConverter.prototype.parseData=function(input,context){input=this.runPreConverter(input,context);if(looksLikeJsonObject(input)){validatePlainObject('Unsupported field value:',context,input);return this.parseObject(input,context);}else if(input instanceof FieldValueImpl){// FieldValues usually parse into transforms (except FieldValue.delete())
// in which case we do not want to include this field in our parsed data
// (as doing so will overwrite the field directly prior to the transform
// trying to transform it). So we don't add this location to
// context.fieldMask and we return null as our parsing result.
this.parseSentinelFieldValue(input,context);return null;}else{// If context.path is null we are inside an array and we don't support
// field mask paths more granular than the top-level array.
if(context.path){context.fieldMask.push(context.path);}if(input instanceof Array){// TODO(b/34871131): Include the path containing the array in the error
// message.
if(context.arrayElement){throw context.createError('Nested arrays are not supported');}return this.parseArray(input,context);}else{return this.parseScalarValue(input,context);}}};UserDataConverter.prototype.parseObject=function(obj,context){var _this=this;var result=new SortedMap(primitiveComparator);if(isEmpty(obj)){// If we encounter an empty object, we explicitly add it to the update
// mask to ensure that the server creates a map entry.
if(context.path&&context.path.length>0){context.fieldMask.push(context.path);}}else{forEach(obj,function(key,val){var parsedValue=_this.parseData(val,context.childContextForField(key));if(parsedValue!=null){result=result.insert(key,parsedValue);}});}return new ObjectValue(result);};UserDataConverter.prototype.parseArray=function(array,context){var result=[];var entryIndex=0;for(var _i=0,array_1=array;_i<array_1.length;_i++){var entry=array_1[_i];var parsedEntry=this.parseData(entry,context.childContextForArray(entryIndex));if(parsedEntry==null){// Just include nulls in the array for fields being replaced with a
// sentinel.
parsedEntry=NullValue.INSTANCE;}result.push(parsedEntry);entryIndex++;}return new ArrayValue(result);};/**
     * "Parses" the provided FieldValueImpl, adding any necessary transforms to
     * context.fieldTransforms.
     */UserDataConverter.prototype.parseSentinelFieldValue=function(value,context){// Sentinels are only supported with writes, and not within arrays.
if(!isWrite(context.dataSource)){throw context.createError(value._methodName+"() can only be used with update() and set()");}if(context.path===null){throw context.createError(value._methodName+"() is not currently supported inside arrays");}if(value instanceof DeleteFieldValueImpl){if(context.dataSource===UserDataSource.MergeSet){// No transform to add for a delete, but we need to add it to our
// fieldMask so it gets deleted.
context.fieldMask.push(context.path);}else if(context.dataSource===UserDataSource.Update){assert(context.path.length>0,'FieldValue.delete() at the top level should have already'+' been handled.');throw context.createError('FieldValue.delete() can only appear at the top level '+'of your update data');}else{// We shouldn't encounter delete sentinels for queries or non-merge set() calls.
throw context.createError('FieldValue.delete() cannot be used with set() unless you pass '+'{merge:true}');}}else if(value instanceof ServerTimestampFieldValueImpl){context.fieldTransforms.push(new FieldTransform(context.path,ServerTimestampTransform.instance));}else if(value instanceof ArrayUnionFieldValueImpl){var parsedElements=this.parseArrayTransformElements(value._methodName,value._elements);var arrayUnion=new ArrayUnionTransformOperation(parsedElements);context.fieldTransforms.push(new FieldTransform(context.path,arrayUnion));}else if(value instanceof ArrayRemoveFieldValueImpl){var parsedElements=this.parseArrayTransformElements(value._methodName,value._elements);var arrayRemove=new ArrayRemoveTransformOperation(parsedElements);context.fieldTransforms.push(new FieldTransform(context.path,arrayRemove));}else if(value instanceof NumericIncrementFieldValueImpl){var operand=this.parseQueryValue('FieldValue.increment',value._operand);var numericIncrement=new NumericIncrementTransformOperation(operand);context.fieldTransforms.push(new FieldTransform(context.path,numericIncrement));}else{fail('Unknown FieldValue type: '+value);}};/**
     * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)
     *
     * @return The parsed value
     */UserDataConverter.prototype.parseScalarValue=function(value,context){if(value===null){return NullValue.INSTANCE;}else if(typeof value==='number'){if(isSafeInteger(value)){return new IntegerValue(value);}else{return new DoubleValue(value);}}else if(typeof value==='boolean'){return BooleanValue.of(value);}else if(typeof value==='string'){return new StringValue(value);}else if(value instanceof Date){return new TimestampValue(Timestamp.fromDate(value));}else if(value instanceof Timestamp){// Firestore backend truncates precision down to microseconds. To ensure
// offline mode works the same with regards to truncation, perform the
// truncation immediately without waiting for the backend to do that.
return new TimestampValue(new Timestamp(value.seconds,Math.floor(value.nanoseconds/1000)*1000));}else if(value instanceof GeoPoint){return new GeoPointValue(value);}else if(value instanceof Blob){return new BlobValue(value);}else if(value instanceof DocumentKeyReference){return new RefValue(value.databaseId,value.key);}else{throw context.createError("Unsupported field value: "+valueDescription(value));}};UserDataConverter.prototype.parseArrayTransformElements=function(methodName,elements){var _this=this;return elements.map(function(element,i){// Although array transforms are used with writes, the actual elements
// being unioned or removed are not considered writes since they cannot
// contain any FieldValue sentinels, etc.
var context=new ParseContext(UserDataSource.Argument,methodName,FieldPath.EMPTY_PATH);return _this.parseData(element,context.childContextForArray(i));});};return UserDataConverter;}();/**
 * Checks whether an object looks like a JSON object that should be converted
 * into a struct. Normal class/prototype instances are considered to look like
 * JSON objects since they should be converted to a struct value. Arrays, Dates,
 * GeoPoints, etc. are not considered to look like JSON objects since they map
 * to specific FieldValue types other than ObjectValue.
 */function looksLikeJsonObject(input){return typeof input==='object'&&input!==null&&!(input instanceof Array)&&!(input instanceof Date)&&!(input instanceof Timestamp)&&!(input instanceof GeoPoint)&&!(input instanceof Blob)&&!(input instanceof DocumentKeyReference)&&!(input instanceof FieldValueImpl);}function validatePlainObject(message,context,input){if(!looksLikeJsonObject(input)||!isPlainObject(input)){var description=valueDescription(input);if(description==='an object'){// Massage the error if it was an object.
throw context.createError(message+' a custom object');}else{throw context.createError(message+' '+description);}}}/**
 * Helper that calls fromDotSeparatedString() but wraps any error thrown.
 */function fieldPathFromArgument(methodName,path){if(path instanceof FieldPath$1){return path._internalPath;}else if(typeof path==='string'){return fieldPathFromDotSeparatedString(methodName,path);}else{var message='Field path arguments must be of type string or FieldPath.';throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+methodName+"() called with invalid data. "+message);}}/**
 * Wraps fromDotSeparatedString with an error message about the method that
 * was thrown.
 * @param methodName The publicly visible method name
 * @param path The dot-separated string form of a field path which will be split
 * on dots.
 */function fieldPathFromDotSeparatedString(methodName,path){try{return fromDotSeparatedString(path)._internalPath;}catch(e){var message=errorMessage(e);throw new FirestoreError(Code.INVALID_ARGUMENT,"Function "+methodName+"() called with invalid data. "+message);}}/**
 * Extracts the message from a caught exception, which should be an Error object
 * though JS doesn't guarantee that.
 */function errorMessage(error){return error instanceof Error?error.message:error.toString();}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */// The objects that are a part of this API are exposed to third-parties as
// compiled javascript so we want to flag our private members with a leading
// underscore to discourage their use.
// tslint:disable:strip-private-property-underscore
// settings() defaults:
var DEFAULT_HOST='firestore.googleapis.com';var DEFAULT_SSL=true;var DEFAULT_TIMESTAMPS_IN_SNAPSHOTS=true;var DEFAULT_FORCE_LONG_POLLING=false;/**
 * Constant used to indicate the LRU garbage collection should be disabled.
 * Set this value as the `cacheSizeBytes` on the settings passed to the
 * `Firestore` instance.
 */var CACHE_SIZE_UNLIMITED=LruParams.COLLECTION_DISABLED;// enablePersistence() defaults:
var DEFAULT_SYNCHRONIZE_TABS=false;/**
 * A concrete type describing all the values that can be applied via a
 * user-supplied firestore.Settings object. This is a separate type so that
 * defaults can be supplied and the value can be checked for equality.
 */var FirestoreSettings=/** @class */function(){function FirestoreSettings(settings){if(settings.host===undefined){if(settings.ssl!==undefined){throw new FirestoreError(Code.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");}this.host=DEFAULT_HOST;this.ssl=DEFAULT_SSL;}else{validateNamedType('settings','non-empty string','host',settings.host);this.host=settings.host;validateNamedOptionalType('settings','boolean','ssl',settings.ssl);this.ssl=defaulted(settings.ssl,DEFAULT_SSL);}validateOptionNames('settings',settings,['host','ssl','credentials','timestampsInSnapshots','cacheSizeBytes','experimentalForceLongPolling']);validateNamedOptionalType('settings','object','credentials',settings.credentials);this.credentials=settings.credentials;validateNamedOptionalType('settings','boolean','timestampsInSnapshots',settings.timestampsInSnapshots);// Nobody should set timestampsInSnapshots anymore, but the error depends on
// whether they set it to true or false...
if(settings.timestampsInSnapshots===true){error("\n  The timestampsInSnapshots setting now defaults to true and you no\n  longer need to explicitly set it. In a future release, the setting\n  will be removed entirely and so it is recommended that you remove it\n  from your firestore.settings() call now.");}else if(settings.timestampsInSnapshots===false){error("\n  The timestampsInSnapshots setting will soon be removed. YOU MUST UPDATE\n  YOUR CODE.\n\n  To hide this warning, stop using the timestampsInSnapshots setting in your\n  firestore.settings({ ... }) call.\n\n  Once you remove the setting, Timestamps stored in Cloud Firestore will be\n  read back as Firebase Timestamp objects instead of as system Date objects.\n  So you will also need to update code expecting a Date to instead expect a\n  Timestamp. For example:\n\n  // Old:\n  const date = snapshot.get('created_at');\n  // New:\n  const timestamp = snapshot.get('created_at'); const date =\n  timestamp.toDate();\n\n  Please audit all existing usages of Date when you enable the new\n  behavior.");}this.timestampsInSnapshots=defaulted(settings.timestampsInSnapshots,DEFAULT_TIMESTAMPS_IN_SNAPSHOTS);validateNamedOptionalType('settings','number','cacheSizeBytes',settings.cacheSizeBytes);if(settings.cacheSizeBytes===undefined){this.cacheSizeBytes=LruParams.DEFAULT_CACHE_SIZE_BYTES;}else{if(settings.cacheSizeBytes!==CACHE_SIZE_UNLIMITED&&settings.cacheSizeBytes<LruParams.MINIMUM_CACHE_SIZE_BYTES){throw new FirestoreError(Code.INVALID_ARGUMENT,"cacheSizeBytes must be at least "+LruParams.MINIMUM_CACHE_SIZE_BYTES);}else{this.cacheSizeBytes=settings.cacheSizeBytes;}}validateNamedOptionalType('settings','boolean','experimentalForceLongPolling',settings.experimentalForceLongPolling);this.forceLongPolling=settings.experimentalForceLongPolling===undefined?DEFAULT_FORCE_LONG_POLLING:settings.experimentalForceLongPolling;}FirestoreSettings.prototype.isEqual=function(other){return this.host===other.host&&this.ssl===other.ssl&&this.timestampsInSnapshots===other.timestampsInSnapshots&&this.credentials===other.credentials&&this.cacheSizeBytes===other.cacheSizeBytes&&this.forceLongPolling===other.forceLongPolling;};return FirestoreSettings;}();var FirestoreConfig=/** @class */function(){function FirestoreConfig(){}return FirestoreConfig;}();/**
 * The root reference to the database.
 */var Firestore=/** @class */function(){function Firestore(databaseIdOrApp){var _this=this;// Public for use in tests.
// TODO(mikelehen): Use modularized initialization instead.
this._queue=new AsyncQueue();this.INTERNAL={delete:function(){return tslib_1.__awaiter(_this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:// The client must be initalized to ensure that all subsequent API usage
// throws an exception.
this.ensureClientConfigured();return[4/*yield*/,this._firestoreClient.shutdown()];case 1:_a.sent();this.clientRunning=false;return[2/*return*/];}});});}};this.clientRunning=false;var config=new FirestoreConfig();if(typeof databaseIdOrApp.options==='object'){// This is very likely a Firebase app object
// TODO(b/34177605): Can we somehow use instanceof?
var app=databaseIdOrApp;config.firebaseApp=app;config.databaseId=Firestore.databaseIdFromApp(app);config.persistenceKey=config.firebaseApp.name;config.credentials=new FirebaseCredentialsProvider(app);}else{var external_1=databaseIdOrApp;if(!external_1.projectId){throw new FirestoreError(Code.INVALID_ARGUMENT,'Must provide projectId');}config.databaseId=new DatabaseId(external_1.projectId,external_1.database);// Use a default persistenceKey that lines up with FirebaseApp.
config.persistenceKey='[DEFAULT]';config.credentials=new EmptyCredentialsProvider();}config.settings=new FirestoreSettings({});this._config=config;this._databaseId=config.databaseId;}Firestore.prototype.settings=function(settingsLiteral){validateExactNumberOfArgs('Firestore.settings',arguments,1);validateArgType('Firestore.settings','object',1,settingsLiteral);if(contains(settingsLiteral,'persistence')){throw new FirestoreError(Code.INVALID_ARGUMENT,'"persistence" is now specified with a separate call to '+'firestore.enablePersistence().');}var newSettings=new FirestoreSettings(settingsLiteral);if(this._firestoreClient&&!this._config.settings.isEqual(newSettings)){throw new FirestoreError(Code.FAILED_PRECONDITION,'Firestore has already been started and its settings can no longer '+'be changed. You can only call settings() before calling any other '+'methods on a Firestore object.');}this._config.settings=newSettings;if(newSettings.credentials!==undefined){this._config.credentials=makeCredentialsProvider(newSettings.credentials);}};Firestore.prototype.enableNetwork=function(){this.ensureClientConfigured();return this._firestoreClient.enableNetwork();};Firestore.prototype.disableNetwork=function(){this.ensureClientConfigured();return this._firestoreClient.disableNetwork();};Firestore.prototype.enablePersistence=function(settings){if(this._firestoreClient){throw new FirestoreError(Code.FAILED_PRECONDITION,'Firestore has already been started and persistence can no longer '+'be enabled. You can only call enablePersistence() before calling '+'any other methods on a Firestore object.');}return this.configureClient(new IndexedDbPersistenceSettings(this._config.settings.cacheSizeBytes,settings!==undefined&&defaulted(settings.experimentalTabSynchronization,DEFAULT_SYNCHRONIZE_TABS)));};Firestore.prototype._clearPersistence=function(){if(this.clientRunning){throw new FirestoreError(Code.FAILED_PRECONDITION,'Persistence cannot be cleared while the client is running');}var persistenceKey=IndexedDbPersistence.buildStoragePrefix(this.makeDatabaseInfo());return IndexedDbPersistence.clearPersistence(persistenceKey);};Firestore.prototype.ensureClientConfigured=function(){if(!this._firestoreClient){// Kick off starting the client but don't actually wait for it.
// tslint:disable-next-line:no-floating-promises
this.configureClient(new MemoryPersistenceSettings());}return this._firestoreClient;};Firestore.prototype.makeDatabaseInfo=function(){return new DatabaseInfo(this._config.databaseId,this._config.persistenceKey,this._config.settings.host,this._config.settings.ssl,this._config.settings.forceLongPolling);};Firestore.prototype.configureClient=function(persistenceSettings){var _this=this;assert(!!this._config.settings.host,'FirestoreSettings.host cannot be falsey');assert(!this._firestoreClient,'configureClient() called multiple times');this.clientRunning=true;var databaseInfo=this.makeDatabaseInfo();var preConverter=function(value){if(value instanceof DocumentReference){var thisDb=_this._config.databaseId;var otherDb=value.firestore._config.databaseId;if(!otherDb.isEqual(thisDb)){throw new FirestoreError(Code.INVALID_ARGUMENT,'Document reference is for database '+(otherDb.projectId+"/"+otherDb.database+" but should be ")+("for database "+thisDb.projectId+"/"+thisDb.database));}return new DocumentKeyReference(_this._config.databaseId,value._key);}else{return value;}};this._dataConverter=new UserDataConverter(preConverter);this._firestoreClient=new FirestoreClient(PlatformSupport.getPlatform(),databaseInfo,this._config.credentials,this._queue);return this._firestoreClient.start(persistenceSettings);};Firestore.databaseIdFromApp=function(app){var options=app.options;if(!contains(options,'projectId')){throw new FirestoreError(Code.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');}var projectId=options['projectId'];if(!projectId||typeof projectId!=='string'){throw new FirestoreError(Code.INVALID_ARGUMENT,'projectId must be a string in FirebaseApp.options');}return new DatabaseId(projectId);};Object.defineProperty(Firestore.prototype,"app",{get:function(){if(!this._config.firebaseApp){throw new FirestoreError(Code.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is "+'not available');}return this._config.firebaseApp;},enumerable:true,configurable:true});Firestore.prototype.collection=function(pathString){validateExactNumberOfArgs('Firestore.collection',arguments,1);validateArgType('Firestore.collection','non-empty string',1,pathString);this.ensureClientConfigured();return new CollectionReference(ResourcePath.fromString(pathString),this);};Firestore.prototype.doc=function(pathString){validateExactNumberOfArgs('Firestore.doc',arguments,1);validateArgType('Firestore.doc','non-empty string',1,pathString);this.ensureClientConfigured();return DocumentReference.forPath(ResourcePath.fromString(pathString),this);};// TODO(b/116617988): Fix name, uncomment d.ts definitions, and update CHANGELOG.md.
Firestore.prototype._collectionGroup=function(collectionId){validateExactNumberOfArgs('Firestore.collectionGroup',arguments,1);validateArgType('Firestore.collectionGroup','non-empty string',1,collectionId);if(collectionId.indexOf('/')>=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid collection ID '"+collectionId+"' passed to function "+"Firestore.collectionGroup(). Collection IDs must not contain '/'.");}this.ensureClientConfigured();return new Query$1(new Query(ResourcePath.EMPTY_PATH,collectionId),this);};Firestore.prototype.runTransaction=function(updateFunction){var _this=this;validateExactNumberOfArgs('Firestore.runTransaction',arguments,1);validateArgType('Firestore.runTransaction','function',1,updateFunction);return this.ensureClientConfigured().transaction(function(transaction){return updateFunction(new Transaction$1(_this,transaction));});};Firestore.prototype.batch=function(){this.ensureClientConfigured();return new WriteBatch(this);};Object.defineProperty(Firestore,"logLevel",{get:function(){switch(getLogLevel()){case LogLevel.DEBUG:return'debug';case LogLevel.ERROR:return'error';case LogLevel.SILENT:return'silent';default:return fail('Unknown log level: '+getLogLevel());}},enumerable:true,configurable:true});Firestore.setLogLevel=function(level){validateExactNumberOfArgs('Firestore.setLogLevel',arguments,1);validateArgType('Firestore.setLogLevel','non-empty string',1,level);switch(level){case'debug':setLogLevel(LogLevel.DEBUG);break;case'error':setLogLevel(LogLevel.ERROR);break;case'silent':setLogLevel(LogLevel.SILENT);break;default:throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid log level: '+level);}};// Note: this is not a property because the minifier can't work correctly with
// the way TypeScript compiler outputs properties.
Firestore.prototype._areTimestampsInSnapshotsEnabled=function(){return this._config.settings.timestampsInSnapshots;};return Firestore;}();/**
 * A reference to a transaction.
 */var Transaction$1=/** @class */function(){function Transaction(_firestore,_transaction){this._firestore=_firestore;this._transaction=_transaction;}Transaction.prototype.get=function(documentRef){var _this=this;validateExactNumberOfArgs('Transaction.get',arguments,1);var ref=validateReference('Transaction.get',documentRef,this._firestore);return this._transaction.lookup([ref._key]).then(function(docs){if(!docs||docs.length!==1){return fail('Mismatch in docs returned from document lookup.');}var doc=docs[0];if(doc instanceof NoDocument){return new DocumentSnapshot(_this._firestore,ref._key,null,/* fromCache= */false,/* hasPendingWrites= */false);}else if(doc instanceof Document){return new DocumentSnapshot(_this._firestore,ref._key,doc,/* fromCache= */false,/* hasPendingWrites= */false);}else{throw fail("BatchGetDocumentsRequest returned unexpected document type: "+doc.constructor.name);}});};Transaction.prototype.set=function(documentRef,value,options){validateBetweenNumberOfArgs('Transaction.set',arguments,2,3);var ref=validateReference('Transaction.set',documentRef,this._firestore);options=validateSetOptions('Transaction.set',options);var parsed=options.merge||options.mergeFields?this._firestore._dataConverter.parseMergeData('Transaction.set',value,options.mergeFields):this._firestore._dataConverter.parseSetData('Transaction.set',value);this._transaction.set(ref._key,parsed);return this;};Transaction.prototype.update=function(documentRef,fieldOrUpdateData,value){var moreFieldsAndValues=[];for(var _i=3;_i<arguments.length;_i++){moreFieldsAndValues[_i-3]=arguments[_i];}var ref;var parsed;if(typeof fieldOrUpdateData==='string'||fieldOrUpdateData instanceof FieldPath$1){validateAtLeastNumberOfArgs('Transaction.update',arguments,3);ref=validateReference('Transaction.update',documentRef,this._firestore);parsed=this._firestore._dataConverter.parseUpdateVarargs('Transaction.update',fieldOrUpdateData,value,moreFieldsAndValues);}else{validateExactNumberOfArgs('Transaction.update',arguments,2);ref=validateReference('Transaction.update',documentRef,this._firestore);parsed=this._firestore._dataConverter.parseUpdateData('Transaction.update',fieldOrUpdateData);}this._transaction.update(ref._key,parsed);return this;};Transaction.prototype.delete=function(documentRef){validateExactNumberOfArgs('Transaction.delete',arguments,1);var ref=validateReference('Transaction.delete',documentRef,this._firestore);this._transaction.delete(ref._key);return this;};return Transaction;}();var WriteBatch=/** @class */function(){function WriteBatch(_firestore){this._firestore=_firestore;this._mutations=[];this._committed=false;}WriteBatch.prototype.set=function(documentRef,value,options){validateBetweenNumberOfArgs('WriteBatch.set',arguments,2,3);this.verifyNotCommitted();var ref=validateReference('WriteBatch.set',documentRef,this._firestore);options=validateSetOptions('WriteBatch.set',options);var parsed=options.merge||options.mergeFields?this._firestore._dataConverter.parseMergeData('WriteBatch.set',value,options.mergeFields):this._firestore._dataConverter.parseSetData('WriteBatch.set',value);this._mutations=this._mutations.concat(parsed.toMutations(ref._key,Precondition.NONE));return this;};WriteBatch.prototype.update=function(documentRef,fieldOrUpdateData,value){var moreFieldsAndValues=[];for(var _i=3;_i<arguments.length;_i++){moreFieldsAndValues[_i-3]=arguments[_i];}this.verifyNotCommitted();var ref;var parsed;if(typeof fieldOrUpdateData==='string'||fieldOrUpdateData instanceof FieldPath$1){validateAtLeastNumberOfArgs('WriteBatch.update',arguments,3);ref=validateReference('WriteBatch.update',documentRef,this._firestore);parsed=this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update',fieldOrUpdateData,value,moreFieldsAndValues);}else{validateExactNumberOfArgs('WriteBatch.update',arguments,2);ref=validateReference('WriteBatch.update',documentRef,this._firestore);parsed=this._firestore._dataConverter.parseUpdateData('WriteBatch.update',fieldOrUpdateData);}this._mutations=this._mutations.concat(parsed.toMutations(ref._key,Precondition.exists(true)));return this;};WriteBatch.prototype.delete=function(documentRef){validateExactNumberOfArgs('WriteBatch.delete',arguments,1);this.verifyNotCommitted();var ref=validateReference('WriteBatch.delete',documentRef,this._firestore);this._mutations=this._mutations.concat(new DeleteMutation(ref._key,Precondition.NONE));return this;};WriteBatch.prototype.commit=function(){return tslib_1.__awaiter(this,void 0,void 0,function(){return tslib_1.__generator(this,function(_a){this.verifyNotCommitted();this._committed=true;if(this._mutations.length>0){return[2/*return*/,this._firestore.ensureClientConfigured().write(this._mutations)];}return[2/*return*/];});});};WriteBatch.prototype.verifyNotCommitted=function(){if(this._committed){throw new FirestoreError(Code.FAILED_PRECONDITION,'A write batch can no longer be used after commit() '+'has been called.');}};return WriteBatch;}();/**
 * A reference to a particular document in a collection in the database.
 */var DocumentReference=/** @class */function(){function DocumentReference(_key,firestore){this._key=_key;this.firestore=firestore;this._firestoreClient=this.firestore.ensureClientConfigured();}DocumentReference.forPath=function(path,firestore){if(path.length%2!==0){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid document reference. Document '+'references must have an even number of segments, but '+(path.canonicalString()+" has "+path.length));}return new DocumentReference(new DocumentKey(path),firestore);};Object.defineProperty(DocumentReference.prototype,"id",{get:function(){return this._key.path.lastSegment();},enumerable:true,configurable:true});Object.defineProperty(DocumentReference.prototype,"parent",{get:function(){return new CollectionReference(this._key.path.popLast(),this.firestore);},enumerable:true,configurable:true});Object.defineProperty(DocumentReference.prototype,"path",{get:function(){return this._key.path.canonicalString();},enumerable:true,configurable:true});DocumentReference.prototype.collection=function(pathString){validateExactNumberOfArgs('DocumentReference.collection',arguments,1);validateArgType('DocumentReference.collection','non-empty string',1,pathString);if(!pathString){throw new FirestoreError(Code.INVALID_ARGUMENT,'Must provide a non-empty collection name to collection()');}var path=ResourcePath.fromString(pathString);return new CollectionReference(this._key.path.child(path),this.firestore);};DocumentReference.prototype.isEqual=function(other){if(!(other instanceof DocumentReference)){throw invalidClassError('isEqual','DocumentReference',1,other);}return this.firestore===other.firestore&&this._key.isEqual(other._key);};DocumentReference.prototype.set=function(value,options){validateBetweenNumberOfArgs('DocumentReference.set',arguments,1,2);options=validateSetOptions('DocumentReference.set',options);var parsed=options.merge||options.mergeFields?this.firestore._dataConverter.parseMergeData('DocumentReference.set',value,options.mergeFields):this.firestore._dataConverter.parseSetData('DocumentReference.set',value);return this._firestoreClient.write(parsed.toMutations(this._key,Precondition.NONE));};DocumentReference.prototype.update=function(fieldOrUpdateData,value){var moreFieldsAndValues=[];for(var _i=2;_i<arguments.length;_i++){moreFieldsAndValues[_i-2]=arguments[_i];}var parsed;if(typeof fieldOrUpdateData==='string'||fieldOrUpdateData instanceof FieldPath$1){validateAtLeastNumberOfArgs('DocumentReference.update',arguments,2);parsed=this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update',fieldOrUpdateData,value,moreFieldsAndValues);}else{validateExactNumberOfArgs('DocumentReference.update',arguments,1);parsed=this.firestore._dataConverter.parseUpdateData('DocumentReference.update',fieldOrUpdateData);}return this._firestoreClient.write(parsed.toMutations(this._key,Precondition.exists(true)));};DocumentReference.prototype.delete=function(){validateExactNumberOfArgs('DocumentReference.delete',arguments,0);return this._firestoreClient.write([new DeleteMutation(this._key,Precondition.NONE)]);};DocumentReference.prototype.onSnapshot=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}validateBetweenNumberOfArgs('DocumentReference.onSnapshot',arguments,1,4);var options={includeMetadataChanges:false};var observer;var currArg=0;if(typeof args[currArg]==='object'&&!isPartialObserver(args[currArg])){options=args[currArg];validateOptionNames('DocumentReference.onSnapshot',options,['includeMetadataChanges']);validateNamedOptionalType('DocumentReference.onSnapshot','boolean','includeMetadataChanges',options.includeMetadataChanges);currArg++;}var internalOptions={includeMetadataChanges:options.includeMetadataChanges};if(isPartialObserver(args[currArg])){observer=args[currArg];}else{validateArgType('DocumentReference.onSnapshot','function',currArg,args[currArg]);validateOptionalArgType('DocumentReference.onSnapshot','function',currArg+1,args[currArg+1]);validateOptionalArgType('DocumentReference.onSnapshot','function',currArg+2,args[currArg+2]);observer={next:args[currArg],error:args[currArg+1],complete:args[currArg+2]};}return this.onSnapshotInternal(internalOptions,observer);};DocumentReference.prototype.onSnapshotInternal=function(options,observer){var _this=this;var errHandler=function(err){console.error('Uncaught Error in onSnapshot:',err);};if(observer.error){errHandler=observer.error.bind(observer);}var asyncObserver=new AsyncObserver({next:function(snapshot){if(observer.next){assert(snapshot.docs.size<=1,'Too many documents returned on a document query');var doc=snapshot.docs.get(_this._key);observer.next(new DocumentSnapshot(_this.firestore,_this._key,doc,snapshot.fromCache,snapshot.hasPendingWrites));}},error:errHandler});var internalListener=this._firestoreClient.listen(Query.atPath(this._key.path),asyncObserver,options);return function(){asyncObserver.mute();_this._firestoreClient.unlisten(internalListener);};};DocumentReference.prototype.get=function(options){var _this=this;validateBetweenNumberOfArgs('DocumentReference.get',arguments,0,1);validateGetOptions('DocumentReference.get',options);return new Promise(function(resolve,reject){if(options&&options.source==='cache'){_this.firestore.ensureClientConfigured().getDocumentFromLocalCache(_this._key).then(function(doc){resolve(new DocumentSnapshot(_this.firestore,_this._key,doc,/*fromCache=*/true,doc instanceof Document?doc.hasLocalMutations:false));},reject);}else{_this.getViaSnapshotListener(resolve,reject,options);}});};DocumentReference.prototype.getViaSnapshotListener=function(resolve,reject,options){var unlisten=this.onSnapshotInternal({includeMetadataChanges:true,waitForSyncWhenOnline:true},{next:function(snap){// Remove query first before passing event to user to avoid
// user actions affecting the now stale query.
unlisten();if(!snap.exists&&snap.metadata.fromCache){// TODO(dimond): If we're online and the document doesn't
// exist then we resolve with a doc.exists set to false. If
// we're offline however, we reject the Promise in this
// case. Two options: 1) Cache the negative response from
// the server so we can deliver that even when you're
// offline 2) Actually reject the Promise in the online case
// if the document doesn't exist.
reject(new FirestoreError(Code.UNAVAILABLE,'Failed to get document because the client is '+'offline.'));}else if(snap.exists&&snap.metadata.fromCache&&options&&options.source==='server'){reject(new FirestoreError(Code.UNAVAILABLE,'Failed to get document from server. (However, this '+'document does exist in the local cache. Run again '+'without setting source to "server" to '+'retrieve the cached document.)'));}else{resolve(snap);}},error:reject});};return DocumentReference;}();var SnapshotMetadata=/** @class */function(){function SnapshotMetadata(hasPendingWrites,fromCache){this.hasPendingWrites=hasPendingWrites;this.fromCache=fromCache;}SnapshotMetadata.prototype.isEqual=function(other){return this.hasPendingWrites===other.hasPendingWrites&&this.fromCache===other.fromCache;};return SnapshotMetadata;}();var DocumentSnapshot=/** @class */function(){function DocumentSnapshot(_firestore,_key,_document,_fromCache,_hasPendingWrites){this._firestore=_firestore;this._key=_key;this._document=_document;this._fromCache=_fromCache;this._hasPendingWrites=_hasPendingWrites;}DocumentSnapshot.prototype.data=function(options){validateBetweenNumberOfArgs('DocumentSnapshot.data',arguments,0,1);options=validateSnapshotOptions('DocumentSnapshot.data',options);return!this._document?undefined:this.convertObject(this._document.data,FieldValueOptions.fromSnapshotOptions(options,this._firestore._areTimestampsInSnapshotsEnabled()));};DocumentSnapshot.prototype.get=function(fieldPath,options){validateBetweenNumberOfArgs('DocumentSnapshot.get',arguments,1,2);options=validateSnapshotOptions('DocumentSnapshot.get',options);if(this._document){var value=this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get',fieldPath));if(value!==undefined){return this.convertValue(value,FieldValueOptions.fromSnapshotOptions(options,this._firestore._areTimestampsInSnapshotsEnabled()));}}return undefined;};Object.defineProperty(DocumentSnapshot.prototype,"id",{get:function(){return this._key.path.lastSegment();},enumerable:true,configurable:true});Object.defineProperty(DocumentSnapshot.prototype,"ref",{get:function(){return new DocumentReference(this._key,this._firestore);},enumerable:true,configurable:true});Object.defineProperty(DocumentSnapshot.prototype,"exists",{get:function(){return this._document!==null;},enumerable:true,configurable:true});Object.defineProperty(DocumentSnapshot.prototype,"metadata",{get:function(){return new SnapshotMetadata(this._hasPendingWrites,this._fromCache);},enumerable:true,configurable:true});DocumentSnapshot.prototype.isEqual=function(other){if(!(other instanceof DocumentSnapshot)){throw invalidClassError('isEqual','DocumentSnapshot',1,other);}return this._firestore===other._firestore&&this._fromCache===other._fromCache&&this._key.isEqual(other._key)&&(this._document===null?other._document===null:this._document.isEqual(other._document));};DocumentSnapshot.prototype.convertObject=function(data,options){var _this=this;var result={};data.forEach(function(key,value){result[key]=_this.convertValue(value,options);});return result;};DocumentSnapshot.prototype.convertValue=function(value,options){if(value instanceof ObjectValue){return this.convertObject(value,options);}else if(value instanceof ArrayValue){return this.convertArray(value,options);}else if(value instanceof RefValue){var key=value.value(options);var database=this._firestore.ensureClientConfigured().databaseId();if(!value.databaseId.isEqual(database)){// TODO(b/64130202): Somehow support foreign references.
error("Document "+this._key.path+" contains a document "+"reference within a different database ("+(value.databaseId.projectId+"/"+value.databaseId.database+") which is not ")+"supported. It will be treated as a reference in the current "+("database ("+database.projectId+"/"+database.database+") ")+"instead.");}return new DocumentReference(key,this._firestore);}else{return value.value(options);}};DocumentSnapshot.prototype.convertArray=function(data,options){var _this=this;return data.internalValue.map(function(value){return _this.convertValue(value,options);});};return DocumentSnapshot;}();var QueryDocumentSnapshot=/** @class */function(_super){tslib_1.__extends(QueryDocumentSnapshot,_super);function QueryDocumentSnapshot(firestore,key,document,fromCache,hasPendingWrites){return _super.call(this,firestore,key,document,fromCache,hasPendingWrites)||this;}QueryDocumentSnapshot.prototype.data=function(options){var data=_super.prototype.data.call(this,options);assert(typeof data==='object','Document in a QueryDocumentSnapshot should exist');return data;};return QueryDocumentSnapshot;}(DocumentSnapshot);var Query$1=/** @class */function(){function Query(_query,firestore){this._query=_query;this.firestore=firestore;}Query.prototype.where=function(field,opStr,value){validateExactNumberOfArgs('Query.where',arguments,3);validateDefined('Query.where',3,value);// Enumerated from the WhereFilterOp type in index.d.ts.
var whereFilterOpEnums=['<','<=','==','>=','>','array-contains'];validateStringEnum('Query.where',whereFilterOpEnums,2,opStr);var fieldValue;var fieldPath=fieldPathFromArgument('Query.where',field);var relationOp=RelationOp.fromString(opStr);if(fieldPath.isKeyField()){if(relationOp===RelationOp.ARRAY_CONTAINS){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid Query. You can't perform array-contains queries on "+'FieldPath.documentId() since document IDs are not arrays.');}if(typeof value==='string'){if(value===''){throw new FirestoreError(Code.INVALID_ARGUMENT,'Function Query.where() requires its third parameter to be a '+'valid document ID if the first parameter is '+'FieldPath.documentId(), but it was an empty string.');}if(!this._query.isCollectionGroupQuery()&&value.indexOf('/')!==-1){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid third parameter to Query.where(). When querying a collection by "+"FieldPath.documentId(), the value provided must be a plain document ID, but "+("'"+value+"' contains a slash."));}var path=this._query.path.child(ResourcePath.fromString(value));if(!DocumentKey.isDocumentKey(path)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid third parameter to Query.where(). When querying a collection group by "+"FieldPath.documentId(), the value provided must result in a valid document path, "+("but '"+path+"' is not because it has an odd number of segments ("+path.length+")."));}fieldValue=new RefValue(this.firestore._databaseId,new DocumentKey(path));}else if(value instanceof DocumentReference){var ref=value;fieldValue=new RefValue(this.firestore._databaseId,ref._key);}else{throw new FirestoreError(Code.INVALID_ARGUMENT,"Function Query.where() requires its third parameter to be a "+"string or a DocumentReference if the first parameter is "+"FieldPath.documentId(), but it was: "+(valueDescription(value)+"."));}}else{fieldValue=this.firestore._dataConverter.parseQueryValue('Query.where',value);}var filter=Filter.create(fieldPath,relationOp,fieldValue);this.validateNewFilter(filter);return new Query(this._query.addFilter(filter),this.firestore);};Query.prototype.orderBy=function(field,directionStr){validateBetweenNumberOfArgs('Query.orderBy',arguments,1,2);validateOptionalArgType('Query.orderBy','non-empty string',2,directionStr);var direction;if(directionStr===undefined||directionStr==='asc'){direction=Direction.ASCENDING;}else if(directionStr==='desc'){direction=Direction.DESCENDING;}else{throw new FirestoreError(Code.INVALID_ARGUMENT,"Function Query.orderBy() has unknown direction '"+directionStr+"', "+"expected 'asc' or 'desc'.");}if(this._query.startAt!==null){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You must not call Query.startAt() or '+'Query.startAfter() before calling Query.orderBy().');}if(this._query.endAt!==null){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You must not call Query.endAt() or '+'Query.endBefore() before calling Query.orderBy().');}var fieldPath=fieldPathFromArgument('Query.orderBy',field);var orderBy=new OrderBy(fieldPath,direction);this.validateNewOrderBy(orderBy);return new Query(this._query.addOrderBy(orderBy),this.firestore);};Query.prototype.limit=function(n){validateExactNumberOfArgs('Query.limit',arguments,1);validateArgType('Query.limit','number',1,n);if(n<=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid Query. Query limit ("+n+") is invalid. Limit must be "+'positive.');}return new Query(this._query.withLimit(n),this.firestore);};Query.prototype.startAt=function(docOrField){var fields=[];for(var _i=1;_i<arguments.length;_i++){fields[_i-1]=arguments[_i];}validateAtLeastNumberOfArgs('Query.startAt',arguments,1);var bound=this.boundFromDocOrFields('Query.startAt',docOrField,fields,/*before=*/true);return new Query(this._query.withStartAt(bound),this.firestore);};Query.prototype.startAfter=function(docOrField){var fields=[];for(var _i=1;_i<arguments.length;_i++){fields[_i-1]=arguments[_i];}validateAtLeastNumberOfArgs('Query.startAfter',arguments,1);var bound=this.boundFromDocOrFields('Query.startAfter',docOrField,fields,/*before=*/false);return new Query(this._query.withStartAt(bound),this.firestore);};Query.prototype.endBefore=function(docOrField){var fields=[];for(var _i=1;_i<arguments.length;_i++){fields[_i-1]=arguments[_i];}validateAtLeastNumberOfArgs('Query.endBefore',arguments,1);var bound=this.boundFromDocOrFields('Query.endBefore',docOrField,fields,/*before=*/true);return new Query(this._query.withEndAt(bound),this.firestore);};Query.prototype.endAt=function(docOrField){var fields=[];for(var _i=1;_i<arguments.length;_i++){fields[_i-1]=arguments[_i];}validateAtLeastNumberOfArgs('Query.endAt',arguments,1);var bound=this.boundFromDocOrFields('Query.endAt',docOrField,fields,/*before=*/false);return new Query(this._query.withEndAt(bound),this.firestore);};Query.prototype.isEqual=function(other){if(!(other instanceof Query)){throw invalidClassError('isEqual','Query',1,other);}return this.firestore===other.firestore&&this._query.isEqual(other._query);};/** Helper function to create a bound from a document or fields */Query.prototype.boundFromDocOrFields=function(methodName,docOrField,fields,before){validateDefined(methodName,1,docOrField);if(docOrField instanceof DocumentSnapshot){if(fields.length>0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Too many arguments provided to "+methodName+"().");}var snap=docOrField;if(!snap.exists){throw new FirestoreError(Code.NOT_FOUND,"Can't use a DocumentSnapshot that doesn't exist for "+(methodName+"()."));}return this.boundFromDocument(methodName,snap._document,before);}else{var allFields=[docOrField].concat(fields);return this.boundFromFields(methodName,allFields,before);}};/**
     * Create a Bound from a query and a document.
     *
     * Note that the Bound will always include the key of the document
     * and so only the provided document will compare equal to the returned
     * position.
     *
     * Will throw if the document does not contain all fields of the order by
     * of the query or if any of the fields in the order by are an uncommitted
     * server timestamp.
     */Query.prototype.boundFromDocument=function(methodName,doc,before){var components=[];// Because people expect to continue/end a query at the exact document
// provided, we need to use the implicit sort order rather than the explicit
// sort order, because it's guaranteed to contain the document key. That way
// the position becomes unambiguous and the query continues/ends exactly at
// the provided document. Without the key (by using the explicit sort
// orders), multiple documents could match the position, yielding duplicate
// results.
for(var _i=0,_a=this._query.orderBy;_i<_a.length;_i++){var orderBy=_a[_i];if(orderBy.field.isKeyField()){components.push(new RefValue(this.firestore._databaseId,doc.key));}else{var value=doc.field(orderBy.field);if(value instanceof ServerTimestampValue){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You are trying to start or end a query using a '+'document for which the field "'+orderBy.field+'" is an uncommitted server timestamp. (Since the value of '+'this field is unknown, you cannot start/end a query with it.)');}else if(value!==undefined){components.push(value);}else{var field=orderBy.field.canonicalString();throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. You are trying to start or end a query using a "+("document for which the field '"+field+"' (used as the ")+"orderBy) does not exist.");}}}return new Bound(components,before);};/**
     * Converts a list of field values to a Bound for the given query.
     */Query.prototype.boundFromFields=function(methodName,values,before){// Use explicit order by's because it has to match the query the user made
var orderBy=this._query.explicitOrderBy;if(values.length>orderBy.length){throw new FirestoreError(Code.INVALID_ARGUMENT,"Too many arguments provided to "+methodName+"(). "+"The number of arguments must be less than or equal to the "+"number of Query.orderBy() clauses");}var components=[];for(var i=0;i<values.length;i++){var rawValue=values[i];var orderByComponent=orderBy[i];if(orderByComponent.field.isKeyField()){if(typeof rawValue!=='string'){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. Expected a string for document ID in "+(methodName+"(), but got a "+typeof rawValue));}if(!this._query.isCollectionGroupQuery()&&rawValue.indexOf('/')!==-1){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. When querying a collection and ordering by FieldPath.documentId(), "+("the value passed to "+methodName+"() must be a plain document ID, but ")+("'"+rawValue+"' contains a slash."));}var path=this._query.path.child(ResourcePath.fromString(rawValue));if(!DocumentKey.isDocumentKey(path)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. When querying a collection group and ordering by "+("FieldPath.documentId(), the value passed to "+methodName+"() must result in a ")+("valid document path, but '"+path+"' is not because it contains an odd number ")+"of segments.");}var key=new DocumentKey(path);components.push(new RefValue(this.firestore._databaseId,key));}else{var wrapped=this.firestore._dataConverter.parseQueryValue(methodName,rawValue);components.push(wrapped);}}return new Bound(components,before);};Query.prototype.onSnapshot=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}validateBetweenNumberOfArgs('Query.onSnapshot',arguments,1,4);var options={};var observer;var currArg=0;if(typeof args[currArg]==='object'&&!isPartialObserver(args[currArg])){options=args[currArg];validateOptionNames('Query.onSnapshot',options,['includeMetadataChanges']);validateNamedOptionalType('Query.onSnapshot','boolean','includeMetadataChanges',options.includeMetadataChanges);currArg++;}if(isPartialObserver(args[currArg])){observer=args[currArg];}else{validateArgType('Query.onSnapshot','function',currArg,args[currArg]);validateOptionalArgType('Query.onSnapshot','function',currArg+1,args[currArg+1]);validateOptionalArgType('Query.onSnapshot','function',currArg+2,args[currArg+2]);observer={next:args[currArg],error:args[currArg+1],complete:args[currArg+2]};}return this.onSnapshotInternal(options,observer);};Query.prototype.onSnapshotInternal=function(options,observer){var _this=this;var errHandler=function(err){console.error('Uncaught Error in onSnapshot:',err);};if(observer.error){errHandler=observer.error.bind(observer);}var asyncObserver=new AsyncObserver({next:function(result){if(observer.next){observer.next(new QuerySnapshot(_this.firestore,_this._query,result));}},error:errHandler});var firestoreClient=this.firestore.ensureClientConfigured();var internalListener=firestoreClient.listen(this._query,asyncObserver,options);return function(){asyncObserver.mute();firestoreClient.unlisten(internalListener);};};Query.prototype.get=function(options){var _this=this;validateBetweenNumberOfArgs('Query.get',arguments,0,1);validateGetOptions('Query.get',options);return new Promise(function(resolve,reject){if(options&&options.source==='cache'){_this.firestore.ensureClientConfigured().getDocumentsFromLocalCache(_this._query).then(function(viewSnap){resolve(new QuerySnapshot(_this.firestore,_this._query,viewSnap));},reject);}else{_this.getViaSnapshotListener(resolve,reject,options);}});};Query.prototype.getViaSnapshotListener=function(resolve,reject,options){var unlisten=this.onSnapshotInternal({includeMetadataChanges:true,waitForSyncWhenOnline:true},{next:function(result){// Remove query first before passing event to user to avoid
// user actions affecting the now stale query.
unlisten();if(result.metadata.fromCache&&options&&options.source==='server'){reject(new FirestoreError(Code.UNAVAILABLE,'Failed to get documents from server. (However, these '+'documents may exist in the local cache. Run again '+'without setting source to "server" to '+'retrieve the cached documents.)'));}else{resolve(result);}},error:reject});};Query.prototype.validateNewFilter=function(filter){if(filter instanceof RelationFilter){if(filter.isInequality()){var existingField=this._query.getInequalityFilterField();if(existingField!==null&&!existingField.isEqual(filter.field)){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. All where filters with an inequality'+' (<, <=, >, or >=) must be on the same field. But you have'+(" inequality filters on '"+existingField.toString()+"'")+(" and '"+filter.field.toString()+"'"));}var firstOrderByField=this._query.getFirstOrderByField();if(firstOrderByField!==null){this.validateOrderByAndInequalityMatch(filter.field,firstOrderByField);}}else if(filter.op===RelationOp.ARRAY_CONTAINS){if(this._query.hasArrayContainsFilter()){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. Queries only support a single array-contains '+'filter.');}}}};Query.prototype.validateNewOrderBy=function(orderBy){if(this._query.getFirstOrderByField()===null){// This is the first order by. It must match any inequality.
var inequalityField=this._query.getInequalityFilterField();if(inequalityField!==null){this.validateOrderByAndInequalityMatch(inequalityField,orderBy.field);}}};Query.prototype.validateOrderByAndInequalityMatch=function(inequality,orderBy){if(!orderBy.isEqual(inequality)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. You have a where filter with an inequality "+("(<, <=, >, or >=) on field '"+inequality.toString()+"' ")+("and so you must also use '"+inequality.toString()+"' ")+"as your first Query.orderBy(), but your first Query.orderBy() "+("is on field '"+orderBy.toString()+"' instead."));}};return Query;}();var QuerySnapshot=/** @class */function(){function QuerySnapshot(_firestore,_originalQuery,_snapshot){this._firestore=_firestore;this._originalQuery=_originalQuery;this._snapshot=_snapshot;this._cachedChanges=null;this._cachedChangesIncludeMetadataChanges=null;this.metadata=new SnapshotMetadata(_snapshot.hasPendingWrites,_snapshot.fromCache);}Object.defineProperty(QuerySnapshot.prototype,"docs",{get:function(){var result=[];this.forEach(function(doc){return result.push(doc);});return result;},enumerable:true,configurable:true});Object.defineProperty(QuerySnapshot.prototype,"empty",{get:function(){return this._snapshot.docs.isEmpty();},enumerable:true,configurable:true});Object.defineProperty(QuerySnapshot.prototype,"size",{get:function(){return this._snapshot.docs.size;},enumerable:true,configurable:true});QuerySnapshot.prototype.forEach=function(callback,thisArg){var _this=this;validateBetweenNumberOfArgs('QuerySnapshot.forEach',arguments,1,2);validateArgType('QuerySnapshot.forEach','function',1,callback);this._snapshot.docs.forEach(function(doc){callback.call(thisArg,_this.convertToDocumentImpl(doc));});};Object.defineProperty(QuerySnapshot.prototype,"query",{get:function(){return new Query$1(this._originalQuery,this._firestore);},enumerable:true,configurable:true});QuerySnapshot.prototype.docChanges=function(options){if(options){validateOptionNames('QuerySnapshot.docChanges',options,['includeMetadataChanges']);validateNamedOptionalType('QuerySnapshot.docChanges','boolean','includeMetadataChanges',options.includeMetadataChanges);}var includeMetadataChanges=!!(options&&options.includeMetadataChanges);if(includeMetadataChanges&&this._snapshot.excludesMetadataChanges){throw new FirestoreError(Code.INVALID_ARGUMENT,'To include metadata changes with your document changes, you must '+'also pass { includeMetadataChanges:true } to onSnapshot().');}if(!this._cachedChanges||this._cachedChangesIncludeMetadataChanges!==includeMetadataChanges){this._cachedChanges=changesFromSnapshot(this._firestore,includeMetadataChanges,this._snapshot);this._cachedChangesIncludeMetadataChanges=includeMetadataChanges;}return this._cachedChanges;};/** Check the equality. The call can be very expensive. */QuerySnapshot.prototype.isEqual=function(other){if(!(other instanceof QuerySnapshot)){throw invalidClassError('isEqual','QuerySnapshot',1,other);}return this._firestore===other._firestore&&this._originalQuery.isEqual(other._originalQuery)&&this._snapshot.isEqual(other._snapshot);};QuerySnapshot.prototype.convertToDocumentImpl=function(doc){return new QueryDocumentSnapshot(this._firestore,doc.key,doc,this.metadata.fromCache,this._snapshot.mutatedKeys.has(doc.key));};return QuerySnapshot;}();// TODO(2018/11/01): As of 2018/04/17 we're changing docChanges from an array
// into a method. Because this is a runtime breaking change and somewhat subtle
// (both Array and Function have a .length, etc.), we'll replace commonly-used
// properties (including Symbol.iterator) to throw a custom error message. In
// ~6 months we can delete the custom error as most folks will have hopefully
// migrated.
function throwDocChangesMethodError(){throw new FirestoreError(Code.INVALID_ARGUMENT,'QuerySnapshot.docChanges has been changed from a property into a '+'method, so usages like "querySnapshot.docChanges" should become '+'"querySnapshot.docChanges()"');}var docChangesPropertiesToOverride=['length','forEach','map'].concat(typeof Symbol!=='undefined'?[Symbol.iterator]:[]);docChangesPropertiesToOverride.forEach(function(property){/**
     * We are (re-)defining properties on QuerySnapshot.prototype.docChanges which
     * is a Function. This could fail, in particular in the case of 'length' which
     * already exists on Function.prototype and on IE11 is improperly defined with
     * `{ configurable: false }`. So we wrap this in a try/catch to ensure that we
     * still have a functional SDK.
     */try{Object.defineProperty(QuerySnapshot.prototype.docChanges,property,{get:function(){return throwDocChangesMethodError();}});}catch(err){}// Ignore this failure intentionally
});var CollectionReference=/** @class */function(_super){tslib_1.__extends(CollectionReference,_super);function CollectionReference(path,firestore){var _this=_super.call(this,Query.atPath(path),firestore)||this;if(path.length%2!==1){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid collection reference. Collection '+'references must have an odd number of segments, but '+(path.canonicalString()+" has "+path.length));}return _this;}Object.defineProperty(CollectionReference.prototype,"id",{get:function(){return this._query.path.lastSegment();},enumerable:true,configurable:true});Object.defineProperty(CollectionReference.prototype,"parent",{get:function(){var parentPath=this._query.path.popLast();if(parentPath.isEmpty()){return null;}else{return new DocumentReference(new DocumentKey(parentPath),this.firestore);}},enumerable:true,configurable:true});Object.defineProperty(CollectionReference.prototype,"path",{get:function(){return this._query.path.canonicalString();},enumerable:true,configurable:true});CollectionReference.prototype.doc=function(pathString){validateBetweenNumberOfArgs('CollectionReference.doc',arguments,0,1);// We allow omission of 'pathString' but explicitly prohibit passing in both
// 'undefined' and 'null'.
if(arguments.length===0){pathString=AutoId.newId();}validateArgType('CollectionReference.doc','non-empty string',1,pathString);if(pathString===''){throw new FirestoreError(Code.INVALID_ARGUMENT,'Document path must be a non-empty string');}var path=ResourcePath.fromString(pathString);return DocumentReference.forPath(this._query.path.child(path),this.firestore);};CollectionReference.prototype.add=function(value){validateExactNumberOfArgs('CollectionReference.add',arguments,1);validateArgType('CollectionReference.add','object',1,value);var docRef=this.doc();return docRef.set(value).then(function(){return docRef;});};return CollectionReference;}(Query$1);function validateSetOptions(methodName,options){if(options===undefined){return{merge:false};}validateOptionNames(methodName,options,['merge','mergeFields']);validateNamedOptionalType(methodName,'boolean','merge',options.merge);validateOptionalArrayElements(methodName,'mergeFields','a string or a FieldPath',options.mergeFields,function(element){return typeof element==='string'||element instanceof FieldPath$1;});if(options.mergeFields!==undefined&&options.merge!==undefined){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid options passed to function "+methodName+"(): You cannot specify both \"merge\" "+"and \"mergeFields\".");}return options;}function validateSnapshotOptions(methodName,options){if(options===undefined){return{};}validateOptionNames(methodName,options,['serverTimestamps']);validateNamedOptionalPropertyEquals(methodName,'options','serverTimestamps',options.serverTimestamps,['estimate','previous','none']);return options;}function validateGetOptions(methodName,options){validateOptionalArgType(methodName,'object',1,options);if(options){validateOptionNames(methodName,options,['source']);validateNamedOptionalPropertyEquals(methodName,'options','source',options.source,['default','server','cache']);}}function validateReference(methodName,documentRef,firestore){if(!(documentRef instanceof DocumentReference)){throw invalidClassError(methodName,'DocumentReference',1,documentRef);}else if(documentRef.firestore!==firestore){throw new FirestoreError(Code.INVALID_ARGUMENT,'Provided document reference is from a different Firestore instance.');}else{return documentRef;}}/**
 * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.
 *
 * Exported for testing.
 */function changesFromSnapshot(firestore,includeMetadataChanges,snapshot){if(snapshot.oldDocs.isEmpty()){// Special case the first snapshot because index calculation is easy and
// fast
var lastDoc_1;var index_1=0;return snapshot.docChanges.map(function(change){var doc=new QueryDocumentSnapshot(firestore,change.doc.key,change.doc,snapshot.fromCache,snapshot.mutatedKeys.has(change.doc.key));assert(change.type===ChangeType.Added,'Invalid event type for first snapshot');assert(!lastDoc_1||snapshot.query.docComparator(lastDoc_1,change.doc)<0,'Got added events in wrong order');lastDoc_1=change.doc;return{type:'added',doc:doc,oldIndex:-1,newIndex:index_1++};});}else{// A DocumentSet that is updated incrementally as changes are applied to use
// to lookup the index of a document.
var indexTracker_1=snapshot.oldDocs;return snapshot.docChanges.filter(function(change){return includeMetadataChanges||change.type!==ChangeType.Metadata;}).map(function(change){var doc=new QueryDocumentSnapshot(firestore,change.doc.key,change.doc,snapshot.fromCache,snapshot.mutatedKeys.has(change.doc.key));var oldIndex=-1;var newIndex=-1;if(change.type!==ChangeType.Added){oldIndex=indexTracker_1.indexOf(change.doc.key);assert(oldIndex>=0,'Index for document not found');indexTracker_1=indexTracker_1.delete(change.doc.key);}if(change.type!==ChangeType.Removed){indexTracker_1=indexTracker_1.add(change.doc);newIndex=indexTracker_1.indexOf(change.doc.key);}return{type:resultChangeType(change.type),doc:doc,oldIndex:oldIndex,newIndex:newIndex};});}}function resultChangeType(type){switch(type){case ChangeType.Added:return'added';case ChangeType.Modified:case ChangeType.Metadata:return'modified';case ChangeType.Removed:return'removed';default:return fail('Unknown change type: '+type);}}// Export the classes with a private constructor (it will fail if invoked
// at runtime). Note that this still allows instanceof checks.
// We're treating the variables as class names, so disable checking for lower
// case variable names.
// tslint:disable:variable-name
var PublicFirestore=makeConstructorPrivate(Firestore,'Use firebase.firestore() instead.');var PublicTransaction=makeConstructorPrivate(Transaction$1,'Use firebase.firestore().runTransaction() instead.');var PublicWriteBatch=makeConstructorPrivate(WriteBatch,'Use firebase.firestore().batch() instead.');var PublicDocumentReference=makeConstructorPrivate(DocumentReference,'Use firebase.firestore().doc() instead.');var PublicDocumentSnapshot=makeConstructorPrivate(DocumentSnapshot);var PublicQueryDocumentSnapshot=makeConstructorPrivate(QueryDocumentSnapshot);var PublicQuery=makeConstructorPrivate(Query$1);var PublicQuerySnapshot=makeConstructorPrivate(QuerySnapshot);var PublicCollectionReference=makeConstructorPrivate(CollectionReference,'Use firebase.firestore().collection() instead.');// tslint:enable:variable-name
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var firestoreNamespace={Firestore:PublicFirestore,GeoPoint:GeoPoint,Timestamp:Timestamp,Blob:PublicBlob,Transaction:PublicTransaction,WriteBatch:PublicWriteBatch,DocumentReference:PublicDocumentReference,DocumentSnapshot:PublicDocumentSnapshot,Query:PublicQuery,QueryDocumentSnapshot:PublicQueryDocumentSnapshot,QuerySnapshot:PublicQuerySnapshot,CollectionReference:PublicCollectionReference,FieldPath:FieldPath$1,FieldValue:PublicFieldValue,setLogLevel:Firestore.setLogLevel,CACHE_SIZE_UNLIMITED:CACHE_SIZE_UNLIMITED};/**
 * Configures Firestore as part of the Firebase SDK by calling registerService.
 */function configureForFirebase(firebase){firebase.INTERNAL.registerService('firestore',function(app){return new Firestore(app);},shallowCopy(firestoreNamespace));}/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function registerFirestore(instance){configureForFirebase(instance);}registerFirestore(firebase);exports.registerFirestore=registerFirestore;//# sourceMappingURL=index.cjs.js.map

/***/ }),

/***/ "eOjq":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("PDcB");
module.exports = __webpack_require__("zKeE").Object.keys;

/***/ }),

/***/ "eW0v":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOM", function() { return DOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return Children; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return render$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createClass", function() { return createClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPortal", function() { return createPortal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFactory", function() { return createFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return createElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return cloneElement$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return isValidElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return findDOMNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return unmountComponentAtNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PureComponent", function() { return PureComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_renderSubtreeIntoContainer", function() { return renderSubtreeIntoContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return unstable_batchedUpdates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return extend; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types__ = __webpack_require__("5D9O");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prop_types__);
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "PropTypes", function() { return __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact__ = __webpack_require__("KM04");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_preact__);
/* harmony reexport (binding) */ if(__webpack_require__.o(__WEBPACK_IMPORTED_MODULE_1_preact__, "createRef")) __webpack_require__.d(__webpack_exports__, "createRef", function() { return __WEBPACK_IMPORTED_MODULE_1_preact__["createRef"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_preact_context__ = __webpack_require__("ZShz");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_preact_context___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_preact_context__);
/* harmony reexport (binding) */ if(__webpack_require__.o(__WEBPACK_IMPORTED_MODULE_2_preact_context__, "createContext")) __webpack_require__.d(__webpack_exports__, "createContext", function() { return __WEBPACK_IMPORTED_MODULE_2_preact_context__["createContext"]; });







var version = '15.1.0'; // trick libraries to think we are react

var ELEMENTS = 'a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr circle clipPath defs ellipse g image line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan'.split(' ');

var REACT_ELEMENT_TYPE = typeof Symbol !== 'undefined' && Symbol.for && Symbol.for('react.element') || 0xeac7;

var COMPONENT_WRAPPER_KEY = typeof Symbol !== 'undefined' && Symbol.for ? Symbol.for('__preactCompatWrapper') : '__preactCompatWrapper';

// don't autobind these methods since they already have guaranteed context.
var AUTOBIND_BLACKLIST = {
	constructor: 1,
	render: 1,
	shouldComponentUpdate: 1,
	componentWillReceiveProps: 1,
	componentWillUpdate: 1,
	componentDidUpdate: 1,
	componentWillMount: 1,
	componentDidMount: 1,
	componentWillUnmount: 1,
	componentDidUnmount: 1
};

var CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip|color|fill|flood|font|glyph|horiz|marker|overline|paint|stop|strikethrough|stroke|text|underline|unicode|units|v|vector|vert|word|writing|x)[A-Z]/;

var BYPASS_HOOK = {};

/*global process*/
var DEV = false;
try {
	DEV = "production" !== 'production';
} catch (e) {}

// a component that renders nothing. Used to replace components for unmountComponentAtNode.
function EmptyComponent() {
	return null;
}

// make react think we're react.
var VNode = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["h"])('a', null).constructor;
VNode.prototype.$$typeof = REACT_ELEMENT_TYPE;
VNode.prototype.preactCompatUpgraded = false;
VNode.prototype.preactCompatNormalized = false;

Object.defineProperty(VNode.prototype, 'type', {
	get: function () {
		return this.nodeName;
	},
	set: function (v) {
		this.nodeName = v;
	},
	configurable: true
});

Object.defineProperty(VNode.prototype, 'props', {
	get: function () {
		return this.attributes;
	},
	set: function (v) {
		this.attributes = v;
	},
	configurable: true
});

var oldEventHook = __WEBPACK_IMPORTED_MODULE_1_preact__["options"].event;
__WEBPACK_IMPORTED_MODULE_1_preact__["options"].event = function (e) {
	if (oldEventHook) {
		e = oldEventHook(e);
	}
	e.persist = Object;
	e.nativeEvent = e;
	return e;
};

var oldVnodeHook = __WEBPACK_IMPORTED_MODULE_1_preact__["options"].vnode;
__WEBPACK_IMPORTED_MODULE_1_preact__["options"].vnode = function (vnode) {
	if (!vnode.preactCompatUpgraded) {
		vnode.preactCompatUpgraded = true;

		var tag = vnode.nodeName,
		    attrs = vnode.attributes = vnode.attributes == null ? {} : extend({}, vnode.attributes);

		if (typeof tag === 'function') {
			if (tag[COMPONENT_WRAPPER_KEY] === true || tag.prototype && 'isReactComponent' in tag.prototype) {
				if (vnode.children && String(vnode.children) === '') {
					vnode.children = undefined;
				}
				if (vnode.children) {
					attrs.children = vnode.children;
				}

				if (!vnode.preactCompatNormalized) {
					normalizeVNode(vnode);
				}
				handleComponentVNode(vnode);
			}
		} else {
			if (vnode.children && String(vnode.children) === '') {
				vnode.children = undefined;
			}
			if (vnode.children) {
				attrs.children = vnode.children;
			}

			if (attrs.defaultValue) {
				if (!attrs.value && attrs.value !== 0) {
					attrs.value = attrs.defaultValue;
				}
				delete attrs.defaultValue;
			}

			handleElementVNode(vnode, attrs);
		}
	}

	if (oldVnodeHook) {
		oldVnodeHook(vnode);
	}
};

function handleComponentVNode(vnode) {
	var tag = vnode.nodeName,
	    a = vnode.attributes;

	vnode.attributes = {};
	if (tag.defaultProps) {
		extend(vnode.attributes, tag.defaultProps);
	}
	if (a) {
		extend(vnode.attributes, a);
	}
}

function handleElementVNode(vnode, a) {
	var shouldSanitize, attrs, i;
	if (a) {
		for (i in a) {
			if (shouldSanitize = CAMEL_PROPS.test(i)) {
				break;
			}
		}
		if (shouldSanitize) {
			attrs = vnode.attributes = {};
			for (i in a) {
				if (a.hasOwnProperty(i)) {
					attrs[CAMEL_PROPS.test(i) ? i.replace(/([A-Z0-9])/, '-$1').toLowerCase() : i] = a[i];
				}
			}
		}
	}
}

// proxy render() since React returns a Component reference.
function render$1(vnode, parent, callback) {
	var prev = parent && parent._preactCompatRendered && parent._preactCompatRendered.base;

	// ignore impossible previous renders
	if (prev && prev.parentNode !== parent) {
		prev = null;
	}

	// default to first Element child
	if (!prev && parent) {
		prev = parent.firstElementChild;
	}

	// remove unaffected siblings
	for (var i = parent.childNodes.length; i--;) {
		if (parent.childNodes[i] !== prev) {
			parent.removeChild(parent.childNodes[i]);
		}
	}

	var out = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["render"])(vnode, parent, prev);
	if (parent) {
		parent._preactCompatRendered = out && (out._component || { base: out });
	}
	if (typeof callback === 'function') {
		callback();
	}
	return out && out._component || out;
}

var ContextProvider = function () {};

ContextProvider.prototype.getChildContext = function () {
	return this.props.context;
};
ContextProvider.prototype.render = function (props) {
	return props.children[0];
};

function renderSubtreeIntoContainer(parentComponent, vnode, container, callback) {
	var wrap = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["h"])(ContextProvider, { context: parentComponent.context }, vnode);
	var renderContainer = render$1(wrap, container);
	var component = renderContainer._component || renderContainer.base;
	if (callback) {
		callback.call(component, renderContainer);
	}
	return component;
}

function Portal(props) {
	renderSubtreeIntoContainer(this, props.vnode, props.container);
}

function createPortal(vnode, container) {
	return Object(__WEBPACK_IMPORTED_MODULE_1_preact__["h"])(Portal, { vnode: vnode, container: container });
}

function unmountComponentAtNode(container) {
	var existing = container._preactCompatRendered && container._preactCompatRendered.base;
	if (existing && existing.parentNode === container) {
		Object(__WEBPACK_IMPORTED_MODULE_1_preact__["render"])(Object(__WEBPACK_IMPORTED_MODULE_1_preact__["h"])(EmptyComponent), container, existing);
		return true;
	}
	return false;
}

var ARR = [];

// This API is completely unnecessary for Preact, so it's basically passthrough.
var Children = {
	map: function (children, fn, ctx) {
		if (children == null) {
			return null;
		}
		children = Children.toArray(children);
		if (ctx && ctx !== children) {
			fn = fn.bind(ctx);
		}
		return children.map(fn);
	},
	forEach: function (children, fn, ctx) {
		if (children == null) {
			return null;
		}
		children = Children.toArray(children);
		if (ctx && ctx !== children) {
			fn = fn.bind(ctx);
		}
		children.forEach(fn);
	},
	count: function (children) {
		return children && children.length || 0;
	},
	only: function (children) {
		children = Children.toArray(children);
		if (children.length !== 1) {
			throw new Error('Children.only() expects only one child.');
		}
		return children[0];
	},
	toArray: function (children) {
		if (children == null) {
			return [];
		}
		return ARR.concat(children);
	}
};

/** Track current render() component for ref assignment */
var currentComponent;

function createFactory(type) {
	return createElement.bind(null, type);
}

var DOM = {};
for (var i = ELEMENTS.length; i--;) {
	DOM[ELEMENTS[i]] = createFactory(ELEMENTS[i]);
}

function upgradeToVNodes(arr, offset) {
	for (var i = offset || 0; i < arr.length; i++) {
		var obj = arr[i];
		if (Array.isArray(obj)) {
			upgradeToVNodes(obj);
		} else if (obj && typeof obj === 'object' && !isValidElement(obj) && (obj.props && obj.type || obj.attributes && obj.nodeName || obj.children)) {
			arr[i] = createElement(obj.type || obj.nodeName, obj.props || obj.attributes, obj.children);
		}
	}
}

function isStatelessComponent(c) {
	return typeof c === 'function' && !(c.prototype && c.prototype.render);
}

// wraps stateless functional components in a PropTypes validator
function wrapStatelessComponent(WrappedComponent) {
	return createClass({
		displayName: WrappedComponent.displayName || WrappedComponent.name,
		render: function () {
			return WrappedComponent(this.props, this.context);
		}
	});
}

function statelessComponentHook(Ctor) {
	var Wrapped = Ctor[COMPONENT_WRAPPER_KEY];
	if (Wrapped) {
		return Wrapped === true ? Ctor : Wrapped;
	}

	Wrapped = wrapStatelessComponent(Ctor);

	Object.defineProperty(Wrapped, COMPONENT_WRAPPER_KEY, { configurable: true, value: true });
	Wrapped.displayName = Ctor.displayName;
	Wrapped.propTypes = Ctor.propTypes;
	Wrapped.defaultProps = Ctor.defaultProps;

	Object.defineProperty(Ctor, COMPONENT_WRAPPER_KEY, { configurable: true, value: Wrapped });

	return Wrapped;
}

function createElement() {
	var args = [],
	    len = arguments.length;
	while (len--) args[len] = arguments[len];

	upgradeToVNodes(args, 2);
	return normalizeVNode(__WEBPACK_IMPORTED_MODULE_1_preact__["h"].apply(void 0, args));
}

function normalizeVNode(vnode) {
	vnode.preactCompatNormalized = true;

	applyClassName(vnode);

	if (isStatelessComponent(vnode.nodeName)) {
		vnode.nodeName = statelessComponentHook(vnode.nodeName);
	}

	var ref = vnode.attributes.ref,
	    type = ref && typeof ref;
	if (currentComponent && (type === 'string' || type === 'number')) {
		vnode.attributes.ref = createStringRefProxy(ref, currentComponent);
	}

	applyEventNormalization(vnode);

	return vnode;
}

function cloneElement$1(element, props) {
	var children = [],
	    len = arguments.length - 2;
	while (len-- > 0) children[len] = arguments[len + 2];

	if (!isValidElement(element)) {
		return element;
	}
	var elementProps = element.attributes || element.props;
	var node = Object(__WEBPACK_IMPORTED_MODULE_1_preact__["h"])(element.nodeName || element.type, extend({}, elementProps), element.children || elementProps && elementProps.children);
	// Only provide the 3rd argument if needed.
	// Arguments 3+ overwrite element.children in preactCloneElement
	var cloneArgs = [node, props];
	if (children && children.length) {
		cloneArgs.push(children);
	} else if (props && props.children) {
		cloneArgs.push(props.children);
	}
	return normalizeVNode(__WEBPACK_IMPORTED_MODULE_1_preact__["cloneElement"].apply(void 0, cloneArgs));
}

function isValidElement(element) {
	return element && (element instanceof VNode || element.$$typeof === REACT_ELEMENT_TYPE);
}

function createStringRefProxy(name, component) {
	return component._refProxies[name] || (component._refProxies[name] = function (resolved) {
		if (component && component.refs) {
			component.refs[name] = resolved;
			if (resolved === null) {
				delete component._refProxies[name];
				component = null;
			}
		}
	});
}

function applyEventNormalization(ref) {
	var nodeName = ref.nodeName;
	var attributes = ref.attributes;

	if (!attributes || typeof nodeName !== 'string') {
		return;
	}
	var props = {};
	for (var i in attributes) {
		props[i.toLowerCase()] = i;
	}
	if (props.ondoubleclick) {
		attributes.ondblclick = attributes[props.ondoubleclick];
		delete attributes[props.ondoubleclick];
	}
	// for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:
	if (props.onchange && (nodeName === 'textarea' || nodeName.toLowerCase() === 'input' && !/^fil|che|rad/i.test(attributes.type))) {
		var normalized = props.oninput || 'oninput';
		if (!attributes[normalized]) {
			attributes[normalized] = multihook([attributes[normalized], attributes[props.onchange]]);
			delete attributes[props.onchange];
		}
	}
}

function applyClassName(vnode) {
	var a = vnode.attributes || (vnode.attributes = {});
	classNameDescriptor.enumerable = 'className' in a;
	if (a.className) {
		a.class = a.className;
	}
	Object.defineProperty(a, 'className', classNameDescriptor);
}

var classNameDescriptor = {
	configurable: true,
	get: function () {
		return this.class;
	},
	set: function (v) {
		this.class = v;
	}
};

function extend(base, props) {
	var arguments$1 = arguments;

	for (var i = 1, obj = void 0; i < arguments.length; i++) {
		if (obj = arguments$1[i]) {
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					base[key] = obj[key];
				}
			}
		}
	}
	return base;
}

function shallowDiffers(a, b) {
	for (var i in a) {
		if (!(i in b)) {
			return true;
		}
	}
	for (var i$1 in b) {
		if (a[i$1] !== b[i$1]) {
			return true;
		}
	}
	return false;
}

function findDOMNode(component) {
	return component && (component.base || component.nodeType === 1 && component) || null;
}

function F() {}

function createClass(obj) {
	function cl(props, context) {
		bindAll(this);
		Component$1.call(this, props, context, BYPASS_HOOK);
		newComponentHook.call(this, props, context);
	}

	obj = extend({ constructor: cl }, obj);

	// We need to apply mixins here so that getDefaultProps is correctly mixed
	if (obj.mixins) {
		applyMixins(obj, collateMixins(obj.mixins));
	}
	if (obj.statics) {
		extend(cl, obj.statics);
	}
	if (obj.propTypes) {
		cl.propTypes = obj.propTypes;
	}
	if (obj.defaultProps) {
		cl.defaultProps = obj.defaultProps;
	}
	if (obj.getDefaultProps) {
		cl.defaultProps = obj.getDefaultProps.call(cl);
	}

	F.prototype = Component$1.prototype;
	cl.prototype = extend(new F(), obj);

	cl.displayName = obj.displayName || 'Component';

	return cl;
}

// Flatten an Array of mixins to a map of method name to mixin implementations
function collateMixins(mixins) {
	var keyed = {};
	for (var i = 0; i < mixins.length; i++) {
		var mixin = mixins[i];
		for (var key in mixin) {
			if (mixin.hasOwnProperty(key) && typeof mixin[key] === 'function') {
				(keyed[key] || (keyed[key] = [])).push(mixin[key]);
			}
		}
	}
	return keyed;
}

// apply a mapping of Arrays of mixin methods to a component prototype
function applyMixins(proto, mixins) {
	for (var key in mixins) {
		if (mixins.hasOwnProperty(key)) {
			proto[key] = multihook(mixins[key].concat(proto[key] || ARR), key === 'getDefaultProps' || key === 'getInitialState' || key === 'getChildContext');
		}
	}
}

function bindAll(ctx) {
	for (var i in ctx) {
		var v = ctx[i];
		if (typeof v === 'function' && !v.__bound && !AUTOBIND_BLACKLIST.hasOwnProperty(i)) {
			(ctx[i] = v.bind(ctx)).__bound = true;
		}
	}
}

function callMethod(ctx, m, args) {
	if (typeof m === 'string') {
		m = ctx.constructor.prototype[m];
	}
	if (typeof m === 'function') {
		return m.apply(ctx, args);
	}
}

function multihook(hooks, skipDuplicates) {
	return function () {
		var arguments$1 = arguments;
		var this$1 = this;

		var ret;
		for (var i = 0; i < hooks.length; i++) {
			var r = callMethod(this$1, hooks[i], arguments$1);

			if (skipDuplicates && r != null) {
				if (!ret) {
					ret = {};
				}
				for (var key in r) {
					if (r.hasOwnProperty(key)) {
						ret[key] = r[key];
					}
				}
			} else if (typeof r !== 'undefined') {
				ret = r;
			}
		}
		return ret;
	};
}

function newComponentHook(props, context) {
	propsHook.call(this, props, context);
	this.componentWillReceiveProps = multihook([propsHook, this.componentWillReceiveProps || 'componentWillReceiveProps']);
	this.render = multihook([propsHook, beforeRender, this.render || 'render', afterRender]);
}

function propsHook(props, context) {
	if (!props) {
		return;
	}

	// React annoyingly special-cases single children, and some react components are ridiculously strict about this.
	var c = props.children;
	if (c && Array.isArray(c) && c.length === 1 && (typeof c[0] === 'string' || typeof c[0] === 'function' || c[0] instanceof VNode)) {
		props.children = c[0];

		// but its totally still going to be an Array.
		if (props.children && typeof props.children === 'object') {
			props.children.length = 1;
			props.children[0] = props.children;
		}
	}

	// add proptype checking
	if (DEV) {
		var ctor = typeof this === 'function' ? this : this.constructor,
		    propTypes = this.propTypes || ctor.propTypes;
		var displayName = this.displayName || ctor.name;

		if (propTypes) {
			__WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.checkPropTypes(propTypes, props, 'prop', displayName);
		}
	}
}

function beforeRender(props) {
	currentComponent = this;
}

function afterRender() {
	if (currentComponent === this) {
		currentComponent = null;
	}
}

function Component$1(props, context, opts) {
	__WEBPACK_IMPORTED_MODULE_1_preact__["Component"].call(this, props, context);
	this.state = this.getInitialState ? this.getInitialState() : {};
	this.refs = {};
	this._refProxies = {};
	if (opts !== BYPASS_HOOK) {
		newComponentHook.call(this, props, context);
	}
}
extend(Component$1.prototype = new __WEBPACK_IMPORTED_MODULE_1_preact__["Component"](), {
	constructor: Component$1,

	isReactComponent: {},

	replaceState: function (state, callback) {
		var this$1 = this;

		this.setState(state, callback);
		for (var i in this$1.state) {
			if (!(i in state)) {
				delete this$1.state[i];
			}
		}
	},

	getDOMNode: function () {
		return this.base;
	},

	isMounted: function () {
		return !!this.base;
	}
});

function PureComponent(props, context) {
	Component$1.call(this, props, context);
}
F.prototype = Component$1.prototype;
PureComponent.prototype = new F();
PureComponent.prototype.isPureReactComponent = true;
PureComponent.prototype.shouldComponentUpdate = function (props, state) {
	return shallowDiffers(this.props, props) || shallowDiffers(this.state, state);
};

function unstable_batchedUpdates(callback) {
	callback();
}

var index = {
	version: version,
	DOM: DOM,
	PropTypes: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a,
	Children: Children,
	render: render$1,
	hydrate: render$1,
	createClass: createClass,
	createContext: __WEBPACK_IMPORTED_MODULE_2_preact_context__["createContext"],
	createPortal: createPortal,
	createFactory: createFactory,
	createElement: createElement,
	cloneElement: cloneElement$1,
	createRef: __WEBPACK_IMPORTED_MODULE_1_preact__["createRef"],
	isValidElement: isValidElement,
	findDOMNode: findDOMNode,
	unmountComponentAtNode: unmountComponentAtNode,
	Component: Component$1,
	PureComponent: PureComponent,
	unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer,
	unstable_batchedUpdates: unstable_batchedUpdates,
	__spread: extend
};

/* harmony default export */ __webpack_exports__["default"] = (index);

//# sourceMappingURL=preact-compat.es.js.map

/***/ }),

/***/ "ebIA":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("i1Q6").document;
module.exports = document && document.documentElement;

/***/ }),

/***/ "ew/s":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Defines jumpToLine command. Uses dialog.js if present.

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("4e7A"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../dialog/dialog"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  function dialog(cm, text, shortText, deflt, f) {
    if (cm.openDialog) cm.openDialog(text, f, { value: deflt, selectValueOnOpen: true });else f(prompt(shortText, deflt));
  }

  function getJumpDialog(cm) {
    return cm.phrase("Jump to line:") + ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use line:column or scroll% syntax)") + '</span>';
  }

  function interpretLine(cm, string) {
    var num = Number(string);
    if (/^[-+]/.test(string)) return cm.getCursor().line + num;else return num - 1;
  }

  CodeMirror.commands.jumpToLine = function (cm) {
    var cur = cm.getCursor();
    dialog(cm, getJumpDialog(cm), cm.phrase("Jump to line:"), cur.line + 1 + ":" + cur.ch, function (posStr) {
      if (!posStr) return;

      var match;
      if (match = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr)) {
        cm.setCursor(interpretLine(cm, match[1]), Number(match[2]));
      } else if (match = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr)) {
        var line = Math.round(cm.lineCount() * Number(match[1]) / 100);
        if (/^[-+]/.test(match[1])) line = cur.line + line + 1;
        cm.setCursor(line - 1, cur.ch);
      } else if (match = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) {
        cm.setCursor(interpretLine(cm, match[1]), cur.ch);
      }
    });
  };

  CodeMirror.keyMap["default"]["Alt-G"] = "jumpToLine";
});

/***/ }),

/***/ "f4vO":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Top level file is just a mixin of submodules & constants


var assign = __webpack_require__("tbG5").assign;

var deflate = __webpack_require__("nFS2");
var inflate = __webpack_require__("faQk");
var constants = __webpack_require__("xUUw");

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

/***/ }),

/***/ "fHwt":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createStyles = __webpack_require__("uqKE");

var _createStyles2 = _interopRequireDefault(_createStyles);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * A short description of the object values.
 * Can be used to render tree node in ObjectInspector
 * or render objects in TableInspector.
 */
var ObjectValue = function ObjectValue(_ref, _ref2) {
  var object = _ref.object,
      styles = _ref.styles;
  var theme = _ref2.theme;

  var themeStyles = (0, _createStyles2.default)('ObjectValue', theme);

  var mkStyle = function mkStyle(key) {
    return (0, _extends3.default)({}, themeStyles[key], styles);
  };

  switch (typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) {
    case 'number':
      return _react2.default.createElement('span', { style: mkStyle('objectValueNumber') }, String(object));
    case 'string':
      return _react2.default.createElement('span', { style: mkStyle('objectValueString') }, '"', object, '"');
    case 'boolean':
      return _react2.default.createElement('span', { style: mkStyle('objectValueBoolean') }, String(object));
    case 'undefined':
      return _react2.default.createElement('span', { style: mkStyle('objectValueUndefined') }, 'undefined');
    case 'object':
      if (object === null) {
        return _react2.default.createElement('span', { style: mkStyle('objectValueNull') }, 'null');
      }
      if (object instanceof Date) {
        return _react2.default.createElement('span', null, object.toString());
      }
      if (object instanceof RegExp) {
        return _react2.default.createElement('span', { style: mkStyle('objectValueRegExp') }, object.toString());
      }
      if (Array.isArray(object)) {
        return _react2.default.createElement('span', null, 'Array[' + object.length + ']');
      }
      if (!object.constructor) {
        return _react2.default.createElement('span', null, 'Object');
      }
      if (typeof object.constructor.isBuffer === 'function' && object.constructor.isBuffer(object)) {
        return _react2.default.createElement('span', null, 'Buffer[' + object.length + ']');
      }

      return _react2.default.createElement('span', null, object.constructor.name);
    case 'function':
      return _react2.default.createElement('span', null, _react2.default.createElement('span', { style: mkStyle('objectValueFunctionKeyword') }, 'function'), _react2.default.createElement('span', { style: mkStyle('objectValueFunctionName') }, '\xA0', object.name, '()'));
    case 'symbol':
      return _react2.default.createElement('span', { style: mkStyle('objectValueSymbol') }, object.toString());
    default:
      return _react2.default.createElement('span', null);
  }
};

ObjectValue.propTypes = {
  /** the object to describe */
  object: _propTypes2.default.any
};

ObjectValue.contextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
};

exports.default = ObjectValue;

/***/ }),

/***/ "fOKV":
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__("CGvP");
var ObjectPrototype = Object.prototype;

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (toString !== ObjectPrototype.toString) {
  __webpack_require__("iKbl")(ObjectPrototype, 'toString', toString, { unsafe: true });
}

/***/ }),

/***/ "fOjT":
/***/ (function(module, exports, __webpack_require__) {

/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = __webpack_require__("fnRj");

/***/ }),

/***/ "faQk":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var zlib_inflate = __webpack_require__("GIDK");
var utils = __webpack_require__("tbG5");
var strings = __webpack_require__("34Q3");
var c = __webpack_require__("xUUw");
var msg = __webpack_require__("gMAY");
var ZStream = __webpack_require__("bdtv");
var GZheader = __webpack_require__("/+WI");

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }

          this.onData(utf8str);
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }

  return inflator.result;
}

/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}

/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/

exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip = inflate;

/***/ }),

/***/ "fnRj":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__("FRpO").EventEmitter;
var inherits = __webpack_require__("4Bm0");

inherits(Stream, EE);
Stream.Readable = __webpack_require__("tzeh");
Stream.Writable = __webpack_require__("LnjZ");
Stream.Duplex = __webpack_require__("kT1X");
Stream.Transform = __webpack_require__("A9/K");
Stream.PassThrough = __webpack_require__("C6nS");

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

/***/ }),

/***/ "fz1y":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createStyles = __webpack_require__("uqKE");

var _createStyles2 = _interopRequireDefault(_createStyles);

var _TH = __webpack_require__("oBpM");

var _TH2 = _interopRequireDefault(_TH);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var HeaderContainer = function HeaderContainer(_ref, _ref2) {
  var indexColumnText = _ref.indexColumnText,
      columns = _ref.columns,
      sorted = _ref.sorted,
      sortIndexColumn = _ref.sortIndexColumn,
      sortColumn = _ref.sortColumn,
      sortAscending = _ref.sortAscending,
      onTHClick = _ref.onTHClick,
      onIndexTHClick = _ref.onIndexTHClick;
  var theme = _ref2.theme;

  var styles = (0, _createStyles2.default)('TableInspectorHeaderContainer', theme);
  var borderStyles = (0, _createStyles2.default)('TableInspectorLeftBorder', theme);
  return _react2.default.createElement('div', { style: styles.base }, _react2.default.createElement('table', { style: styles.table }, _react2.default.createElement('tbody', null, _react2.default.createElement('tr', null, _react2.default.createElement(_TH2.default, {
    borderStyle: borderStyles.none,
    sorted: sorted && sortIndexColumn,
    sortAscending: sortAscending,
    onClick: onIndexTHClick
  }, indexColumnText), columns.map(function (column) {
    return _react2.default.createElement(_TH2.default, {
      borderStyle: borderStyles.solid,
      key: column,
      sorted: sorted && sortColumn === column,
      sortAscending: sortAscending,
      onClick: onTHClick.bind(undefined, column)
    }, column);
  })))));
};

HeaderContainer.defaultProps = {
  indexColumnText: '(index)',
  columns: []
};

HeaderContainer.contextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};

exports.default = HeaderContainer;

/***/ }),

/***/ "g31e":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "g3pf":
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "gMAY":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary', /* Z_NEED_DICT       2  */
  1: 'stream end', /* Z_STREAM_END      1  */
  0: '', /* Z_OK              0  */
  '-1': 'file error', /* Z_ERRNO         (-1) */
  '-2': 'stream error', /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error', /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error', /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
};

/***/ }),

/***/ "gPKv":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";
  var GUTT_CLASS = "CodeMirror-activeline-gutter";

  CodeMirror.defineOption("styleActiveLine", false, function (cm, val, old) {
    var prev = old == CodeMirror.Init ? false : old;
    if (val == prev) return;
    if (prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }
    if (val) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    }
  });

  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
    }
  }

  function sameArray(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) if (a[i] != b[i]) return false;
    return true;
  }

  function updateActiveLines(cm, ranges) {
    var active = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var option = cm.getOption("styleActiveLine");
      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty()) continue;
      var line = cm.getLineHandleVisualStart(range.head.line);
      if (active[active.length - 1] != line) active.push(line);
    }
    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function () {
      clearActiveLines(cm);
      for (var i = 0; i < active.length; i++) {
        cm.addLineClass(active[i], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i], "background", BACK_CLASS);
        cm.addLineClass(active[i], "gutter", GUTT_CLASS);
      }
      cm.state.activeLines = active;
    });
  }

  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});

/***/ }),

/***/ "gYye":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = __webpack_require__("mYpx");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

exports.default = getHeaders;

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/*
 * Polyfill for running tests
 * `includes` is an ES2016 feature
 */
if (!Array.prototype.includes) {
  Array.prototype.includes = function (searchElement /*, fromIndex*/) {
    var O = Object(this);
    var len = parseInt(O.length) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1]) || 0;
    var k;
    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) {
        k = 0;
      }
    }
    var currentElement;
    while (k < len) {
      currentElement = O[k];
      if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
        // NaN !== NaN
        return true;
      }
      k++;
    }
    return false;
  };
}

function getHeaders(data) {
  if ((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) === 'object') {
    var rowHeaders = void 0;
    // is an array
    if (Array.isArray(data)) {
      var nRows = data.length;
      rowHeaders = [].concat((0, _toConsumableArray3.default)(Array(nRows).keys()));
    } else if (data !== null) {
      // is an object
      // keys are row indexes
      rowHeaders = Object.keys(data);
    }

    // Time: O(nRows * nCols)
    var colHeaders = rowHeaders.reduce(function (colHeaders, rowHeader) {
      var row = data[rowHeader];
      if ((typeof row === 'undefined' ? 'undefined' : (0, _typeof3.default)(row)) === 'object' && row !== null) {
        /* O(nCols) Could optimize `includes` here */
        var cols = Object.keys(row);
        cols.reduce(function (xs, x) {
          if (!xs.includes(x)) {
            /* xs is the colHeaders to be filled by searching the row's indexes */
            xs.push(x);
          }
          return xs;
        }, colHeaders);
      }
      return colHeaders;
    }, []);
    return {
      rowHeaders: rowHeaders,
      colHeaders: colHeaders
    };
  }
  return undefined;
}

/***/ }),

/***/ "gc0D":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("vcHl"), __esModule: true };

/***/ }),

/***/ "geN+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var StreamHelper = __webpack_require__("2P9T");
var DataWorker = __webpack_require__("ABU1");
var utf8 = __webpack_require__("Sm7/");
var CompressedObject = __webpack_require__("PO9O");
var GenericWorker = __webpack_require__("ZKdc");

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function (name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function (type) {
        var result = null,
            outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function (compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if (!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker: function () {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for (var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

/***/ }),

/***/ "gfUn":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }
  return descriptors;
};

var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function (val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__("vexR");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__("tcrG");

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function () {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/***/ }),

/***/ "ggoL":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("css", function (config, parserConfig) {
    var inline = parserConfig.inline;
    if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

    var indentUnit = config.indentUnit,
        tokenHooks = parserConfig.tokenHooks,
        documentTypes = parserConfig.documentTypes || {},
        mediaTypes = parserConfig.mediaTypes || {},
        mediaFeatures = parserConfig.mediaFeatures || {},
        mediaValueKeywords = parserConfig.mediaValueKeywords || {},
        propertyKeywords = parserConfig.propertyKeywords || {},
        nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
        fontProperties = parserConfig.fontProperties || {},
        counterDescriptors = parserConfig.counterDescriptors || {},
        colorKeywords = parserConfig.colorKeywords || {},
        valueKeywords = parserConfig.valueKeywords || {},
        allowNested = parserConfig.allowNested,
        lineComment = parserConfig.lineComment,
        supportsAtComponent = parserConfig.supportsAtComponent === true;

    var type, override;
    function ret(style, tp) {
      type = tp;return style;
    }

    // Tokenizers

    function tokenBase(stream, state) {
      var ch = stream.next();
      if (tokenHooks[ch]) {
        var result = tokenHooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == "@") {
        stream.eatWhile(/[\w\\\-]/);
        return ret("def", stream.current());
      } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
        return ret(null, "compare");
      } else if (ch == "\"" || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "#") {
        stream.eatWhile(/[\w\\\-]/);
        return ret("atom", "hash");
      } else if (ch == "!") {
        stream.match(/^\s*\w*/);
        return ret("keyword", "important");
      } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (ch === "-") {
        if (/[\d.]/.test(stream.peek())) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        } else if (stream.match(/^-[\w\\\-]*/)) {
          stream.eatWhile(/[\w\\\-]/);
          if (stream.match(/^\s*:/, false)) return ret("variable-2", "variable-definition");
          return ret("variable-2", "variable");
        } else if (stream.match(/^\w+-/)) {
          return ret("meta", "meta");
        }
      } else if (/[,+>*\/]/.test(ch)) {
        return ret(null, "select-op");
      } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
        return ret("qualifier", "qualifier");
      } else if (/[:;{}\[\]\(\)]/.test(ch)) {
        return ret(null, ch);
      } else if (stream.match(/[\w-.]+(?=\()/)) {
        if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {
          state.tokenize = tokenParenthesized;
        }
        return ret("variable callee", "variable");
      } else if (/[\w\\\-]/.test(ch)) {
        stream.eatWhile(/[\w\\\-]/);
        return ret("property", "word");
      } else {
        return ret(null, null);
      }
    }

    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false,
            ch;
        while ((ch = stream.next()) != null) {
          if (ch == quote && !escaped) {
            if (quote == ")") stream.backUp(1);
            break;
          }
          escaped = !escaped && ch == "\\";
        }
        if (ch == quote || !escaped && quote != ")") state.tokenize = null;
        return ret("string", "string");
      };
    }

    function tokenParenthesized(stream, state) {
      stream.next(); // Must be '('
      if (!stream.match(/\s*[\"\')]/, false)) state.tokenize = tokenString(")");else state.tokenize = null;
      return ret(null, "(");
    }

    // Context management

    function Context(type, indent, prev) {
      this.type = type;
      this.indent = indent;
      this.prev = prev;
    }

    function pushContext(state, stream, type, indent) {
      state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
      return type;
    }

    function popContext(state) {
      if (state.context.prev) state.context = state.context.prev;
      return state.context.type;
    }

    function pass(type, stream, state) {
      return states[state.context.type](type, stream, state);
    }
    function popAndPass(type, stream, state, n) {
      for (var i = n || 1; i > 0; i--) state.context = state.context.prev;
      return pass(type, stream, state);
    }

    // Parser

    function wordAsValue(stream) {
      var word = stream.current().toLowerCase();
      if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "variable";
    }

    var states = {};

    states.top = function (type, stream, state) {
      if (type == "{") {
        return pushContext(state, stream, "block");
      } else if (type == "}" && state.context.prev) {
        return popContext(state);
      } else if (supportsAtComponent && /@component/i.test(type)) {
        return pushContext(state, stream, "atComponentBlock");
      } else if (/^@(-moz-)?document$/i.test(type)) {
        return pushContext(state, stream, "documentTypes");
      } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
        return pushContext(state, stream, "atBlock");
      } else if (/^@(font-face|counter-style)/i.test(type)) {
        state.stateArg = type;
        return "restricted_atBlock_before";
      } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
        return "keyframes";
      } else if (type && type.charAt(0) == "@") {
        return pushContext(state, stream, "at");
      } else if (type == "hash") {
        override = "builtin";
      } else if (type == "word") {
        override = "tag";
      } else if (type == "variable-definition") {
        return "maybeprop";
      } else if (type == "interpolation") {
        return pushContext(state, stream, "interpolation");
      } else if (type == ":") {
        return "pseudo";
      } else if (allowNested && type == "(") {
        return pushContext(state, stream, "parens");
      }
      return state.context.type;
    };

    states.block = function (type, stream, state) {
      if (type == "word") {
        var word = stream.current().toLowerCase();
        if (propertyKeywords.hasOwnProperty(word)) {
          override = "property";
          return "maybeprop";
        } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
          override = "string-2";
          return "maybeprop";
        } else if (allowNested) {
          override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
          return "block";
        } else {
          override += " error";
          return "maybeprop";
        }
      } else if (type == "meta") {
        return "block";
      } else if (!allowNested && (type == "hash" || type == "qualifier")) {
        override = "error";
        return "block";
      } else {
        return states.top(type, stream, state);
      }
    };

    states.maybeprop = function (type, stream, state) {
      if (type == ":") return pushContext(state, stream, "prop");
      return pass(type, stream, state);
    };

    states.prop = function (type, stream, state) {
      if (type == ";") return popContext(state);
      if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
      if (type == "}" || type == "{") return popAndPass(type, stream, state);
      if (type == "(") return pushContext(state, stream, "parens");

      if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
        override += " error";
      } else if (type == "word") {
        wordAsValue(stream);
      } else if (type == "interpolation") {
        return pushContext(state, stream, "interpolation");
      }
      return "prop";
    };

    states.propBlock = function (type, _stream, state) {
      if (type == "}") return popContext(state);
      if (type == "word") {
        override = "property";return "maybeprop";
      }
      return state.context.type;
    };

    states.parens = function (type, stream, state) {
      if (type == "{" || type == "}") return popAndPass(type, stream, state);
      if (type == ")") return popContext(state);
      if (type == "(") return pushContext(state, stream, "parens");
      if (type == "interpolation") return pushContext(state, stream, "interpolation");
      if (type == "word") wordAsValue(stream);
      return "parens";
    };

    states.pseudo = function (type, stream, state) {
      if (type == "meta") return "pseudo";

      if (type == "word") {
        override = "variable-3";
        return state.context.type;
      }
      return pass(type, stream, state);
    };

    states.documentTypes = function (type, stream, state) {
      if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
        override = "tag";
        return state.context.type;
      } else {
        return states.atBlock(type, stream, state);
      }
    };

    states.atBlock = function (type, stream, state) {
      if (type == "(") return pushContext(state, stream, "atBlock_parens");
      if (type == "}" || type == ";") return popAndPass(type, stream, state);
      if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

      if (type == "interpolation") return pushContext(state, stream, "interpolation");

      if (type == "word") {
        var word = stream.current().toLowerCase();
        if (word == "only" || word == "not" || word == "and" || word == "or") override = "keyword";else if (mediaTypes.hasOwnProperty(word)) override = "attribute";else if (mediaFeatures.hasOwnProperty(word)) override = "property";else if (mediaValueKeywords.hasOwnProperty(word)) override = "keyword";else if (propertyKeywords.hasOwnProperty(word)) override = "property";else if (nonStandardPropertyKeywords.hasOwnProperty(word)) override = "string-2";else if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "error";
      }
      return state.context.type;
    };

    states.atComponentBlock = function (type, stream, state) {
      if (type == "}") return popAndPass(type, stream, state);
      if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
      if (type == "word") override = "error";
      return state.context.type;
    };

    states.atBlock_parens = function (type, stream, state) {
      if (type == ")") return popContext(state);
      if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
      return states.atBlock(type, stream, state);
    };

    states.restricted_atBlock_before = function (type, stream, state) {
      if (type == "{") return pushContext(state, stream, "restricted_atBlock");
      if (type == "word" && state.stateArg == "@counter-style") {
        override = "variable";
        return "restricted_atBlock_before";
      }
      return pass(type, stream, state);
    };

    states.restricted_atBlock = function (type, stream, state) {
      if (type == "}") {
        state.stateArg = null;
        return popContext(state);
      }
      if (type == "word") {
        if (state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())) override = "error";else override = "property";
        return "maybeprop";
      }
      return "restricted_atBlock";
    };

    states.keyframes = function (type, stream, state) {
      if (type == "word") {
        override = "variable";return "keyframes";
      }
      if (type == "{") return pushContext(state, stream, "top");
      return pass(type, stream, state);
    };

    states.at = function (type, stream, state) {
      if (type == ";") return popContext(state);
      if (type == "{" || type == "}") return popAndPass(type, stream, state);
      if (type == "word") override = "tag";else if (type == "hash") override = "builtin";
      return "at";
    };

    states.interpolation = function (type, stream, state) {
      if (type == "}") return popContext(state);
      if (type == "{" || type == ";") return popAndPass(type, stream, state);
      if (type == "word") override = "variable";else if (type != "variable" && type != "(" && type != ")") override = "error";
      return "interpolation";
    };

    return {
      startState: function (base) {
        return { tokenize: null,
          state: inline ? "block" : "top",
          stateArg: null,
          context: new Context(inline ? "block" : "top", base || 0, null) };
      },

      token: function (stream, state) {
        if (!state.tokenize && stream.eatSpace()) return null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style && typeof style == "object") {
          type = style[1];
          style = style[0];
        }
        override = style;
        if (type != "comment") state.state = states[state.state](type, stream, state);
        return override;
      },

      indent: function (state, textAfter) {
        var cx = state.context,
            ch = textAfter && textAfter.charAt(0);
        var indent = cx.indent;
        if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
        if (cx.prev) {
          if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
            // Resume indentation from parent context.
            cx = cx.prev;
            indent = cx.indent;
          } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
            // Dedent relative to current context.
            indent = Math.max(0, cx.indent - indentUnit);
          }
        }
        return indent;
      },

      electricChars: "}",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      blockCommentContinue: " * ",
      lineComment: lineComment,
      fold: "brace"
    };
  });

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }
    return keys;
  }

  var documentTypes_ = ["domain", "regexp", "url", "url-prefix"],
      documentTypes = keySet(documentTypes_);

  var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"],
      mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "orientation", "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio", "pointer", "any-pointer", "hover", "any-hover"],
      mediaFeatures = keySet(mediaFeatures_);

  var mediaValueKeywords_ = ["landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover", "interlace", "progressive"],
      mediaValueKeywords = keySet(mediaValueKeywords_);

  var propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "mix-blend-mode", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "z-index",
  // SVG-specific
  "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"],
      propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"],
      nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

  var fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"],
      fontProperties = keySet(fontProperties_);

  var counterDescriptors_ = ["additive-symbols", "fallback", "negative", "pad", "prefix", "range", "speak-as", "suffix", "symbols", "system"],
      counterDescriptors = keySet(counterDescriptors_);

  var colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"],
      colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"],
      valueKeywords = keySet(valueKeywords_);

  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false,
        ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = ch == "*";
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function (stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function (stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function (stream) {
        if (stream.match(/\s*\{/, false)) return [null, null];
        return false;
      },
      "$": function (stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false)) return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function (stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function (stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function (stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false)) return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function () {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function (stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });
});

/***/ }),

/***/ "gjjs":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("Gfzd");
var anObject = __webpack_require__("zotD");
var getKeys = __webpack_require__("knrM");

module.exports = __webpack_require__("6MLN") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),

/***/ "gkZy":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("TEgB"), __esModule: true };

/***/ }),

/***/ "gojl":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("akPY");

/***/ }),

/***/ "gpbE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__("ZKdc");
var crc32 = __webpack_require__("cvyR");
var utils = __webpack_require__("dvMn");

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
  GenericWorker.call(this, "Crc32Probe");
  this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
  this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
  this.push(chunk);
};
module.exports = Crc32Probe;

/***/ }),

/***/ "h6ac":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "hEIm":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("zotD");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "hrV0":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("dmyY");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }return it;
};

/***/ }),

/***/ "htFH":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("vSO4");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__("6MLN"), 'Object', { defineProperty: __webpack_require__("Gfzd").f });

/***/ }),

/***/ "hu5A":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  WebkitTouchCallout: 'none',
  WebkitUserSelect: 'none',
  KhtmlUserSelect: 'none',
  MozUserSelect: 'none',
  msUserSelect: 'none',
  OUserSelect: 'none',
  userSelect: 'none'
};

/***/ }),

/***/ "i+u+":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__("lytE")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("uRfg")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

/***/ }),

/***/ "i1Q6":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
// eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "i3Mv":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("dmyY");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "i8j3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (obj) {

  if (obj == null) {
    return false;
  }

  var o = Object(obj);

  return o === o.window;
};

/***/ }),

/***/ "iJoW":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description


var DESCRIPTORS = __webpack_require__("xWhT");
var has = __webpack_require__("UYRC");
var isObject = __webpack_require__("dmyY");
var defineProperty = __webpack_require__("uebg").f;
var copyConstructorProperties = __webpack_require__("CAJ1");
var NativeSymbol = __webpack_require__("wJQ+").Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
// Safari 12 bug
NativeSymbol().description !== undefined)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper ? new NativeSymbol(description)
    // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
    : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  __webpack_require__("c+Wn")({ global: true, forced: true }, { Symbol: SymbolWrapper });
}

/***/ }),

/***/ "iKbl":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("wJQ+");
var hide = __webpack_require__("2O9B");
var has = __webpack_require__("UYRC");
var setGlobal = __webpack_require__("G6zQ");
var nativeFunctionToString = __webpack_require__("mv67");
var InternalStateModule = __webpack_require__("q/RK");
var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(nativeFunctionToString).split('toString');

__webpack_require__("JE34")('inspectSource', function (it) {
  return nativeFunctionToString.call(it);
});

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;else hide(O, key, value);
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);
});

/***/ }),

/***/ "iLWV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = __webpack_require__("zCAL");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _classCallCheck2 = __webpack_require__("dACh");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("jx4H");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("VOrx");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("ZKjc");

var _inherits3 = _interopRequireDefault(_inherits2);

var _defineProperty2 = __webpack_require__("Xos8");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _TreeNode = __webpack_require__("3tGu");

var _TreeNode2 = _interopRequireDefault(_TreeNode);

var _pathUtils = __webpack_require__("5XDi");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var reducer = function reducer(state, action) {
  switch (action.type) {
    case 'TOGGLE_EXPAND':
      {
        var path = action.path;
        var expandedPaths = state.expandedPaths;
        var expanded = !!expandedPaths[path];

        return _extends({}, state, {
          expandedPaths: _extends({}, state.expandedPaths, (0, _defineProperty3.default)({}, path, !expanded))
        });
      }
    default:
      return state;
  }
};

var ConnectedTreeNode = function (_Component) {
  (0, _inherits3.default)(ConnectedTreeNode, _Component);

  function ConnectedTreeNode(props, context) {
    (0, _classCallCheck3.default)(this, ConnectedTreeNode);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ConnectedTreeNode.__proto__ || Object.getPrototypeOf(ConnectedTreeNode)).call(this, props));

    _this.state = context.store.storeState;
    return _this;
  }

  (0, _createClass3.default)(ConnectedTreeNode, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      return !!nextState.expandedPaths[nextProps.path] !== !!this.state.expandedPaths[this.props.path] || nextProps.data !== this.props.data || nextProps.name !== this.props.name;
    }
  }, {
    key: 'handleClick',
    value: function handleClick(path) {
      this.context.store.storeState = reducer(this.context.store.storeState, {
        type: 'TOGGLE_EXPAND',
        path: path
      });
      this.setState(this.context.store.storeState);
    }
  }, {
    key: 'renderChildNodes',
    value: function renderChildNodes(parentData, parentPath) {
      var dataIterator = this.props.dataIterator;
      var depth = this.props.depth;
      var nodeRenderer = this.props.nodeRenderer;

      var childNodes = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = dataIterator(parentData)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref2 = _step.value;
          var name = _ref2.name,
              data = _ref2.data,
              props = (0, _objectWithoutProperties3.default)(_ref2, ['name', 'data']);

          var key = name;
          var path = parentPath + '.' + key;
          childNodes.push(_react2.default.createElement(ConnectedTreeNode, (0, _extends3.default)({
            name: name,
            data: data,
            depth: depth + 1,
            path: path,
            key: key,
            dataIterator: dataIterator,
            nodeRenderer: nodeRenderer
          }, props)) // props for nodeRenderer
          );
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return childNodes;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          data = _props.data,
          dataIterator = _props.dataIterator,
          path = _props.path,
          depth = _props.depth;

      var nodeHasChildNodes = (0, _pathUtils.hasChildNodes)(data, dataIterator);
      var expandedPaths = this.state.expandedPaths;

      var expanded = !!expandedPaths[path];

      var nodeRenderer = this.props.nodeRenderer;

      return _react2.default.createElement(_TreeNode2.default, (0, _extends3.default)({
        expanded: expanded,
        onClick: nodeHasChildNodes ? this.handleClick.bind(this, path) : function () {}
        // show arrow anyway even if not expanded and not rendering children
        , shouldShowArrow: nodeHasChildNodes
        // show placeholder only for non root nodes
        , shouldShowPlaceholder: depth > 0
        // Render a node from name and data (or possibly other props like isNonenumerable)
        , nodeRenderer: nodeRenderer
      }, this.props),
      // only render if the node is expanded
      expanded ? this.renderChildNodes(data, path) : undefined);
    }
  }]);
  return ConnectedTreeNode;
}(_react.Component);

ConnectedTreeNode.propTypes = {
  name: _propTypes2.default.string,
  data: _propTypes2.default.any,
  dataIterator: _propTypes2.default.func,

  depth: _propTypes2.default.number,
  expanded: _propTypes2.default.bool,

  nodeRenderer: _propTypes2.default.func
};

ConnectedTreeNode.contextTypes = {
  store: _propTypes2.default.any
};

var TreeView = function (_Component2) {
  (0, _inherits3.default)(TreeView, _Component2);

  function TreeView(props) {
    (0, _classCallCheck3.default)(this, TreeView);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (TreeView.__proto__ || Object.getPrototypeOf(TreeView)).call(this, props));

    _this2.store = {
      storeState: {
        expandedPaths: (0, _pathUtils.getExpandedPaths)(props.data, props.dataIterator, props.expandPaths, props.expandLevel)
      }
    };
    return _this2;
  }

  (0, _createClass3.default)(TreeView, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.store = {
        storeState: {
          expandedPaths: (0, _pathUtils.getExpandedPaths)(nextProps.data, nextProps.dataIterator, nextProps.expandPaths, nextProps.expandLevel, this.store.storeState.expandedPaths)
        }
      };
    }
  }, {
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        store: this.store
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          name = _props2.name,
          data = _props2.data,
          dataIterator = _props2.dataIterator;
      var nodeRenderer = this.props.nodeRenderer;

      var rootPath = _pathUtils.DEFAULT_ROOT_PATH;

      return _react2.default.createElement(ConnectedTreeNode, {
        name: name,
        data: data,
        dataIterator: dataIterator,
        depth: 0,
        path: rootPath,
        nodeRenderer: nodeRenderer
      });
    }
  }]);
  return TreeView;
}(_react.Component);

TreeView.defaultProps = {
  expandLevel: 0,
  expandPaths: []
};
TreeView.childContextTypes = {
  store: _propTypes2.default.any
};

TreeView.propTypes = {
  name: _propTypes2.default.string,
  data: _propTypes2.default.any,
  dataIterator: _propTypes2.default.func,

  nodeRenderer: _propTypes2.default.func
};

TreeView.defaultProps = {
  name: undefined
};

exports.default = TreeView;

/***/ }),

/***/ "ibPW":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("Ky5l"), __esModule: true };

/***/ }),

/***/ "j68S":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getPrototypeOf = __webpack_require__("Dylg");
var hide = __webpack_require__("2O9B");
var has = __webpack_require__("UYRC");
var IS_PURE = __webpack_require__("qCGA");
var ITERATOR = __webpack_require__("95jh")('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () {
  return this;
};

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

/***/ }),

/***/ "jJ+0":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.replace` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.replace
__webpack_require__("KGgk")('replace');

/***/ }),

/***/ "jJCL":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.hasInstance` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.hasinstance
__webpack_require__("KGgk")('hasInstance');

/***/ }),

/***/ "jNRJ":
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

/***/ }),

/***/ "jNvH":
/***/ (function(module, exports, __webpack_require__) {

if (true) {
  module.exports = __webpack_require__("pJ9j");
} else {
  module.exports = require("./cjs/core.development.js");
}

/***/ }),

/***/ "jOjK":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = __webpack_require__("dACh");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("jx4H");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("VOrx");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("ZKjc");

var _inherits3 = _interopRequireDefault(_inherits2);

var _regenerator = __webpack_require__("aIIw");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _DOMNodePreview = __webpack_require__("O6BQ");

var _DOMNodePreview2 = _interopRequireDefault(_DOMNodePreview);

var _TreeView = __webpack_require__("iLWV");

var _TreeView2 = _interopRequireDefault(_TreeView);

var _shouldInline = __webpack_require__("MdwO");

var _shouldInline2 = _interopRequireDefault(_shouldInline);

var _ThemeProvider = __webpack_require__("ZQr7");

var _ThemeProvider2 = _interopRequireDefault(_ThemeProvider);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var domIterator = /*#__PURE__*/_regenerator2.default.mark(function domIterator(data) {
  var textInlined, i, node;
  return _regenerator2.default.wrap(function domIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(data && data.childNodes)) {
            _context.next = 17;
            break;
          }

          textInlined = (0, _shouldInline2.default)(data);

          if (!textInlined) {
            _context.next = 4;
            break;
          }

          return _context.abrupt('return');

        case 4:
          i = 0;

        case 5:
          if (!(i < data.childNodes.length)) {
            _context.next = 14;
            break;
          }

          node = data.childNodes[i];

          if (!(node.nodeType === Node.TEXT_NODE && node.textContent.trim().length === 0)) {
            _context.next = 9;
            break;
          }

          return _context.abrupt('continue', 11);

        case 9:
          _context.next = 11;
          return {
            name: node.tagName + '[' + i + ']',
            data: node
          };

        case 11:
          i++;
          _context.next = 5;
          break;

        case 14:
          if (!data.tagName) {
            _context.next = 17;
            break;
          }

          _context.next = 17;
          return {
            name: 'CLOSE_TAG',
            data: {
              tagName: data.tagName
            },
            isCloseTag: true
          };

        case 17:
        case 'end':
          return _context.stop();
      }
    }
  }, domIterator, this);
});

var DOMInspector = function (_Component) {
  (0, _inherits3.default)(DOMInspector, _Component);

  function DOMInspector() {
    (0, _classCallCheck3.default)(this, DOMInspector);
    return (0, _possibleConstructorReturn3.default)(this, (DOMInspector.__proto__ || Object.getPrototypeOf(DOMInspector)).apply(this, arguments));
  }

  (0, _createClass3.default)(DOMInspector, [{
    key: 'render',
    value: function render() {
      var nodeRenderer = _DOMNodePreview2.default;

      return _react2.default.createElement(_ThemeProvider2.default, { theme: this.props.theme }, _react2.default.createElement(_TreeView2.default, (0, _extends3.default)({ nodeRenderer: nodeRenderer, dataIterator: domIterator }, this.props)));
    }
  }]);
  return DOMInspector;
}(_react.Component);

DOMInspector.propTypes = {
  /** The DOM Node to inspect */
  data: _propTypes2.default.object.isRequired
};
DOMInspector.defaultProps = {
  theme: 'chromeLight'
};
exports.default = DOMInspector;

/***/ }),

/***/ "jsP4":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("xypO");

/***/ }),

/***/ "jx4H":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__("FFZn");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "kT1X":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("Hba+");

/***/ }),

/***/ "knrM":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("B9Lq");
var enumBugKeys = __webpack_require__("KxjL");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "kugD":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("7qSu");

module.exports = __webpack_require__("ALBP")('Array', 'findIndex');

/***/ }),

/***/ "ky2m":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("BtHH");
module.exports = __webpack_require__("zKeE").Object.getPrototypeOf;

/***/ }),

/***/ "lUr3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

/***/ }),

/***/ "lZLl":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("rytr");
var isWindow = __webpack_require__("i8j3");

function isNode(val) {
  if (!isObject(val) || !isWindow(window) || typeof window.Node !== 'function') {
    return false;
  }

  return typeof val.nodeType === 'number' && typeof val.nodeName === 'string';
}

module.exports = isNode;

/***/ }),

/***/ "lytE":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("MpYs");
var defined = __webpack_require__("U72i");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "m+Gh":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

if (!global.Promise) global.Promise = __webpack_require__("vfAE");
if (!global.fetch) global.fetch = __webpack_require__("VS7n");
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("h6ac")))

/***/ }),

/***/ "m8OI":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__("gkZy");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__("X9RM");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),

/***/ "mSND":
/***/ (function(module, exports, __webpack_require__) {

/*! Split.js - v1.3.4 */

(function (global, factory) {
     true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Split = factory();
})(this, function () {
    'use strict';

    // The programming goals of Split.js are to deliver readable, understandable and
    // maintainable code, while at the same time manually optimizing for tiny minified file size,
    // browser compatibility without additional requirements, graceful fallback (IE8 is supported)
    // and very few assumptions about the user's page layout.

    var global = window;
    var document = global.document;

    // Save a couple long function names that are used frequently.
    // This optimization saves around 400 bytes.
    var addEventListener = 'addEventListener';
    var removeEventListener = 'removeEventListener';
    var getBoundingClientRect = 'getBoundingClientRect';
    var NOOP = function () {
        return false;
    };

    // Set a float fudging global, used when dividing and setting sizes to long floats.
    // There's a chance that sometimes the sum of the floats would end up being slightly
    // larger than 100%, breaking the layout. The float fudging value is subtracted from
    // the percentage size.
    var FLOAT_FUDGING = 0.1;

    // Figure out if we're in IE8 or not. IE8 will still render correctly,
    // but will be static instead of draggable.
    var isIE8 = global.attachEvent && !global[addEventListener];

    // This library only needs two helper functions:
    //
    // The first determines which prefixes of CSS calc we need.
    // We only need to do this once on startup, when this anonymous function is called.
    //
    // Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:
    // http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167
    var calc = ['', '-webkit-', '-moz-', '-o-'].filter(function (prefix) {
        var el = document.createElement('div');
        el.style.cssText = "width:" + prefix + "calc(9px)";

        return !!el.style.length;
    }).shift() + "calc";

    // The second helper function allows elements and string selectors to be used
    // interchangeably. In either case an element is returned. This allows us to
    // do `Split(elem1, elem2)` as well as `Split('#id1', '#id2')`.
    var elementOrSelector = function (el) {
        if (typeof el === 'string' || el instanceof String) {
            return document.querySelector(el);
        }

        return el;
    };

    // The main function to initialize a split. Split.js thinks about each pair
    // of elements as an independant pair. Dragging the gutter between two elements
    // only changes the dimensions of elements in that pair. This is key to understanding
    // how the following functions operate, since each function is bound to a pair.
    //
    // A pair object is shaped like this:
    //
    // {
    //     a: DOM element,
    //     b: DOM element,
    //     aMin: Number,
    //     bMin: Number,
    //     dragging: Boolean,
    //     parent: DOM element,
    //     isFirst: Boolean,
    //     isLast: Boolean,
    //     direction: 'horizontal' | 'vertical'
    // }
    //
    // The basic sequence:
    //
    // 1. Set defaults to something sane. `options` doesn't have to be passed at all.
    // 2. Initialize a bunch of strings based on the direction we're splitting.
    //    A lot of the behavior in the rest of the library is paramatized down to
    //    rely on CSS strings and classes.
    // 3. Define the dragging helper functions, and a few helpers to go with them.
    // 4. Loop through the elements while pairing them off. Every pair gets an
    //    `pair` object, a gutter, and special isFirst/isLast properties.
    // 5. Actually size the pair elements, insert gutters and attach event listeners.
    var Split = function (ids, options) {
        if (options === void 0) options = {};

        var dimension;
        var clientDimension;
        var clientAxis;
        var position;
        var paddingA;
        var paddingB;

        // All DOM elements in the split should have a common parent. We can grab
        // the first elements parent and hope users read the docs because the
        // behavior will be whacky otherwise.
        var parent = elementOrSelector(ids[0]).parentNode;
        var parentFlexDirection = global.getComputedStyle(parent).flexDirection;

        // Set default options.sizes to equal percentages of the parent element.
        var sizes = options.sizes || ids.map(function () {
            return 100 / ids.length;
        });

        // Standardize minSize to an array if it isn't already. This allows minSize
        // to be passed as a number.
        var minSize = options.minSize !== undefined ? options.minSize : 100;
        var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () {
            return minSize;
        });
        var gutterSize = options.gutterSize !== undefined ? options.gutterSize : 10;
        var snapOffset = options.snapOffset !== undefined ? options.snapOffset : 30;
        var direction = options.direction || 'horizontal';
        var cursor = options.cursor || (direction === 'horizontal' ? 'ew-resize' : 'ns-resize');
        var gutter = options.gutter || function (i, gutterDirection) {
            var gut = document.createElement('div');
            gut.className = "gutter gutter-" + gutterDirection;
            return gut;
        };
        var elementStyle = options.elementStyle || function (dim, size, gutSize) {
            var style = {};

            if (typeof size !== 'string' && !(size instanceof String)) {
                if (!isIE8) {
                    style[dim] = calc + "(" + size + "% - " + gutSize + "px)";
                } else {
                    style[dim] = size + "%";
                }
            } else {
                style[dim] = size;
            }

            return style;
        };
        var gutterStyle = options.gutterStyle || function (dim, gutSize) {
            return obj = {}, obj[dim] = gutSize + "px", obj;
            var obj;
        };

        // 2. Initialize a bunch of strings based on the direction we're splitting.
        // A lot of the behavior in the rest of the library is paramatized down to
        // rely on CSS strings and classes.
        if (direction === 'horizontal') {
            dimension = 'width';
            clientDimension = 'clientWidth';
            clientAxis = 'clientX';
            position = 'left';
            paddingA = 'paddingLeft';
            paddingB = 'paddingRight';
        } else if (direction === 'vertical') {
            dimension = 'height';
            clientDimension = 'clientHeight';
            clientAxis = 'clientY';
            position = 'top';
            paddingA = 'paddingTop';
            paddingB = 'paddingBottom';
        }

        // 3. Define the dragging helper functions, and a few helpers to go with them.
        // Each helper is bound to a pair object that contains it's metadata. This
        // also makes it easy to store references to listeners that that will be
        // added and removed.
        //
        // Even though there are no other functions contained in them, aliasing
        // this to self saves 50 bytes or so since it's used so frequently.
        //
        // The pair object saves metadata like dragging state, position and
        // event listener references.

        function setElementSize(el, size, gutSize) {
            // Split.js allows setting sizes via numbers (ideally), or if you must,
            // by string, like '300px'. This is less than ideal, because it breaks
            // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,
            // make sure you calculate the gutter size by hand.
            var style = elementStyle(dimension, size, gutSize);

            // eslint-disable-next-line no-param-reassign
            Object.keys(style).forEach(function (prop) {
                return el.style[prop] = style[prop];
            });
        }

        function setGutterSize(gutterElement, gutSize) {
            var style = gutterStyle(dimension, gutSize);

            // eslint-disable-next-line no-param-reassign
            Object.keys(style).forEach(function (prop) {
                return gutterElement.style[prop] = style[prop];
            });
        }

        // Actually adjust the size of elements `a` and `b` to `offset` while dragging.
        // calc is used to allow calc(percentage + gutterpx) on the whole split instance,
        // which allows the viewport to be resized without additional logic.
        // Element a's size is the same as offset. b's size is total size - a size.
        // Both sizes are calculated from the initial parent percentage,
        // then the gutter size is subtracted.
        function adjust(offset) {
            setElementSize(this.a, offset / this.size * this.percentage - FLOAT_FUDGING, this.aGutterSize);
            setElementSize(this.b, this.percentage - offset / this.size * this.percentage - FLOAT_FUDGING, this.bGutterSize);
        }

        // drag, where all the magic happens. The logic is really quite simple:
        //
        // 1. Ignore if the pair is not dragging.
        // 2. Get the offset of the event.
        // 3. Snap offset to min if within snappable range (within min + snapOffset).
        // 4. Actually adjust each element in the pair to offset.
        //
        // ---------------------------------------------------------------------
        // |    | <- this.aMin               ||              this.bMin -> |    |
        // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |
        // |    |  |                         ||                        |  |    |
        // |    |  |                         ||                        |  |    |
        // ---------------------------------------------------------------------
        // | <- this.start                                        this.size -> |
        function drag(e) {
            var offset;

            if (!this.dragging) {
                return;
            }

            // Get the offset of the event from the first side of the
            // pair `this.start`. Supports touch events, but not multitouch, so only the first
            // finger `touches[0]` is counted.
            if ('touches' in e) {
                offset = e.touches[0][clientAxis] - this.start;
            } else {
                offset = e[clientAxis] - this.start;
            }

            // If within snapOffset of min or max, set offset to min or max.
            // snapOffset buffers aMin and bMin, so logic is opposite for both.
            // Include the appropriate gutter sizes to prevent overflows.
            if (offset <= this.aMin + snapOffset + this.aGutterSize) {
                offset = this.aMin + this.aGutterSize;
            } else if (offset >= this.size - (this.bMin + snapOffset + this.bGutterSize)) {
                offset = this.size - (this.bMin + this.bGutterSize);
            }

            // Actually adjust the size.
            adjust.call(this, offset);

            // Call the drag callback continously. Don't do anything too intensive
            // in this callback.
            if (options.onDrag) {
                options.onDrag();
            }
        }

        // Cache some important sizes when drag starts, so we don't have to do that
        // continously:
        //
        // `size`: The total size of the pair. First + second + first gutter + second gutter.
        // `percentage`: The percentage between 0-100 that the pair occupies in the parent.
        // `start`: The leading side of the first element.
        //
        // ------------------------------------------------ - - - - - - - - - - -
        // |      aGutterSize -> |||                      |                     |
        // |                     |||                      |                     |
        // |                     |||                      |                     |
        // |                     ||| <- bGutterSize       |                     |
        // ------------------------------------------------ - - - - - - - - - - -
        // | <- start                             size -> |       parentSize -> |
        function calculateSizes() {
            // Figure out the parent size minus padding.
            var computedStyle = global.getComputedStyle(this.parent);
            var parentSize = this.parent[clientDimension] - parseFloat(computedStyle[paddingA] || 0) - parseFloat(computedStyle[paddingB] || 0);

            this.size = this.a[getBoundingClientRect]()[dimension] + this.b[getBoundingClientRect]()[dimension] + this.aGutterSize + this.bGutterSize;
            this.percentage = Math.min(this.size / parentSize * 100, 100);
            this.start = this.a[getBoundingClientRect]()[position];
        }

        // stopDragging is very similar to startDragging in reverse.
        function stopDragging() {
            var self = this;
            var a = self.a;
            var b = self.b;

            if (self.dragging && options.onDragEnd) {
                options.onDragEnd();
            }

            self.dragging = false;

            // Remove the stored event listeners. This is why we store them.
            global[removeEventListener]('mouseup', self.stop);
            global[removeEventListener]('touchend', self.stop);
            global[removeEventListener]('touchcancel', self.stop);

            self.parent[removeEventListener]('mousemove', self.move);
            self.parent[removeEventListener]('touchmove', self.move);

            // Delete them once they are removed. I think this makes a difference
            // in memory usage with a lot of splits on one page. But I don't know for sure.
            delete self.stop;
            delete self.move;

            a[removeEventListener]('selectstart', NOOP);
            a[removeEventListener]('dragstart', NOOP);
            b[removeEventListener]('selectstart', NOOP);
            b[removeEventListener]('dragstart', NOOP);

            a.style.userSelect = '';
            a.style.webkitUserSelect = '';
            a.style.MozUserSelect = '';
            a.style.pointerEvents = '';

            b.style.userSelect = '';
            b.style.webkitUserSelect = '';
            b.style.MozUserSelect = '';
            b.style.pointerEvents = '';

            self.gutter.style.cursor = '';
            self.parent.style.cursor = '';
        }

        // startDragging calls `calculateSizes` to store the inital size in the pair object.
        // It also adds event listeners for mouse/touch events,
        // and prevents selection while dragging so avoid the selecting text.
        function startDragging(e) {
            // Alias frequently used variables to save space. 200 bytes.
            var self = this;
            var a = self.a;
            var b = self.b;

            // Call the onDragStart callback.
            if (!self.dragging && options.onDragStart) {
                options.onDragStart();
            }

            // Don't actually drag the element. We emulate that in the drag function.
            e.preventDefault();

            // Set the dragging property of the pair object.
            self.dragging = true;

            // Create two event listeners bound to the same pair object and store
            // them in the pair object.
            self.move = drag.bind(self);
            self.stop = stopDragging.bind(self);

            // All the binding. `window` gets the stop events in case we drag out of the elements.
            global[addEventListener]('mouseup', self.stop);
            global[addEventListener]('touchend', self.stop);
            global[addEventListener]('touchcancel', self.stop);

            self.parent[addEventListener]('mousemove', self.move);
            self.parent[addEventListener]('touchmove', self.move);

            // Disable selection. Disable!
            a[addEventListener]('selectstart', NOOP);
            a[addEventListener]('dragstart', NOOP);
            b[addEventListener]('selectstart', NOOP);
            b[addEventListener]('dragstart', NOOP);

            a.style.userSelect = 'none';
            a.style.webkitUserSelect = 'none';
            a.style.MozUserSelect = 'none';
            a.style.pointerEvents = 'none';

            b.style.userSelect = 'none';
            b.style.webkitUserSelect = 'none';
            b.style.MozUserSelect = 'none';
            b.style.pointerEvents = 'none';

            // Set the cursor, both on the gutter and the parent element.
            // Doing only a, b and gutter causes flickering.
            self.gutter.style.cursor = cursor;
            self.parent.style.cursor = cursor;

            // Cache the initial sizes of the pair.
            calculateSizes.call(self);
        }

        // 5. Loop through the elements while pairing them off. Every pair gets a
        // `pair` object, a gutter, and isFirst/isLast properties.
        //
        // Basic logic:
        //
        // - Starting with the second element `i > 0`, create `pair` objects with
        //   `a = ids[i - 1]` and `b = ids[i]`
        // - Set gutter sizes based on the _pair_ being first/last. The first and last
        //   pair have gutterSize / 2, since they only have one half gutter, and not two.
        // - Create gutter elements and add event listeners.
        // - Set the size of the elements, minus the gutter sizes.
        //
        // -----------------------------------------------------------------------
        // |     i=0     |         i=1         |        i=2       |      i=3     |
        // |             |       isFirst       |                  |     isLast   |
        // |           pair 0                pair 1             pair 2           |
        // |             |                     |                  |              |
        // -----------------------------------------------------------------------
        var pairs = ids.map(function (id, i) {
            var el = elementOrSelector(id);
            var isFirstPair = i === 1;
            var isLastPair = i === ids.length - 1;
            var size = sizes[i];

            var pair;

            if (i > 0) {
                // Create the pair object with it's metadata.
                pair = {
                    a: elementOrSelector(ids[i - 1]),
                    b: el,
                    aMin: minSizes[i - 1],
                    bMin: minSizes[i],
                    dragging: false,
                    isFirst: isFirstPair,
                    isLast: isLastPair,
                    direction: direction,
                    parent: parent
                };

                // For first and last pairs, first and last gutter width is half.
                pair.aGutterSize = gutterSize;
                pair.bGutterSize = gutterSize;

                if (isFirstPair) {
                    pair.aGutterSize = gutterSize / 2;
                }

                if (isLastPair) {
                    pair.bGutterSize = gutterSize / 2;
                }

                // if the parent has a reverse flex-direction, switch the pair elements.
                if (parentFlexDirection === 'row-reverse' || parentFlexDirection === 'column-reverse') {
                    var temp = pair.a;
                    pair.a = pair.b;
                    pair.b = temp;
                }
            }

            // Determine the size of the current element. IE8 is supported by
            // staticly assigning sizes without draggable gutters. Assigns a string
            // to `size`.
            //
            // IE9 and above
            if (!isIE8) {
                // Create gutter elements for each pair.
                if (i > 0) {
                    var gutterElement = gutter(i, direction);
                    setGutterSize(gutterElement, gutterSize);

                    gutterElement[addEventListener]('mousedown', startDragging.bind(pair));
                    gutterElement[addEventListener]('touchstart', startDragging.bind(pair));

                    parent.insertBefore(gutterElement, el);

                    pair.gutter = gutterElement;
                }
            }

            // Set the element size to our determined size.
            // Half-size gutters for first and last elements.
            if (i === 0 || i === ids.length - 1) {
                setElementSize(el, size, gutterSize / 2);
            } else {
                setElementSize(el, size, gutterSize);
            }

            if (i > 0) {
                var aSize = pair.a[getBoundingClientRect]()[dimension];
                var bSize = pair.b[getBoundingClientRect]()[dimension];

                if (aSize < pair.aMin) {
                    pair.aMin = aSize;
                }

                if (bSize < pair.bMin) {
                    pair.bMin = bSize;
                }
            }

            // After the first iteration, and we have a pair object, append it to the
            // list of pairs.
            if (i > 0) {
                return pair;
            }

            return null;
        });

        pairs.shift();

        function setSizes(newSizes) {
            newSizes.forEach(function (newSize, i) {
                if (i > 0) {
                    var pair = pairs[i - 1];

                    setElementSize(pair.a, newSizes[i - 1], pair.aGutterSize);
                    setElementSize(pair.b, newSize, pair.bGutterSize);
                }
            });
        }

        function destroy() {
            pairs.forEach(function (pair) {
                pair.parent.removeChild(pair.gutter);
                pair.a.style[dimension] = ''; // eslint-disable-line no-param-reassign
                pair.b.style[dimension] = ''; // eslint-disable-line no-param-reassign
            });
        }

        if (isIE8) {
            return {
                setSizes: setSizes,
                destroy: destroy
            };
        }

        return {
            setSizes: setSizes,
            getSizes: function getSizes() {
                var newSizes = [];

                pairs.forEach(function (pair, i) {
                    var computedStyle = global.getComputedStyle(pair.parent);
                    var parentSize = pair.parent[clientDimension] - parseFloat(computedStyle[paddingA] || 0) - parseFloat(computedStyle[paddingB] || 0);

                    newSizes.push((pair.a[getBoundingClientRect]()[dimension] + pair.aGutterSize) / parentSize * 100);

                    if (i === pairs.length - 1) {
                        newSizes.push((pair.b[getBoundingClientRect]()[dimension] + pair.bGutterSize) / parentSize * 100);
                    }
                });

                return newSizes;
            },
            collapse: function collapse(i) {
                if (i === pairs.length) {
                    var pair = pairs[i - 1];

                    calculateSizes.call(pair);

                    if (!isIE8) {
                        adjust.call(pair, pair.size - pair.bGutterSize);
                    }
                } else {
                    var pair$1 = pairs[i];

                    calculateSizes.call(pair$1);

                    if (!isIE8) {
                        adjust.call(pair$1, pair$1.aGutterSize);
                    }
                }
            },
            destroy: destroy
        };
    };

    return Split;
});

/***/ }),

/***/ "mYpx":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__("VuZO");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),

/***/ "mbLO":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("U72i");
module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "mv67":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("JE34")('native-function-to-string', Function.toString);

/***/ }),

/***/ "nFDa":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("i+u+");
__webpack_require__("COf8");
module.exports = __webpack_require__("ZxII").f('iterator');

/***/ }),

/***/ "nFS2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var zlib_deflate = __webpack_require__("+BLB");
var utils = __webpack_require__("tbG5");
var strings = __webpack_require__("34Q3");
var msg = __webpack_require__("gMAY");
var ZStream = __webpack_require__("bdtv");

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH = 0;
var Z_FINISH = 4;

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_SYNC_FLUSH = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY = 0;

var Z_DEFLATED = 8;

/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }

  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode); /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};

/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) {
    throw deflator.msg || msg[deflator.err];
  }

  return deflator.result;
}

/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}

/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}

exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

/***/ }),

/***/ "nIol":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("jNRJ");
var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

/***/ }),

/***/ "nR4t":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayReader = __webpack_require__("TCoK");
var utils = __webpack_require__("dvMn");

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

/***/ }),

/***/ "nrvx":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.species` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.species
__webpack_require__("KGgk")('species');

/***/ }),

/***/ "nw/5":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.toStringTag` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
__webpack_require__("KGgk")('toStringTag');

/***/ }),

/***/ "nwyA":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__("7tlB");

/*<replacement>*/
var util = __webpack_require__("Q14w");
util.inherits = __webpack_require__("4Bm0");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "oBpM":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("T4f3");

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = __webpack_require__("zCAL");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _classCallCheck2 = __webpack_require__("dACh");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__("jx4H");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__("VOrx");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__("ZKjc");

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__("eW0v");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("5D9O");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createStyles = __webpack_require__("uqKE");

var _createStyles2 = _interopRequireDefault(_createStyles);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var SortIconContainer = function SortIconContainer(props) {
  return _react2.default.createElement('div', {
    style: {
      position: 'absolute',
      top: 1,
      right: 0,
      bottom: 1,
      display: 'flex',
      alignItems: 'center'
    }
  }, props.children);
};

var SortIcon = function SortIcon(_ref, _ref2) {
  var sortAscending = _ref.sortAscending;
  var theme = _ref2.theme;

  var glyph = sortAscending ? '▲' : '▼';
  var styles = (0, _createStyles2.default)('TableInspectorSortIcon', theme);
  return _react2.default.createElement('div', { style: styles }, glyph);
};

SortIcon.contextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};

var TH = function (_Component) {
  (0, _inherits3.default)(TH, _Component);

  function TH() {
    var _ref3;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, TH);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref3 = TH.__proto__ || Object.getPrototypeOf(TH)).call.apply(_ref3, [this].concat(args))), _this), _this.state = { hovered: false }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(TH, [{
    key: 'toggleHovered',
    value: function toggleHovered(hovered) {
      this.setState({ hovered: hovered });
    }
  }, {
    key: 'render',
    value: function render() {
      // either not sorted, sort ascending or sort descending
      var _props = this.props,
          borderStyle = _props.borderStyle,
          children = _props.children,
          onClick = _props.onClick,
          sortAscending = _props.sortAscending,
          sorted = _props.sorted,
          props = (0, _objectWithoutProperties3.default)(_props, ['borderStyle', 'children', 'onClick', 'sortAscending', 'sorted']);
      var theme = this.context.theme;

      var styles = (0, _createStyles2.default)('TableInspectorTH', theme);

      return _react2.default.createElement('th', (0, _extends3.default)({}, props, {
        style: (0, _extends3.default)({}, styles.base, borderStyle, this.state.hovered ? styles.base[':hover'] : {}),
        onMouseEnter: this.toggleHovered.bind(this, true),
        onMouseLeave: this.toggleHovered.bind(this, false),
        onClick: onClick
      }), _react2.default.createElement('div', { style: styles.div }, children), sorted && _react2.default.createElement(SortIconContainer, null, _react2.default.createElement(SortIcon, { sortAscending: sortAscending })));
    }
  }]);
  return TH;
}(_react.Component);

TH.contextTypes = {
  theme: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};

TH.defaultProps = {
  sortAscending: false,
  sorted: false,
  onClick: undefined
};

exports.default = TH;

/***/ }),

/***/ "p7FV":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("UYRC");
var toIndexedObject = __webpack_require__("SD9a");
var arrayIndexOf = __webpack_require__("6DLj")(false);
var hiddenKeys = __webpack_require__("g3pf");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),

/***/ "p7rG":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';

var pako = __webpack_require__("f4vO");
var utils = __webpack_require__("dvMn");
var GenericWorker = __webpack_require__("ZKdc");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function (data) {
        self.push({
            data: data,
            meta: self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

/***/ }),

/***/ "pJ9j":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: !0 });function g(a) {
  return a && "object" === typeof a && "default" in a ? a["default"] : a;
}var h = g(__webpack_require__("zCAL")),
    l = g(__webpack_require__("T4f3")),
    m = g(__webpack_require__("8FtN")),
    n = g(__webpack_require__("GyB/")),
    r = g(__webpack_require__("dACh")),
    t = g(__webpack_require__("jx4H"));function u(a) {
  return "function" === typeof a;
}
function v(a) {
  var b = new Intl.DateTimeFormat(a, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {});return function (a) {
    "string" === typeof a && (a = new Date(a));return b.format(a);
  };
}function w(a) {
  var b = new Intl.NumberFormat(a, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {});return function (a) {
    return b.format(a);
  };
}
function x(a, b) {
  function c(a, q) {
    return function (c) {
      c = u(q) ? q(c) : q;c = Array.isArray(c) ? c : [c];var p = new Intl.NumberFormat(b).format(a);return c.map(function (b) {
        return "string" === typeof b ? b.replace("#", p) : b;
      });
    };
  }function e(b) {
    return "string" === typeof b ? f[b] || { style: b } : b;
  }var d = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {},
      f = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};b = b || a;var k = d.plurals;return { plural: function (b, a) {
      var d = a.offset;d = void 0 === d ? 0 : d;a = h(a, ["offset"]);a = a[b] || a[k(b - d)];return c(b - d, a);
    }, selectordinal: function (b, a) {
      var d = a.offset;d = void 0 === d ? 0 : d;a = h(a, ["offset"]);a = a[b] || a[k(b - d, !0)];return c(b - d, a);
    }, select: function (b, a) {
      return a[b] || a.other;
    }, number: function (a, d) {
      return w(b, e(d))(a);
    }, date: function (a, d) {
      return v(b, e(d))(a);
    }, undefined: function (b) {
      return b;
    } };
}function y(a) {
  var b = a.values,
      c = x(a.language, a.locales, a.languageData, a.formats);return function p(a, f, k) {
    a = c[f](b[a], k);a = u(a) ? a(p) : a;return Array.isArray(a) ? a.join("") : a;
  };
}
function z(a, b, c, e) {
  return function (d) {
    var f = a(y({ language: b, locales: c, languageData: e, formats: 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, values: d }));return Array.isArray(f) ? f.join("").trim() : f;
  };
}
var B = function () {
  function a() {
    r(this, a);this._activeMessages = {};this._catalogs = {};
  }t(a, [{ key: "_cacheActiveLanguage", value: function () {
      var a = this._catalogs[this.language],
          c = (a || {}).languageData || {};this._activeMessages = (a || {}).messages || {};this._activeLanguageData = c;
    } }, { key: "load", value: function (a) {
      var b = this;"object" === ("undefined" === typeof a ? "undefined" : n(a)) && (m(l({}, this._catalogs, a)).forEach(function (c) {
        b._catalogs[c] = { messages: l({}, (b._catalogs[c] || {}).messages || {}, (a[c] || {}).messages || {}), languageData: l({}, (b._catalogs[c] || {}).languageData || {}, (a[c] || {}).languageData || {}) };
      }), this._cacheActiveLanguage());
    } }, { key: "activate", value: function (a, c) {
      a && (this._language = a, this._locales = c, this._cacheActiveLanguage());
    } }, { key: "use", value: function (a, c) {
      return A({ language: a, locales: c, catalogs: this._catalogs, development: this._dev });
    } }, { key: "_", value: function (a) {
      var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
          e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {},
          d = e.defaults;e = e.formats;e = void 0 === e ? {} : e;a && "object" === ("undefined" === typeof a ? "undefined" : n(a)) && (b = a.values, d = a.defaults, e = a.formats, a = a.id);d = this.messages[a] || d || a;var f = this._missing;f && !this.messages[a] && (d = u(f) ? f(this.language, a) : f);return u(d) ? z(d, this.language, this.locales, this.languageData)(b, e) : d;
    } }, { key: "pluralForm", value: function (a) {
      return this.languageData.plurals ? this.languageData.plurals(a, "ordinal" === (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "cardinal")) : "other";
    } }, { key: "date", value: function (a, c) {
      return v(this.locales || this.language, c)(a);
    } }, { key: "number", value: function (a, c) {
      return w(this.locales || this.language, c)(a);
    } }, { key: "availableLanguages", get: function () {
      return m(this._catalogs);
    } }, { key: "language", get: function () {
      return this._language;
    } }, { key: "locales", get: function () {
      return this._locales;
    } }, { key: "messages", get: function () {
      return this._activeMessages;
    } }, { key: "languageData", get: function () {
      return this._activeLanguageData;
    } }]);return a;
}();
function A() {
  var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {},
      b = new B();a.catalogs && b.load(a.catalogs);a.language && b.activate(a.language, a.locales);a.missing && (b._missing = a.missing);return b;
}var C = A();exports.i18nMark = function (a) {
  return a;
};exports.i18n = C;exports.setupI18n = A;exports.date = v;exports.number = w;

/***/ }),

/***/ "pRGz":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("0zht");

__webpack_require__("sKXM");
__webpack_require__("Xu4i");
__webpack_require__("3DJC");

/***/ }),

/***/ "pTe4":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  var defaults = {
    pairs: "()[]{}''\"\"",
    closeBefore: ")]}'\":;>",
    triples: "",
    explode: "[]{}"
  };

  var Pos = CodeMirror.Pos;

  CodeMirror.defineOption("autoCloseBrackets", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.removeKeyMap(keyMap);
      cm.state.closeBrackets = null;
    }
    if (val) {
      ensureBound(getOption(val, "pairs"));
      cm.state.closeBrackets = val;
      cm.addKeyMap(keyMap);
    }
  });

  function getOption(conf, name) {
    if (name == "pairs" && typeof conf == "string") return conf;
    if (typeof conf == "object" && conf[name] != null) return conf[name];
    return defaults[name];
  }

  var keyMap = { Backspace: handleBackspace, Enter: handleEnter };
  function ensureBound(chars) {
    for (var i = 0; i < chars.length; i++) {
      var ch = chars.charAt(i),
          key = "'" + ch + "'";
      if (!keyMap[key]) keyMap[key] = handler(ch);
    }
  }
  ensureBound(defaults.pairs + "`");

  function handler(ch) {
    return function (cm) {
      return handleChar(cm, ch);
    };
  }

  function getConfig(cm) {
    var deflt = cm.state.closeBrackets;
    if (!deflt || deflt.override) return deflt;
    var mode = cm.getModeAt(cm.getCursor());
    return mode.closeBrackets || deflt;
  }

  function handleBackspace(cm) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

    var pairs = getOption(conf, "pairs");
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    for (var i = ranges.length - 1; i >= 0; i--) {
      var cur = ranges[i].head;
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
    }
  }

  function handleEnter(cm) {
    var conf = getConfig(cm);
    var explode = conf && getOption(conf, "explode");
    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;

    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    cm.operation(function () {
      var linesep = cm.lineSeparator() || "\n";
      cm.replaceSelection(linesep + linesep, null);
      cm.execCommand("goCharLeft");
      ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        var line = ranges[i].head.line;
        cm.indentLine(line, null, true);
        cm.indentLine(line + 1, null, true);
      }
    });
  }

  function contractSelection(sel) {
    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
    return { anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
      head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1)) };
  }

  function handleChar(cm, ch) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

    var pairs = getOption(conf, "pairs");
    var pos = pairs.indexOf(ch);
    if (pos == -1) return CodeMirror.Pass;

    var closeBefore = getOption(conf, "closeBefore");

    var triples = getOption(conf, "triples");

    var identical = pairs.charAt(pos + 1) == ch;
    var ranges = cm.listSelections();
    var opening = pos % 2 == 0;

    var type;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
          cur = range.head,
          curType;
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
      if (opening && !range.empty()) {
        curType = "surround";
      } else if ((identical || !opening) && next == ch) {
        if (identical && stringStartsAfter(cm, cur)) curType = "both";else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch) curType = "skipThree";else curType = "skip";
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
        if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
        curType = "addFour";
      } else if (identical) {
        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";else return CodeMirror.Pass;
      } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
        curType = "both";
      } else {
        return CodeMirror.Pass;
      }
      if (!type) type = curType;else if (type != curType) return CodeMirror.Pass;
    }

    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
    cm.operation(function () {
      if (type == "skip") {
        cm.execCommand("goCharRight");
      } else if (type == "skipThree") {
        for (var i = 0; i < 3; i++) cm.execCommand("goCharRight");
      } else if (type == "surround") {
        var sels = cm.getSelections();
        for (var i = 0; i < sels.length; i++) sels[i] = left + sels[i] + right;
        cm.replaceSelections(sels, "around");
        sels = cm.listSelections().slice();
        for (var i = 0; i < sels.length; i++) sels[i] = contractSelection(sels[i]);
        cm.setSelections(sels);
      } else if (type == "both") {
        cm.replaceSelection(left + right, null);
        cm.triggerElectric(left + right);
        cm.execCommand("goCharLeft");
      } else if (type == "addFour") {
        cm.replaceSelection(left + left + left + left, "before");
        cm.execCommand("goCharRight");
      }
    });
  }

  function charsAround(cm, pos) {
    var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));
    return str.length == 2 ? str : null;
  }

  function stringStartsAfter(cm, pos) {
    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
    return (/\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)))
    );
  }
});

/***/ }),

/***/ "peL6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__("yh9p");
var ieee754 = __webpack_require__("JgNJ");
var isArray = __webpack_require__("REa7");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("h6ac")))

/***/ }),

/***/ "pgIM":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: !0 });function g(c) {
  return c && "object" === typeof c && "default" in c ? c["default"] : c;
}
var k = g(__webpack_require__("BX4+")),
    m = g(__webpack_require__("dACh")),
    p = g(__webpack_require__("jx4H")),
    q = g(__webpack_require__("VOrx")),
    r = g(__webpack_require__("ZKjc")),
    t = __webpack_require__("eW0v"),
    v = g(__webpack_require__("5D9O")),
    x = g(__webpack_require__("VMPx")),
    z = __webpack_require__("jNvH"),
    A = g(__webpack_require__("T4f3")),
    B = g(__webpack_require__("89El")),
    C = g(__webpack_require__("X9RM")),
    D = g(__webpack_require__("m8OI")),
    F = g(__webpack_require__("8FtN")),
    G = g(__webpack_require__("mYpx")),
    H = g(__webpack_require__("zCAL"));
function K(c) {
  var b = [];return { i18n: c, i18nHash: null, getSubscribers: function () {
      return b;
    }, subscribe: function (a) {
      b.push(a);
    }, unsubscribe: function (a) {
      b = b.filter(function (b) {
        return b !== a;
      });
    }, update: function () {
      var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};if (a) {
        var e = a.catalogs,
            d = a.language;a = a.locales;if (e || d || a) e && c.load(e), d && c.activate(d, a), this.i18nHash = x([c.language, c.messages]), b.forEach(function (a) {
          return a();
        });
      }
    } };
}
var L = function (c) {
  function b(a) {
    m(this, b);var e = q(this, (b.__proto__ || k(b)).call(this, a)),
        d = a.language,
        c = a.locales,
        h = a.catalogs;a = a.i18n || z.setupI18n({ language: d, locales: c, catalogs: h });e.linguiPublisher = K(a);e.linguiPublisher.i18n._missing = e.props.missing;return e;
  }r(b, c);p(b, [{ key: "componentDidUpdate", value: function (a) {
      var b = this.props,
          d = b.language,
          c = b.locales;b = b.catalogs;d === a.language && c === a.locales && b === a.catalogs || this.linguiPublisher.update({ language: d, catalogs: b, locales: c });this.linguiPublisher.i18n._missing = this.props.missing;
    } }, { key: "getChildContext", value: function () {
      return { linguiPublisher: this.linguiPublisher, linguiDefaultRender: this.props.defaultRender };
    } }, { key: "render", value: function () {
      return this.props.children || null;
    } }]);return b;
}(t.Component);L.defaultProps = { defaultRender: null };L.childContextTypes = { linguiPublisher: v.object.isRequired, linguiDefaultRender: v.any };
var M = function (c) {
  function b() {
    var a, c, d, f;m(this, b);for (var h = arguments.length, l = Array(h), u = 0; u < h; u++) l[u] = arguments[u];return f = (c = (d = q(this, (a = b.__proto__ || k(b)).call.apply(a, [this].concat(l))), d), d.checkUpdate = function () {
      d.forceUpdate();
    }, c), q(d, f);
  }r(b, c);p(b, [{ key: "componentDidMount", value: function () {
      var a = this.getI18n().subscribe;this.props.update && a && a(this.checkUpdate);
    } }, { key: "componentWillUnmount", value: function () {
      var a = this.getI18n().unsubscribe;this.props.update && a && a(this.checkUpdate);
    } }, { key: "getI18n", value: function () {
      return this.context.linguiPublisher || {};
    } }, { key: "render", value: function () {
      var a = this.props,
          b = a.children;a = a.withHash;var c = this.getI18n(),
          f = c.i18nHash;a = A({ i18n: c.i18n }, a ? { i18nHash: f } : {});return "function" === typeof b ? b(a) : t.isValidElement(b) ? t.cloneElement(b, a) : t.createElement(b, a);
    } }]);return b;
}(t.Component);M.defaultProps = { update: !0, withHash: !0 };M.contextTypes = { linguiPublisher: v.object };
function N() {
  var c = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};return function (b) {
    var a = c.update,
        e = void 0 === a ? !0 : a;a = c.withHash;var d = void 0 === a ? !0 : a;a = c.withRef;var f = void 0 === a ? !1 : a;a = function (a) {
      function c() {
        var a, b, d, e;m(this, c);for (var l = arguments.length, h = Array(l), w = 0; w < l; w++) h[w] = arguments[w];return e = (b = (d = q(this, (a = c.__proto__ || k(c)).call.apply(a, [this].concat(h))), d), d.wrappedInstance = null, d.setWrappedInstance = function (a) {
          f && (d.wrappedInstance = a);
        }, d.getWrappedInstance = function () {
          if (!f) throw Error("To access the wrapped instance, you need to specify { withRef: true } in the options argument of the withI18n() call.");
          return d.wrappedInstance;
        }, b), q(d, e);
      }r(c, a);p(c, [{ key: "render", value: function () {
          var a = A({}, this.props, f ? { ref: this.setWrappedInstance } : {});return t.createElement(M, { update: e, withHash: d }, function (c) {
            return t.createElement(b, A({}, a, { i18n: c.i18n, i18nHash: c.i18nHash }));
          });
        } }]);return c;
    }(t.Component);a.contextTypes = { linguiPublisher: v.object };return B(a, b);
  };
}var O = /<(\d+)>(.*)<\/\1>|<(\d+)\/>/,
    P = /(?:\r\n|\r|\n)/g;
function Q(c) {
  var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : [],
      a = c.replace(P, "").split(O);if (1 === a.length) return c;var e = [],
      d = a.shift();d && e.push(d);d = !0;var f = !1,
      h = void 0;try {
    for (var l = C(R(a)), u; !(d = (u = l.next()).done); d = !0) {
      var E = D(u.value, 3),
          I = E[0],
          J = E[1],
          y = E[2],
          n = b[I];e.push(t.cloneElement(n, { key: I }, J ? Q(J, b) : n.props.children));y && e.push(y);
    }
  } catch (w) {
    f = !0, h = w;
  } finally {
    try {
      !d && l.return && l.return();
    } finally {
      if (f) throw h;
    }
  }return e;
}
function R(c) {
  if (!c.length) return [];var b = c.slice(0, 4);b = D(b, 4);var a = b[1],
      e = b[2],
      d = b[3];return [[parseInt(b[0] || e), a || "", d]].concat(R(c.slice(4, c.length)));
}
var S = function (c) {
  function b() {
    m(this, b);return q(this, (b.__proto__ || k(b)).apply(this, arguments));
  }r(b, c);p(b, [{ key: "render", value: function () {
      var a = this.props,
          b = a.className;a = a.value;var c = this.props.render || this.context.linguiDefaultRender;return null === c || void 0 === c ? a || null : "string" === typeof c ? t.createElement(c, { className: b }, a) : t.isValidElement(c) ? t.cloneElement(c, {}, a) : t.createElement(c, { translation: a });
    } }]);return b;
}(t.Component);S.contextTypes = { linguiDefaultRender: v.any };
var T = function (c) {
  function b() {
    m(this, b);return q(this, (b.__proto__ || k(b)).apply(this, arguments));
  }r(b, c);p(b, [{ key: "componentDidMount", value: function () {} }, { key: "getTranslation", value: function () {
      var a = this.props,
          b = a.id;b = void 0 === b ? "" : b;var c = a.defaults,
          f = a.i18n;a = a.formats;var h = A({}, this.props.values),
          l = this.props.components ? [].concat(G(this.props.components)) : [];h && F(h).forEach(function (a) {
        var b = h[a];t.isValidElement(b) && (b = l.push(b) - 1, h[a] = "\x3c" + b + "/\x3e");
      });return (a = f && "function" === typeof f._ ? f._(b, h, { defaults: c, formats: a }) : b) ? Q(a, l) : null;
    } }, { key: "render", value: function () {
      return t.createElement(S, { render: this.props.render, className: this.props.className, value: this.getTranslation() });
    } }]);return b;
}(t.Component),
    U = N()(T),
    V = N()(function (c) {
  function b() {
    m(this, b);return q(this, (b.__proto__ || k(b)).apply(this, arguments));
  }r(b, c);p(b, [{ key: "render", value: function () {
      var a = this.props,
          b = a.className,
          c = a.render,
          f = a.i18n;a = H(a, ["className", "render", "i18n"]);return t.createElement(S, { className: b, render: c,
        value: f.select(a) });
    } }]);return b;
}(t.Component));
function W() {
  var c,
      b,
      a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : !1,
      e = a ? "SelectOrdinal" : "Plural",
      d = a ? "selectOrdinal" : "plural";return b = c = function (a) {
    function b() {
      var a, c, d, f;m(this, b);for (var h = arguments.length, y = Array(h), n = 0; n < h; n++) y[n] = arguments[n];return f = (c = (d = q(this, (a = b.__proto__ || k(b)).call.apply(a, [this].concat(y))), d), d.displayName = e, c), q(d, f);
    }r(b, a);p(b, [{ key: "render", value: function () {
        var a = this.props,
            b = a.className,
            c = a.render,
            e = a.i18n,
            f = a.value,
            h = a.offset,
            n = H(a, ["className", "render", "i18n", "value", "offset"]);a = F(n).reduce(function (a, b) {
          var c = b.replace("_", "");a[c] = n[b];return a;
        }, { value: Number(f), offset: Number(h) });return t.createElement(S, { className: b, render: c, value: e[d](a) });
      } }]);return b;
  }(t.Component), c.defaultProps = { offset: 0 }, b;
}var X = N()(W(!1)),
    Y = N()(W(!0));function Z(c) {
  return function (b) {
    var a = b.value,
        e = b.i18n,
        d = b.className,
        f = b.render;b = c(e.locales || e.language, b.format);return t.createElement(S, { className: d, render: f, value: b(a) });
  };
}var aa = N()(Z(z.date)),
    ba = N()(Z(z.number));
exports.i18nMark = function (c) {
  return c;
};exports.withI18n = N;exports.I18nProvider = L;exports.I18n = M;exports.Trans = U;exports.Plural = X;exports.Select = V;exports.SelectOrdinal = Y;exports.DateFormat = aa;exports.NumberFormat = ba;

/***/ }),

/***/ "pmmJ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim

var global = __webpack_require__("wJQ+");
var has = __webpack_require__("UYRC");
var DESCRIPTORS = __webpack_require__("xWhT");
var IS_PURE = __webpack_require__("qCGA");
var $export = __webpack_require__("c+Wn");
var redefine = __webpack_require__("iKbl");
var hiddenKeys = __webpack_require__("g3pf");
var fails = __webpack_require__("b3E9");
var shared = __webpack_require__("JE34");
var setToStringTag = __webpack_require__("xyxa");
var uid = __webpack_require__("6n5Z");
var wellKnownSymbol = __webpack_require__("95jh");
var wrappedWellKnownSymbolModule = __webpack_require__("HOGQ");
var defineWellKnownSymbol = __webpack_require__("KGgk");
var enumKeys = __webpack_require__("7T8+");
var isArray = __webpack_require__("+KPf");
var anObject = __webpack_require__("hrV0");
var isObject = __webpack_require__("dmyY");
var toIndexedObject = __webpack_require__("SD9a");
var toPrimitive = __webpack_require__("i3Mv");
var createPropertyDescriptor = __webpack_require__("IFQ2");
var nativeObjectCreate = __webpack_require__("M3NV");
var getOwnPropertyNamesExternal = __webpack_require__("Uq/2");
var getOwnPropertyDescriptorModule = __webpack_require__("1g0E");
var definePropertyModule = __webpack_require__("uebg");
var propertyIsEnumerableModule = __webpack_require__("2uWC");
var hide = __webpack_require__("2O9B");
var objectKeys = __webpack_require__("cjyi");
var HIDDEN = __webpack_require__("YYE9")('hidden');
var InternalStateModule = __webpack_require__("q/RK");
var SYMBOL = 'Symbol';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var $Symbol = global.Symbol;
var JSON = global.JSON;
var nativeJSONStringify = JSON && JSON.stringify;
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');
var ObjectPrototype = Object[PROTOTYPE];
var QObject = global.QObject;
var NATIVE_SYMBOL = __webpack_require__("CXjr");
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () {
      return nativeDefineProperty(this, 'a', { value: 7 }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, key);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[key];
  nativeDefineProperty(it, key, D);
  if (ObjectPrototypeDescriptor && it !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, key, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = NATIVE_SYMBOL && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) nativeDefineProperty(it, HIDDEN, createPropertyDescriptor(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = nativeObjectCreate(D, { enumerable: createPropertyDescriptor(0, false) });
    }return setSymbolDescriptor(it, key, D);
  }return nativeDefineProperty(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIndexedObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};

var $create = function create(it, P) {
  return P === undefined ? nativeObjectCreate(it) : $defineProperties(nativeObjectCreate(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = nativePropertyIsEnumerable.call(this, key = toPrimitive(key, true));
  if (this === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIndexedObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var D = nativeGetOwnPropertyDescriptor(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && !has(hiddenKeys, key)) result.push(key);
  }return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OP ? ObjectPrototypeSymbols : toIndexedObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectPrototype, key) : true)) result.push(AllSymbols[key]);
  }return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  __webpack_require__("+puC").f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  __webpack_require__("Mve8").f = $getOwnPropertySymbols;

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
}

$export({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, { Symbol: $Symbol });

for (var wellKnownSymbols = objectKeys(WellKnownSymbolsStore), k = 0; wellKnownSymbols.length > k;) {
  defineWellKnownSymbol(wellKnownSymbols[k++]);
}

$export({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () {
    USE_SETTER = true;
  },
  useSimple: function () {
    USE_SETTER = false;
  }
});

$export({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$export({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
JSON && $export({ target: 'JSON', stat: true, forced: !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return nativeJSONStringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || nativeJSONStringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || nativeJSONStringify(Object(symbol)) != '{}';
  }) }, {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return nativeJSONStringify.apply(JSON, args);
  }
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;

/***/ }),

/***/ "pup0":
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

/***/ }),

/***/ "pvap":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var codePointAt = __webpack_require__("br85");
var InternalStateModule = __webpack_require__("q/RK");
var defineIterator = __webpack_require__("GHga");
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
  // `%StringIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = codePointAt(string, index, true);
  state.index += point.length;
  return { value: point, done: false };
});

/***/ }),

/***/ "pwNi":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _preact = __webpack_require__("KM04");

if (false) {
	require('preact/devtools');
} else if (false) {
	navigator.serviceWorker.register(__webpack_public_path__ + 'sw.js');
}

const interopDefault = m => m && m.default ? m.default : m;

let app = interopDefault(__webpack_require__("JkW7"));

if (typeof app === 'function') {
	let root = document.body.firstElementChild;

	let init = () => {
		let app = interopDefault(__webpack_require__("JkW7"));
		root = (0, _preact.render)((0, _preact.h)(app), document.body, root);
	};

	if (false) module.hot.accept('preact-cli-entrypoint', init);

	init();
}

/***/ }),

/***/ "q/RK":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__("BiiT");
var isObject = __webpack_require__("dmyY");
var hide = __webpack_require__("2O9B");
var objectHas = __webpack_require__("UYRC");
var sharedKey = __webpack_require__("YYE9");
var hiddenKeys = __webpack_require__("g3pf");
var WeakMap = __webpack_require__("wJQ+").WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    hide(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

/***/ }),

/***/ "q6qL":
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory(__webpack_require__("KM04")) : typeof define === 'function' && define.amd ? define(['preact'], factory) : global.preactPortal = factory(global.preact);
})(this, function (preact) {
  'use strict';

  var asyncGenerator = function () {
    function AwaitValue(value) {
      this.value = value;
    }

    function AsyncGenerator(gen) {
      var front, back;

      function send(key, arg) {
        return new Promise(function (resolve, reject) {
          var request = {
            key: key,
            arg: arg,
            resolve: resolve,
            reject: reject,
            next: null
          };

          if (back) {
            back = back.next = request;
          } else {
            front = back = request;
            resume(key, arg);
          }
        });
      }

      function resume(key, arg) {
        try {
          var result = gen[key](arg);
          var value = result.value;

          if (value instanceof AwaitValue) {
            Promise.resolve(value.value).then(function (arg) {
              resume("next", arg);
            }, function (arg) {
              resume("throw", arg);
            });
          } else {
            settle(result.done ? "return" : "normal", result.value);
          }
        } catch (err) {
          settle("throw", err);
        }
      }

      function settle(type, value) {
        switch (type) {
          case "return":
            front.resolve({
              value: value,
              done: true
            });
            break;

          case "throw":
            front.reject(value);
            break;

          default:
            front.resolve({
              value: value,
              done: false
            });
            break;
        }

        front = front.next;

        if (front) {
          resume(front.key, front.arg);
        } else {
          back = null;
        }
      }

      this._invoke = send;

      if (typeof gen.return !== "function") {
        this.return = undefined;
      }
    }

    if (typeof Symbol === "function" && Symbol.asyncIterator) {
      AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
        return this;
      };
    }

    AsyncGenerator.prototype.next = function (arg) {
      return this._invoke("next", arg);
    };

    AsyncGenerator.prototype.throw = function (arg) {
      return this._invoke("throw", arg);
    };

    AsyncGenerator.prototype.return = function (arg) {
      return this._invoke("return", arg);
    };

    return {
      wrap: function (fn) {
        return function () {
          return new AsyncGenerator(fn.apply(this, arguments));
        };
      },
      await: function (value) {
        return new AwaitValue(value);
      }
    };
  }();

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var Portal = function (_Component) {
    inherits(Portal, _Component);

    function Portal() {
      classCallCheck(this, Portal);
      return possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Portal.prototype.componentDidUpdate = function componentDidUpdate(props) {
      for (var i in props) {
        if (props[i] !== this.props[i]) {
          return setTimeout(this.renderLayer);
        }
      }
    };

    Portal.prototype.componentDidMount = function componentDidMount() {
      this.isMounted = true;
      this.renderLayer = this.renderLayer.bind(this);
      this.renderLayer();
    };

    Portal.prototype.componentWillUnmount = function componentWillUnmount() {
      this.renderLayer(false);
      this.isMounted = false;
      if (this.remote) this.remote.parentNode.removeChild(this.remote);
    };

    Portal.prototype.findNode = function findNode(node) {
      return typeof node === 'string' ? document.querySelector(node) : node;
    };

    Portal.prototype.renderLayer = function renderLayer() {
      var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (!this.isMounted) return;

      if (this.props.into !== this.intoPointer) {
        this.intoPointer = this.props.into;
        if (this.into && this.remote) {
          this.remote = preact.render(preact.h(PortalProxy, null), this.into, this.remote);
        }
        this.into = this.findNode(this.props.into);
      }

      this.remote = preact.render(preact.h(PortalProxy, { context: this.context }, show && this.props.children || null), this.into, this.remote);
    };

    Portal.prototype.render = function render() {
      return null;
    };

    return Portal;
  }(preact.Component);

  var PortalProxy = function (_Component2) {
    inherits(PortalProxy, _Component2);

    function PortalProxy() {
      classCallCheck(this, PortalProxy);
      return possibleConstructorReturn(this, _Component2.apply(this, arguments));
    }

    PortalProxy.prototype.getChildContext = function getChildContext() {
      return this.props.context;
    };

    PortalProxy.prototype.render = function render(_ref) {
      var children = _ref.children;

      return children && children[0] || null;
    };

    return PortalProxy;
  }(preact.Component);

  return Portal;
});
//# sourceMappingURL=preact-portal.js.map

/***/ }),

/***/ "qCGA":
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "qqFR":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("javascript", function (config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

    // Tokenizer

    var keywords = function () {
      function kw(type) {
        return { type: type, style: "keyword" };
      }
      var A = kw("keyword a"),
          B = kw("keyword b"),
          C = kw("keyword c"),
          D = kw("keyword d");
      var operator = kw("operator"),
          atom = { type: "atom", style: "atom" };

      return {
        "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
        "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
        "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
        "function": kw("function"), "catch": kw("catch"),
        "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
        "in": operator, "typeof": operator, "instanceof": operator,
        "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
        "this": kw("this"), "class": kw("class"), "super": kw("atom"),
        "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
        "await": C
      };
    }();

    var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

    function readRegexp(stream) {
      var escaped = false,
          next,
          inSet = false;
      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet) return;
          if (next == "[") inSet = true;else if (inSet && next == "]") inSet = false;
        }
        escaped = !escaped && next == "\\";
      }
    }

    // Used as scratch variables to communicate multiple values without
    // consing up tons of objects.
    var type, content;
    function ret(tp, style, cont) {
      type = tp;content = cont;
      return style;
    }
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
        return ret("number", "number");
      } else if (/\d/.test(ch)) {
        stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (expressionAllowed(stream, state, 1)) {
          readRegexp(stream);
          stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
          return ret("regexp", "string-2");
        } else {
          stream.eat("=");
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "#") {
        stream.skipToEnd();
        return ret("error", "error");
      } else if (isOperatorChar.test(ch)) {
        if (ch != ">" || !state.lexical || state.lexical.type != ">") {
          if (stream.eat("=")) {
            if (ch == "!" || ch == "=") stream.eat("=");
          } else if (/[<>*+\-]/.test(ch)) {
            stream.eat(ch);
            if (ch == ">") stream.eat(ch);
          }
        }
        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current();
        if (state.lastType != ".") {
          if (keywords.propertyIsEnumerable(word)) {
            var kw = keywords[word];
            return ret(kw.type, kw.style, word);
          }
          if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false)) return ret("async", "keyword", word);
        }
        return ret("variable", "variable", word);
      }
    }

    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false,
            next;
        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) break;
          escaped = !escaped && next == "\\";
        }
        if (!escaped) state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false,
          ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = ch == "*";
      }
      return ret("comment", "comment");
    }

    function tokenQuasi(stream, state) {
      var escaped = false,
          next;
      while ((next = stream.next()) != null) {
        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      return ret("quasi", "string-2", stream.current());
    }

    var brackets = "([{}])";
    // This is a crude lookahead trick to try and notice that we're
    // parsing the argument patterns for a fat-arrow function before we
    // actually hit the arrow token. It only works if the arrow is on
    // the same line as the arguments and there's no strange noise
    // (comments) in between. Fallback is to only notice when we hit the
    // arrow, and not declare the arguments as locals for the arrow
    // body.
    function findFatArrow(stream, state) {
      if (state.fatArrowAt) state.fatArrowAt = null;
      var arrow = stream.string.indexOf("=>", stream.start);
      if (arrow < 0) return;

      if (isTS) {
        // Try to skip TypeScript return type declarations after the arguments
        var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
        if (m) arrow = m.index;
      }

      var depth = 0,
          sawSomething = false;
      for (var pos = arrow - 1; pos >= 0; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets.indexOf(ch);
        if (bracket >= 0 && bracket < 3) {
          if (!depth) {
            ++pos;break;
          }
          if (--depth == 0) {
            if (ch == "(") sawSomething = true;break;
          }
        } else if (bracket >= 3 && bracket < 6) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (/["'\/`]/.test(ch)) {
          for (;; --pos) {
            if (pos == 0) return;
            var next = stream.string.charAt(pos - 1);
            if (next == ch && stream.string.charAt(pos - 2) != "\\") {
              pos--;break;
            }
          }
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }
      if (sawSomething && !depth) state.fatArrowAt = pos;
    }

    // Parser

    var atomicTypes = { "atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true };

    function JSLexical(indented, column, type, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.prev = prev;
      this.info = info;
      if (align != null) this.align = align;
    }

    function inScope(state, varname) {
      for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;
      for (var cx = state.context; cx; cx = cx.prev) {
        for (var v = cx.vars; v; v = v.next) if (v.name == varname) return true;
      }
    }

    function parseJS(state, style, type, content, stream) {
      var cc = state.cc;
      // Communicate our context to the combinators.
      // (Less wasteful than consing up a hundred closures on every call.)
      cx.state = state;cx.stream = stream;cx.marked = null, cx.cc = cc;cx.style = style;

      if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;

      while (true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
        if (combinator(type, content)) {
          while (cc.length && cc[cc.length - 1].lex) cc.pop()();
          if (cx.marked) return cx.marked;
          if (type == "variable" && inScope(state, content)) return "variable-2";
          return style;
        }
      }
    }

    // Combinator utils

    var cx = { state: null, column: null, marked: null, cc: null };
    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
    }
    function cont() {
      pass.apply(null, arguments);
      return true;
    }
    function inList(name, list) {
      for (var v = list; v; v = v.next) if (v.name == name) return true;
      return false;
    }
    function register(varname) {
      var state = cx.state;
      cx.marked = "def";
      if (state.context) {
        if (state.lexical.info == "var" && state.context && state.context.block) {
          // FIXME function decls are also not block scoped
          var newContext = registerVarScoped(varname, state.context);
          if (newContext != null) {
            state.context = newContext;
            return;
          }
        } else if (!inList(varname, state.localVars)) {
          state.localVars = new Var(varname, state.localVars);
          return;
        }
      }
      // Fall through means this is global
      if (parserConfig.globalVars && !inList(varname, state.globalVars)) state.globalVars = new Var(varname, state.globalVars);
    }
    function registerVarScoped(varname, context) {
      if (!context) {
        return null;
      } else if (context.block) {
        var inner = registerVarScoped(varname, context.prev);
        if (!inner) return null;
        if (inner == context.prev) return context;
        return new Context(inner, context.vars, true);
      } else if (inList(varname, context.vars)) {
        return context;
      } else {
        return new Context(context.prev, new Var(varname, context.vars), false);
      }
    }

    function isModifier(name) {
      return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
    }

    // Combinators

    function Context(prev, vars, block) {
      this.prev = prev;this.vars = vars;this.block = block;
    }
    function Var(name, next) {
      this.name = name;this.next = next;
    }

    var defaultVars = new Var("this", new Var("arguments", null));
    function pushcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
      cx.state.localVars = defaultVars;
    }
    function pushblockcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
      cx.state.localVars = null;
    }
    function popcontext() {
      cx.state.localVars = cx.state.context.vars;
      cx.state.context = cx.state.context.prev;
    }
    popcontext.lex = true;
    function pushlex(type, info) {
      var result = function () {
        var state = cx.state,
            indent = state.indented;
        if (state.lexical.type == "stat") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev) indent = outer.indented;
        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
      };
      result.lex = true;
      return result;
    }
    function poplex() {
      var state = cx.state;
      if (state.lexical.prev) {
        if (state.lexical.type == ")") state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }
    poplex.lex = true;

    function expect(wanted) {
      function exp(type) {
        if (type == wanted) return cont();else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();else return cont(exp);
      };
      return exp;
    }

    function statement(type, value) {
      if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
      if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
      if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
      if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
      if (type == "debugger") return cont(expect(";"));
      if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
      if (type == ";") return cont();
      if (type == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();
        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
      }
      if (type == "function") return cont(functiondef);
      if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
      if (type == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form", type == "class" ? type : value), className, poplex);
      }
      if (type == "variable") {
        if (isTS && value == "declare") {
          cx.marked = "keyword";
          return cont(statement);
        } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
          cx.marked = "keyword";
          if (value == "enum") return cont(enumdef);else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
        } else if (isTS && value == "namespace") {
          cx.marked = "keyword";
          return cont(pushlex("form"), expression, statement, poplex);
        } else if (isTS && value == "abstract") {
          cx.marked = "keyword";
          return cont(statement);
        } else {
          return cont(pushlex("stat"), maybelabel);
        }
      }
      if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
      if (type == "case") return cont(expression, expect(":"));
      if (type == "default") return cont(expect(":"));
      if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
      if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
      if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
      if (type == "async") return cont(statement);
      if (value == "@") return cont(expression, statement);
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }
    function maybeCatchBinding(type) {
      if (type == "(") return cont(funarg, expect(")"));
    }
    function expression(type, value) {
      return expressionInner(type, value, false);
    }
    function expressionNoComma(type, value) {
      return expressionInner(type, value, true);
    }
    function parenExpr(type) {
      if (type != "(") return pass();
      return cont(pushlex(")"), expression, expect(")"), poplex);
    }
    function expressionInner(type, value, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
      }

      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
      if (type == "function") return cont(functiondef, maybeop);
      if (type == "class" || isTS && value == "interface") {
        cx.marked = "keyword";return cont(pushlex("form"), classExpression, poplex);
      }
      if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
      if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
      if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
      if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type == "{") return contCommasep(objprop, "}", null, maybeop);
      if (type == "quasi") return pass(quasi, maybeop);
      if (type == "new") return cont(maybeTarget(noComma));
      if (type == "import") return cont(expression);
      return cont();
    }
    function maybeexpression(type) {
      if (type.match(/[;\}\)\],]/)) return pass();
      return pass(expression);
    }

    function maybeoperatorComma(type, value) {
      if (type == ",") return cont(expression);
      return maybeoperatorNoComma(type, value, false);
    }
    function maybeoperatorNoComma(type, value, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
      if (type == "operator") {
        if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
        if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false)) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
        if (value == "?") return cont(expression, expect(":"), expr);
        return cont(expr);
      }
      if (type == "quasi") {
        return pass(quasi, me);
      }
      if (type == ";") return;
      if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
      if (type == ".") return cont(property, me);
      if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      if (isTS && value == "as") {
        cx.marked = "keyword";return cont(typeexpr, me);
      }
      if (type == "regexp") {
        cx.state.lastType = cx.marked = "operator";
        cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
        return cont(expr);
      }
    }
    function quasi(type, value) {
      if (type != "quasi") return pass();
      if (value.slice(value.length - 2) != "${") return cont(quasi);
      return cont(expression, continueQuasi);
    }
    function continueQuasi(type) {
      if (type == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }
    function arrowBody(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expression);
    }
    function arrowBodyNoComma(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expressionNoComma);
    }
    function maybeTarget(noComma) {
      return function (type) {
        if (type == ".") return cont(noComma ? targetNoComma : target);else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);else return pass(noComma ? expressionNoComma : expression);
      };
    }
    function target(_, value) {
      if (value == "target") {
        cx.marked = "keyword";return cont(maybeoperatorComma);
      }
    }
    function targetNoComma(_, value) {
      if (value == "target") {
        cx.marked = "keyword";return cont(maybeoperatorNoComma);
      }
    }
    function maybelabel(type) {
      if (type == ":") return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }
    function property(type) {
      if (type == "variable") {
        cx.marked = "property";return cont();
      }
    }
    function objprop(type, value) {
      if (type == "async") {
        cx.marked = "property";
        return cont(objprop);
      } else if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set") return cont(getterSetter);
        var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params
        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false))) cx.state.fatArrowAt = cx.stream.pos + m[0].length;
        return cont(afterprop);
      } else if (type == "number" || type == "string") {
        cx.marked = jsonldMode ? "property" : cx.style + " property";
        return cont(afterprop);
      } else if (type == "jsonld-keyword") {
        return cont(afterprop);
      } else if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == "[") {
        return cont(expression, maybetype, expect("]"), afterprop);
      } else if (type == "spread") {
        return cont(expressionNoComma, afterprop);
      } else if (value == "*") {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == ":") {
        return pass(afterprop);
      }
    }
    function getterSetter(type) {
      if (type != "variable") return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }
    function afterprop(type) {
      if (type == ":") return cont(expressionNoComma);
      if (type == "(") return pass(functiondef);
    }
    function commasep(what, end, sep) {
      function proceed(type, value) {
        if (sep ? sep.indexOf(type) > -1 : type == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
          return cont(function (type, value) {
            if (type == end || value == end) return pass();
            return pass(what);
          }, proceed);
        }
        if (type == end || value == end) return cont();
        if (sep && sep.indexOf(";") > -1) return pass(what);
        return cont(expect(end));
      }
      return function (type, value) {
        if (type == end || value == end) return cont();
        return pass(what, proceed);
      };
    }
    function contCommasep(what, end, info) {
      for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);
      return cont(pushlex(end, info), commasep(what, end), poplex);
    }
    function block(type) {
      if (type == "}") return cont();
      return pass(statement, block);
    }
    function maybetype(type, value) {
      if (isTS) {
        if (type == ":") return cont(typeexpr);
        if (value == "?") return cont(maybetype);
      }
    }
    function maybetypeOrIn(type, value) {
      if (isTS && (type == ":" || value == "in")) return cont(typeexpr);
    }
    function mayberettype(type) {
      if (isTS && type == ":") {
        if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr);else return cont(typeexpr);
      }
    }
    function isKW(_, value) {
      if (value == "is") {
        cx.marked = "keyword";
        return cont();
      }
    }
    function typeexpr(type, value) {
      if (value == "keyof" || value == "typeof" || value == "infer") {
        cx.marked = "keyword";
        return cont(value == "typeof" ? expressionNoComma : typeexpr);
      }
      if (type == "variable" || value == "void") {
        cx.marked = "type";
        return cont(afterType);
      }
      if (value == "|" || value == "&") return cont(typeexpr);
      if (type == "string" || type == "number" || type == "atom") return cont(afterType);
      if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
      if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType);
      if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType);
      if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr);
    }
    function maybeReturnType(type) {
      if (type == "=>") return cont(typeexpr);
    }
    function typeprop(type, value) {
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(typeprop);
      } else if (value == "?" || type == "number" || type == "string") {
        return cont(typeprop);
      } else if (type == ":") {
        return cont(typeexpr);
      } else if (type == "[") {
        return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
      } else if (type == "(") {
        return pass(functiondecl, typeprop);
      }
    }
    function typearg(type, value) {
      if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg);
      if (type == ":") return cont(typeexpr);
      if (type == "spread") return cont(typearg);
      return pass(typeexpr);
    }
    function afterType(type, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      if (value == "|" || type == "." || value == "&") return cont(typeexpr);
      if (type == "[") return cont(typeexpr, expect("]"), afterType);
      if (value == "extends" || value == "implements") {
        cx.marked = "keyword";return cont(typeexpr);
      }
      if (value == "?") return cont(typeexpr, expect(":"), typeexpr);
    }
    function maybeTypeArgs(_, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
    }
    function typeparam() {
      return pass(typeexpr, maybeTypeDefault);
    }
    function maybeTypeDefault(_, value) {
      if (value == "=") return cont(typeexpr);
    }
    function vardef(_, value) {
      if (value == "enum") {
        cx.marked = "keyword";return cont(enumdef);
      }
      return pass(pattern, maybetype, maybeAssign, vardefCont);
    }
    function pattern(type, value) {
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";return cont(pattern);
      }
      if (type == "variable") {
        register(value);return cont();
      }
      if (type == "spread") return cont(pattern);
      if (type == "[") return contCommasep(eltpattern, "]");
      if (type == "{") return contCommasep(proppattern, "}");
    }
    function proppattern(type, value) {
      if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
        register(value);
        return cont(maybeAssign);
      }
      if (type == "variable") cx.marked = "property";
      if (type == "spread") return cont(pattern);
      if (type == "}") return pass();
      if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
      return cont(expect(":"), pattern, maybeAssign);
    }
    function eltpattern() {
      return pass(pattern, maybeAssign);
    }
    function maybeAssign(_type, value) {
      if (value == "=") return cont(expressionNoComma);
    }
    function vardefCont(type) {
      if (type == ",") return cont(vardef);
    }
    function maybeelse(type, value) {
      if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
    }
    function forspec(type, value) {
      if (value == "await") return cont(forspec);
      if (type == "(") return cont(pushlex(")"), forspec1, poplex);
    }
    function forspec1(type) {
      if (type == "var") return cont(vardef, forspec2);
      if (type == "variable") return cont(forspec2);
      return pass(forspec2);
    }
    function forspec2(type, value) {
      if (type == ")") return cont();
      if (type == ";") return cont(forspec2);
      if (value == "in" || value == "of") {
        cx.marked = "keyword";return cont(expression, forspec2);
      }
      return pass(expression, forspec2);
    }
    function functiondef(type, value) {
      if (value == "*") {
        cx.marked = "keyword";return cont(functiondef);
      }
      if (type == "variable") {
        register(value);return cont(functiondef);
      }
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
    }
    function functiondecl(type, value) {
      if (value == "*") {
        cx.marked = "keyword";return cont(functiondecl);
      }
      if (type == "variable") {
        register(value);return cont(functiondecl);
      }
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
    }
    function typename(type, value) {
      if (type == "keyword" || type == "variable") {
        cx.marked = "type";
        return cont(typename);
      } else if (value == "<") {
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
      }
    }
    function funarg(type, value) {
      if (value == "@") cont(expression, funarg);
      if (type == "spread") return cont(funarg);
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";return cont(funarg);
      }
      if (isTS && type == "this") return cont(maybetype, maybeAssign);
      return pass(pattern, maybetype, maybeAssign);
    }
    function classExpression(type, value) {
      // Class expressions may have an optional name.
      if (type == "variable") return className(type, value);
      return classNameAfter(type, value);
    }
    function className(type, value) {
      if (type == "variable") {
        register(value);return cont(classNameAfter);
      }
    }
    function classNameAfter(type, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
      if (value == "extends" || value == "implements" || isTS && type == ",") {
        if (value == "implements") cx.marked = "keyword";
        return cont(isTS ? typeexpr : expression, classNameAfter);
      }
      if (type == "{") return cont(pushlex("}"), classBody, poplex);
    }
    function classBody(type, value) {
      if (type == "async" || type == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(isTS ? classfield : functiondef, classBody);
      }
      if (type == "number" || type == "string") return cont(isTS ? classfield : functiondef, classBody);
      if (type == "[") return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody);
      if (value == "*") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (isTS && type == "(") return pass(functiondecl, classBody);
      if (type == ";" || type == ",") return cont(classBody);
      if (type == "}") return cont();
      if (value == "@") return cont(expression, classBody);
    }
    function classfield(type, value) {
      if (value == "?") return cont(classfield);
      if (type == ":") return cont(typeexpr, maybeAssign);
      if (value == "=") return cont(expressionNoComma);
      var context = cx.state.lexical.prev,
          isInterface = context && context.info == "interface";
      return pass(isInterface ? functiondecl : functiondef);
    }
    function afterExport(type, value) {
      if (value == "*") {
        cx.marked = "keyword";return cont(maybeFrom, expect(";"));
      }
      if (value == "default") {
        cx.marked = "keyword";return cont(expression, expect(";"));
      }
      if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
      return pass(statement);
    }
    function exportField(type, value) {
      if (value == "as") {
        cx.marked = "keyword";return cont(expect("variable"));
      }
      if (type == "variable") return pass(expressionNoComma, exportField);
    }
    function afterImport(type) {
      if (type == "string") return cont();
      if (type == "(") return pass(expression);
      return pass(importSpec, maybeMoreImports, maybeFrom);
    }
    function importSpec(type, value) {
      if (type == "{") return contCommasep(importSpec, "}");
      if (type == "variable") register(value);
      if (value == "*") cx.marked = "keyword";
      return cont(maybeAs);
    }
    function maybeMoreImports(type) {
      if (type == ",") return cont(importSpec, maybeMoreImports);
    }
    function maybeAs(_type, value) {
      if (value == "as") {
        cx.marked = "keyword";return cont(importSpec);
      }
    }
    function maybeFrom(_type, value) {
      if (value == "from") {
        cx.marked = "keyword";return cont(expression);
      }
    }
    function arrayLiteral(type) {
      if (type == "]") return cont();
      return pass(commasep(expressionNoComma, "]"));
    }
    function enumdef() {
      return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
    }
    function enummember() {
      return pass(pattern, maybeAssign);
    }

    function isContinuedStatement(state, textAfter) {
      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
    }

    function expressionAllowed(stream, state, backUp) {
      return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
    }

    // Interface

    return {
      startState: function (basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && new Context(null, null, false),
          indented: basecolumn || 0
        };
        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object") state.globalVars = parserConfig.globalVars;
        return state;
      },

      token: function (stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }
        if (state.tokenize != tokenComment && stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        if (type == "comment") return style;
        state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
        return parseJS(state, style, type, content, stream);
      },

      indent: function (state, textAfter) {
        if (state.tokenize == tokenComment) return CodeMirror.Pass;
        if (state.tokenize != tokenBase) return 0;
        var firstChar = textAfter && textAfter.charAt(0),
            lexical = state.lexical,
            top;
        // Kludge to prevent 'maybelse' from blocking lexical scope pops
        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
          var c = state.cc[i];
          if (c == poplex) lexical = lexical.prev;else if (c != maybeelse) break;
        }
        while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter))) lexical = lexical.prev;
        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;
        var type = lexical.type,
            closing = firstChar == type;

        if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
      },

      electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
      blockCommentStart: jsonMode ? null : "/*",
      blockCommentEnd: jsonMode ? null : "*/",
      blockCommentContinue: jsonMode ? null : " * ",
      lineComment: jsonMode ? null : "//",
      fold: "brace",
      closeBrackets: "()[]{}''\"\"``",

      helperType: jsonMode ? "json" : "javascript",
      jsonldMode: jsonldMode,
      jsonMode: jsonMode,

      expressionAllowed: expressionAllowed,

      skipExpression: function (state) {
        var top = state.cc[state.cc.length - 1];
        if (top == expression || top == expressionNoComma) state.cc.pop();
      }
    };
  });

  CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

  CodeMirror.defineMIME("text/javascript", "javascript");
  CodeMirror.defineMIME("text/ecmascript", "javascript");
  CodeMirror.defineMIME("application/javascript", "javascript");
  CodeMirror.defineMIME("application/x-javascript", "javascript");
  CodeMirror.defineMIME("application/ecmascript", "javascript");
  CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
  CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
  CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
  CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
  CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
});

/***/ }),

/***/ "qub/":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("jNRJ");
var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

/***/ }),

/***/ "rAgE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var readerFor = __webpack_require__("9Uuy");
var utils = __webpack_require__("dvMn");
var sig = __webpack_require__("Ctqd");
var ZipEntry = __webpack_require__("dFUs");
var utf8 = __webpack_require__("Sm7/");
var support = __webpack_require__("untT");
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function (expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function (askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function () {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function () {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function () {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function () {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function () {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function () {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();

        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function (data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function (data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

/***/ }),

/***/ "rMkZ":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("Wyka");
var gOPN = __webpack_require__("Ni5N").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "rQTS":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "rbVD":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function (cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = { hint: getHints };
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function (options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections();
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++) if (selections[i].head.line != selections[i].anchor.line) return;
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  CodeMirror.defineExtension("closeHint", function () {
    if (this.state.completionActive) this.state.completionActive.close();
  });

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

    var self = this;
    cm.on("cursorActivity", this.activityFunc = function () {
      self.cursorActivity();
    });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function (fn) {
    return setTimeout(fn, 1000 / 60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function () {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function () {
      return this.cm.state.completionActive == this;
    },

    pick: function (data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);else this.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    cursorActivity: function () {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(),
          line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < this.startPos.ch || this.cm.somethingSelected() || !pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function () {
          self.update();
        });
        if (this.widget) this.widget.disable();
      }
    },

    update: function (first) {
      if (this.tick == null) return;
      var self = this,
          myTick = ++this.tick;
      fetchHints(this.options.hint, this.cm, this.options, function (data) {
        if (self.tick == myTick) self.finishUpdate(data, first);
      });
    },

    finishUpdate: function (data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");

      var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
      if (this.widget) this.widget.close();

      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor) if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options) if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos);
    return out;
  }

  function getText(completion) {
    if (typeof completion == "string") return completion;else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function () {
        handle.moveFocus(-1);
      },
      Down: function () {
        handle.moveFocus(1);
      },
      PageUp: function () {
        handle.moveFocus(-handle.menuSize() + 1, true);
      },
      PageDown: function () {
        handle.moveFocus(handle.menuSize() - 1, true);
      },
      Home: function () {
        handle.setFocus(0);
      },
      End: function () {
        handle.setFocus(handle.length - 1);
      },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };

    var mac = /Mac/.test(navigator.platform);

    if (mac) {
      baseMap["Ctrl-P"] = function () {
        handle.moveFocus(-1);
      };
      baseMap["Ctrl-N"] = function () {
        handle.moveFocus(1);
      };
    }

    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string") bound = function (cm) {
        return val(cm, handle);
      };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val)) bound = baseMap[val];else bound = val;
      ourMap[key] = bound;
    }
    if (custom) for (var key in custom) if (custom.hasOwnProperty(key)) addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra) for (var key in extra) if (extra.hasOwnProperty(key)) addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this,
        cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;

    var hints = this.hints = ownerDocument.createElement("ul");
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(ownerDocument.createElement("li")),
          cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var container = completion.options.container || ownerDocument.body;
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left,
        top = pos.bottom,
        below = true;
    var offsetLeft = 0,
        offsetTop = 0;
    if (container !== ownerDocument.body) {
      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.
      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
      var offsetParent = isContainerPositioned ? container : container.offsetParent;
      var offsetParentPosition = offsetParent.getBoundingClientRect();
      var bodyPosition = ownerDocument.body.getBoundingClientRect();
      offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;
      offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;
    }
    hints.style.left = left - offsetLeft + "px";
    hints.style.top = top - offsetTop + "px";

    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    container.appendChild(hints);
    var box = hints.getBoundingClientRect(),
        overlapY = box.bottom - winH;
    var scrolls = hints.scrollHeight > hints.clientHeight + 1;
    var startScroll = cm.getScrollInfo();

    if (overlapY > 0) {
      var height = box.bottom - box.top,
          curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) {
        // Fits above cursor
        hints.style.top = (top = pos.top - height - offsetTop) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = winH - 5 + "px";
        hints.style.top = (top = pos.bottom - box.top - offsetTop) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left - offsetLeft) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + "px";
        overlapX -= box.right - box.left - winW;
      }
      hints.style.left = (left = pos.left - overlapX - offsetLeft) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling) node.style.paddingRight = cm.display.nativeBarWidth + "px";

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function (n, avoidWrap) {
        widget.changeActive(widget.selectedHint + n, avoidWrap);
      },
      setFocus: function (n) {
        widget.changeActive(n);
      },
      menuSize: function () {
        return widget.screenAmount();
      },
      length: completions.length,
      close: function () {
        completion.close();
      },
      pick: function () {
        widget.pick();
      },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function () {
        closingOnBlur = setTimeout(function () {
          completion.close();
        }, 100);
      });
      cm.on("focus", this.onFocus = function () {
        clearTimeout(closingOnBlur);
      });
    }

    cm.on("scroll", this.onScroll = function () {
      var curScroll = cm.getScrollInfo(),
          editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = left + startScroll.left - curScroll.left + "px";
    });

    CodeMirror.on(hints, "dblclick", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);widget.pick();
      }
    });

    CodeMirror.on(hints, "click", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function () {
      setTimeout(function () {
        cm.focus();
      }, 20);
    });

    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }

  Widget.prototype = {
    close: function () {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function () {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = { Enter: function () {
          widget.picked = true;
        } };
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function () {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function (i, avoidWrap) {
      if (i >= this.data.list.length) i = avoidWrap ? this.data.list.length - 1 : 0;else if (i < 0) i = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop) this.hints.scrollTop = node.offsetTop - 3;else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight) this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function () {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers;
    var result = [];
    for (var i = 0; i < helpers.length; i++) if (helpers[i].supportsSelection) result.push(helpers[i]);
    return result;
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options);
    } else {
      var result = hint(cm, options);
      if (result && result.then) result.then(callback);else callback(result);
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"),
        words;
    if (helpers.length) {
      var resolved = function (cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null);
          fetchHints(app[i], cm, options, function (result) {
            if (result && result.list.length > 0) callback(result);else run(i + 1);
          });
        }
        run(0);
      };
      resolved.async = true;
      resolved.supportsSelection = true;
      return resolved;
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function (cm) {
        return CodeMirror.hint.fromList(cm, { words: words });
      };
    } else if (CodeMirror.hint.anyword) {
      return function (cm, options) {
        return CodeMirror.hint.anyword(cm, options);
      };
    } else {
      return function () {};
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });

  CodeMirror.registerHelper("hint", "fromList", function (cm, options) {
    var cur = cm.getCursor(),
        token = cm.getTokenAt(cur);
    var term,
        from = CodeMirror.Pos(cur.line, token.start),
        to = cur;
    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start);
    } else {
      term = "";
      from = cur;
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term) found.push(word);
    }

    if (found.length) return { list: found, from: from, to: to };
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  };

  CodeMirror.defineOption("hintOptions", null);
});

/***/ }),

/***/ "rytr":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

/***/ }),

/***/ "sKXM":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-using-statement
__webpack_require__("KGgk")('dispose');

/***/ }),

/***/ "sSDB":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("kugD");

/***/ }),

/***/ "sa2S":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("d5jv");

module.exports = __webpack_require__("zadB").Object.assign;

/***/ }),

/***/ "sxPs":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("z7R8");
var createDesc = __webpack_require__("0WCH");
var toIObject = __webpack_require__("Wyka");
var toPrimitive = __webpack_require__("EKwp");
var has = __webpack_require__("yS17");
var IE8_DOM_DEFINE = __webpack_require__("R6c1");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__("6MLN") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "tMLt":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("H+g/"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./foldcode"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineOption("foldGutter", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.clearGutter(cm.state.foldGutter.options.gutter);
      cm.state.foldGutter = null;
      cm.off("gutterClick", onGutterClick);
      cm.off("change", onChange);
      cm.off("viewportChange", onViewportChange);
      cm.off("fold", onFold);
      cm.off("unfold", onFold);
      cm.off("swapDoc", onChange);
    }
    if (val) {
      cm.state.foldGutter = new State(parseOptions(val));
      updateInViewport(cm);
      cm.on("gutterClick", onGutterClick);
      cm.on("change", onChange);
      cm.on("viewportChange", onViewportChange);
      cm.on("fold", onFold);
      cm.on("unfold", onFold);
      cm.on("swapDoc", onChange);
    }
  });

  var Pos = CodeMirror.Pos;

  function State(options) {
    this.options = options;
    this.from = this.to = 0;
  }

  function parseOptions(opts) {
    if (opts === true) opts = {};
    if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";
    if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";
    if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";
    return opts;
  }

  function isFolded(cm, line) {
    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
    for (var i = 0; i < marks.length; ++i) {
      if (marks[i].__isFold) {
        var fromPos = marks[i].find(-1);
        if (fromPos && fromPos.line === line) return marks[i];
      }
    }
  }

  function marker(spec) {
    if (typeof spec == "string") {
      var elt = document.createElement("div");
      elt.className = spec + " CodeMirror-guttermarker-subtle";
      return elt;
    } else {
      return spec.cloneNode(true);
    }
  }

  function updateFoldInfo(cm, from, to) {
    var opts = cm.state.foldGutter.options,
        cur = from;
    var minSize = cm.foldOption(opts, "minFoldSize");
    var func = cm.foldOption(opts, "rangeFinder");
    cm.eachLine(from, to, function (line) {
      var mark = null;
      if (isFolded(cm, cur)) {
        mark = marker(opts.indicatorFolded);
      } else {
        var pos = Pos(cur, 0);
        var range = func && func(cm, pos);
        if (range && range.to.line - range.from.line >= minSize) mark = marker(opts.indicatorOpen);
      }
      cm.setGutterMarker(line, opts.gutter, mark);
      ++cur;
    });
  }

  function updateInViewport(cm) {
    var vp = cm.getViewport(),
        state = cm.state.foldGutter;
    if (!state) return;
    cm.operation(function () {
      updateFoldInfo(cm, vp.from, vp.to);
    });
    state.from = vp.from;state.to = vp.to;
  }

  function onGutterClick(cm, line, gutter) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    if (gutter != opts.gutter) return;
    var folded = isFolded(cm, line);
    if (folded) folded.clear();else cm.foldCode(Pos(line, 0), opts);
  }

  function onChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    state.from = state.to = 0;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function () {
      updateInViewport(cm);
    }, opts.foldOnChangeTimeSpan || 600);
  }

  function onViewportChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function () {
      var vp = cm.getViewport();
      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
        updateInViewport(cm);
      } else {
        cm.operation(function () {
          if (vp.from < state.from) {
            updateFoldInfo(cm, vp.from, state.from);
            state.from = vp.from;
          }
          if (vp.to > state.to) {
            updateFoldInfo(cm, state.to, vp.to);
            state.to = vp.to;
          }
        });
      }
    }, opts.updateViewportTimeSpan || 400);
  }

  function onFold(cm, from) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var line = from.line;
    if (line >= state.from && line < state.to) updateFoldInfo(cm, line, line + 1);
  }
});

/***/ }),

/***/ "tQq4":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
   true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.CodeMirror = factory();
})(this, function () {
  'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) {
    presto_version = Number(presto_version[1]);
  }
  if (presto_version && presto_version >= 15) {
    presto = false;webkit = true;
  }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && ie_version >= 9;

  function classTest(cls) {
    return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
  }

  var rmClass = function (node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) {
      e.removeChild(e.firstChild);
    }
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) {
      e.className = className;
    }
    if (style) {
      e.style.cssText = style;
    }
    if (typeof content == "string") {
      e.appendChild(document.createTextNode(content));
    } else if (content) {
      for (var i = 0; i < content.length; ++i) {
        e.appendChild(content[i]);
      }
    }
    return e;
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e;
  }

  var range;
  if (document.createRange) {
    range = function (node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r;
    };
  } else {
    range = function (node, start, end) {
      var r = document.body.createTextRange();
      try {
        r.moveToElementText(node.parentNode);
      } catch (e) {
        return r;
      }
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };
  }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      {
        child = child.parentNode;
      }
    if (parent.contains) {
      return parent.contains(child);
    }
    do {
      if (child.nodeType == 11) {
        child = child.host;
      }
      if (child == parent) {
        return true;
      }
    } while (child = child.parentNode);
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch (e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
      activeElement = activeElement.shadowRoot.activeElement;
    }
    return activeElement;
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) {
      node.className += (current ? " " : "") + cls;
    }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++) {
      if (as[i] && !classTest(as[i]).test(b)) {
        b += " " + as[i];
      }
    }
    return b;
  }

  var selectInput = function (node) {
    node.select();
  };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    {
      selectInput = function (node) {
        node.selectionStart = 0;node.selectionEnd = node.value.length;
      };
    } else if (ie) // Suppress mysterious IE10 errors
    {
      selectInput = function (node) {
        try {
          node.select();
        } catch (_e) {}
      };
    }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }

  function copyObj(obj, target, overwrite) {
    if (!target) {
      target = {};
    }
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
        target[prop] = obj[prop];
      }
    }
    return target;
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) {
        end = string.length;
      }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end) {
        return n + (end - i);
      }
      n += nextTab - i;
      n += tabSize - n % tabSize;
      i = nextTab + 1;
    }
  }

  var Delayed = function () {
    this.id = null;
  };
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i) {
      if (array[i] == elt) {
        return i;
      }
    }
    return -1;
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = { toString: function () {
      return "CodeMirror.Pass";
    } };

  // Reused option objects for setSelection & friends
  var sel_dontScroll = { scroll: false },
      sel_mouse = { origin: "*mouse" },
      sel_move = { origin: "+move" };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) {
        nextTab = string.length;
      }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal) {
        return pos + Math.min(skipped, goal - col);
      }
      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;
      if (col >= goal) {
        return pos;
      }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n) {
      spaceStrs.push(lst(spaceStrs) + " ");
    }
    return spaceStrs[n];
  }

  function lst(arr) {
    return arr[arr.length - 1];
  }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) {
      out[i] = f(array[i], i);
    }
    return out;
  }

  function insertSorted(array, value, score) {
    var pos = 0,
        priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) {
      pos++;
    }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) {
      copyObj(props, inst);
    }
    return inst;
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
    );
  }
  function isWordChar(ch, helper) {
    if (!helper) {
      return isWordCharBasic(ch);
    }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
      return true;
    }
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) {
      if (obj.hasOwnProperty(n) && obj[n]) {
        return false;
      }
    }
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
      pos += dir;
    }
    return pos;
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) {
        return from;
      }
      var midF = (from + to) / 2,
          mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) {
        return pred(mid) ? from : to;
      }
      if (pred(mid)) {
        to = mid;
      } else {
        from = mid + dir;
      }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) {
      return f(from, to, "ltr", 0);
    }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) {
      f(from, to, "ltr");
    }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) {
        return i;
      }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }
    }
    return found != null ? found : bidiOther;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = function () {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) {
        return lowTypes.charAt(code);
      } else if (0x590 <= code && code <= 0x5f4) {
        return "R";
      } else if (0x600 <= code && code <= 0x6f9) {
        return arabicTypes.charAt(code - 0x600);
      } else if (0x6ee <= code && code <= 0x8ac) {
        return "r";
      } else if (0x2000 <= code && code <= 0x200b) {
        return "w";
      } else if (code == 0x200c) {
        return "b";
      } else {
        return "L";
      }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/,
        isStrong = /[LRr]/,
        countsAsLeft = /[Lb1n]/,
        countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from;this.to = to;
    }

    return function (str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
        return false;
      }
      var len = str.length,
          types = [];
      for (var i = 0; i < len; ++i) {
        types.push(charType(str.charCodeAt(i)));
      }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") {
          types[i$1] = prev;
        } else {
          prev = type;
        }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") {
          types[i$2] = "n";
        } else if (isStrong.test(type$1)) {
          cur = type$1;if (type$1 == "r") {
            types[i$2] = "R";
          }
        }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
          types[i$3] = "1";
        } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
          types[i$3] = prev$1;
        }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") {
          types[i$4] = "N";
        } else if (type$3 == "%") {
          var end = void 0;
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
          for (var j = i$4; j < end; ++j) {
            types[j] = replace;
          }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") {
          types[i$5] = "L";
        } else if (isStrong.test(type$4)) {
          cur$1 = type$4;
        }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = void 0;
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? before ? "L" : "R" : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) {
            types[j$1] = replace$1;
          }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [],
          m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7,
              at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) {
                order.splice(at, 0, new BidiSpan(1, pos, j$2));
              }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else {
              ++j$2;
            }
          }
          if (pos < i$7) {
            order.splice(at, 0, new BidiSpan(1, pos, i$7));
          }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order;
    };
  }();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) {
      order = line.order = bidiOrdering(line.text, direction);
    }
    return order;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function (emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers;
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers,
          arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1) {
          map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1));
        }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) {
      handlers[i].apply(null, args);
    }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") {
      e = { type: e, preventDefault: function () {
          this.defaultPrevented = true;
        } };
    }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) {
      return;
    }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) {
      if (indexOf(set, arr[i]) == -1) {
        set.push(arr[i]);
      }
    }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) {
      on(this, type, f);
    };
    ctor.prototype.off = function (type, f) {
      off(this, type, f);
    };
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {
    e_preventDefault(e);e_stopPropagation(e);
  }

  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) {
        b = 1;
      } else if (e.button & 2) {
        b = 3;
      } else if (e.button & 4) {
        b = 2;
      }
    }
    if (mac && e.ctrlKey && b == 1) {
      b = 3;
    }
    return b;
  }

  // Detect drag-and-drop
  var dragAndDrop = function () {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) {
      return false;
    }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0) {
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
    }
    var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) {
      return badBidiRects;
    }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) {
      return false;
    } // Safari returns null in some cases (#2780)
    return badBidiRects = r1.right - r0.right < 3;
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0,
        result = [],
        l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) {
        nl = string.length;
      }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function (string) {
    return string.split(/\r\n?|\n/);
  };

  var hasSelection = window.getSelection ? function (te) {
    try {
      return te.selectionStart != te.selectionEnd;
    } catch (e) {
      return false;
    }
  } : function (te) {
    var range$$1;
    try {
      range$$1 = te.ownerDocument.selection.createRange();
    } catch (e) {}
    if (!range$$1 || range$$1.parentElement() != te) {
      return false;
    }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0;
  };

  var hasCopyEvent = function () {
    var e = elt("div");
    if ("oncopy" in e) {
      return true;
    }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  }();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) {
      return badZoomedRects;
    }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // Known modes, by name and by MIME
  var modes = {},
      mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2) {
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") {
        found = { name: found };
      }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json");
    }
    if (typeof spec == "string") {
      return { name: spec };
    } else {
      return spec || { name: "null" };
    }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) {
      return getMode(options, "text/plain");
    }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) {
          continue;
        }
        if (modeObj.hasOwnProperty(prop)) {
          modeObj["_" + prop] = modeObj[prop];
        }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) {
      modeObj.helperType = spec.helperType;
    }
    if (spec.modeProps) {
      for (var prop$1 in spec.modeProps) {
        modeObj[prop$1] = spec.modeProps[prop$1];
      }
    }

    return modeObj;
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) {
      return state;
    }
    if (mode.copyState) {
      return mode.copyState(state);
    }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) {
        val = val.concat([]);
      }
      nstate[n] = val;
    }
    return nstate;
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) {
        break;
      }
      state = info.state;
      mode = info.mode;
    }
    return info || { mode: mode, state: state };
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function (string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {
    return this.pos >= this.string.length;
  };
  StringStream.prototype.sol = function () {
    return this.pos == this.lineStart;
  };
  StringStream.prototype.peek = function () {
    return this.string.charAt(this.pos) || undefined;
  };
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length) {
      return this.string.charAt(this.pos++);
    }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") {
      ok = ch == match;
    } else {
      ok = ch && (match.test ? match.test(ch) : match(ch));
    }
    if (ok) {
      ++this.pos;return ch;
    }
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)) {}
    return this.pos > start;
  };
  StringStream.prototype.eatSpace = function () {
    var this$1 = this;

    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
      ++this$1.pos;
    }
    return this.pos > start;
  };
  StringStream.prototype.skipToEnd = function () {
    this.pos = this.string.length;
  };
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;return true;
    }
  };
  StringStream.prototype.backUp = function (n) {
    this.pos -= n;
  };
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) {
        return caseInsensitive ? str.toLowerCase() : str;
      };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) {
          this.pos += pattern.length;
        }
        return true;
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) {
        return null;
      }
      if (match && consume !== false) {
        this.pos += match[0].length;
      }
      return match;
    }
  };
  StringStream.prototype.current = function () {
    return this.string.slice(this.start, this.pos);
  };
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try {
      return inner();
    } finally {
      this.lineStart -= n;
    }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n);
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos);
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) {
      throw new Error("There is no line " + (n + doc.first) + " in the document.");
    }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i],
            sz = child.chunkSize();
        if (n < sz) {
          chunk = child;break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [],
        n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) {
        text = text.slice(0, end.ch);
      }
      if (n == start.line) {
        text = text.slice(start.ch);
      }
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    }); // iter aborts when callback returns truthy value
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) {
      for (var n = line; n; n = n.parent) {
        n.height += diff;
      }
    }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) {
      return null;
    }
    var cur = line.parent,
        no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) {
          break;
        }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1],
            ch = child.height;
        if (h < ch) {
          chunk = child;continue outer;
        }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i],
          lh = line.height;
      if (h < lh) {
        break;
      }
      h -= lh;
    }
    return n + i;
  }

  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if (sticky === void 0) sticky = null;

    if (!(this instanceof Pos)) {
      return new Pos(line, ch, sticky);
    }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }

  function equalCursorPos(a, b) {
    return a.sticky == b.sticky && cmp(a, b) == 0;
  }

  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }
  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first) {
      return Pos(doc.first, 0);
    }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) {
      return Pos(last, getLine(doc, last).text.length);
    }
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) {
      return Pos(pos.line, linelen);
    } else if (ch < 0) {
      return Pos(pos.line, 0);
    } else {
      return pos;
    }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) {
      out[i] = clipPos(doc, array[i]);
    }
    return out;
  }

  var SavedContext = function (state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function (doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) {
      this.maxLookAhead = n;
    }
    return line;
  };

  Context.prototype.baseToken = function (n) {
    var this$1 = this;

    if (!this.baseTokens) {
      return null;
    }
    while (this.baseTokens[this.baseTokenPos] <= n) {
      this$1.baseTokenPos += 2;
    }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return { type: type && type.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n };
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) {
      this.maxLookAhead--;
    }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext) {
      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
    } else {
      return new Context(doc, copyState(doc.mode, saved), line);
    }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
  };

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen],
        lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {
      return st.push(end, style);
    }, lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function (o) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o],
          i = 1,
          at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end) {
            st.splice(i, 1, end, st[i + 1], i_end);
          }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) {
          return;
        }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);

    return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) {
        context.state = resetState;
      }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) {
        line.styleClasses = result.classes;
      } else if (line.styleClasses) {
        line.styleClasses = null;
      }
      if (updateFrontier === cm.doc.highlightFrontier) {
        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
      }
    }
    return line.styles;
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc,
        display = cm.display;
    if (!doc.mode.startState) {
      return new Context(doc, true, n);
    }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) {
      doc.modeFrontier = context.line;
    }
    return context;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") {
      callBlankLine(mode, context.state);
    }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) {
      return mode.blankLine(state);
    }
    if (!mode.innerMode) {
      return;
    }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) {
      return inner.mode.blankLine(inner.state);
    }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) {
        inner[0] = innerMode(mode, state).mode;
      }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) {
        return style;
      }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  var Token = function (stream, type, state) {
    this.start = stream.start;this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc,
        mode = doc.mode,
        style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line),
        context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context),
        tokens;
    if (asArray) {
      tokens = [];
    }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) {
        tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
      }
    }
    return asArray ? tokens : new Token(stream, style, context.state);
  }

  function extractLineClasses(type, output) {
    if (type) {
      for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
        if (!lineClass) {
          break;
        }
        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";
        if (output[prop] == null) {
          output[prop] = lineClass[2];
        } else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(output[prop])) {
          output[prop] += " " + lineClass[2];
        }
      }
    }
    return type;
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) {
      flattenSpans = cm.options.flattenSpans;
    }
    var curStart = 0,
        curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context),
        style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") {
      extractLineClasses(callBlankLine(mode, context.state), lineClasses);
    }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) {
          processLine(cm, text, context, stream.pos);
        }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) {
          style = "m-" + (style ? mName + " " + style : mName);
        }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent,
        minline,
        doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) {
        return doc.first;
      }
      var line = getLine(doc, search - 1),
          after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
        return search;
      }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) {
      return;
    }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break;
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false,
      sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker) {
          return span;
        }
      }
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i] != span) {
        (r || (r = [])).push(spans[i]);
      }
    }
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
            marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
            marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
        }
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) {
      return null;
    }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) {
      return null;
    }

    var startCh = change.from.ch,
        endCh = change.to.ch,
        isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1,
        offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) {
            span.to = startCh;
          } else if (sameLine) {
            span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) {
          span$1.to += offset;
        }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        } else {
          span$1.from += offset;
          if (sameLine) {
            (first || (first = [])).push(span$1);
          }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) {
      first = clearEmptySpans(first);
    }
    if (last && last != first) {
      last = clearEmptySpans(last);
    }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2,
          gapMarkers;
      if (gap > 0 && first) {
        for (var i$2 = 0; i$2 < first.length; ++i$2) {
          if (first[i$2].to == null) {
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
          }
        }
      }
      for (var i$3 = 0; i$3 < gap; ++i$3) {
        newMarkers.push(gapMarkers);
      }
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
        spans.splice(i--, 1);
      }
    }
    if (!spans.length) {
      return null;
    }
    return spans;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
            (markers || (markers = [])).push(mark);
          }
        }
      }
    });
    if (!markers) {
      return null;
    }
    var parts = [{ from: from, to: to }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i],
          m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
          continue;
        }
        var newParts = [j, 1],
            dfrom = cmp(p.from, m.from),
            dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
          newParts.push({ from: p.from, to: m.from });
        }
        if (dto > 0 || !mk.inclusiveRight && !dto) {
          newParts.push({ from: m.to, to: p.to });
        }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) {
      return;
    }
    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.detachLine(line);
    }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) {
      return;
    }
    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.attachLine(line);
    }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }
  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) {
      return lenDiff;
    }
    var aPos = a.find(),
        bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) {
      return -fromCmp;
    }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) {
      return toCmp;
    }
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans,
        found;
    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans,
        found;
    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (!sp.marker.collapsed) {
          continue;
        }
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
          continue;
        }
        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
          return true;
        }
      }
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line)) {
      line = merged.find(-1, true).line;
    }
    return line;
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;(lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN),
        vis = visualLine(line);
    if (line == vis) {
      return lineN;
    }
    return lineNo(vis);
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) {
      return lineN;
    }
    var line = getLine(doc, lineN),
        merged;
    if (!lineIsHidden(doc, line)) {
      return lineN;
    }
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed) {
          continue;
        }
        if (sp.from == null) {
          return true;
        }
        if (sp.marker.widgetNode) {
          continue;
        }
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length) {
      return true;
    }
    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
        return true;
      }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0,
        chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) {
        break;
      } else {
        h += line.height;
      }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) {
          break;
        } else {
          h += cur.height;
        }
      }
    }
    return h;
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) {
      return 0;
    }
    var len = line.text.length,
        merged,
        cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display,
        doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function (text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () {
    return lineNo(this);
  };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    if (line.styles) {
      line.styles = null;
    }
    if (line.order != null) {
      line.order = null;
    }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) {
      updateLineHeight(line, estHeight);
    }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {},
      styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) {
      return null;
    }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = { pre: eltP("pre", [content], "CodeMirror-line"), content: content,
      col: 0, pos: 0, cm: cm,
      trailingSpace: false,
      splitSpaces: cm.getOption("lineWrapping") };
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line,
          order = void 0;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass) {
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        }
        if (line.styleClasses.textClass) {
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0) {
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
        builder.content.className = "cm-tab-wrap-hack";
      }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className) {
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    }

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) {
      return;
    }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars,
        mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) {
        mustWrap = true;
      }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt]));
          } else {
            content.appendChild(txt);
          }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) {
          break;
        }
        pos += skipped + 1;
        var txt$1 = void 0;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize,
              tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt$1]));
          } else {
            content.appendChild(txt$1);
          }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) {
        fullStyle += startStyle;
      }
      if (endStyle) {
        fullStyle += endStyle;
      }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) {
          if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
            token.setAttribute(attr, attributes[attr]);
          }
        }
      }
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) {
      return text;
    }
    var spaceBefore = trailingBefore,
        result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
        ch = "\u00a0";
      }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos,
          end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = void 0;
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) {
            break;
          }
        }
        if (part.to >= end) {
          return inner(builder, text, style, startStyle, endStyle, css, attributes);
        }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
    }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) {
        widget = builder.content.appendChild(document.createElement("span"));
      }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans,
        allText = line.text,
        at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
      }
      return;
    }

    var len = allText.length,
        pos = 0,
        i = 1,
        text = "",
        style,
        css;
    var nextChange = 0,
        spanStyle,
        spanEndStyle,
        spanStartStyle,
        collapsed,
        attributes;
    for (;;) {
      if (nextChange == pos) {
        // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null;nextChange = Infinity;
        var foundBookmarks = [],
            endStyles = void 0;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j],
              m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) {
              spanStyle += " " + m.className;
            }
            if (m.css) {
              css = (css ? css + ";" : "") + m.css;
            }
            if (m.startStyle && sp.from == pos) {
              spanStartStyle += " " + m.startStyle;
            }
            if (m.endStyle && sp.to == nextChange) {
              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
            }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) {
              (attributes || (attributes = {})).title = m.title;
            }
            if (m.attributes) {
              for (var attr in m.attributes) {
                (attributes || (attributes = {}))[attr] = m.attributes[attr];
              }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
              collapsed = sp;
            }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) {
          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
            if (endStyles[j$1 + 1] == nextChange) {
              spanEndStyle += " " + endStyles[j$1];
            }
          }
        }

        if (!collapsed || collapsed.from == pos) {
          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
          }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) {
            return;
          }
          if (collapsed.to == pos) {
            collapsed = false;
          }
        }
      }
      if (pos >= len) {
        break;
      }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {
            text = text.slice(upto - pos);pos = upto;break;
          }
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [],
        nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks,
        i = 0;
    do {
      for (; i < callbacks.length; i++) {
        callbacks[i].call(null);
      }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        }
      }
    } while (i < callbacks.length);
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) {
      return;
    }

    try {
      fireCallbacksForOps(group);
    } finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2),
        list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function (i) {
      list.push(function () {
        return arr[i].apply(null, args);
      });
    };

    for (var i = 0; i < arr.length; ++i) loop(i);
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) {
      delayed[i]();
    }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") {
        updateLineText(cm, lineView);
      } else if (type == "gutter") {
        updateLineGutter(cm, lineView, lineN, dims);
      } else if (type == "class") {
        updateLineClasses(cm, lineView);
      } else if (type == "widget") {
        updateLineWidgets(cm, lineView, dims);
      }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode) {
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) {
        lineView.node.style.zIndex = 2;
      }
    }
    return lineView.node;
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) {
      cls += " CodeMirror-linebackground";
    }
    if (lineView.background) {
      if (cls) {
        lineView.background.className = cls;
      } else {
        lineView.background.parentNode.removeChild(lineView.background);lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) {
      lineView.node = built.pre;
    }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass) {
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    } else if (lineView.node != lineView.text) {
      lineView.node.className = "";
    }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass) {
        gutterWrap.className += " " + lineView.line.gutterClass;
      }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
      }
      if (markers) {
        for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
          var id = cm.display.gutterSpecs[k].className,
              found = markers.hasOwnProperty(id) && markers[id];
          if (found) {
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
          }
        }
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) {
      lineView.alignable = null;
    }
    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget") {
        lineView.node.removeChild(node);
      }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) {
      lineView.bgClass = built.bgClass;
    }
    if (built.textClass) {
      lineView.textClass = built.textClass;
    }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++) {
        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
      }
    }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) {
      return;
    }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i],
          node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) {
        node.setAttribute("cm-ignore-events", "true");
      }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above) {
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      } else {
        wrap.appendChild(node);
      }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) {
        node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) {
      return widget.height;
    }
    var cm = widget.doc.cm;
    if (!cm) {
      return 0;
    }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter) {
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      }
      if (widget.noHScroll) {
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
        return true;
      }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingH(display) {
    if (display.cachedPaddingH) {
      return display.cachedPaddingH;
    }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
    if (!isNaN(data.left) && !isNaN(data.right)) {
      display.cachedPaddingH = data;
    }
    return data;
  }

  function scrollGap(cm) {
    return scrollerGap - cm.display.nativeBarWidth;
  }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i],
              next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2) {
            heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) {
      return { map: lineView.measure.map, cache: lineView.measure.cache };
    }
    for (var i = 0; i < lineView.rest.length; i++) {
      if (lineView.rest[i] == line) {
        return { map: lineView.measure.maps[i], cache: lineView.measure.caches[i] };
      }
    }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
      if (lineNo(lineView.rest[i$1]) > lineN) {
        return { map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true };
      }
    }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
      return cm.display.view[findViewIndex(cm, lineN)];
    }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
      return ext;
    }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view) {
      view = updateExternalMeasurement(cm, line);
    }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) {
      ch = -1;
    }
    var key = ch + (bias || ""),
        found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) {
        prepared.rect = prepared.view.text.getBoundingClientRect();
      }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) {
        prepared.cache[key] = found;
      }
    }
    return { left: found.left, right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom };
  }

  var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };

  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0;end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) {
          collapse = "right";
        }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
          collapse = bias;
        }
        if (bias == "left" && start == 0) {
          while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          }
        }
        if (bias == "right" && start == mEnd - mStart) {
          while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          }
        }
        break;
      }
    }
    return { node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd };
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") {
      for (var i = 0; i < rects.length; i++) {
        if ((rect = rects[i]).left != rect.right) {
          break;
        }
      }
    } else {
      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
        if ((rect = rects[i$1]).left != rect.right) {
          break;
        }
      }
    }
    return rect;
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node,
        start = place.start,
        end = place.end,
        collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) {
      // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) {
        // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
          --start;
        }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
          ++end;
        }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else {
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
        }
        if (rect.left || rect.right || start == 0) {
          break;
        }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) {
        rect = maybeUpdateRectForZooming(cm.display.measure, rect);
      }
    } else {
      // If it is a widget, simply get the box for the whole widget.
      if (start > 0) {
        collapse = bias = "right";
      }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      } else {
        rect = node.getBoundingClientRect();
      }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan) {
        rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
      } else {
        rect = nullRect;
      }
    }

    var rtop = rect.top - prepared.rect.top,
        rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++) {
      if (mid < heights[i]) {
        break;
      }
    }
    var top = i ? heights[i - 1] : 0,
        bot = heights[i];
    var result = { left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top: top, bottom: bot };
    if (!rect.left && !rect.right) {
      result.bogus = true;
    }
    if (!cm.options.singleCursorHeightPerLine) {
      result.rtop = rtop;result.rbottom = rbot;
    }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
      return rect;
    }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return { left: rect.left * scaleX, right: rect.right * scaleX,
      top: rect.top * scaleY, bottom: rect.bottom * scaleY };
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) {
        for (var i = 0; i < lineView.rest.length; i++) {
          lineView.measure.caches[i] = {};
        }
      }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++) {
      clearLineMeasurementCacheFor(cm.display.view[i]);
    }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) {
      cm.display.maxLineChanged = true;
    }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
    }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
  }
  function pageScrollY() {
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
    }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop;
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) {
      for (var i = 0; i < lineObj.widgets.length; ++i) {
        if (lineObj.widgets[i].above) {
          height += widgetHeight(lineObj.widgets[i]);
        }
      }
    }
    return height;
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height;rect.bottom += height;
    }
    if (context == "line") {
      return rect;
    }
    if (!context) {
      context = "local";
    }
    var yOff = heightAtLine(lineObj);
    if (context == "local") {
      yOff += paddingTop(cm.display);
    } else {
      yOff -= cm.display.viewOffset;
    }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff;rect.right += xOff;
    }
    rect.top += yOff;rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") {
      return coords;
    }
    var left = coords.left,
        top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) {
      lineObj = getLine(cm.doc, pos.line);
    }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) {
        m.left = m.right;
      } else {
        m.right = m.left;
      }
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj, cm.doc.direction),
        ch = pos.ch,
        sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) {
      return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
    }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos],
          right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert);
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) {
      val.other = getBidi(ch, other, sticky != "before");
    }
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) {
      left = charWidth(cm.display) * pos.ch;
    }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return { left: left, right: left, top: top, bottom: top + lineObj.height };
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) {
      pos.outside = outside;
    }
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) {
      return PosWithInfo(doc.first, 0, null, -1, -1);
    }
    var lineN = lineAtHeight(doc, y),
        last = doc.first + doc.size - 1;
    if (lineN > last) {
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
    }
    if (x < 0) {
      x = 0;
    }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) {
        return found;
      }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) {
        return rangeEnd;
      }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
    }, end, 0);
    end = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch).top > y;
    }, begin, end);
    return { begin: begin, end: end };
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
  }

  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0,
        end = lineObj.text.length,
        ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null,
        boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1;box.bottom += widgetHeight$$1;
      if (!boxIsAfter(box, x, y, false)) {
        return false;
      }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true;
    }, begin, end);

    var baseX,
        sticky,
        outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x,
          atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) {
        ch++;
      }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX);
  }

  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i],
          ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y) {
        part = order[index - 1];
      }
    }
    return part;
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) {
      end--;
    }
    var part = null,
        closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) {
        continue;
      }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) {
      part = order[order.length - 1];
    }
    // Clip the part to the wrapped line.
    if (part.from < begin) {
      part = { from: begin, to: part.to, level: part.level };
    }
    if (part.to > end) {
      part = { from: part.from, to: end, level: part.level };
    }
    return part;
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) {
      return display.cachedTextHeight;
    }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) {
      display.cachedTextHeight = height;
    }
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) {
      return display.cachedCharWidth;
    }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(),
        width = (rect.right - rect.left) / 10;
    if (width > 2) {
      display.cachedCharWidth = width;
    }
    return width || 10;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display,
        left = {},
        width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return { fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth };
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display),
        wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) {
        return 0;
      }

      var widgetsHeight = 0;
      if (line.widgets) {
        for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) {
            widgetsHeight += line.widgets[i].height;
          }
        }
      }

      if (wrapping) {
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      } else {
        return widgetsHeight + th;
      }
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc,
        est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
      return null;
    }

    var x,
        y,
        space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try {
      x = e.clientX - space.left;y = e.clientY - space.top;
    } catch (e) {
      return null;
    }
    var coords = coordsChar(cm, x, y),
        line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) {
      return null;
    }
    n -= cm.display.viewFrom;
    if (n < 0) {
      return null;
    }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) {
        return i;
      }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) {
      from = cm.doc.first;
    }
    if (to == null) {
      to = cm.doc.first + cm.doc.size;
    }
    if (!lendiff) {
      lendiff = 0;
    }

    var display = cm.display;
    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
      display.updateLineNumbers = from;
    }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) {
      // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
        resetView(cm);
      }
    } else if (to <= display.viewFrom) {
      // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) {
      // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else {
      // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN) {
        ext.lineN += lendiff;
      } else if (from < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display,
        ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
      display.externalMeasured = null;
    }

    if (line < display.viewFrom || line >= display.viewTo) {
      return;
    }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) {
      return;
    }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) {
      arr.push(type);
    }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN),
        diff,
        view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
      return { index: index, lineN: newN };
    }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++) {
      n += view[i].size;
    }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) {
          return null;
        }
        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff;newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) {
        return null;
      }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return { index: index, lineN: newN };
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display,
        view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) {
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      } else if (display.viewFrom < from) {
        display.view = display.view.slice(findViewIndex(cm, from));
      }
      display.viewFrom = from;
      if (display.viewTo < to) {
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      } else if (display.viewTo > to) {
        display.view = display.view.slice(0, findViewIndex(cm, to));
      }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view,
        dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) {
        ++dirty;
      }
    }
    return dirty;
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if (primary === void 0) primary = true;

    var doc = cm.doc,
        result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) {
        continue;
      }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) {
        continue;
      }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range$$1.head, curFragment);
      }
      if (!collapsed) {
        drawSelectionRange(cm, range$$1, selFragment);
      }
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) {
    return a.top - b.top || a.left - b.left;
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display,
        doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display),
        leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) {
        top = 0;
      }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = dir == "ltr" == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop];
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0,
            openEnd = toArg == null && to == lineLen;
        var first = i == 0,
            last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) {
          // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else {
          // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) {
            add(leftSide, fromPos.bottom, null, toPos.top);
          }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) {
          start = fromPos;
        }
        if (cmpCoords(toPos, start) < 0) {
          start = toPos;
        }
        if (!end || cmpCoords(fromPos, end) < 0) {
          end = fromPos;
        }
        if (cmpCoords(toPos, end) < 0) {
          end = toPos;
        }
      });
      return { start: start, end: end };
    }

    var sFrom = range$$1.from(),
        sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line),
          toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top) {
        add(leftSide, leftEnd.bottom, null, rightStart.top);
      }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) {
      return;
    }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function () {
        return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    } else if (cm.options.cursorBlinkRate < 0) {
      display.cursorDiv.style.visibility = "hidden";
    }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) {
      cm.display.input.focus();onFocus(cm);
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
    }

    if (cm.options.readOnly == "nocursor") {
      return;
    }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) {
          setTimeout(function () {
            return cm.display.input.reset(true);
          }, 20);
        } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) {
      return;
    }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused) {
        cm.display.shift = false;
      }
    }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i],
          wrapping = cm.options.lineWrapping;
      var height = void 0,
          width = 0;
      if (cur.hidden) {
        continue;
      }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild) {
          width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
        }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) {
            updateWidgetHeight(cur.rest[j]);
          }
        }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i = 0; i < line.widgets.length; ++i) {
        var w = line.widgets[i],
            parent = w.node.parentNode;
        if (parent) {
          w.height = parent.offsetHeight;
        }
      }
    }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top),
        to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line,
          ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return { from: from, to: Math.max(to, from + 1) };
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) {
      return;
    }

    var display = cm.display,
        box = display.sizer.getBoundingClientRect(),
        doScroll = null;
    if (rect.top + box.top < 0) {
      doScroll = true;
    } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
      doScroll = false;
    }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) {
      margin = 0;
    }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = { left: Math.min(coords.left, endCoords.left),
        top: Math.min(coords.top, endCoords.top) - margin,
        right: Math.max(coords.left, endCoords.left),
        bottom: Math.max(coords.bottom, endCoords.bottom) + margin };
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop,
          startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
          changed = true;
        }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
    return rect;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
    }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display,
        snapMargin = textHeight(cm.display);
    if (rect.top < 0) {
      rect.top = 0;
    }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm),
        result = {};
    if (rect.bottom - rect.top > screen) {
      rect.bottom = rect.top + screen;
    }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin,
        atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) {
        result.scrollTop = newTop;
      }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) {
      rect.right = rect.left + screenw;
    }
    if (rect.left < 10) {
      result.scrollLeft = 0;
    } else if (rect.left < screenleft) {
      result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));
    } else if (rect.right > screenw + screenleft - 3) {
      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
    }
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) {
      return;
    }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) {
      resolveScrollToPos(cm);
    }
    if (x != null) {
      cm.curOp.scrollLeft = x;
    }
    if (y != null) {
      cm.curOp.scrollTop = y;
    }
  }

  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from),
          to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) {
      return;
    }
    if (!gecko) {
      updateDisplaySimple(cm, { top: val });
    }
    setScrollTop(cm, val, true);
    if (gecko) {
      updateDisplaySimple(cm);
    }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
    if (cm.display.scroller.scrollTop == val && !forceScroll) {
      return;
    }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) {
      cm.display.scroller.scrollTop = val;
    }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
      return;
    }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) {
      cm.display.scroller.scrollLeft = val;
    }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display,
        gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  var NativeScrollbars = function (place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert);place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) {
        scroll(vert.scrollTop, "vertical");
      }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) {
        scroll(horiz.scrollLeft, "horizontal");
      }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) {
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
    }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) {
        this.zeroWidthHack();
      }
      this.checkedZeroWidth = true;
    }

    return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) {
      this.horiz.scrollLeft = pos;
    }
    if (this.disableHoriz) {
      this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) {
      this.vert.scrollTop = pos;
    }
    if (this.disableVert) {
      this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed();
    this.disableVert = new Delayed();
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt$$1 != bar) {
        bar.style.pointerEvents = "none";
      } else {
        delay.set(1000, maybeDisable);
      }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () {
    return { bottom: 0, right: 0 };
  };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) {
      measure = measureForScrollbars(cm);
    }
    var startWidth = cm.display.barWidth,
        startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
        updateHeightsInViewport(cm);
      }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth;startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else {
      d.scrollbarFiller.style.display = "";
    }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else {
      d.gutterFiller.style.display = "";
    }
  }

  var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass) {
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) {
          setTimeout(function () {
            return cm.display.input.focus();
          }, 0);
        }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") {
        setScrollLeft(cm, pos);
      } else {
        updateScrollTop(cm, pos);
      }
    }, cm);
    if (cm.display.scrollbars.addClass) {
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false, // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false, // Used to force a redraw
      updateInput: 0, // Whether to reset the input textarea
      typing: false, // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null, // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false, // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null, // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) {
      finishOperation(op, function (group) {
        for (var i = 0; i < group.ops.length; i++) {
          group.ops[i].cm.curOp = null;
        }
        endOperations(group);
      });
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
    {
      endOperation_R1(ops[i]);
    }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
    {
      endOperation_W1(ops[i$1]);
    }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
    {
      endOperation_R2(ops[i$2]);
    }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
    {
      endOperation_W2(ops[i$3]);
    }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
    {
      endOperation_finish(ops[i$4]);
    }
  }

  function endOperation_R1(op) {
    var cm = op.cm,
        display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) {
      findMaxLine(cm);
    }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm,
        display = cm.display;
    if (op.updatedDisplay) {
      updateHeightsInViewport(cm);
    }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged) {
      op.preparedSelection = display.input.prepareSelection();
    }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft) {
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection) {
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    }
    if (op.updatedDisplay || op.startHeight != cm.doc.height) {
      updateScrollbars(cm, op.barMeasure);
    }
    if (op.updatedDisplay) {
      setDocumentHeight(cm, op.barMeasure);
    }

    if (op.selectionChanged) {
      restartBlink(cm);
    }

    if (cm.state.focused && op.updateInput) {
      cm.display.input.reset(op.typing);
    }
    if (takeFocus) {
      ensureFocus(op.cm);
    }
  }

  function endOperation_finish(op) {
    var cm = op.cm,
        display = cm.display,
        doc = cm.doc;

    if (op.updatedDisplay) {
      postUpdateDisplay(cm, op.update);
    }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
      display.wheelStartX = display.wheelStartY = null;
    }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) {
      setScrollTop(cm, op.scrollTop, op.forceScroll);
    }

    if (op.scrollLeft != null) {
      setScrollLeft(cm, op.scrollLeft, true, true);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers,
        unhidden = op.maybeUnhiddenMarkers;
    if (hidden) {
      for (var i = 0; i < hidden.length; ++i) {
        if (!hidden[i].lines.length) {
          signal(hidden[i], "hide");
        }
      }
    }
    if (unhidden) {
      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
        if (unhidden[i$1].lines.length) {
          signal(unhidden[i$1], "unhide");
        }
      }
    }

    if (display.wrapper.offsetHeight) {
      doc.scrollTop = cm.display.scroller.scrollTop;
    }

    // Fire change events, and delayed event handlers
    if (op.changeObjs) {
      signal(cm, "changes", cm, op.changeObjs);
    }
    if (op.update) {
      op.update.finish();
    }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) {
      return f();
    }
    startOperation(cm);
    try {
      return f();
    } finally {
      endOperation(cm);
    }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function () {
      if (cm.curOp) {
        return f.apply(cm, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(cm, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function () {
      if (this.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(this);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(this);
      }
    };
  }
  function docMethodOp(f) {
    return function () {
      var cm = this.cm;
      if (!cm || cm.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo) {
      cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) {
      return;
    }
    var end = +new Date() + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) {
        // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) {
          context.state = resetState;
        }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses,
            newCls = highlighted.classes;
        if (newCls) {
          line.styleClasses = newCls;
        } else if (oldCls) {
          line.styleClasses = null;
        }
        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) {
          ischange = oldStyles[i] != line.styles[i];
        }
        if (ischange) {
          changedLines.push(context.line);
        }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) {
          processLine(cm, line.text, context);
        }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) {
      runInOp(cm, function () {
        for (var i = 0; i < changedLines.length; i++) {
          regLineChange(cm, changedLines[i], "text");
        }
      });
    }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function (cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type)) {
      this.events.push(arguments);
    }
  };
  DisplayUpdate.prototype.finish = function () {
    var this$1 = this;

    for (var i = 0; i < this.events.length; i++) {
      signal.apply(null, this$1.events[i]);
    }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) {
      return null;
    }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) {
      return null;
    }
    var result = { activeElt: active };
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result;
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
      return;
    }
    snapshot.activeElt.focus();
    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(),
          range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display,
        doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
      return false;
    }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) {
      from = Math.max(doc.first, display.viewFrom);
    }
    if (display.viewTo > to && display.viewTo - to < 20) {
      to = Math.min(end, display.viewTo);
    }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
      return false;
    }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "none";
    }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "";
    }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null) {
          viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
        }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
          break;
        }
      }
      if (!updateDisplayIfNeeded(cm, update)) {
        break;
      }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom;cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display,
        lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv,
        cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }

    var view = display.view,
        lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ;else if (!lineView.node || lineView.node.parentNode != container) {
        // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        // Already drawn
        while (cur != lineView.node) {
          cur = rm(cur);
        }
        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) {
            updateNumber = false;
          }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) {
      cur = rm(cur);
    }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display,
        view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
      return;
    }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth,
        left = comp + "px";
    for (var i = 0; i < view.length; i++) {
      if (!view[i].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i].gutter) {
            view[i].gutter.style.left = left;
          }
          if (view[i].gutterBackground) {
            view[i].gutterBackground.style.left = left;
          }
        }
        var align = view[i].alignable;
        if (align) {
          for (var j = 0; j < align.length; j++) {
            align[j].style.left = left;
          }
        }
      }
    }
    if (cm.options.fixedGutter) {
      display.gutters.style.left = comp + gutterW + "px";
    }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) {
      return false;
    }
    var doc = cm.doc,
        last = lineNumberFor(cm.options, doc.first + doc.size - 1),
        display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth,
          padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true;
    }
    return false;
  }

  function getGutters(gutters, lineNumbers) {
    var result = [],
        sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i],
          style = null;
      if (typeof name != "string") {
        style = name.style;name = name.className;
      }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) {
          continue;
        } else {
          sawLineNumbers = true;
        }
      }
      result.push({ className: name, style: style });
    }
    if (lineNumbers && !sawLineNumbers) {
      result.push({ className: "CodeMirror-linenumbers", style: null });
    }
    return result;
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters,
        specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) {
        gElt.style.cssText = style;
      }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) {
      d.gutters.style.zIndex = -1;d.scroller.style.paddingRight = 0;
    }
    if (!webkit && !(gecko && mobile)) {
      d.scroller.draggable = true;
    }

    if (place) {
      if (place.appendChild) {
        place.appendChild(d.wrapper);
      } else {
        place(d.wrapper);
      }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0,
      wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) {
    wheelPixelsPerUnit = -.53;
  } else if (gecko) {
    wheelPixelsPerUnit = 15;
  } else if (chrome) {
    wheelPixelsPerUnit = -.7;
  } else if (safari) {
    wheelPixelsPerUnit = -1 / 3;
  }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX,
        dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
      dx = e.detail;
    }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
      dy = e.detail;
    } else if (dy == null) {
      dy = e.wheelDelta;
    }
    return { x: dx, y: dy };
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e),
        dx = delta.x,
        dy = delta.y;

    var display = cm.display,
        scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) {
      return;
    }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY) {
        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
      }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || dy && canScrollY) {
        e_preventDefault(e);
      }
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop,
          bot = top + display.wrapper.clientHeight;
      if (pixels < 0) {
        top = Math.max(0, top + pixels - 50);
      } else {
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      }
      updateDisplaySimple(cm, { top: top, bottom: bot });
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) {
            return;
          }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) {
            return;
          }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function (ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () {
    return this.ranges[this.primIndex];
  };

  Selection.prototype.equals = function (other) {
    var this$1 = this;

    if (other == this) {
      return true;
    }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
      return false;
    }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i],
          there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
        return false;
      }
    }
    return true;
  };

  Selection.prototype.deepCopy = function () {
    var this$1 = this;

    var out = [];
    for (var i = 0; i < this.ranges.length; i++) {
      out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
    }
    return new Selection(out, this.primIndex);
  };

  Selection.prototype.somethingSelected = function () {
    var this$1 = this;

    for (var i = 0; i < this.ranges.length; i++) {
      if (!this$1.ranges[i].empty()) {
        return true;
      }
    }
    return false;
  };

  Selection.prototype.contains = function (pos, end) {
    var this$1 = this;

    if (!end) {
      end = pos;
    }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
        return i;
      }
    }
    return -1;
  };

  var Range = function (anchor, head) {
    this.anchor = anchor;this.head = head;
  };

  Range.prototype.from = function () {
    return minPos(this.anchor, this.head);
  };
  Range.prototype.to = function () {
    return maxPos(this.anchor, this.head);
  };
  Range.prototype.empty = function () {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i],
          prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()),
            to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) {
          --primIndex;
        }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) {
      return change.to;
    }
    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) {
      return pos;
    }
    if (cmp(pos, change.to) <= 0) {
      return changeEnd(change);
    }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
        ch = pos.ch;
    if (pos.line == change.to.line) {
      ch += changeEnd(change).ch - change.to.ch;
    }
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) {
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    } else {
      return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0),
        newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i],
            inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) {
      regChange(cm);
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i) {
        result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
      }
      return result;
    }

    var from = change.from,
        to = change.to,
        text = change.text;
    var firstLine = getLine(doc, from.line),
        lastLine = getLine(doc, to.line);
    var lastText = lst(text),
        lastSpans = spansFor(text.length - 1),
        nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) {
        doc.remove(from.line, nlines);
      }
      if (added.length) {
        doc.insert(from.line, added);
      }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) {
        doc.remove(from.line + 1, nlines - 1);
      }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) {
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip) {
            continue;
          }
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) {
            continue;
          }
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) {
      throw new Error("This document is already in use.");
    }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) {
      findMaxLine(cm);
    }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = [];this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) {
        array.pop();
      } else {
        break;
      }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(),
        cur;
    var last;

    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges) {
        pushSelectionToHistory(doc.sel, hist.done);
      }
      cur = { changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) {
          hist.done.shift();
        }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) {
      signal(doc, "historyAdded");
    }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history,
        origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
      hist.done[hist.done.length - 1] = sel;
    } else {
      pushSelectionToHistory(sel, hist.done);
    }

    hist.lastSelTime = +new Date();
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false) {
      clearSelectionEvents(hist.undone);
    }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel))) {
      dest.push(sel);
    }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id],
        n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans) {
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) {
      return null;
    }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out) {
          out = spans.slice(0, i);
        }
      } else if (out) {
        out.push(spans[i]);
      }
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) {
      return null;
    }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i) {
      nw.push(removeClearedSpans(found[i]));
    }
    return nw;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) {
      return stretched;
    }
    if (!stretched) {
      return old;
    }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i],
          stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k) {
            if (oldCur[k].marker == span.marker) {
              continue spans;
            }
          }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes,
          newChanges = [];
      copy.push({ changes: newChanges });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j],
            m = void 0;
        newChanges.push({ from: change.from, to: change.to, text: change.text });
        if (newGroup) {
          for (var prop in change) {
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
      }
    }
    return copy;
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) {
      extend = doc.cm && (doc.cm.display.shift || doc.extend);
    }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
    }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function (ranges) {
        var this$1 = this;

        this.ranges = [];
        for (var i = 0; i < ranges.length; i++) {
          this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
        }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) {
      signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    }
    if (obj.ranges != sel.ranges) {
      return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
    } else {
      return sel;
    }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done,
        last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      sel = filterSelectionChange(doc, sel, options);
    }

    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm) {
      ensureCursorVisible(doc.cm);
    }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) {
      return;
    }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) {
          out = sel.ranges.slice(0, i);
        }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) {
      for (var i = 0; i < line.markedSpans.length; ++i) {
        var sp = line.markedSpans[i],
            m = sp.marker;

        // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
        // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
        // is with selectLeft/Right
        var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
        var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;

        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");
            if (m.explicitlyCleared) {
              if (!line.markedSpans) {
                break;
              } else {
                --i;continue;
              }
            }
          }
          if (!m.atomic) {
            continue;
          }

          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1),
                diff = void 0;
            if (dir < 0 ? preventCursorRight : preventCursorLeft) {
              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
            }
            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
              return skipAtomicInner(doc, near, pos, dir, mayClear);
            }
          }

          var far = m.find(dir < 0 ? -1 : 1);
          if (dir < 0 ? preventCursorLeft : preventCursorRight) {
            far = movePos(doc, far, dir, far.line == pos.line ? line : null);
          }
          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
        }
      }
    }
    return pos;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }
    return found;
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) {
        return clipPos(doc, Pos(pos.line - 1));
      } else {
        return null;
      }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) {
        return Pos(pos.line + 1, 0);
      } else {
        return null;
      }
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () {
        return obj.canceled = true;
      }
    };
    if (update) {
      obj.update = function (from, to, text, origin) {
        if (from) {
          obj.from = clipPos(doc, from);
        }
        if (to) {
          obj.to = clipPos(doc, to);
        }
        if (text) {
          obj.text = text;
        }
        if (origin !== undefined) {
          obj.origin = origin;
        }
      };
    }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) {
      signal(doc.cm, "beforeChange", doc.cm, obj);
    }

    if (obj.canceled) {
      if (doc.cm) {
        doc.cm.curOp.updateInput = 2;
      }
      return null;
    }
    return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) {
        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      }
      if (doc.cm.state.suppressEdits) {
        return;
      }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) {
        return;
      }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i) {
        makeChangeInner(doc, { from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin });
      }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
      return;
    }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) {
      return;
    }

    var hist = doc.history,
        event,
        selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone,
        dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
        break;
      }
    }
    if (i == source.length) {
      return;
    }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, { clearRedo: false });
          return;
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return;
      } else {
        break;
      }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({ changes: antiChanges, generation: hist.generation });
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function (i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {};
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) {
        doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
      }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop(i$1);

      if (returned) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) {
      return;
    }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
        regLineChange(doc.cm, l, "gutter");
      }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) {
      return;
    }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = { from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)], origin: change.origin };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = { from: change.from, to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]], origin: change.origin };
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) {
      selAfter = computeSelAfterChange(doc, change);
    }
    if (doc.cm) {
      makeChangeSingleDocInEditor(doc.cm, change, spans);
    } else {
      updateDoc(doc, change, spans);
    }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
      doc.cantEdit = false;
    }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc,
        display = cm.display,
        from = change.from,
        to = change.to;

    var recomputeMaxLength = false,
        checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1) {
      signalCursorActivity(cm);
    }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) {
        cm.curOp.updateMaxLine = true;
      }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full) {
      regChange(cm);
    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
      regLineChange(cm, from.line, "text");
    } else {
      regChange(cm, from.line, to.line + 1, lendiff);
    }

    var changesHandler = hasHandler(cm, "changes"),
        changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) {
        signalLater(cm, "change", cm, obj);
      }
      if (changesHandler) {
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) {
      to = from;
    }
    if (cmp(to, from) < 0) {
      assign = [to, from], from = assign[0], to = assign[1];
    }
    if (typeof code == "string") {
      code = doc.splitLines(code);
    }
    makeChange(doc, { from: from, to: to, text: code, origin: origin });
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i],
          ok = true;
      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i] = sub.deepCopy();sub.copied = true;
        }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line,
        to = change.to.line,
        diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle,
        line = handle;
    if (typeof handle == "number") {
      line = getLine(doc, clipLine(doc, handle));
    } else {
      no = lineNo(handle);
    }
    if (no == null) {
      return null;
    }
    if (op(line, no) && doc.cm) {
      regLineChange(doc.cm, no, changeType);
    }
    return line;
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;

    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function () {
      return this.lines.length;
    },

    // Remove the n lines at offset 'at'.
    removeInner: function (at, n) {
      var this$1 = this;

      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function (lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function (at, lines, height) {
      var this$1 = this;

      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) {
        lines[i].parent = this$1;
      }
    },

    // Used to iterate over a part of the tree.
    iterN: function (at, n, op) {
      var this$1 = this;

      for (var e = at + n; at < e; ++at) {
        if (op(this$1.lines[at])) {
          return true;
        }
      }
    }
  };

  function BranchChunk(children) {
    var this$1 = this;

    this.children = children;
    var size = 0,
        height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize();height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function () {
      return this.size;
    },

    removeInner: function (at, n) {
      var this$1 = this;

      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at),
              oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) {
            this$1.children.splice(i--, 1);child.parent = null;
          }
          if ((n -= rm) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function (lines) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        this$1.children[i].collapse(lines);
      }
    },

    insertInner: function (at, lines, height) {
      var this$1 = this;

      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function () {
      if (this.children.length <= 10) {
        return;
      }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },

    iterN: function (at, n, op) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) {
            return true;
          }
          if ((n -= used) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function (doc, node, options) {
    var this$1 = this;

    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          this$1[opt] = options[opt];
        }
      }
    }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var this$1 = this;

    var cm = this.doc.cm,
        ws = this.line.widgets,
        line = this.line,
        no = lineNo(line);
    if (no == null || !ws) {
      return;
    }
    for (var i = 0; i < ws.length; ++i) {
      if (ws[i] == this$1) {
        ws.splice(i--, 1);
      }
    }
    if (!ws.length) {
      line.widgets = null;
    }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
    var this$1 = this;

    var oldH = this.height,
        cm = this.doc.cm,
        line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) {
      return;
    }
    if (!lineIsHidden(this.doc, line)) {
      updateLineHeight(line, line.height + diff);
    }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
      addToScrollTop(cm, diff);
    }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) {
      cm.display.alignWidgets = true;
    }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) {
        widgets.push(widget);
      } else {
        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) {
          addToScrollTop(cm, widget.height);
        }
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    if (cm) {
      signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
    }
    return widget;
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function (doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    var this$1 = this;

    if (this.explicitlyCleared) {
      return;
    }
    var cm = this.doc.cm,
        withOp = cm && !cm.curOp;
    if (withOp) {
      startOperation(cm);
    }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) {
        signalLater(this, "clear", found.from, found.to);
      }
    }
    var min = null,
        max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) {
        regLineChange(cm, lineNo(line), "text");
      } else if (cm) {
        if (span.to != null) {
          max = lineNo(line);
        }
        if (span.from != null) {
          min = lineNo(line);
        }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm) {
        updateLineHeight(line, textHeight(cm.display));
      }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
        var visual = visualLine(this$1.lines[i$1]),
            len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }

    if (min != null && cm && this.collapsed) {
      regChange(cm, min, max + 1);
    }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) {
        reCheckSelection(cm.doc);
      }
    }
    if (cm) {
      signalLater(cm, "markerCleared", cm, this, min, max);
    }
    if (withOp) {
      endOperation(cm);
    }
    if (this.parent) {
      this.parent.clear();
    }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    var this$1 = this;

    if (side == null && this.type == "bookmark") {
      side = 1;
    }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) {
          return from;
        }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) {
          return to;
        }
      }
    }
    return from && { from: from, to: to };
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
    var this$1 = this;

    var pos = this.find(-1, true),
        widget = this,
        cm = this.doc.cm;
    if (!pos || !cm) {
      return;
    }
    runInOp(cm, function () {
      var line = pos.line,
          lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight) {
          updateLineHeight(line, line.height + dHeight);
        }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) {
      return markTextShared(doc, from, to, options, type);
    }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, markText)(doc, from, to, options, type);
    }

    var marker = new TextMarker(doc, type),
        diff = cmp(from, to);
    if (options) {
      copyObj(options, marker, false);
    }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
      return marker;
    }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) {
        marker.widgetNode.setAttribute("cm-ignore-events", "true");
      }
      if (options.insertLeft) {
        marker.widgetNode.insertLeft = true;
      }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      }
      seeCollapsedSpans();
    }

    if (marker.addToHistory) {
      addChangeToHistory(doc, { from: from, to: to, origin: "markText" }, doc.sel, NaN);
    }

    var curLine = from.line,
        cm = doc.cm,
        updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
        updateMaxLine = true;
      }
      if (marker.collapsed && curLine != from.line) {
        updateLineHeight(line, 0);
      }
      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) {
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line)) {
          updateLineHeight(line, 0);
        }
      });
    }

    if (marker.clearOnEnter) {
      on(marker, "beforeCursorEnter", function () {
        return marker.clear();
      });
    }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length) {
        doc.clearHistory();
      }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) {
        cm.curOp.updateMaxLine = true;
      }
      if (marker.collapsed) {
        regChange(cm, from.line, to.line + 1);
      } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
        for (var i = from.line; i <= to.line; i++) {
          regLineChange(cm, i, "text");
        }
      }
      if (marker.atomic) {
        reCheckSelection(cm.doc);
      }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function (markers, primary) {
    var this$1 = this;

    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i) {
      markers[i].parent = this$1;
    }
  };

  SharedTextMarker.prototype.clear = function () {
    var this$1 = this;

    if (this.explicitlyCleared) {
      return;
    }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i) {
      this$1.markers[i].clear();
    }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj);
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)],
        primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) {
        options.widgetNode = widget.cloneNode(true);
      }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i) {
        if (doc.linked[i].isParent) {
          return;
        }
      }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
      return m.parent;
    });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i],
          pos = marker.find();
      var mFrom = doc.clipPos(pos.from),
          mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function (i) {
      var marker = markers[i],
          linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) {
        return linked.push(d);
      });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop(i);
  }

  var nextDocId = 0;
  var Doc = function (text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) {
      return new Doc(text, mode, firstLine, lineSep, direction);
    }
    if (firstLine == null) {
      firstLine = 0;
    }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = direction == "rtl" ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") {
      text = this.splitLines(text);
    }
    updateDoc(this, { from: start, to: start, text: text });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function (from, to, op) {
      if (op) {
        this.iterN(from - this.first, to - from, op);
      } else {
        this.iterN(this.first, this.first + this.size, from);
      }
    },

    // Non-public interface for adding and removing lines.
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) {
        height += lines[i].height;
      }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function (code) {
      var top = Pos(this.first, 0),
          last = this.first + this.size - 1;
      makeChange(this, { from: top, to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code), origin: "setValue", full: true }, true);
      if (this.cm) {
        scrollToCoords(this.cm, 0, 0);
      }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },

    getLine: function (line) {
      var l = this.getLineHandle(line);return l && l.text;
    },

    getLineHandle: function (line) {
      if (isLine(this, line)) {
        return getLine(this, line);
      }
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },

    getLineHandleVisualStart: function (line) {
      if (typeof line == "number") {
        line = getLine(this, line);
      }
      return visualLine(line);
    },

    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },

    clipPos: function (pos) {
      return clipPos(this, pos);
    },

    getCursor: function (start) {
      var range$$1 = this.sel.primary(),
          pos;
      if (start == null || start == "head") {
        pos = range$$1.head;
      } else if (start == "anchor") {
        pos = range$$1.anchor;
      } else if (start == "end" || start == "to" || start === false) {
        pos = range$$1.to();
      } else {
        pos = range$$1.from();
      }
      return pos;
    },
    listSelections: function () {
      return this.sel.ranges;
    },
    somethingSelected: function () {
      return this.sel.somethingSelected();
    },

    setCursor: docMethodOp(function (line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function (anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function (head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function (heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function (f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function (ranges, primary, options) {
      var this$1 = this;

      if (!ranges.length) {
        return;
      }
      var out = [];
      for (var i = 0; i < ranges.length; i++) {
        out[i] = new Range(clipPos(this$1, ranges[i].anchor), clipPos(this$1, ranges[i].head));
      }
      if (primary == null) {
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function (anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function (lineSep) {
      var this$1 = this;

      var ranges = this.sel.ranges,
          lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) {
        return lines;
      } else {
        return lines.join(lineSep || this.lineSeparator());
      }
    },
    getSelections: function (lineSep) {
      var this$1 = this;

      var parts = [],
          ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) {
          sel = sel.join(lineSep || this$1.lineSeparator());
        }
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function (code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++) {
        dup[i] = code;
      }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function (code, collapse, origin) {
      var this$1 = this;

      var changes = [],
          sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = { from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin };
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
        makeChange(this$1, changes[i$1]);
      }
      if (newSel) {
        setSelectionReplaceHistory(this, newSel);
      } else if (this.cm) {
        ensureCursorVisible(this.cm);
      }
    }),
    undo: docMethodOp(function () {
      makeChangeFromHistory(this, "undo");
    }),
    redo: docMethodOp(function () {
      makeChangeFromHistory(this, "redo");
    }),
    undoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "undo", true);
    }),
    redoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "redo", true);
    }),

    setExtending: function (val) {
      this.extend = val;
    },
    getExtending: function () {
      return this.extend;
    },

    historySize: function () {
      var hist = this.history,
          done = 0,
          undone = 0;
      for (var i = 0; i < hist.done.length; i++) {
        if (!hist.done[i].ranges) {
          ++done;
        }
      }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
        if (!hist.undone[i$1].ranges) {
          ++undone;
        }
      }
      return { undo: done, redo: undone };
    },
    clearHistory: function () {
      this.history = new History(this.history.maxGeneration);
    },

    markClean: function () {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function (forceSplit) {
      if (forceSplit) {
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      }
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function () {
      return { done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone) };
    },
    setHistory: function (histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function (line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) {
          line.gutterMarkers = null;
        }
        return true;
      });
    }),

    clearGutter: docMethodOp(function (gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) {
              line.gutterMarkers = null;
            }
            return true;
          });
        }
      });
    }),

    lineInfo: function (line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) {
          return null;
        }
        n = line;
        line = getLine(this, line);
        if (!line) {
          return null;
        }
      } else {
        n = lineNo(line);
        if (n == null) {
          return null;
        }
      }
      return { line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
        textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
        widgets: line.widgets };
    },

    addLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) {
          line[prop] = cls;
        } else if (classTest(cls).test(line[prop])) {
          return false;
        } else {
          line[prop] += " " + cls;
        }
        return true;
      });
    }),
    removeLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) {
          return false;
        } else if (cls == null) {
          line[prop] = null;
        } else {
          var found = cur.match(classTest(cls));
          if (!found) {
            return false;
          }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },

    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function (pos, options) {
      var realOpts = { replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false, shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [],
          spans = getLine(this, pos.line).markedSpans;
      if (spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
            markers.push(span.marker.parent || span.marker);
          }
        }
      }
      return markers;
    },
    findMarks: function (from, to, filter) {
      from = clipPos(this, from);to = clipPos(this, to);
      var found = [],
          lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) {
          for (var i = 0; i < spans.length; i++) {
            var span = spans[i];
            if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to || span.from == null && lineNo$$1 != from.line || span.from != null && lineNo$$1 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
              found.push(span.marker.parent || span.marker);
            }
          }
        }
        ++lineNo$$1;
      });
      return found;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            if (sps[i].from != null) {
              markers.push(sps[i].marker);
            }
          }
        }
      });
      return markers;
    },

    posFromIndex: function (off) {
      var ch,
          lineNo$$1 = this.first,
          sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) {
          ch = off;return true;
        }
        off -= sz;
        ++lineNo$$1;
      });
      return clipPos(this, Pos(lineNo$$1, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) {
        return 0;
      }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index;
    },

    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop;doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function (options) {
      if (!options) {
        options = {};
      }
      var from = this.first,
          to = this.first + this.size;
      if (options.from != null && options.from > from) {
        from = options.from;
      }
      if (options.to != null && options.to < to) {
        to = options.to;
      }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) {
        copy.history = this.history;
      }(this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
      copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function (other) {
      var this$1 = this;

      if (other instanceof CodeMirror) {
        other = other.doc;
      }
      if (this.linked) {
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this$1.linked[i];
          if (link.doc != other) {
            continue;
          }
          this$1.linked.splice(i, 1);
          other.unlinkDoc(this$1);
          detachSharedMarkers(findSharedMarkers(this$1));
          break;
        }
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          return splitIds.push(doc.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },

    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    },

    splitLines: function (str) {
      if (this.lineSep) {
        return str.split(this.lineSep);
      }
      return splitLinesAuto(str);
    },
    lineSeparator: function () {
      return this.lineSep || "\n";
    },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") {
        dir = "ltr";
      }
      if (dir == this.direction) {
        return;
      }
      this.direction = dir;
      this.iter(function (line) {
        return line.order = null;
      });
      if (this.cm) {
        directionChanged(this.cm);
      }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e_preventDefault(e);
    if (ie) {
      lastDrop = +new Date();
    }
    var pos = posFromMouse(cm, e, true),
        files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) {
      return;
    }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length,
          text = Array(n),
          read = 0;
      var loadFile = function (file, i) {
        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          return;
        }

        var reader = new FileReader();
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            content = "";
          }
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = { from: pos, to: pos,
              text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
              origin: "paste" };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) {
        loadFile(files[i], i);
      }
    } else {
      // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () {
          return cm.display.input.focus();
        }, 20);
        return;
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy) {
            selected = cm.listSelections();
          }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) {
            for (var i$1 = 0; i$1 < selected.length; ++i$1) {
              replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
            }
          }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      } catch (e) {}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
      e_stop(e);return;
    }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) {
        img.parentNode.removeChild(img);
      }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) {
      return;
    }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) {
      return;
    }
    var byClass = document.getElementsByClassName("CodeMirror"),
        editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) {
        editors.push(cm);
      }
    }
    if (editors.length) {
      editors[0].operation(function () {
        for (var i = 0; i < editors.length; i++) {
          f(editors[i]);
        }
      });
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) {
      return;
    }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () {
      return forEachCodeMirror(onBlur);
    });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) {
    keyNames[i + 48] = keyNames[i + 96] = String(i);
  }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) {
    keyNames[i$1] = String.fromCharCode(i$1);
  }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) {
    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
  }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        cmd = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift = true;
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }
    if (alt) {
      name = "Alt-" + name;
    }
    if (ctrl) {
      name = "Ctrl-" + name;
    }
    if (cmd) {
      name = "Cmd-" + name;
    }
    if (shift) {
      name = "Shift-" + name;
    }
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];
        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
          continue;
        }
        if (value == "...") {
          delete keymap[keyname];continue;
        }

        var keys = map(keyname.split(" "), normalizeKeyName);
        for (var i = 0; i < keys.length; i++) {
          var val = void 0,
              name = void 0;
          if (i == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i + 1).join(" ");
            val = "...";
          }
          var prev = copy[name];
          if (!prev) {
            copy[name] = val;
          } else if (prev != val) {
            throw new Error("Inconsistent bindings for " + name);
          }
        }
        delete keymap[keyname];
      }
    }
    for (var prop in copy) {
      keymap[prop] = copy[prop];
    }
    return keymap;
  }

  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) {
      return "nothing";
    }
    if (found === "...") {
      return "multi";
    }
    if (found != null && handle(found)) {
      return "handled";
    }

    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]") {
        return lookupKey(key, map$$1.fallthrough, handle, context);
      }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) {
          return result;
        }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") {
      name = "Alt-" + name;
    }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
      name = "Ctrl-" + name;
    }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") {
      name = "Cmd-" + name;
    }
    if (!noShift && event.shiftKey && base != "Shift") {
      name = "Shift-" + name;
    }
    return name;
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) {
      return false;
    }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) {
      return false;
    }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) {
      name = event.code;
    }
    return addModifierNames(name, event, noShift);
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges,
        kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--) {
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target;
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = dir < 0 == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) {
            return measureCharPrepared(cm, prep, ch).top == targetTop;
          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") {
            ch = moveCharLogically(lineObj, ch, 1);
          }
        } else {
          ch = dir < 0 ? part.to : part.from;
        }
        return new Pos(lineNo, ch, sticky);
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) {
      return moveLogically(line, start, dir);
    }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
        part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir);
    }

    var mv = function (pos, dir) {
      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
    };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) {
        return { begin: 0, end: line.text.length };
      }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch);
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = part.level == 1 == dir < 0;
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky);
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) {
        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
      };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = dir > 0 == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) {
          return getRes(ch, moveInStorageOrder);
        }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
          return getRes(ch, moveInStorageOrder);
        }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) {
      return res;
    }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) {
        return res;
      }
    }

    // Case 4: Nowhere to move
    return null;
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) {
      return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function (cm) {
      return deleteNearSelection(cm, function (range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine()) {
            return { from: range.head, to: Pos(range.head.line + 1, 0) };
          } else {
            return { from: range.head, to: Pos(range.head.line, len) };
          }
        } else {
          return { from: range.from(), to: range.to() };
        }
      });
    },
    deleteLine: function (cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
        };
      });
    },
    delLineLeft: function (cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0), to: range.from()
        };
      });
    },
    delWrappedLineLeft: function (cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({ left: 0, top: top }, "div");
        return { from: leftPos, to: range.from() };
      });
    },
    delWrappedLineRight: function (cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top }, "div");
        return { from: range.from(), to: rightPos };
      });
    },
    undo: function (cm) {
      return cm.undo();
    },
    redo: function (cm) {
      return cm.redo();
    },
    undoSelection: function (cm) {
      return cm.undoSelection();
    },
    redoSelection: function (cm) {
      return cm.redoSelection();
    },
    goDocStart: function (cm) {
      return cm.extendSelection(Pos(cm.firstLine(), 0));
    },
    goDocEnd: function (cm) {
      return cm.extendSelection(Pos(cm.lastLine()));
    },
    goLineStart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStart(cm, range.head.line);
      }, { origin: "+move", bias: 1 });
    },
    goLineStartSmart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStartSmart(cm, range.head);
      }, { origin: "+move", bias: 1 });
    },
    goLineEnd: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineEnd(cm, range.head.line);
      }, { origin: "+move", bias: -1 });
    },
    goLineRight: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top }, "div");
      }, sel_move);
    },
    goLineLeft: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({ left: 0, top: top }, "div");
      }, sel_move);
    },
    goLineLeftSmart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({ left: 0, top: top }, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
          return lineStartSmart(cm, range.head);
        }
        return pos;
      }, sel_move);
    },
    goLineUp: function (cm) {
      return cm.moveV(-1, "line");
    },
    goLineDown: function (cm) {
      return cm.moveV(1, "line");
    },
    goPageUp: function (cm) {
      return cm.moveV(-1, "page");
    },
    goPageDown: function (cm) {
      return cm.moveV(1, "page");
    },
    goCharLeft: function (cm) {
      return cm.moveH(-1, "char");
    },
    goCharRight: function (cm) {
      return cm.moveH(1, "char");
    },
    goColumnLeft: function (cm) {
      return cm.moveH(-1, "column");
    },
    goColumnRight: function (cm) {
      return cm.moveH(1, "column");
    },
    goWordLeft: function (cm) {
      return cm.moveH(-1, "word");
    },
    goGroupRight: function (cm) {
      return cm.moveH(1, "group");
    },
    goGroupLeft: function (cm) {
      return cm.moveH(-1, "group");
    },
    goWordRight: function (cm) {
      return cm.moveH(1, "word");
    },
    delCharBefore: function (cm) {
      return cm.deleteH(-1, "char");
    },
    delCharAfter: function (cm) {
      return cm.deleteH(1, "char");
    },
    delWordBefore: function (cm) {
      return cm.deleteH(-1, "word");
    },
    delWordAfter: function (cm) {
      return cm.deleteH(1, "word");
    },
    delGroupBefore: function (cm) {
      return cm.deleteH(-1, "group");
    },
    delGroupAfter: function (cm) {
      return cm.deleteH(1, "group");
    },
    indentAuto: function (cm) {
      return cm.indentSelection("smart");
    },
    indentMore: function (cm) {
      return cm.indentSelection("add");
    },
    indentLess: function (cm) {
      return cm.indentSelection("subtract");
    },
    insertTab: function (cm) {
      return cm.replaceSelection("\t");
    },
    insertSoftTab: function (cm) {
      var spaces = [],
          ranges = cm.listSelections(),
          tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) {
        cm.indentSelection("add");
      } else {
        cm.execCommand("insertTab");
      }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) {
      return runInOp(cm, function () {
        var ranges = cm.listSelections(),
            newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) {
            continue;
          }
          var cur = ranges[i].head,
              line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) {
              cur = new Pos(cur.line, cur.ch - 1);
            }
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
              }
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function (cm) {
      return runInOp(cm, function () {
        var sels = cm.listSelections();
        for (var i = sels.length - 1; i >= 0; i--) {
          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
        }
        sels = cm.listSelections();
        for (var i$1 = 0; i$1 < sels.length; i$1++) {
          cm.indentLine(sels[i$1].from().line, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    openLine: function (cm) {
      return cm.replaceSelection("\n", "start");
    },
    toggleOverwrite: function (cm) {
      return cm.toggleOverwrite();
    }
  };

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, visual, lineN, 1);
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, line, lineN, -1);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
    }
    return start;
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) {
        return false;
      }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift,
        done = false;
    try {
      if (cm.isReadOnly()) {
        cm.state.suppressEdits = true;
      }
      if (dropShift) {
        cm.display.shift = false;
      }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) {
        return result;
      }
    }
    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed();

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) {
        return "handled";
      }
      if (/\'$/.test(name)) {
        cm.state.keySeq = null;
      } else {
        stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        });
      }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
        return true;
      }
    }
    return dispatchKeyInner(cm, name, e, handle);
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi") {
      cm.state.keySeq = name;
    }
    if (result == "handled") {
      signalLater(cm, "keyHandled", cm, name, e);
    }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) {
      return false;
    }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) {
        return doHandleBinding(cm, b, true);
      }) || dispatchKey(cm, name, e, function (b) {
        if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
          return doHandleBinding(cm, b);
        }
      });
    } else {
      return dispatchKey(cm, name, e, function (b) {
        return doHandleBinding(cm, b);
      });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) {
      return doHandleBinding(cm, b, true);
    });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) {
      return;
    }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) {
      e.returnValue = false;
    }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
        cm.replaceSelection("", null, "cut");
      }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
      showCrossHair(cm);
    }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) {
      this.doc.sel.shift = false;
    }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
      return;
    }
    var keyCode = e.keyCode,
        charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;e_preventDefault(e);return;
    }
    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
      return;
    }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") {
      return;
    }
    if (handleCharBinding(cm, e, ch)) {
      return;
    }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function (time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date();
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple";
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double";
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single";
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this,
        display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
      return;
    }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () {
          return display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) {
      return;
    }
    var pos = posFromMouse(cm, e),
        button = e_button(e),
        repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText) {
      cm.state.selectingText(e);
    }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
      return;
    }

    if (button == 1) {
      if (pos) {
        leftButtonDown(cm, pos, repeat, e);
      } else if (e_target(e) == display.scroller) {
        e_preventDefault(e);
      }
    } else if (button == 2) {
      if (pos) {
        extendSelection(cm.doc, pos);
      }
      setTimeout(function () {
        return display.input.focus();
      }, 20);
    } else if (button == 3) {
      if (captureRightClick) {
        cm.display.input.onContextMenu(e);
      } else {
        delayBlurEvent(cm);
      }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") {
      name = "Double" + name;
    } else if (repeat == "triple") {
      name = "Triple" + name;
    }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") {
        bound = commands[bound];
      }
      if (!bound) {
        return false;
      }
      var done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done;
    });
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) {
      value.extend = cm.doc.extend || event.shiftKey;
    }
    if (value.addNew == null) {
      value.addNew = mac ? event.metaKey : event.ctrlKey;
    }
    if (value.moveOnDrag == null) {
      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
    }
    return value;
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) {
      setTimeout(bind(ensureFocus, cm), 0);
    } else {
      cm.curOp.focus = activeElt();
    }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel,
        contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
      leftButtonStartDrag(cm, event, pos, behavior);
    } else {
      leftButtonSelect(cm, event, pos, behavior);
    }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display,
        moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) {
        display.scroller.draggable = false;
      }
      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew) {
          extendSelection(cm.doc, pos, null, null, behavior.extend);
        }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9) {
          setTimeout(function () {
            display.wrapper.ownerDocument.body.focus();display.input.focus();
          }, 20);
        } else {
          display.input.focus();
        }
      }
    });
    var mouseMove = function (e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () {
      return moved = true;
    };
    // Let the drag handler handle this.
    if (webkit) {
      display.scroller.draggable = true;
    }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) {
      display.scroller.dragDrop();
    }
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    delayBlurEvent(cm);
    setTimeout(function () {
      return display.input.focus();
    }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") {
      return new Range(pos, pos);
    }
    if (unit == "word") {
      return cm.findWordAt(pos);
    }
    if (unit == "line") {
      return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
    }
    var result = unit(cm, pos);
    return new Range(result.from, result.to);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display,
        doc = cm.doc;
    e_preventDefault(event);

    var ourRange,
        ourIndex,
        startSel = doc.sel,
        ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1) {
        ourRange = ranges[ourIndex];
      } else {
        ourRange = new Range(start, start);
      }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) {
        ourRange = new Range(start, start);
      }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend) {
        ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend);
      } else {
        ourRange = range$$1;
      }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) {
        return;
      }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [],
            tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol),
            right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc, line).text,
              leftPos = findColumn(text, left, tabSize);
          if (left == right) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          } else if (text.length > leftPos) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
        }
        if (!ranges.length) {
          ranges.push(new Range(start, start));
        }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), { origin: "*mouse", scroll: false });
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor,
            head;
        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) {
        return;
      }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from) {
          setTimeout(operation(cm, function () {
            if (counter == curCount) {
              extend(e);
            }
          }), 150);
        }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) {
          setTimeout(operation(cm, function () {
            if (counter != curCount) {
              return;
            }
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) {
        done(e);
      } else {
        extend(e);
      }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
      return range$$1;
    }
    var order = getOrder(anchorLine);
    if (!order) {
      return range$$1;
    }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
        part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) {
      return range$$1;
    }
    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) {
      return range$$1;
    }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary) {
        leftSide = dir < 0;
      } else {
        leftSide = dir > 0;
      }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to,
        sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try {
        mX = e.clientX;mY = e.clientY;
      } catch (e) {
        return false;
      }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
      return false;
    }
    if (prevent) {
      e_preventDefault(e);
    }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) {
      return e_defaultPrevented(e);
    }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
      return;
    }
    if (signalDOMEvent(cm, e, "contextmenu")) {
      return;
    }
    if (!captureRightClick) {
      cm.display.input.onContextMenu(e);
    }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) {
      return false;
    }
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = { toString: function () {
      return "CodeMirror.Init";
    } };

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) {
        optionHandlers[name] = notOnInit ? function (cm, val, old) {
          if (old != Init) {
            handle(cm, val, old);
          }
        } : handle;
      }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) {
      return cm.setValue(val);
    }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) {
        return;
      }
      var newBreaks = [],
          lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) {
            break;
          }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--) {
        replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
      }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) {
        cm.refresh();
      }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
      return cm.refresh();
    }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) {
      return cm.getInputField().spellcheck = val;
    }, true);
    option("autocorrect", false, function (cm, val) {
      return cm.getInputField().autocorrect = val;
    }, true);
    option("autocapitalize", false, function (cm, val) {
      return cm.getInputField().autocapitalize = val;
    }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) {
        prev.detach(cm, next);
      }
      if (next.attach) {
        next.attach(cm, prev || null);
      }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) {
      return updateScrollbars(cm);
    }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) {
      return integer;
    }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {
      if (!val) {
        cm.display.input.reset();
      }
    }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) {
      return cm.doc.history.undoDepth = val;
    });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) {
      return cm.refresh();
    }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) {
        cm.display.input.resetPosition();
      }
    });

    option("tabindex", null, function (cm, val) {
      return cm.display.input.getField().tabIndex = val || "";
    });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) {
      return cm.doc.setDirection(val);
    }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      return updateScrollbars(cm);
    }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) {
      return new CodeMirror(place, options);
    }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") {
      doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
    } else if (options.mode) {
      doc.modeOption = options.mode;
    }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping) {
      this.display.wrapper.className += " CodeMirror-wrap";
    }
    initScrollbars(this);

    this.state = {
      keyMaps: [], // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0, // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null, // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) {
      display.input.focus();
    }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) {
      setTimeout(function () {
        return this$1.display.input.reset(true);
      }, 20);
    }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if (options.autofocus && !mobile || this.hasFocus()) {
      setTimeout(bind(onFocus, this), 20);
    } else {
      onBlur(this);
    }

    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) {
        optionHandlers[opt](this$1, options[opt], Init);
      }
    }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) {
      options.finishInit(this);
    }
    for (var i = 0; i < initHooks.length; ++i) {
      initHooks[i](this$1);
    }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
      display.lineDiv.style.textRendering = "auto";
    }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    } else {
      on(d.scroller, "dblclick", function (e) {
        return signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) {
      return onContextMenu(cm, e);
    });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished,
        prevTouch = { end: 0 };
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () {
          return d.activeTouch = null;
        }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date();
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) {
        return false;
      }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) {
        return true;
      }
      var dx = other.left - touch.left,
          dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date();
        d.activeTouch = { start: now, moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null };
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) {
        d.activeTouch.moved = true;
      }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"),
            range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          {
            range = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          {
            range = cm.findWordAt(pos);
          } else // Triple tap
          {
            range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) {
      return onScrollWheel(cm, e);
    });
    on(d.scroller, "DOMMouseScroll", function (e) {
      return onScrollWheel(cm, e);
    });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () {
      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });

    d.dragFunctions = {
      enter: function (e) {
        if (!signalDOMEvent(cm, e)) {
          e_stop(e);
        }
      },
      over: function (e) {
        if (!signalDOMEvent(cm, e)) {
          onDragOver(cm, e);e_stop(e);
        }
      },
      start: function (e) {
        return onDragStart(cm, e);
      },
      drop: operation(cm, onDrop),
      leave: function (e) {
        if (!signalDOMEvent(cm, e)) {
          clearDragCursor(cm);
        }
      }
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) {
      return onKeyUp.call(cm, e);
    });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) {
      return onFocus(cm, e);
    });
    on(inp, "blur", function (e) {
      return onBlur(cm, e);
    });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) {
    return initHooks.push(f);
  };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc,
        state;
    if (how == null) {
      how = "add";
    }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) {
        how = "prev";
      } else {
        state = getContextBefore(cm, n).state;
      }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n),
        curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    var curSpaceString = line.text.match(/^\s*/)[0],
        indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) {
          return;
        }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) {
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      } else {
        indentation = 0;
      }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "",
        pos = 0;
    if (cm.options.indentWithTabs) {
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;indentString += "\t";
      }
    }
    if (pos < indentation) {
      indentString += spaceStr(indentation - pos);
    }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break;
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) {
      sel = doc.sel;
    }

    var recent = +new Date() - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted),
        multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++) {
            multiPaste.push(doc.splitLines(lastCopied.text[i]));
          }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) {
          return [l];
        });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(),
          to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste) // Handle overwrite
          {
            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted) {
          from = to = Pos(from.line, 0);
        }
      }
      var changeEvent = { from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input") };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste) {
      triggerElectric(cm, inserted);
    }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) {
      cm.curOp.updateInput = updateInput;
    }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput) {
        runInOp(cm, function () {
          return applyTextInput(cm, pasted, 0, null, "paste");
        });
      }
      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) {
      return;
    }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line) {
        continue;
      }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break;
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch))) {
          indented = indentLine(cm, range$$1.head.line, "smart");
        }
      }
      if (indented) {
        signalLater(cm, "electricInput", cm, range$$1.head.line);
      }
    }
  }

  function copyableRanges(cm) {
    var text = [],
        ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return { text: text, ranges: ranges };
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) {
      te.style.width = "1000px";
    } else {
      te.setAttribute("wrap", "off");
    }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) {
      te.style.border = "1px solid black";
    }
    disableBrowserMagic(te);
    return div;
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function () {
        window.focus();this.display.input.focus();
      },

      setOption: function (option, value) {
        var options = this.options,
            old = options[option];
        if (options[option] == value && option != "mode") {
          return;
        }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option)) {
          operation(this, optionHandlers[option])(this, value, old);
        }
        signal(this, "optionChange", this, option);
      },

      getOption: function (option) {
        return this.options[option];
      },
      getDoc: function () {
        return this.doc;
      },

      addKeyMap: function (map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function (map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i) {
          if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true;
          }
        }
      },

      addOverlay: methodOp(function (spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) {
          throw new Error("Overlays may not be stateful.");
        }
        insertSorted(this.state.overlays, { mode: mode, modeSpec: spec, opaque: options && options.opaque,
          priority: options && options.priority || 0 }, function (overlay) {
          return overlay.priority;
        });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function (spec) {
        var this$1 = this;

        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return;
          }
        }
      }),

      indentLine: methodOp(function (n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) {
            dir = this.options.smartIndent ? "smart" : "prev";
          } else {
            dir = dir ? "add" : "subtract";
          }
        }
        if (isLine(this.doc, n)) {
          indentLine(this, n, dir, aggressive);
        }
      }),
      indentSelection: methodOp(function (how) {
        var this$1 = this;

        var ranges = this.doc.sel.ranges,
            end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(),
                to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j) {
              indentLine(this$1, j, how);
            }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
              replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
            }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) {
              ensureCursorVisible(this$1);
            }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function (pos, precise) {
        return takeToken(this, pos, precise);
      },

      getLineTokens: function (line, precise) {
        return takeToken(this, Pos(line), precise, true);
      },

      getTokenTypeAt: function (pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0,
            after = (styles.length - 1) / 2,
            ch = pos.ch;
        var type;
        if (ch == 0) {
          type = styles[2];
        } else {
          for (;;) {
            var mid = before + after >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
              after = mid;
            } else if (styles[mid * 2 + 1] < ch) {
              before = mid + 1;
            } else {
              type = styles[mid * 2 + 2];break;
            }
          }
        }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
      },

      getModeAt: function (pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) {
          return mode;
        }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
      },

      getHelper: function (pos, type) {
        return this.getHelpers(pos, type)[0];
      },

      getHelpers: function (pos, type) {
        var this$1 = this;

        var found = [];
        if (!helpers.hasOwnProperty(type)) {
          return found;
        }
        var help = helpers[type],
            mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) {
            found.push(help[mode[type]]);
          }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) {
              found.push(val);
            }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1) {
            found.push(cur.val);
          }
        }
        return found;
      },

      getStateAfter: function (line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
        return getContextBefore(this, line + 1, precise).state;
      },

      cursorCoords: function (start, mode) {
        var pos,
            range$$1 = this.doc.sel.primary();
        if (start == null) {
          pos = range$$1.head;
        } else if (typeof start == "object") {
          pos = clipPos(this.doc, start);
        } else {
          pos = start ? range$$1.from() : range$$1.to();
        }
        return cursorCoords(this, pos, mode || "page");
      },

      charCoords: function (pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page");
      },

      coordsChar: function (coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top);
      },

      lineAtHeight: function (height, mode) {
        height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function (line, mode, includeWidgets) {
        var end = false,
            lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) {
            line = this.doc.first;
          } else if (line > last) {
            line = last;end = true;
          }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
      },

      defaultTextHeight: function () {
        return textHeight(this.display);
      },
      defaultCharWidth: function () {
        return charWidth(this.display);
      },

      getViewport: function () {
        return { from: this.display.viewFrom, to: this.display.viewTo };
      },

      addWidget: function (pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom,
            left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
              hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
            top = pos.top - node.offsetHeight;
          } else if (pos.bottom + node.offsetHeight <= vspace) {
            top = pos.bottom;
          }
          if (left + node.offsetWidth > hspace) {
            left = hspace - node.offsetWidth;
          }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") {
            left = 0;
          } else if (horiz == "middle") {
            left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          }
          node.style.left = left + "px";
        }
        if (scroll) {
          scrollIntoView(this, { left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
        }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function (cmd) {
        if (commands.hasOwnProperty(cmd)) {
          return commands[cmd].call(null, this);
        }
      },

      triggerElectric: methodOp(function (text) {
        triggerElectric(this, text);
      }),

      findPosH: function (from, amount, unit, visually) {
        var this$1 = this;

        var dir = 1;
        if (amount < 0) {
          dir = -1;amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },

      moveH: methodOp(function (dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty()) {
            return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually);
          } else {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
        }, sel_move);
      }),

      deleteH: methodOp(function (dir, unit) {
        var sel = this.doc.sel,
            doc = this.doc;
        if (sel.somethingSelected()) {
          doc.replaceSelection("", null, "+delete");
        } else {
          deleteNearSelection(this, function (range$$1) {
            var other = findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? { from: other, to: range$$1.head } : { from: range$$1.head, to: other };
          });
        }
      }),

      findPosV: function (from, amount, unit, goalColumn) {
        var this$1 = this;

        var dir = 1,
            x = goalColumn;
        if (amount < 0) {
          dir = -1;amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this$1, cur, "div");
          if (x == null) {
            x = coords.left;
          } else {
            coords.left = x;
          }
          cur = findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },

      moveV: methodOp(function (dir, unit) {
        var this$1 = this;

        var doc = this.doc,
            goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse) {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
          var headPos = cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) {
            headPos.left = range$$1.goalColumn;
          }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary()) {
            addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
          }
          return pos;
        }, sel_move);
        if (goals.length) {
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            doc.sel.ranges[i].goalColumn = goals[i];
          }
        }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function (pos) {
        var doc = this.doc,
            line = getLine(doc, pos.line).text;
        var start = pos.ch,
            end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) {
            --start;
          } else {
            ++end;
          }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper) ? function (ch) {
            return isWordChar(ch, helper);
          } : /\s/.test(startChar) ? function (ch) {
            return (/\s/.test(ch)
            );
          } : function (ch) {
            return !/\s/.test(ch) && !isWordChar(ch);
          };
          while (start > 0 && check(line.charAt(start - 1))) {
            --start;
          }
          while (end < line.length && check(line.charAt(end))) {
            ++end;
          }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end));
      },

      toggleOverwrite: function (value) {
        if (value != null && value == this.state.overwrite) {
          return;
        }
        if (this.state.overwrite = !this.state.overwrite) {
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        } else {
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
        }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function () {
        return this.display.input.getField() == activeElt();
      },
      isReadOnly: function () {
        return !!(this.options.readOnly || this.doc.cantEdit);
      },

      scrollTo: methodOp(function (x, y) {
        scrollToCoords(this, x, y);
      }),
      getScrollInfo: function () {
        var scroller = this.display.scroller;
        return { left: scroller.scrollLeft, top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this), clientWidth: displayWidth(this) };
      },

      scrollIntoView: methodOp(function (range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = { from: this.doc.sel.primary().head, to: null };
          if (margin == null) {
            margin = this.options.cursorScrollMargin;
          }
        } else if (typeof range$$1 == "number") {
          range$$1 = { from: Pos(range$$1, 0), to: null };
        } else if (range$$1.from == null) {
          range$$1 = { from: range$$1, to: null };
        }
        if (!range$$1.to) {
          range$$1.to = range$$1.from;
        }
        range$$1.margin = margin || 0;

        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),

      setSize: methodOp(function (width, height) {
        var this$1 = this;

        var interpret = function (val) {
          return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
        };
        if (width != null) {
          this.display.wrapper.style.width = interpret(width);
        }
        if (height != null) {
          this.display.wrapper.style.height = interpret(height);
        }
        if (this.options.lineWrapping) {
          clearLineMeasurementCache(this);
        }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].noHScroll) {
                regLineChange(this$1, lineNo$$1, "widget");break;
              }
            }
          }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function (f) {
        return runInOp(this, f);
      },
      startOperation: function () {
        return startOperation(this);
      },
      endOperation: function () {
        return endOperation(this);
      },

      refresh: methodOp(function () {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {
          estimateLineHeights(this);
        }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function (doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) {
          this.state.selectingText();
        }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old;
      }),

      phrase: function (phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
      },

      getInputField: function () {
        return this.display.input.getField();
      },
      getWrapperElement: function () {
        return this.display.wrapper;
      },
      getScrollerElement: function () {
        return this.display.scroller;
      },
      getGutterElement: function () {
        return this.display.gutters;
      }
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function (type, name, value) {
      if (!helpers.hasOwnProperty(type)) {
        helpers[type] = CodeMirror[type] = { _global: [] };
      }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({ pred: predicate, val: value });
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    function findNextLine() {
      var l = pos.line + dir;
      if (l < doc.first || l >= doc.first + doc.size) {
        return false;
      }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next;
      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);
        } else {
          return false;
        }
      } else {
        pos = next;
      }
      return true;
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null,
          group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) {
          break;
        }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
        if (group && !first && !type) {
          type = "s";
        }
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;moveOnce();pos.sticky = "after";
          }
          break;
        }

        if (type) {
          sawType = type;
        }
        if (dir > 0 && !moveOnce(!first)) {
          break;
        }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) {
      result.hitSide = true;
    }
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc,
        x = pos.left,
        y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) {
        break;
      }
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;break;
      }
      y += dir * 5;
    }
    return target;
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function (cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;

    var input = this,
        cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) {
        setTimeout(operation(cm, function () {
          return this$1.updateFromDOM();
        }), 20);
      }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = { data: e.data, done: false };
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) {
        this$1.composing = { data: e.data, done: false };
      }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) {
          this$1.readFromDOMSoon();
        }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () {
      return input.forceCompositionEnd();
    });

    on(div, "input", function () {
      if (!this$1.composing) {
        this$1.readFromDOMSoon();
      }
    });

    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
        if (e.type == "cut") {
          cm.replaceSelection("", null, "cut");
        }
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return;
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(),
          te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) {
          input.showPrimarySelection();
        }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result;
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) {
      return;
    }
    if (info.focus || takeFocus) {
      this.showPrimarySelection();
    }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection();
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(),
        cm = this.cm,
        prim = cm.doc.sel.primary();
    var from = prim.from(),
        to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return;
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
      return;
    }

    var view = cm.display.view;
    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = { node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3] };
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return;
    }

    var old = sel.rangeCount && sel.getRangeAt(0),
        rng;
    try {
      rng = range(start.node, start.offset, end.offset, end.node);
    } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) {
        sel.addRange(old);
      } else if (gecko) {
        this.startGracePeriod();
      }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged()) {
        this$1.cm.operation(function () {
          return this$1.cm.curOp.selectionChanged = true;
        });
      }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode;this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode;this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) {
      return false;
    }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node);
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor()) {
        this.showSelection(this.prepareSelection(), true);
      }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () {
    this.div.blur();
  };
  ContentEditableInput.prototype.getField = function () {
    return this.div;
  };

  ContentEditableInput.prototype.supportsTouch = function () {
    return true;
  };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor()) {
      this.pollSelection();
    } else {
      runInOp(this.cm, function () {
        return input.cm.curOp.selectionChanged = true;
      });
    }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
      return;
    }
    var sel = this.getSelection(),
        cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
      this.blur();
      this.focus();
      return;
    }
    if (this.composing) {
      return;
    }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) {
      runInOp(cm, function () {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
        if (anchor.bad || head.bad) {
          cm.curOp.selectionChanged = true;
        }
      });
    }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm,
        display = cm.display,
        sel = cm.doc.sel.primary();
    var from = sel.from(),
        to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine()) {
      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
    }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
      to = Pos(to.line + 1, 0);
    }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
      return false;
    }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) {
      return false;
    }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) {
        newText.pop();oldText.pop();toLine--;
      } else if (newText[0] == oldText[0]) {
        newText.shift();oldText.shift();fromLine++;
      } else {
        break;
      }
    }

    var cutFront = 0,
        cutEnd = 0;
    var newTop = newText[0],
        oldTop = oldText[0],
        maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
      ++cutFront;
    }
    var newBot = lst(newText),
        oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      ++cutEnd;
    }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true;
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) {
      return;
    }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;

    if (this.readDOMTimeout != null) {
      return;
    }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) {
          this$1.composing = null;
        } else {
          return;
        }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent()) {
      runInOp(this.cm, function () {
        return regChange(this$1.cm);
      });
    }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) {
      return;
    }
    e.preventDefault();
    if (!this.cm.isReadOnly()) {
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) {
      return null;
    }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction),
        side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode) {
      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
        return true;
      }
    }
    return false;
  }

  function badPos(pos, bad) {
    if (bad) {
      pos.bad = true;
    }return pos;
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "",
        closing = false,
        lineSep = cm.doc.lineSeparator(),
        extraLinebreak = false;
    function recognizeMarker(id) {
      return function (marker) {
        return marker.id == id;
      };
    }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) {
          text += lineSep;
        }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return;
        }
        var markerID = node.getAttribute("cm-marker"),
            range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find(0))) {
            addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep));
          }
          return;
        }
        if (node.getAttribute("contenteditable") == "false") {
          return;
        }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
          return;
        }

        if (isBlock) {
          close();
        }
        for (var i = 0; i < node.childNodes.length; i++) {
          walk(node.childNodes[i]);
        }

        if (/^(pre|p)$/i.test(node.nodeName)) {
          extraLinebreak = true;
        }
        if (isBlock) {
          closing = true;
        }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) {
        break;
      }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text;
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) {
        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      }
      node = null;offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) {
          return null;
        }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
          break;
        }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode) {
        return locateNodeInLineView(lineView, node, offset);
      }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild,
        bad = false;
    if (!node || !contains(wrapper, node)) {
      return badPos(Pos(lineNo(lineView.line), 0), true);
    }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null,
        topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) {
        offset = textNode.nodeValue.length;
      }
    }
    while (topNode.parentNode != wrapper) {
      topNode = topNode.parentNode;
    }
    var measure = lineView.measure,
        maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) {
              ch = map$$1[j + (offset ? 1 : 0)];
            }
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) {
      return badPos(found, bad);
    }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found) {
        return badPos(Pos(found.line, found.ch - dist), bad);
      } else {
        dist += after.textContent.length;
      }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found) {
        return badPos(Pos(found.line, found.ch + dist$1), bad);
      } else {
        dist$1 += before.textContent.length;
      }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function (cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
    var this$1 = this;

    var input = this,
        cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) {
      te.style.width = "0px";
    }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) {
        this$1.hasSelection = null;
      }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }

      cm.state.pasteIncoming = +new Date();
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") {
        cm.state.cutIncoming = +new Date();
      }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
        return;
      }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date();
        input.focus();
        return;
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) {
        e_preventDefault(e);
      }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) {
        input.composing.range.clear();
      }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm,
        display = cm.display,
        doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(),
          lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
    }

    return result;
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm,
        display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) {
      return;
    }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) {
        selectInput(this.textarea);
      }
      if (ie && ie_version >= 9) {
        this.hasSelection = content;
      }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
    }
  };

  TextareaInput.prototype.getField = function () {
    return this.textarea;
  };

  TextareaInput.prototype.supportsTouch = function () {
    return false;
  };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try {
        this.textarea.focus();
      } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () {
    this.textarea.blur();
  };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () {
    this.slowPoll();
  };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;

    if (this.pollingFast) {
      return;
    }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) {
        this$1.slowPoll();
      }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false,
        input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {
        missed = true;input.polling.set(60, p);
      } else {
        input.pollingFast = false;input.slowPoll();
      }
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
    var this$1 = this;

    var cm = this.cm,
        input = this.textarea,
        prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
      return false;
    }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) {
      return false;
    }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false;
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) {
        prevInput = "\u200b";
      }
      if (first == 0x21da) {
        this.reset();return this.cm.execCommand("undo");
      }
    }
    // Find the part of the input that is actually new
    var same = 0,
        l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
      ++same;
    }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) {
        input.value = this$1.prevInput = "";
      } else {
        this$1.prevInput = text;
      }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
      }
    });
    return true;
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) {
      this.pollingFast = false;
    }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) {
      this.hasSelection = null;
    }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this,
        cm = input.cm,
        display = cm.display,
        te = input.textarea;
    if (input.contextMenuPending) {
      input.contextMenuPending();
    }
    var pos = posFromMouse(cm, e),
        scrollPos = display.scroller.scrollTop;
    if (!pos || presto) {
      return;
    } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1) {
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    }

    var oldCSS = te.style.cssText,
        oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) {
      oldScrollY = window.scrollY;
    } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) {
      window.scrollTo(null, oldScrollY);
    }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) {
      te.value = input.prevInput = " ";
    }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1;te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) {
        return;
      }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) {
        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || ie && ie_version < 9) {
          prepareSelectAllHack();
        }
        var i = 0,
            poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) {
      prepareSelectAllHack();
    }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) {
      this.reset();
    }
    this.textarea.disabled = val == "nocursor";
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex) {
      options.tabindex = textarea.tabIndex;
    }
    if (!options.placeholder && textarea.placeholder) {
      options.placeholder = textarea.placeholder;
    }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {
      textarea.value = cm.getValue();
    }

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () {
        return textarea;
      };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function") {
            textarea.form.submit = realSubmit;
          }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) {
      return textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
    }
  }

  eventMixin(Doc);
  CodeMirror.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function (name /*, mode, …*/) {
    if (!CodeMirror.defaults.mode && name != "null") {
      CodeMirror.defaults.mode = name;
    }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () {
    return { token: function (stream) {
        return stream.skipToEnd();
      } };
  });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.48.4";

  return CodeMirror;
});

/***/ }),

/***/ "tbG5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};

// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size);
  }
  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};

// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

/***/ }),

/***/ "tcrG":
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),

/***/ "tuDi":
/***/ (function(module, exports) {



/***/ }),

/***/ "tzeh":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("DHrQ");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__("WSyY");
exports.Duplex = __webpack_require__("Hba+");
exports.Transform = __webpack_require__("7tlB");
exports.PassThrough = __webpack_require__("nwyA");

/***/ }),

/***/ "u1qH":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var fails = __webpack_require__("b3E9");
var classof = __webpack_require__("rQTS");
var split = ''.split;

module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

/***/ }),

/***/ "uQIK":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);

  var Pos = CodeMirror.Pos;

  var matching = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };

  function bracketRegex(config) {
    return config && config.bracketRegex || /[(){}[\]]/;
  }

  function findMatchingBracket(cm, where, config) {
    var line = cm.getLineHandle(where.line),
        pos = where.ch - 1;
    var afterCursor = config && config.afterCursor;
    if (afterCursor == null) afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);
    var re = bracketRegex(config);

    // A cursor is defined as between two characters, but in in vim command mode
    // (i.e. not insert mode), the cursor is visually represented as a
    // highlighted box on top of the 2nd character. Otherwise, we allow matches
    // from before or after the cursor.
    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config && config.strict && dir > 0 != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));

    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
    if (found == null) return null;
    return { from: Pos(where.line, pos), to: found && found.pos,
      match: found && found.ch == match.charAt(0), forward: dir > 0 };
  }

  // bracketRegex is used to specify which type of bracket to scan
  // should be a regexp, e.g. /[[\]]/
  //
  // Note: If "where" is on an open bracket, then this bracket is ignored.
  //
  // Returns false when no bracket was found, null when it reached
  // maxScanLines and gave up
  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = config && config.maxScanLineLength || 10000;
    var maxScanLines = config && config.maxScanLines || 1000;

    var stack = [];
    var re = bracketRegex(config);
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1,
          end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
          var match = matching[ch];
          if (match && match.charAt(1) == ">" == dir > 0) stack.push(ch);else if (!stack.length) return { pos: Pos(lineNo, pos), ch: ch };else stack.pop();
        }
      }
    }
    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }

  function matchBrackets(cm, autoclear, config) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var marks = [],
        ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), { className: style }));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen) marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), { className: style }));
      }
    }

    if (marks.length) {
      // Kludge to work around the IE bug from issue #1193, where text
      // input stops going to the textare whever this fires.
      if (ie_lt8 && cm.state.focused) cm.focus();

      var clear = function () {
        cm.operation(function () {
          for (var i = 0; i < marks.length; i++) marks[i].clear();
        });
      };
      if (autoclear) setTimeout(clear, 800);else return clear;
    }
  }

  function doMatchBrackets(cm) {
    cm.operation(function () {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchBrackets);
      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
    }
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
    }
  });

  CodeMirror.defineExtension("matchBrackets", function () {
    matchBrackets(this, true);
  });
  CodeMirror.defineExtension("findMatchingBracket", function (pos, config, oldConfig) {
    // Backwards-compatibility kludge
    if (oldConfig || typeof config == "boolean") {
      if (!oldConfig) {
        config = config ? { strict: true } : null;
      } else {
        oldConfig.strict = config;
        config = oldConfig;
      }
    }
    return findMatchingBracket(this, pos, config);
  });
  CodeMirror.defineExtension("scanForBracket", function (pos, dir, style, config) {
    return scanForBracket(this, pos, dir, style, config);
  });
});

/***/ }),

/***/ "uRfg":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__("1kq3");
var $export = __webpack_require__("vSO4");
var redefine = __webpack_require__("gojl");
var hide = __webpack_require__("akPY");
var Iterators = __webpack_require__("dhak");
var $iterCreate = __webpack_require__("b7Q2");
var setToStringTag = __webpack_require__("11Ut");
var getPrototypeOf = __webpack_require__("HHE0");
var ITERATOR = __webpack_require__("Ug9I")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),

/***/ "uUPe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = called = ++called % 2;
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("h6ac")))

/***/ }),

/***/ "ueHA":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorCode", function() { return tmp_2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventType", function() { return tmp_3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebChannel", function() { return tmp_4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XhrIo", function() { return tmp_5; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createWebChannelTransport", function() { return tmp_1; });
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var g,
    goog = goog || {},
    k = commonjsGlobal;function m(a) {
  return "string" == typeof a;
}function aa(a) {
  return "number" == typeof a;
}function n(a, b) {
  a = a.split(".");b = b || k;for (var c = 0; c < a.length; c++) if (b = b[a[c]], null == b) return null;return b;
}function ba() {}
function p(a) {
  var b = typeof a;if ("object" == b) {
    if (a) {
      if (a instanceof Array) return "array";if (a instanceof Object) return b;var c = Object.prototype.toString.call(a);if ("[object Window]" == c) return "object";if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
    } else return "null";
  } else if ("function" == b && "undefined" == typeof a.call) return "object";return b;
}function q(a) {
  return "array" == p(a);
}function ca(a) {
  var b = p(a);return "array" == b || "object" == b && "number" == typeof a.length;
}function r(a) {
  var b = typeof a;return "object" == b && null != a || "function" == b;
}var t = "closure_uid_" + (1E9 * Math.random() >>> 0),
    da = 0;function ea(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function fa(a, b, c) {
  if (!a) throw Error();if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);return function () {
      var e = Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(e, d);return a.apply(b, e);
    };
  }return function () {
    return a.apply(b, arguments);
  };
}function u(a, b, c) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? u = ea : u = fa;return u.apply(null, arguments);
}
function v(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);return function () {
    var d = c.slice();d.push.apply(d, arguments);return a.apply(this, d);
  };
}var w = Date.now || function () {
  return +new Date();
};function x(a, b) {
  function c() {}c.prototype = b.prototype;a.N = b.prototype;a.prototype = new c();a.prototype.constructor = a;a.yb = function (d, e, f) {
    for (var h = Array(arguments.length - 2), l = 2; l < arguments.length; l++) h[l - 2] = arguments[l];return b.prototype[e].apply(d, h);
  };
}function y() {
  this.j = this.j;this.i = this.i;
}var ha = 0;y.prototype.j = !1;y.prototype.la = function () {
  if (!this.j && (this.j = !0, this.G(), 0 != ha)) {
    var a = this[t] || (this[t] = ++da);
  }
};y.prototype.G = function () {
  if (this.i) for (; this.i.length;) this.i.shift()();
};var ja = Array.prototype.indexOf ? function (a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function (a, b) {
  if (m(a)) return m(b) && 1 == b.length ? a.indexOf(b, 0) : -1;for (var c = 0; c < a.length; c++) if (c in a && a[c] === b) return c;return -1;
},
    la = Array.prototype.forEach ? function (a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function (a, b, c) {
  for (var d = a.length, e = m(a) ? a.split("") : a, f = 0; f < d; f++) f in e && b.call(c, e[f], f, a);
};
function ma(a) {
  a: {
    var b = na;for (var c = a.length, d = m(a) ? a.split("") : a, e = 0; e < c; e++) if (e in d && b.call(void 0, d[e], e, a)) {
      b = e;break a;
    }b = -1;
  }return 0 > b ? null : m(a) ? a.charAt(b) : a[b];
}function oa(a) {
  return Array.prototype.concat.apply([], arguments);
}function pa(a) {
  var b = a.length;if (0 < b) {
    for (var c = Array(b), d = 0; d < b; d++) c[d] = a[d];return c;
  }return [];
}function qa(a) {
  return (/^[\s\xa0]*$/.test(a)
  );
}var ra = String.prototype.trim ? function (a) {
  return a.trim();
} : function (a) {
  return (/^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]
  );
};function z(a, b) {
  return -1 != a.indexOf(b);
}function sa(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}var A;a: {
  var ta = k.navigator;if (ta) {
    var ua = ta.userAgent;if (ua) {
      A = ua;break a;
    }
  }A = "";
}function va(a, b, c) {
  for (var d in a) b.call(c, a[d], d, a);
}function wa(a) {
  var b = {},
      c;for (c in a) b[c] = a[c];return b;
}var xa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function ya(a, b) {
  for (var c, d, e = 1; e < arguments.length; e++) {
    d = arguments[e];for (c in d) a[c] = d[c];for (var f = 0; f < xa.length; f++) c = xa[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}function za(a) {
  za[" "](a);return a;
}za[" "] = ba;function Aa(a, b) {
  var c = Ba;return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b(a);
}var Ca = z(A, "Opera"),
    B = z(A, "Trident") || z(A, "MSIE"),
    Da = z(A, "Edge"),
    Ea = Da || B,
    Fa = z(A, "Gecko") && !(z(A.toLowerCase(), "webkit") && !z(A, "Edge")) && !(z(A, "Trident") || z(A, "MSIE")) && !z(A, "Edge"),
    Ga = z(A.toLowerCase(), "webkit") && !z(A, "Edge");function Ha() {
  var a = k.document;return a ? a.documentMode : void 0;
}var Ia;
a: {
  var Ja = "",
      Ka = function () {
    var a = A;if (Fa) return (/rv:([^\);]+)(\)|;)/.exec(a)
    );if (Da) return (/Edge\/([\d\.]+)/.exec(a)
    );if (B) return (/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a)
    );if (Ga) return (/WebKit\/(\S+)/.exec(a)
    );if (Ca) return (/(?:Version)[ \/]?(\S+)/.exec(a)
    );
  }();Ka && (Ja = Ka ? Ka[1] : "");if (B) {
    var La = Ha();if (null != La && La > parseFloat(Ja)) {
      Ia = String(La);break a;
    }
  }Ia = Ja;
}var Ba = {};
function Ma(a) {
  return Aa(a, function () {
    for (var b = 0, c = ra(String(Ia)).split("."), d = ra(String(a)).split("."), e = Math.max(c.length, d.length), f = 0; 0 == b && f < e; f++) {
      var h = c[f] || "",
          l = d[f] || "";do {
        h = /(\d*)(\D*)(.*)/.exec(h) || ["", "", "", ""];l = /(\d*)(\D*)(.*)/.exec(l) || ["", "", "", ""];if (0 == h[0].length && 0 == l[0].length) break;b = sa(0 == h[1].length ? 0 : parseInt(h[1], 10), 0 == l[1].length ? 0 : parseInt(l[1], 10)) || sa(0 == h[2].length, 0 == l[2].length) || sa(h[2], l[2]);h = h[3];l = l[3];
      } while (0 == b);
    }return 0 <= b;
  });
}var Na;var Oa = k.document;
Na = Oa && B ? Ha() || ("CSS1Compat" == Oa.compatMode ? parseInt(Ia, 10) : 5) : void 0;var Pa = !B || 9 <= Number(Na),
    Qa = B && !Ma("9"),
    Ra = function () {
  if (!k.addEventListener || !Object.defineProperty) return !1;var a = !1,
      b = Object.defineProperty({}, "passive", { get: function () {
      a = !0;
    } });try {
    k.addEventListener("test", ba, b), k.removeEventListener("test", ba, b);
  } catch (c) {}return a;
}();function C(a, b) {
  this.type = a;this.a = this.target = b;this.Ja = !0;
}C.prototype.b = function () {
  this.Ja = !1;
};function D(a, b) {
  C.call(this, a ? a.type : "");this.relatedTarget = this.a = this.target = null;this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;this.key = "";this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;this.pointerId = 0;this.pointerType = "";this.c = null;if (a) {
    var c = this.type = a.type,
        d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;this.target = a.target || a.srcElement;this.a = b;if (b = a.relatedTarget) {
      if (Fa) {
        a: {
          try {
            za(b.nodeName);var e = !0;break a;
          } catch (f) {}e = !1;
        }e || (b = null);
      }
    } else "mouseover" == c ? b = a.fromElement : "mouseout" == c && (b = a.toElement);this.relatedTarget = b;d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);this.button = a.button;this.key = a.key || "";this.ctrlKey = a.ctrlKey;this.altKey = a.altKey;this.shiftKey = a.shiftKey;this.metaKey = a.metaKey;this.pointerId = a.pointerId || 0;this.pointerType = m(a.pointerType) ? a.pointerType : Sa[a.pointerType] || "";this.c = a;a.defaultPrevented && this.b();
  }
}x(D, C);var Sa = { 2: "touch", 3: "pen", 4: "mouse" };D.prototype.b = function () {
  D.N.b.call(this);var a = this.c;if (a.preventDefault) a.preventDefault();else if (a.returnValue = !1, Qa) try {
    if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) a.keyCode = -1;
  } catch (b) {}
};var E = "closure_listenable_" + (1E6 * Math.random() | 0),
    Ta = 0;function Ua(a, b, c, d, e) {
  this.listener = a;this.proxy = null;this.src = b;this.type = c;this.capture = !!d;this.da = e;this.key = ++Ta;this.X = this.Z = !1;
}function Va(a) {
  a.X = !0;a.listener = null;a.proxy = null;a.src = null;a.da = null;
}function Wa(a) {
  this.src = a;this.a = {};this.b = 0;
}Wa.prototype.add = function (a, b, c, d, e) {
  var f = a.toString();a = this.a[f];a || (a = this.a[f] = [], this.b++);var h = Xa(a, b, d, e);-1 < h ? (b = a[h], c || (b.Z = !1)) : (b = new Ua(b, this.src, f, !!d, e), b.Z = c, a.push(b));return b;
};function Ya(a, b) {
  var c = b.type;if (c in a.a) {
    var d = a.a[c],
        e = ja(d, b),
        f;(f = 0 <= e) && Array.prototype.splice.call(d, e, 1);f && (Va(b), 0 == a.a[c].length && (delete a.a[c], a.b--));
  }
}
function Xa(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];if (!f.X && f.listener == b && f.capture == !!c && f.da == d) return e;
  }return -1;
}var Za = "closure_lm_" + (1E6 * Math.random() | 0),
    $a = {};function bb(a, b, c, d, e) {
  if (d && d.once) return cb(a, b, c, d, e);if (q(b)) {
    for (var f = 0; f < b.length; f++) bb(a, b[f], c, d, e);return null;
  }c = db(c);return a && a[E] ? a.Aa(b, c, r(d) ? !!d.capture : !!d, e) : eb(a, b, c, !1, d, e);
}
function eb(a, b, c, d, e, f) {
  if (!b) throw Error("Invalid event type");var h = r(e) ? !!e.capture : !!e;if (h && !Pa) return null;var l = fb(a);l || (a[Za] = l = new Wa(a));c = l.add(b, c, d, h, f);if (c.proxy) return c;d = gb();c.proxy = d;d.src = a;d.listener = c;if (a.addEventListener) Ra || (e = h), void 0 === e && (e = !1), a.addEventListener(b.toString(), d, e);else if (a.attachEvent) a.attachEvent(hb(b.toString()), d);else if (a.addListener && a.removeListener) a.addListener(d);else throw Error("addEventListener and attachEvent are unavailable.");return c;
}function gb() {
  var a = ib,
      b = Pa ? function (c) {
    return a.call(b.src, b.listener, c);
  } : function (c) {
    c = a.call(b.src, b.listener, c);if (!c) return c;
  };return b;
}function cb(a, b, c, d, e) {
  if (q(b)) {
    for (var f = 0; f < b.length; f++) cb(a, b[f], c, d, e);return null;
  }c = db(c);return a && a[E] ? a.Ba(b, c, r(d) ? !!d.capture : !!d, e) : eb(a, b, c, !0, d, e);
}
function jb(a, b, c, d, e) {
  if (q(b)) for (var f = 0; f < b.length; f++) jb(a, b[f], c, d, e);else (d = r(d) ? !!d.capture : !!d, c = db(c), a && a[E]) ? (a = a.c, b = String(b).toString(), b in a.a && (f = a.a[b], c = Xa(f, c, d, e), -1 < c && (Va(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b], a.b--)))) : a && (a = fb(a)) && (b = a.a[b.toString()], a = -1, b && (a = Xa(b, c, d, e)), (c = -1 < a ? b[a] : null) && kb(c));
}
function kb(a) {
  if (!aa(a) && a && !a.X) {
    var b = a.src;if (b && b[E]) Ya(b.c, a);else {
      var c = a.type,
          d = a.proxy;b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(hb(c), d) : b.addListener && b.removeListener && b.removeListener(d);(c = fb(b)) ? (Ya(c, a), 0 == c.b && (c.src = null, b[Za] = null)) : Va(a);
    }
  }
}function hb(a) {
  return a in $a ? $a[a] : $a[a] = "on" + a;
}function lb(a, b) {
  var c = a.listener,
      d = a.da || a.src;a.Z && kb(a);return c.call(d, b);
}
function ib(a, b) {
  return a.X ? !0 : Pa ? lb(a, new D(b, this)) : (b = new D(b || n("window.event"), this), lb(a, b));
}function fb(a) {
  a = a[Za];return a instanceof Wa ? a : null;
}var mb = "__closure_events_fn_" + (1E9 * Math.random() >>> 0);function db(a) {
  if ("function" == p(a)) return a;a[mb] || (a[mb] = function (b) {
    return a.handleEvent(b);
  });return a[mb];
}function G() {
  y.call(this);this.c = new Wa(this);this.J = this;this.B = null;
}x(G, y);G.prototype[E] = !0;g = G.prototype;g.addEventListener = function (a, b, c, d) {
  bb(this, a, b, c, d);
};g.removeEventListener = function (a, b, c, d) {
  jb(this, a, b, c, d);
};
g.dispatchEvent = function (a) {
  var b,
      c = this.B;if (c) for (b = []; c; c = c.B) b.push(c);c = this.J;var d = a.type || a;if (m(a)) a = new C(a, c);else if (a instanceof C) a.target = a.target || c;else {
    var e = a;a = new C(d, c);ya(a, e);
  }e = !0;if (b) for (var f = b.length - 1; 0 <= f; f--) {
    var h = a.a = b[f];e = nb(h, d, !0, a) && e;
  }h = a.a = c;e = nb(h, d, !0, a) && e;e = nb(h, d, !1, a) && e;if (b) for (f = 0; f < b.length; f++) h = a.a = b[f], e = nb(h, d, !1, a) && e;return e;
};
g.G = function () {
  G.N.G.call(this);if (this.c) {
    var a = this.c,
        c;for (c in a.a) {
      for (var d = a.a[c], e = 0; e < d.length; e++) Va(d[e]);delete a.a[c];a.b--;
    }
  }this.B = null;
};g.Aa = function (a, b, c, d) {
  return this.c.add(String(a), b, !1, c, d);
};g.Ba = function (a, b, c, d) {
  return this.c.add(String(a), b, !0, c, d);
};
function nb(a, b, c, d) {
  b = a.c.a[String(b)];if (!b) return !0;b = b.concat();for (var e = !0, f = 0; f < b.length; ++f) {
    var h = b[f];if (h && !h.X && h.capture == c) {
      var l = h.listener,
          F = h.da || h.src;h.Z && Ya(a.c, h);e = !1 !== l.call(F, d) && e;
    }
  }return e && 0 != d.Ja;
}var ob = k.JSON.stringify;function pb(a, b) {
  this.c = a;this.f = b;this.b = 0;this.a = null;
}pb.prototype.get = function () {
  if (0 < this.b) {
    this.b--;var a = this.a;this.a = a.next;a.next = null;
  } else a = this.c();return a;
};function qb() {
  this.b = this.a = null;
}var sb = new pb(function () {
  return new rb();
}, function (a) {
  a.reset();
});qb.prototype.add = function (a, b) {
  var c = sb.get();c.set(a, b);this.b ? this.b.next = c : this.a = c;this.b = c;
};function tb() {
  var a = ub,
      b = null;a.a && (b = a.a, a.a = a.a.next, a.a || (a.b = null), b.next = null);return b;
}function rb() {
  this.next = this.b = this.a = null;
}rb.prototype.set = function (a, b) {
  this.a = a;this.b = b;this.next = null;
};rb.prototype.reset = function () {
  this.next = this.b = this.a = null;
};function vb(a) {
  k.setTimeout(function () {
    throw a;
  }, 0);
}function wb(a, b) {
  xb || yb();zb || (xb(), zb = !0);ub.add(a, b);
}var xb;function yb() {
  var a = k.Promise.resolve(void 0);xb = function () {
    a.then(Ab);
  };
}var zb = !1,
    ub = new qb();function Ab() {
  for (var a; a = tb();) {
    try {
      a.a.call(a.b);
    } catch (c) {
      vb(c);
    }var b = sb;b.f(a);100 > b.b && (b.b++, a.next = b.a, b.a = a);
  }zb = !1;
}function Cb(a, b) {
  G.call(this);this.b = a || 1;this.a = b || k;this.f = u(this.gb, this);this.g = w();
}x(Cb, G);g = Cb.prototype;g.ba = !1;g.L = null;g.gb = function () {
  if (this.ba) {
    var a = w() - this.g;0 < a && a < .8 * this.b ? this.L = this.a.setTimeout(this.f, this.b - a) : (this.L && (this.a.clearTimeout(this.L), this.L = null), this.dispatchEvent("tick"), this.ba && (Db(this), this.start()));
  }
};g.start = function () {
  this.ba = !0;this.L || (this.L = this.a.setTimeout(this.f, this.b), this.g = w());
};function Db(a) {
  a.ba = !1;a.L && (a.a.clearTimeout(a.L), a.L = null);
}
g.G = function () {
  Cb.N.G.call(this);Db(this);delete this.a;
};function Eb(a, b, c) {
  if ("function" == p(a)) c && (a = u(a, c));else if (a && "function" == typeof a.handleEvent) a = u(a.handleEvent, a);else throw Error("Invalid listener argument");return 2147483647 < Number(b) ? -1 : k.setTimeout(a, b || 0);
}function Fb(a, b, c) {
  y.call(this);this.f = null != c ? u(a, c) : a;this.c = b;this.b = u(this.ab, this);this.a = [];
}x(Fb, y);g = Fb.prototype;g.ea = !1;g.U = null;g.Ua = function (a) {
  this.a = arguments;this.U ? this.ea = !0 : Gb(this);
};g.G = function () {
  Fb.N.G.call(this);this.U && (k.clearTimeout(this.U), this.U = null, this.ea = !1, this.a = []);
};g.ab = function () {
  this.U = null;this.ea && (this.ea = !1, Gb(this));
};function Gb(a) {
  a.U = Eb(a.b, a.c);a.f.apply(null, a.a);
}function H(a) {
  y.call(this);this.b = a;this.a = {};
}x(H, y);var Hb = [];function Ib(a, b, c, d) {
  q(c) || (c && (Hb[0] = c.toString()), c = Hb);for (var e = 0; e < c.length; e++) {
    var f = bb(b, c[e], d || a.handleEvent, !1, a.b || a);if (!f) break;a.a[f.key] = f;
  }
}function Jb(a) {
  va(a.a, function (b, c) {
    this.a.hasOwnProperty(c) && kb(b);
  }, a);a.a = {};
}H.prototype.G = function () {
  H.N.G.call(this);Jb(this);
};H.prototype.handleEvent = function () {
  throw Error("EventHandler.handleEvent not implemented");
};function Kb() {}var I = new G();function Lb(a) {
  C.call(this, "serverreachability", a);
}x(Lb, C);function J(a) {
  I.dispatchEvent(new Lb(I, a));
}function Mb(a) {
  C.call(this, "statevent", a);
}x(Mb, C);function K(a) {
  I.dispatchEvent(new Mb(I, a));
}function Nb(a) {
  C.call(this, "timingevent", a);
}x(Nb, C);function Ob(a, b) {
  if ("function" != p(a)) throw Error("Fn must not be null and must be a function");return k.setTimeout(function () {
    a();
  }, b);
}var Pb = { NO_ERROR: 0, hb: 1, ob: 2, nb: 3, kb: 4, mb: 5, pb: 6, Ma: 7, TIMEOUT: 8, sb: 9 };var Qb = { jb: "complete", wb: "success", Na: "error", Ma: "abort", ub: "ready", vb: "readystatechange", TIMEOUT: "timeout", qb: "incrementaldata", tb: "progress", lb: "downloadprogress", xb: "uploadprogress" };function Rb() {}Rb.prototype.a = null;function Sb(a) {
  var b;(b = a.a) || (b = a.a = {});return b;
}function Tb() {}var L = { OPEN: "a", ib: "b", Na: "c", rb: "d" };function Ub() {
  C.call(this, "d");
}x(Ub, C);function Vb() {
  C.call(this, "c");
}x(Vb, C);var Wb;function Xb() {}x(Xb, Rb);Wb = new Xb();function M(a, b, c) {
  this.g = a;this.W = b;this.V = c || 1;this.I = new H(this);this.O = Yb;a = Ea ? 125 : void 0;this.P = new Cb(a);this.h = null;this.b = !1;this.l = this.D = this.f = this.F = this.v = this.R = this.i = null;this.j = [];this.a = null;this.A = 0;this.c = this.w = null;this.o = -1;this.m = !1;this.J = 0;this.B = null;this.s = this.S = this.H = !1;
}var Yb = 45E3,
    Zb = {},
    $b = {};g = M.prototype;g.setTimeout = function (a) {
  this.O = a;
};function ac(a, b, c) {
  a.F = 1;a.f = bc(N(b));a.l = c;a.H = !0;cc(a, null);
}function dc(a, b, c, d) {
  a.F = 1;a.f = bc(N(b));a.l = null;a.H = c;cc(a, d);
}
function cc(a, b) {
  a.v = w();ec(a);a.D = N(a.f);fc(a.D, "t", a.V);a.A = 0;a.a = a.g.$(a.g.Y() ? b : null);0 < a.J && (a.B = new Fb(u(a.Ka, a, a.a), a.J));Ib(a.I, a.a, "readystatechange", a.eb);b = a.h ? wa(a.h) : {};a.l ? (a.w || (a.w = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.a.ca(a.D, a.w, a.l, b)) : (a.w = "GET", a.a.ca(a.D, a.w, null, b));J(1);
}g.eb = function (a) {
  a = a.target;var b = this.B;b && 3 == O(a) ? b.Ua() : this.Ka(a);
};
g.Ka = function (a) {
  try {
    if (a == this.a) a: {
      var b = O(this.a),
          c = this.a.ya(),
          d = this.a.T();if (!(3 > b || 3 == b && !Ea && !this.a.aa())) {
        this.m || 4 != b || 7 == c || (8 == c || 0 >= d ? J(3) : J(2));gc(this);var e = this.a.T();this.o = e;var f = this.a.aa();if (this.b = 200 == e) {
          if (this.S && !this.s) {
            b: {
              if (this.a) {
                var h = hc(this.a, "X-HTTP-Initial-Response");if (h && !qa(h)) {
                  var l = h;break b;
                }
              }l = null;
            }if (l) this.s = !0, ic(this, l);else {
              this.b = !1;this.c = 3;K(12);P(this);jc(this);break a;
            }
          }this.H ? (kc(this, b, f), Ea && this.b && 3 == b && (Ib(this.I, this.P, "tick", this.cb), this.P.start())) : ic(this, f);4 == b && P(this);this.b && !this.m && (4 == b ? this.g.na(this) : (this.b = !1, ec(this)));
        } else 400 == e && 0 < f.indexOf("Unknown SID") ? (this.c = 3, K(12)) : (this.c = 0, K(13)), P(this), jc(this);
      }
    }
  } catch (F) {} finally {}
};function kc(a, b, c) {
  for (var d = !0; !a.m && a.A < c.length;) {
    var e = lc(a, c);if (e == $b) {
      4 == b && (a.c = 4, K(14), d = !1);break;
    } else if (e == Zb) {
      a.c = 4;K(15);d = !1;break;
    } else ic(a, e);
  }4 == b && 0 == c.length && (a.c = 1, K(16), d = !1);a.b = a.b && d;d || (P(a), jc(a));
}
g.cb = function () {
  if (this.a) {
    var a = O(this.a),
        b = this.a.aa();this.A < b.length && (gc(this), kc(this, a, b), this.b && 4 != a && ec(this));
  }
};function lc(a, b) {
  var c = a.A,
      d = b.indexOf("\n", c);if (-1 == d) return $b;c = Number(b.substring(c, d));if (isNaN(c)) return Zb;d += 1;if (d + c > b.length) return $b;b = b.substr(d, c);a.A = d + c;return b;
}g.cancel = function () {
  this.m = !0;P(this);
};function ec(a) {
  a.R = w() + a.O;mc(a, a.O);
}function mc(a, b) {
  if (null != a.i) throw Error("WatchDog timer not null");a.i = Ob(u(a.bb, a), b);
}
function gc(a) {
  a.i && (k.clearTimeout(a.i), a.i = null);
}g.bb = function () {
  this.i = null;var a = w();0 <= a - this.R ? (2 != this.F && (J(3), K(17)), P(this), this.c = 2, jc(this)) : mc(this, this.R - a);
};function jc(a) {
  a.g.Da() || a.m || a.g.na(a);
}function P(a) {
  gc(a);var b = a.B;b && "function" == typeof b.la && b.la();a.B = null;Db(a.P);Jb(a.I);a.a && (b = a.a, a.a = null, b.abort(), b.la());
}function ic(a, b) {
  try {
    a.g.Ga(a, b), J(4);
  } catch (c) {}
}function nc(a) {
  if (a.C && "function" == typeof a.C) return a.C();if (m(a)) return a.split("");if (ca(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++) b.push(a[d]);return b;
  }b = [];c = 0;for (d in a) b[c++] = a[d];return b;
}
function oc(a, b) {
  if (a.forEach && "function" == typeof a.forEach) a.forEach(b, void 0);else if (ca(a) || m(a)) la(a, b, void 0);else {
    if (a.K && "function" == typeof a.K) var c = a.K();else if (a.C && "function" == typeof a.C) c = void 0;else if (ca(a) || m(a)) {
      c = [];for (var d = a.length, e = 0; e < d; e++) c.push(e);
    } else for (e in c = [], d = 0, a) c[d++] = e;d = nc(a);e = d.length;for (var f = 0; f < e; f++) b.call(void 0, d[f], c && c[f], a);
  }
}function Q(a, b) {
  this.b = {};this.a = [];this.c = 0;var c = arguments.length;if (1 < c) {
    if (c % 2) throw Error("Uneven number of arguments");for (var d = 0; d < c; d += 2) this.set(arguments[d], arguments[d + 1]);
  } else if (a) if (a instanceof Q) for (c = a.K(), d = 0; d < c.length; d++) this.set(c[d], a.get(c[d]));else for (d in a) this.set(d, a[d]);
}g = Q.prototype;g.C = function () {
  pc(this);for (var a = [], b = 0; b < this.a.length; b++) a.push(this.b[this.a[b]]);return a;
};g.K = function () {
  pc(this);return this.a.concat();
};
function qc(a) {
  a.b = {};a.a.length = 0;a.c = 0;
}function rc(a, b) {
  R(a.b, b) && (delete a.b[b], a.c--, a.a.length > 2 * a.c && pc(a));
}function pc(a) {
  if (a.c != a.a.length) {
    for (var b = 0, c = 0; b < a.a.length;) {
      var d = a.a[b];R(a.b, d) && (a.a[c++] = d);b++;
    }a.a.length = c;
  }if (a.c != a.a.length) {
    var e = {};for (c = b = 0; b < a.a.length;) d = a.a[b], R(e, d) || (a.a[c++] = d, e[d] = 1), b++;a.a.length = c;
  }
}g.get = function (a, b) {
  return R(this.b, a) ? this.b[a] : b;
};g.set = function (a, b) {
  R(this.b, a) || (this.c++, this.a.push(a));this.b[a] = b;
};
g.forEach = function (a, b) {
  for (var c = this.K(), d = 0; d < c.length; d++) {
    var e = c[d],
        f = this.get(e);a.call(b, f, e, this);
  }
};function R(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}var sc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;function tc(a, b) {
  if (a) {
    a = a.split("&");for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="),
          e = null;if (0 <= d) {
        var f = a[c].substring(0, d);e = a[c].substring(d + 1);
      } else f = a[c];b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}function S(a, b) {
  this.b = this.j = this.f = "";this.i = null;this.g = this.a = "";this.h = !1;var c;a instanceof S ? (this.h = void 0 !== b ? b : a.h, uc(this, a.f), this.j = a.j, vc(this, a.b), wc(this, a.i), this.a = a.a, xc(this, yc(a.c)), this.g = a.g) : a && (c = String(a).match(sc)) ? (this.h = !!b, uc(this, c[1] || "", !0), this.j = zc(c[2] || ""), vc(this, c[3] || "", !0), wc(this, c[4]), this.a = zc(c[5] || "", !0), xc(this, c[6] || "", !0), this.g = zc(c[7] || "")) : (this.h = !!b, this.c = new Ac(null, this.h));
}
S.prototype.toString = function () {
  var a = [],
      b = this.f;b && a.push(Bc(b, Cc, !0), ":");var c = this.b;if (c || "file" == b) a.push("//"), (b = this.j) && a.push(Bc(b, Cc, !0), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.i, null != c && a.push(":", String(c));if (c = this.a) this.b && "/" != c.charAt(0) && a.push("/"), a.push(Bc(c, "/" == c.charAt(0) ? Dc : Ec, !0));(c = this.c.toString()) && a.push("?", c);(c = this.g) && a.push("#", Bc(c, Fc));return a.join("");
};
S.prototype.resolve = function (a) {
  var b = N(this),
      c = !!a.f;c ? uc(b, a.f) : c = !!a.j;c ? b.j = a.j : c = !!a.b;c ? vc(b, a.b) : c = null != a.i;var d = a.a;if (c) wc(b, a.i);else if (c = !!a.a) {
    if ("/" != d.charAt(0)) if (this.b && !this.a) d = "/" + d;else {
      var e = b.a.lastIndexOf("/");-1 != e && (d = b.a.substr(0, e + 1) + d);
    }e = d;if (".." == e || "." == e) d = "";else if (z(e, "./") || z(e, "/.")) {
      d = 0 == e.lastIndexOf("/", 0);e = e.split("/");for (var f = [], h = 0; h < e.length;) {
        var l = e[h++];"." == l ? d && h == e.length && f.push("") : ".." == l ? ((1 < f.length || 1 == f.length && "" != f[0]) && f.pop(), d && h == e.length && f.push("")) : (f.push(l), d = !0);
      }d = f.join("/");
    } else d = e;
  }c ? b.a = d : c = "" !== a.c.toString();c ? xc(b, yc(a.c)) : c = !!a.g;c && (b.g = a.g);return b;
};function N(a) {
  return new S(a);
}function uc(a, b, c) {
  a.f = c ? zc(b, !0) : b;a.f && (a.f = a.f.replace(/:$/, ""));
}function vc(a, b, c) {
  a.b = c ? zc(b, !0) : b;
}function wc(a, b) {
  if (b) {
    b = Number(b);if (isNaN(b) || 0 > b) throw Error("Bad port number " + b);a.i = b;
  } else a.i = null;
}function xc(a, b, c) {
  b instanceof Ac ? (a.c = b, Gc(a.c, a.h)) : (c || (b = Bc(b, Hc)), a.c = new Ac(b, a.h));
}
function T(a, b, c) {
  a.c.set(b, c);
}function fc(a, b, c) {
  q(c) || (c = [String(c)]);Ic(a.c, b, c);
}function bc(a) {
  T(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ w()).toString(36));return a;
}function Jc(a) {
  return a instanceof S ? N(a) : new S(a, void 0);
}function Kc(a, b, c, d) {
  var e = new S(null, void 0);a && uc(e, a);b && vc(e, b);c && wc(e, c);d && (e.a = d);return e;
}function zc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Bc(a, b, c) {
  return m(a) ? (a = encodeURI(a).replace(b, Lc), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}function Lc(a) {
  a = a.charCodeAt(0);return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}var Cc = /[#\/\?@]/g,
    Ec = /[#\?:]/g,
    Dc = /[#\?]/g,
    Hc = /[#\?@]/g,
    Fc = /#/g;function Ac(a, b) {
  this.b = this.a = null;this.c = a || null;this.f = !!b;
}function U(a) {
  a.a || (a.a = new Q(), a.b = 0, a.c && tc(a.c, function (b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}g = Ac.prototype;
g.add = function (a, b) {
  U(this);this.c = null;a = V(this, a);var c = this.a.get(a);c || this.a.set(a, c = []);c.push(b);this.b += 1;return this;
};function Mc(a, b) {
  U(a);b = V(a, b);R(a.a.b, b) && (a.c = null, a.b -= a.a.get(b).length, rc(a.a, b));
}function Nc(a, b) {
  U(a);b = V(a, b);return R(a.a.b, b);
}g.forEach = function (a, b) {
  U(this);this.a.forEach(function (c, d) {
    la(c, function (e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
g.K = function () {
  U(this);for (var a = this.a.C(), b = this.a.K(), c = [], d = 0; d < b.length; d++) for (var e = a[d], f = 0; f < e.length; f++) c.push(b[d]);return c;
};g.C = function (a) {
  U(this);var b = [];if (m(a)) Nc(this, a) && (b = oa(b, this.a.get(V(this, a))));else {
    a = this.a.C();for (var c = 0; c < a.length; c++) b = oa(b, a[c]);
  }return b;
};g.set = function (a, b) {
  U(this);this.c = null;a = V(this, a);Nc(this, a) && (this.b -= this.a.get(a).length);this.a.set(a, [b]);this.b += 1;return this;
};
g.get = function (a, b) {
  if (!a) return b;a = this.C(a);return 0 < a.length ? String(a[0]) : b;
};function Ic(a, b, c) {
  Mc(a, b);0 < c.length && (a.c = null, a.a.set(V(a, b), pa(c)), a.b += c.length);
}g.toString = function () {
  if (this.c) return this.c;if (!this.a) return "";for (var a = [], b = this.a.K(), c = 0; c < b.length; c++) {
    var d = b[c],
        e = encodeURIComponent(String(d));d = this.C(d);for (var f = 0; f < d.length; f++) {
      var h = e;"" !== d[f] && (h += "=" + encodeURIComponent(String(d[f])));a.push(h);
    }
  }return this.c = a.join("&");
};
function yc(a) {
  var b = new Ac();b.c = a.c;a.a && (b.a = new Q(a.a), b.b = a.b);return b;
}function V(a, b) {
  b = String(b);a.f && (b = b.toLowerCase());return b;
}function Gc(a, b) {
  b && !a.f && (U(a), a.c = null, a.a.forEach(function (c, d) {
    var e = d.toLowerCase();d != e && (Mc(this, d), Ic(this, e, c));
  }, a));a.f = b;
}function Qc() {}function Rc() {}x(Rc, Qc);function Sc(a) {
  this.a = a;this.b = this.h = null;this.g = !1;this.i = null;this.c = -1;this.l = this.f = null;
}g = Sc.prototype;g.M = null;function Uc(a) {
  var b = a.a.F.a;if (null != b) K(4), b ? (K(10), Vc(a.a, a, !1)) : (K(11), Vc(a.a, a, !0));else {
    a.b = new M(a, void 0, void 0);a.b.h = a.h;b = a.a;b = Wc(b, b.Y() ? a.f : null, a.i);K(4);fc(b, "TYPE", "xmlhttp");var c = a.a.j,
        d = a.a.I;c && d && T(b, c, d);dc(a.b, b, !1, a.f);
  }
}g.$ = function (a) {
  return this.a.$(a);
};g.abort = function () {
  this.b && (this.b.cancel(), this.b = null);this.c = -1;
};g.Da = function () {
  return !1;
};
g.Ga = function (a, b) {
  this.c = a.o;if (0 == this.M) {
    if (!this.a.o && (a = a.a)) {
      var c = hc(a, "X-Client-Wire-Protocol");this.l = c ? c : null;this.a.j && (a = hc(a, "X-HTTP-Session-Id")) && (this.a.I = a);
    }if (b) {
      try {
        var d = this.a.ja.a.parse(b);
      } catch (e) {
        b = this.a;b.m = this.c;W(b, 2);return;
      }this.f = d[0];
    } else b = this.a, b.m = this.c, W(b, 2);
  } else if (1 == this.M) if (this.g) K(6);else if ("11111" == b) {
    if (K(5), this.g = !0, !B || 10 <= Number(Na)) this.c = 200, this.b.cancel(), K(11), Vc(this.a, this, !0);
  } else K(7), this.g = !1;
};
g.na = function () {
  this.c = this.b.o;if (this.b.b) 0 == this.M ? (this.M = 1, Uc(this)) : 1 == this.M && (this.g ? (K(11), Vc(this.a, this, !0)) : (K(10), Vc(this.a, this, !1)));else {
    0 == this.M ? K(8) : 1 == this.M && K(9);var a = this.a;a.m = this.c;W(a, 2);
  }
};g.Y = function () {
  return this.a.Y();
};g.ma = function () {
  return this.a.ma();
};function Xc() {
  this.a = this.b = null;
}function Yc() {
  this.a = new Q();
}function Zc(a) {
  var b = typeof a;return "object" == b && a || "function" == b ? "o" + (a[t] || (a[t] = ++da)) : b.charAt(0) + a;
}Yc.prototype.add = function (a) {
  this.a.set(Zc(a), a);
};Yc.prototype.C = function () {
  return this.a.C();
};function $c(a, b) {
  this.b = a;this.a = b;
}function ad(a) {
  this.g = a || bd;k.PerformanceNavigationTiming ? (a = k.performance.getEntriesByType("navigation"), a = 0 < a.length && ("hq" == a[0].nextHopProtocol || "h2" == a[0].nextHopProtocol)) : a = !!(k.ka && k.ka.Ea && k.ka.Ea() && k.ka.Ea().zb);this.f = a ? this.g : 1;this.a = null;1 < this.f && (this.a = new Yc());this.b = null;this.c = [];
}var bd = 10;function cd(a, b) {
  !a.a && (z(b, "spdy") || z(b, "quic") || z(b, "h2")) && (a.f = a.g, a.a = new Yc(), a.b && (dd(a, a.b), a.b = null));
}function ed(a) {
  return a.b ? !0 : a.a ? a.a.a.c >= a.f : !1;
}
function fd(a) {
  return a.b ? 1 : a.a ? a.a.a.c : 0;
}function gd(a, b) {
  a.b ? a = a.b == b : a.a ? (b = Zc(b), a = R(a.a.a.b, b)) : a = !1;return a;
}function dd(a, b) {
  a.a ? a.a.add(b) : a.b = b;
}function hd(a, b) {
  if (a.b && a.b == b) a.b = null;else {
    var c;if (c = a.a) c = Zc(b), c = R(a.a.a.b, c);c && rc(a.a.a, Zc(b));
  }
}ad.prototype.cancel = function () {
  this.c = id(this);this.b ? (this.b.cancel(), this.b = null) : this.a && 0 != this.a.a.c && (la(this.a.C(), function (a) {
    a.cancel();
  }), qc(this.a.a));
};
function id(a) {
  if (null != a.b) return a.c.concat(a.b.j);if (null != a.a && 0 != a.a.a.c) {
    var b = a.c;la(a.a.C(), function (c) {
      b = b.concat(c.j);
    });return b;
  }return pa(a.c);
}function jd() {}jd.prototype.stringify = function (a) {
  return k.JSON.stringify(a, void 0);
};jd.prototype.parse = function (a) {
  return k.JSON.parse(a, void 0);
};function kd() {
  this.a = new jd();
}function ld(a, b, c) {
  var d = c || "";try {
    oc(a, function (e, f) {
      var h = e;r(e) && (h = ob(e));b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}function md(a, b) {
  var c = new Kb();if (k.Image) {
    var d = new Image();d.onload = v(nd, c, d, "TestLoadImage: loaded", !0, b);d.onerror = v(nd, c, d, "TestLoadImage: error", !1, b);d.onabort = v(nd, c, d, "TestLoadImage: abort", !1, b);d.ontimeout = v(nd, c, d, "TestLoadImage: timeout", !1, b);k.setTimeout(function () {
      if (d.ontimeout) d.ontimeout();
    }, 1E4);d.src = a;
  } else b(!1);
}function nd(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {}
}var od = k.JSON.parse;function X(a) {
  G.call(this);this.headers = new Q();this.H = a || null;this.b = !1;this.s = this.a = null;this.A = "";this.h = 0;this.f = "";this.g = this.w = this.l = this.v = !1;this.o = 0;this.m = null;this.I = pd;this.D = this.F = !1;
}x(X, G);var pd = "",
    qd = /^https?$/i,
    rd = ["POST", "PUT"];g = X.prototype;
g.ca = function (a, b, c, d) {
  if (this.a) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.A + "; newUri=" + a);b = b ? b.toUpperCase() : "GET";this.A = a;this.f = "";this.h = 0;this.v = !1;this.b = !0;this.a = new XMLHttpRequest();this.s = this.H ? Sb(this.H) : Sb(Wb);this.a.onreadystatechange = u(this.Fa, this);try {
    this.w = !0, this.a.open(b, String(a), !0), this.w = !1;
  } catch (f) {
    sd(this, f);return;
  }a = c || "";var e = new Q(this.headers);d && oc(d, function (f, h) {
    e.set(h, f);
  });d = ma(e.K());c = k.FormData && a instanceof k.FormData;!(0 <= ja(rd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");e.forEach(function (f, h) {
    this.a.setRequestHeader(h, f);
  }, this);this.I && (this.a.responseType = this.I);"withCredentials" in this.a && this.a.withCredentials !== this.F && (this.a.withCredentials = this.F);try {
    td(this), 0 < this.o && ((this.D = ud(this.a)) ? (this.a.timeout = this.o, this.a.ontimeout = u(this.Ca, this)) : this.m = Eb(this.Ca, this.o, this)), this.l = !0, this.a.send(a), this.l = !1;
  } catch (f) {
    sd(this, f);
  }
};
function ud(a) {
  return B && Ma(9) && aa(a.timeout) && void 0 !== a.ontimeout;
}function na(a) {
  return "content-type" == a.toLowerCase();
}g.Ca = function () {
  "undefined" != typeof goog && this.a && (this.f = "Timed out after " + this.o + "ms, aborting", this.h = 8, this.dispatchEvent("timeout"), this.abort(8));
};function sd(a, b) {
  a.b = !1;a.a && (a.g = !0, a.a.abort(), a.g = !1);a.f = b;a.h = 5;vd(a);wd(a);
}function vd(a) {
  a.v || (a.v = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"));
}
g.abort = function (a) {
  this.a && this.b && (this.b = !1, this.g = !0, this.a.abort(), this.g = !1, this.h = a || 7, this.dispatchEvent("complete"), this.dispatchEvent("abort"), wd(this));
};g.G = function () {
  this.a && (this.b && (this.b = !1, this.g = !0, this.a.abort(), this.g = !1), wd(this, !0));X.N.G.call(this);
};g.Fa = function () {
  this.j || (this.w || this.l || this.g ? xd(this) : this.$a());
};g.$a = function () {
  xd(this);
};
function xd(a) {
  if (a.b && "undefined" != typeof goog && (!a.s[1] || 4 != O(a) || 2 != a.T())) if (a.l && 4 == O(a)) Eb(a.Fa, 0, a);else if (a.dispatchEvent("readystatechange"), 4 == O(a)) {
    a.b = !1;try {
      var b = a.T();a: switch (b) {case 200:case 201:case 202:case 204:case 206:case 304:case 1223:
          var c = !0;break a;default:
          c = !1;}var d;if (!(d = c)) {
        var e;if (e = 0 === b) {
          var f = String(a.A).match(sc)[1] || null;if (!f && k.self && k.self.location) {
            var h = k.self.location.protocol;f = h.substr(0, h.length - 1);
          }e = !qd.test(f ? f.toLowerCase() : "");
        }d = e;
      }d ? (a.dispatchEvent("complete"), a.dispatchEvent("success")) : (a.h = 6, a.f = a.za() + " [" + a.T() + "]", vd(a));
    } finally {
      wd(a);
    }
  }
}function wd(a, b) {
  if (a.a) {
    td(a);var c = a.a,
        d = a.s[0] ? ba : null;a.a = null;a.s = null;b || a.dispatchEvent("ready");try {
      c.onreadystatechange = d;
    } catch (e) {}
  }
}function td(a) {
  a.a && a.D && (a.a.ontimeout = null);a.m && (k.clearTimeout(a.m), a.m = null);
}function O(a) {
  return a.a ? a.a.readyState : 0;
}g.T = function () {
  try {
    return 2 < O(this) ? this.a.status : -1;
  } catch (a) {
    return -1;
  }
};g.za = function () {
  try {
    return 2 < O(this) ? this.a.statusText : "";
  } catch (a) {
    return "";
  }
};
g.aa = function () {
  try {
    return this.a ? this.a.responseText : "";
  } catch (a) {
    return "";
  }
};g.Va = function (a) {
  if (this.a) {
    var b = this.a.responseText;a && 0 == b.indexOf(a) && (b = b.substring(a.length));return od(b);
  }
};function hc(a, b) {
  return a.a ? a.a.getResponseHeader(b) : null;
}g.ya = function () {
  return this.h;
};g.Ya = function () {
  return m(this.f) ? this.f : String(this.f);
};function yd(a) {
  var b = "";va(a, function (c, d) {
    b += d;b += ":";b += c;b += "\r\n";
  });return b;
}function zd(a, b, c) {
  a: {
    for (d in c) {
      var d = !1;break a;
    }d = !0;
  }if (d) return a;c = yd(c);if (m(a)) {
    b = encodeURIComponent(String(b));c = null != c ? "=" + encodeURIComponent(String(c)) : "";if (b += c) {
      c = a.indexOf("#");0 > c && (c = a.length);d = a.indexOf("?");if (0 > d || d > c) {
        d = c;var e = "";
      } else e = a.substring(d + 1, c);a = [a.substr(0, d), e, a.substr(c)];c = a[1];a[1] = b ? c ? c + "&" + b : b : c;a = a[0] + (a[1] ? "?" + a[1] : "") + a[2];
    }return a;
  }T(a, b, c);return a;
}function Ad(a) {
  this.f = [];this.F = new Xc();this.ga = this.pa = this.B = this.ha = this.a = this.I = this.j = this.V = this.g = this.J = this.i = null;this.Ra = this.P = 0;this.Pa = !!n("internalChannelParams.failFast", a);this.ia = this.w = this.s = this.l = this.h = this.c = null;this.oa = !0;this.m = this.ra = this.O = -1;this.S = this.v = this.A = 0;this.Oa = n("internalChannelParams.baseRetryDelayMs", a) || 5E3;this.Sa = n("internalChannelParams.retryDelaySeedMs", a) || 1E4;this.Qa = n("internalChannelParams.forwardChannelMaxRetries", a) || 2;this.qa = n("internalChannelParams.forwardChannelRequestTimeoutMs", a) || 2E4;this.La = a && a.Ab || void 0;this.D = void 0;this.R = a && a.supportsCrossDomainXhr || !1;this.H = "";this.b = new ad(a && a.concurrentRequestLimit);this.ja = new kd();this.o = a && void 0 !== a.backgroundChannelTest ? a.backgroundChannelTest : !0;(this.W = a && a.fastHandshake || !1) && !this.o && (this.o = !0);a && a.forceLongPolling && (this.oa = !1);this.fa = void 0;
}g = Ad.prototype;g.wa = 8;g.u = 1;
function Bd(a) {
  Cd(a);if (3 == a.u) {
    var b = a.P++,
        c = N(a.B);T(c, "SID", a.H);T(c, "RID", b);T(c, "TYPE", "terminate");Dd(a, c);b = new M(a, b, void 0);b.F = 2;b.f = bc(N(c));c = !1;k.navigator && k.navigator.sendBeacon && (c = k.navigator.sendBeacon(b.f.toString(), ""));!c && k.Image && (new Image().src = b.f, c = !0);c || (b.a = b.g.$(null), b.a.ca(b.f));b.v = w();ec(b);
  }Ed(a);
}
function Cd(a) {
  a.w && (a.w.abort(), a.w = null);a.a && (a.a.cancel(), a.a = null);a.l && (k.clearTimeout(a.l), a.l = null);Fd(a);a.b.cancel();a.h && (aa(a.h) && k.clearTimeout(a.h), a.h = null);
}function Gd(a, b) {
  a.f.push(new $c(a.Ra++, b));3 == a.u && Hd(a);
}g.Da = function () {
  return 0 == this.u;
};function Hd(a) {
  ed(a.b) || a.h || (a.h = !0, wb(a.Ia, a), a.A = 0);
}
function Id(a, b) {
  if (fd(a.b) >= a.b.f - (a.h ? 1 : 0)) return !1;if (a.h) return a.f = b.j.concat(a.f), !0;if (1 == a.u || 2 == a.u || a.A >= (a.Pa ? 0 : a.Qa)) return !1;a.h = Ob(u(a.Ia, a, b), Jd(a, a.A));a.A++;return !0;
}
g.Ia = function (a) {
  if (this.h) if (this.h = null, 1 == this.u) {
    if (!a) {
      this.P = Math.floor(1E5 * Math.random());a = this.P++;var b = new M(this, a, void 0),
          c = this.i;this.J && (c ? (c = wa(c), ya(c, this.J)) : c = this.J);null === this.g && (b.h = c);var d;if (this.W) a: {
        for (var e = d = 0; e < this.f.length; e++) {
          b: {
            var f = this.f[e];if ("__data__" in f.a && (f = f.a.__data__, m(f))) {
              f = f.length;break b;
            }f = void 0;
          }if (void 0 === f) break;d += f;if (4096 < d) {
            d = e;break a;
          }if (4096 === d || e === this.f.length - 1) {
            d = e + 1;break a;
          }
        }d = 1E3;
      } else d = 1E3;d = Kd(this, b, d);e = N(this.B);T(e, "RID", a);T(e, "CVER", 22);this.o && this.j && T(e, "X-HTTP-Session-Id", this.j);Dd(this, e);this.g && c && zd(e, this.g, c);dd(this.b, b);this.W ? (T(e, "$req", d), T(e, "SID", "null"), b.S = !0, ac(b, e, null)) : ac(b, e, d);this.u = 2;
    }
  } else 3 == this.u && (a ? Ld(this, a) : 0 == this.f.length || ed(this.b) || Ld(this));
};
function Ld(a, b) {
  var c;b ? c = b.W : c = a.P++;var d = N(a.B);T(d, "SID", a.H);T(d, "RID", c);T(d, "AID", a.O);Dd(a, d);a.g && a.i && zd(d, a.g, a.i);c = new M(a, c, a.A + 1);null === a.g && (c.h = a.i);b && (a.f = b.j.concat(a.f));b = Kd(a, c, 1E3);c.setTimeout(Math.round(.5 * a.qa) + Math.round(.5 * a.qa * Math.random()));dd(a.b, c);ac(c, d, b);
}function Dd(a, b) {
  a.c && oc({}, function (c, d) {
    T(b, d, c);
  });
}
function Kd(a, b, c) {
  c = Math.min(a.f.length, c);var d = a.c ? u(a.c.Ta, a.c, a) : null;a: for (var e = a.f, f = -1;;) {
    var h = ["count=" + c];-1 == f ? 0 < c ? (f = e[0].b, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);for (var l = !0, F = 0; F < c; F++) {
      var Bb = e[F].b,
          Tc = e[F].a;Bb -= f;if (0 > Bb) f = Math.max(0, e[F].b - 100), l = !1;else try {
        ld(Tc, h, "req" + Bb + "_");
      } catch (Ud) {
        d && d(Tc);
      }
    }if (l) {
      d = h.join("&");break a;
    }
  }a = a.f.splice(0, c);b.j = a;return d;
}function Md(a) {
  a.a || a.l || (a.S = 1, wb(a.Ha, a), a.v = 0);
}
function Nd(a) {
  if (a.a || a.l || 3 <= a.v) return !1;a.S++;a.l = Ob(u(a.Ha, a), Jd(a, a.v));a.v++;return !0;
}g.Ha = function () {
  this.l = null;this.a = new M(this, "rpc", this.S);null === this.g && (this.a.h = this.i);this.a.J = 0;var a = N(this.pa);T(a, "RID", "rpc");T(a, "SID", this.H);T(a, "CI", this.ia ? "0" : "1");T(a, "AID", this.O);Dd(this, a);T(a, "TYPE", "xmlhttp");this.g && this.i && zd(a, this.g, this.i);this.D && this.a.setTimeout(this.D);dc(this.a, a, !0, this.ga);
};
function Vc(a, b, c) {
  var d = b.l;d && cd(a.b, d);a.ia = a.oa && c;a.m = b.c;a.B = Wc(a, null, a.ha);Hd(a);
}
g.Ga = function (a, b) {
  if (0 != this.u && (this.a == a || gd(this.b, a))) if (this.m = a.o, !a.s && gd(this.b, a) && 3 == this.u) {
    try {
      var c = this.ja.a.parse(b);
    } catch (f) {
      c = null;
    }if (q(c) && 3 == c.length) {
      b = c;if (0 == b[0]) a: {
        if (!this.l) {
          if (this.a) if (this.a.v + 3E3 < a.v) Fd(this), this.a.cancel(), this.a = null;else break a;Nd(this);K(18);
        }
      } else this.ra = b[1], 0 < this.ra - this.O && 37500 > b[2] && this.ia && 0 == this.v && !this.s && (this.s = Ob(u(this.Za, this), 6E3));if (1 >= fd(this.b) && this.fa) {
        try {
          this.fa();
        } catch (f) {}this.fa = void 0;
      }
    } else W(this, 11);
  } else if ((a.s || this.a == a) && Fd(this), !qa(b)) for (b = c = this.ja.a.parse(b), c = 0; c < b.length; c++) {
    var d = b[c];this.O = d[0];d = d[1];if (2 == this.u) {
      if ("c" == d[0]) {
        this.H = d[1];this.ga = d[2];var e = d[3];null != e && (this.wa = e);d = d[5];null != d && aa(d) && 0 < d && (this.D = 1.5 * d);this.o && (d = a.a) && ((e = hc(d, "X-Client-Wire-Protocol")) && cd(this.b, e), this.j && (d = hc(d, "X-HTTP-Session-Id"))) && (this.I = d, T(this.B, this.j, d));this.u = 3;this.c && this.c.va();d = a;this.pa = Wc(this, this.Y() ? this.ga : null, this.ha);d.s ? (hd(this.b, d), (e = this.D) && d.setTimeout(e), d.i && (gc(d), ec(d)), this.a = d) : Md(this);0 < this.f.length && Hd(this);
      } else "stop" != d[0] && "close" != d[0] || W(this, 7);
    } else 3 == this.u && ("stop" == d[0] || "close" == d[0] ? "stop" == d[0] ? W(this, 7) : Bd(this) : "noop" != d[0] && this.c && this.c.ua(d), this.v = 0);
  }
};g.Za = function () {
  null != this.s && (this.s = null, this.a.cancel(), this.a = null, Nd(this), K(19));
};function Fd(a) {
  null != a.s && (k.clearTimeout(a.s), a.s = null);
}
g.na = function (a) {
  var b = null;if (this.a == a) {
    Fd(this);this.a = null;var c = 2;
  } else if (gd(this.b, a)) b = a.j, hd(this.b, a), c = 1;else return;this.m = a.o;if (0 != this.u) if (a.b) 1 == c ? (b = w() - a.v, I.dispatchEvent(new Nb(I, a.l ? a.l.length : 0, b, this.A)), Hd(this)) : Md(this);else {
    var d = a.c;if (3 == d || 0 == d && 0 < this.m || !(1 == c && Id(this, a) || 2 == c && Nd(this))) switch (b && 0 < b.length && (a = this.b, a.c = a.c.concat(b)), d) {case 1:
        W(this, 5);break;case 4:
        W(this, 10);break;case 3:
        W(this, 6);break;default:
        W(this, 2);}
  }
};
function Jd(a, b) {
  var c = a.Oa + Math.floor(Math.random() * a.Sa);a.ma() || (c *= 2);return c * b;
}function W(a, b) {
  if (2 == b) {
    var c = null;a.c && (c = null);var d = u(a.fb, a);c || (c = new S("//www.google.com/images/cleardot.gif"), k.location && "http" == k.location.protocol || uc(c, "https"), bc(c));md(c.toString(), d);
  } else K(2);a.u = 0;a.c && a.c.ta(b);Ed(a);Cd(a);
}g.fb = function (a) {
  a ? K(2) : K(1);
};function Ed(a) {
  a.u = 0;a.m = -1;if (a.c) {
    if (0 != id(a.b).length || 0 != a.f.length) a.b.c.length = 0, pa(a.f), a.f.length = 0;a.c.sa();
  }
}
function Wc(a, b, c) {
  var d = Jc(c);if ("" != d.b) b && vc(d, b + "." + d.b), wc(d, d.i);else {
    var e = k.location,
        f;b ? f = b + "." + e.hostname : f = e.hostname;d = Kc(e.protocol, f, +e.port, c);
  }a.V && va(a.V, function (h, l) {
    T(d, l, h);
  });b = a.j;c = a.I;b && c && T(d, b, c);T(d, "VER", a.wa);Dd(a, d);return d;
}g.$ = function (a) {
  if (a && !this.R) throw Error("Can't create secondary domain capable XhrIo object.");a = new X(this.La);a.F = this.R;return a;
};g.ma = function () {
  return !!this.c && !0;
};g.Y = function () {
  return this.R;
};function Od() {}g = Od.prototype;g.va = function () {};
g.ua = function () {};g.ta = function () {};g.sa = function () {};g.Ta = function () {};function Pd(a) {
  for (var b = arguments[0], c = 1; c < arguments.length; c++) {
    var d = arguments[c];if (0 == d.lastIndexOf("/", 0)) b = d;else {
      var e;(e = "" == b) || (e = b.length - 1, e = 0 <= e && b.indexOf("/", e) == e);e ? b += d : b += "/" + d;
    }
  }return b;
}function Qd() {
  if (B && !(10 <= Number(Na))) throw Error("Environmental error: no available transport.");
}Qd.prototype.a = function (a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  G.call(this);this.a = new Ad(b);this.g = a;this.m = b && b.testUrl ? b.testUrl : Pd(this.g, "test");this.b = b && b.messageUrlParams || null;a = b && b.messageHeaders || null;b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });this.a.i = a;a = b && b.initMessageHeaders || null;b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });b && b.xa && (a ? a["X-WebChannel-Client-Profile"] = b.xa : a = { "X-WebChannel-Client-Profile": b.xa });this.a.J = a;(a = b && b.httpHeadersOverwriteParam) && !qa(a) && (this.a.g = a);this.l = b && b.supportsCrossDomainXhr || !1;this.h = b && b.sendRawJson || !1;(b = b && b.httpSessionIdParam) && !qa(b) && (this.a.j = b, a = this.b, null !== a && b in a && (a = this.b, b in a && delete a[b]));this.f = new Z(this);
}x(Y, G);g = Y.prototype;g.addEventListener = function (a, b, c, d) {
  Y.N.addEventListener.call(this, a, b, c, d);
};g.removeEventListener = function (a, b, c, d) {
  Y.N.removeEventListener.call(this, a, b, c, d);
};
g.Wa = function () {
  this.a.c = this.f;this.l && (this.a.R = !0);var a = this.a,
      b = this.m,
      c = this.g,
      d = this.b || void 0;K(0);a.ha = c;a.V = d || {};a.o && (a.F.b = [], a.F.a = !1);a.w = new Sc(a);null === a.g && (a.w.h = a.i);c = b;a.g && a.i && (c = zd(b, a.g, a.i));a = a.w;a.i = c;b = Wc(a.a, null, a.i);K(3);c = a.a.F.b;null != c ? (a.f = c[0], a.M = 1, Uc(a)) : (fc(b, "MODE", "init"), !a.a.o && a.a.j && fc(b, "X-HTTP-Session-Id", a.a.j), a.b = new M(a, void 0, void 0), a.b.h = a.h, dc(a.b, b, !1, null), a.M = 0);
};g.close = function () {
  Bd(this.a);
};
g.Xa = function (a) {
  if (m(a)) {
    var b = {};b.__data__ = a;Gd(this.a, b);
  } else this.h ? (b = {}, b.__data__ = ob(a), Gd(this.a, b)) : Gd(this.a, a);
};g.G = function () {
  this.a.c = null;delete this.f;Bd(this.a);delete this.a;Y.N.G.call(this);
};function Rd(a) {
  Ub.call(this);var b = a.__sm__;if (b) {
    a: {
      for (var c in b) {
        a = c;break a;
      }a = void 0;
    }(this.c = a) ? (a = this.c, this.data = null !== b && a in b ? b[a] : void 0) : this.data = b;
  } else this.data = a;
}x(Rd, Ub);function Sd() {
  Vb.call(this);this.status = 1;
}x(Sd, Vb);function Z(a) {
  this.a = a;
}x(Z, Od);Z.prototype.va = function () {
  this.a.dispatchEvent("a");
};
Z.prototype.ua = function (a) {
  this.a.dispatchEvent(new Rd(a));
};Z.prototype.ta = function (a) {
  this.a.dispatchEvent(new Sd(a));
};Z.prototype.sa = function () {
  this.a.dispatchEvent("b");
};var Td = v(function (a, b) {
  function c() {}c.prototype = a.prototype;var d = new c();a.apply(d, Array.prototype.slice.call(arguments, 1));return d;
}, Qd); /*
        Copyright 2017 Google Inc.
        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
        Unless required by applicable law or agreed to in writing, software
        distributed under the License is distributed on an "AS IS" BASIS,
        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        See the License for the specific language governing permissions and
        limitations under the License.
        */
Qd.prototype.createWebChannel = Qd.prototype.a;Y.prototype.send = Y.prototype.Xa;Y.prototype.open = Y.prototype.Wa;Y.prototype.close = Y.prototype.close;Pb.NO_ERROR = 0;Pb.TIMEOUT = 8;Pb.HTTP_ERROR = 6;Qb.COMPLETE = "complete";Tb.EventType = L;L.OPEN = "a";L.CLOSE = "b";L.ERROR = "c";L.MESSAGE = "d";G.prototype.listen = G.prototype.Aa;X.prototype.listenOnce = X.prototype.Ba;X.prototype.getLastError = X.prototype.Ya;X.prototype.getLastErrorCode = X.prototype.ya;X.prototype.getStatus = X.prototype.T;X.prototype.getStatusText = X.prototype.za;
X.prototype.getResponseJson = X.prototype.Va;X.prototype.getResponseText = X.prototype.aa;X.prototype.send = X.prototype.ca;var tmp = { createWebChannelTransport: Td, ErrorCode: Pb, EventType: Qb, WebChannel: Tb, XhrIo: X };
var tmp_1 = tmp.createWebChannelTransport;
var tmp_2 = tmp.ErrorCode;
var tmp_3 = tmp.EventType;
var tmp_4 = tmp.WebChannel;
var tmp_5 = tmp.XhrIo;

/* harmony default export */ __webpack_exports__["default"] = (tmp);

//# sourceMappingURL=index.esm.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("h6ac")))

/***/ }),

/***/ "uebg":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("xWhT");
var IE8_DOM_DEFINE = __webpack_require__("/7yg");
var anObject = __webpack_require__("hrV0");
var toPrimitive = __webpack_require__("i3Mv");
var nativeDefineProperty = Object.defineProperty;

exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "ugM7":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("zotD");
var get = __webpack_require__("7AqT");
module.exports = __webpack_require__("zKeE").getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

/***/ }),

/***/ "uj5A":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)

var DESCRIPTORS = __webpack_require__("6MLN");
var getKeys = __webpack_require__("knrM");
var gOPS = __webpack_require__("Ocr3");
var pIE = __webpack_require__("z7R8");
var toObject = __webpack_require__("mbLO");
var IObject = __webpack_require__("E5Ce");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("wLcK")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  }return T;
} : $assign;

/***/ }),

/***/ "untT":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
} else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    } catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        } catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!__webpack_require__("fOjT").Readable;
} catch (e) {
    exports.nodestream = false;
}

/***/ }),

/***/ "uqKE":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__("GyB/");

var _typeof3 = _interopRequireDefault(_typeof2);

var _themes = __webpack_require__("ERJL");

var themes = _interopRequireWildcard(_themes);

var _base = __webpack_require__("OAUW");

var _base2 = _interopRequireDefault(_base);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var styles = Object.keys(themes).reduce(function (styles, themeName) {
  styles[themeName] = (0, _base2.default)(themes[themeName]);
  return styles;
}, {});

var createStyles = function createStyles(key, theme) {
  // console.debug(styles, theme, styles[theme])
  if (typeof theme === 'string') {
    return styles[theme][key];
  } else if ((typeof theme === 'undefined' ? 'undefined' : (0, _typeof3.default)(theme)) === 'object') {
    return (0, _base2.default)(theme)[key];
  }
  // Default styles
  return styles['chromeLight'][key];
};

exports.default = createStyles;

/***/ }),

/***/ "uxo6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

/***/ }),

/***/ "vCxL":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__await"] = __await;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/* harmony export (immutable) */ __webpack_exports__["__makeTemplateObject"] = __makeTemplateObject;
/* harmony export (immutable) */ __webpack_exports__["__importStar"] = __importStar;
/* harmony export (immutable) */ __webpack_exports__["__importDefault"] = __importDefault;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function () {
            if (t[0] & 1) throw t[1];return t[1];
        }, trys: [], ops: [] },
        f,
        y,
        t,
        g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
    }), g;
    function verb(n) {
        return function (v) {
            return step([n, v]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0:case 1:
                    t = op;break;
                case 4:
                    _.label++;return { value: op[1], done: false };
                case 5:
                    _.label++;y = op[1];op = [0];continue;
                case 7:
                    op = _.ops.pop();_.trys.pop();continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];t = op;break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];_.ops.push(op);break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [6, e];y = 0;
        } finally {
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function (v) {
            return new Promise(function (a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function () {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function (v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
        } : f;
    }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
        i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function (v) {
            return new Promise(function (resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
            resolve({ value: v, done: d });
        }, reject);
    }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
    } else {
        cooked.raw = raw;
    }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
}

/***/ }),

/***/ "vSO4":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("i1Q6");
var core = __webpack_require__("zKeE");
var ctx = __webpack_require__("3zRh");
var hide = __webpack_require__("akPY");
var has = __webpack_require__("yS17");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();
            case 1:
              return new C(a);
            case 2:
              return new C(a, b);
          }return new C(a, b, c);
        }return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
      // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

/***/ }),

/***/ "vUQk":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__("Gfzd");
var createDesc = __webpack_require__("0WCH");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "vcHl":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("YD0x");
module.exports = __webpack_require__("zKeE").Object.assign;

/***/ }),

/***/ "veA5":
/***/ (function(module, exports, __webpack_require__) {

var getOwnPropertyNamesModule = __webpack_require__("+puC");
var getOwnPropertySymbolsModule = __webpack_require__("Mve8");
var anObject = __webpack_require__("hrV0");
var Reflect = __webpack_require__("wJQ+").Reflect;

// all object keys, includes non-enumerable and symbols
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

/***/ }),

/***/ "vexR":
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),

/***/ "vfAE":
/***/ (function(module, exports) {

(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function () {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    return new Promise(function (resolve, reject) {
      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {
    setImmediate(fn);
  } || function (fn) {
    setTimeoutFunc(fn, 0);
  };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }
})(this);

/***/ }),

/***/ "wGjj":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_whatwg_fetch__ = __webpack_require__("cpTA");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_whatwg_fetch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_whatwg_fetch__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_promise_polyfill_lib_polyfill__ = __webpack_require__("QDxr");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_promise_polyfill_lib_polyfill___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_promise_polyfill_lib_polyfill__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_core_js_features_array_find__ = __webpack_require__("1Gki");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_core_js_features_array_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_core_js_features_array_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_core_js_features_array_find_index__ = __webpack_require__("sSDB");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_core_js_features_array_find_index___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_core_js_features_array_find_index__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_core_js_features_object_assign__ = __webpack_require__("4KuB");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_core_js_features_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_core_js_features_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_core_js_features_string_starts_with__ = __webpack_require__("/Snk");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_core_js_features_string_starts_with___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_core_js_features_string_starts_with__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_core_js_features_string_repeat__ = __webpack_require__("59Aw");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_core_js_features_string_repeat___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_core_js_features_string_repeat__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_core_js_features_symbol__ = __webpack_require__("pRGz");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_core_js_features_symbol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_core_js_features_symbol__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_core_js_features_symbol_iterator__ = __webpack_require__("jsP4");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_core_js_features_symbol_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_core_js_features_symbol_iterator__);










/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//# sourceMappingURL=index.esm.js.map

/***/ }),

/***/ "wJQ+":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports = typeof window == 'object' && window && window.Math == Math ? window : typeof self == 'object' && self && self.Math == Math ? self
// eslint-disable-next-line no-new-func
: Function('return this')();

/***/ }),

/***/ "wLcK":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "wOgZ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataReader = __webpack_require__("ML/b");
var utils = __webpack_require__("dvMn");

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function (i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function (sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function (size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

/***/ }),

/***/ "wVGV":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__("Asjh");

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),

/***/ "wl+m":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__("38Wu").Buffer;
var util = __webpack_require__(1);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "xUUw":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,

  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

/***/ }),

/***/ "xWhT":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("b3E9")(function () {
  return Object.defineProperty({}, 'a', { get: function () {
      return 7;
    } }).a != 7;
});

/***/ }),

/***/ "xdvC":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("1JcR"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../fold/xml-fold"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineOption("matchTags", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchTags);
      cm.off("viewportChange", maybeUpdateMatch);
      clear(cm);
    }
    if (val) {
      cm.state.matchBothTags = typeof val == "object" && val.bothTags;
      cm.on("cursorActivity", doMatchTags);
      cm.on("viewportChange", maybeUpdateMatch);
      doMatchTags(cm);
    }
  });

  function clear(cm) {
    if (cm.state.tagHit) cm.state.tagHit.clear();
    if (cm.state.tagOther) cm.state.tagOther.clear();
    cm.state.tagHit = cm.state.tagOther = null;
  }

  function doMatchTags(cm) {
    cm.state.failedTagMatch = false;
    cm.operation(function () {
      clear(cm);
      if (cm.somethingSelected()) return;
      var cur = cm.getCursor(),
          range = cm.getViewport();
      range.from = Math.min(range.from, cur.line);range.to = Math.max(cur.line + 1, range.to);
      var match = CodeMirror.findMatchingTag(cm, cur, range);
      if (!match) return;
      if (cm.state.matchBothTags) {
        var hit = match.at == "open" ? match.open : match.close;
        if (hit) cm.state.tagHit = cm.markText(hit.from, hit.to, { className: "CodeMirror-matchingtag" });
      }
      var other = match.at == "close" ? match.open : match.close;
      if (other) cm.state.tagOther = cm.markText(other.from, other.to, { className: "CodeMirror-matchingtag" });else cm.state.failedTagMatch = true;
    });
  }

  function maybeUpdateMatch(cm) {
    if (cm.state.failedTagMatch) doMatchTags(cm);
  }

  CodeMirror.commands.toMatchingTag = function (cm) {
    var found = CodeMirror.findMatchingTag(cm, cm.getCursor());
    if (found) {
      var other = found.at == "close" ? found.open : found.close;
      if (other) cm.extendSelection(other.to, other.from);
    }
  };
});

/***/ }),

/***/ "xtj2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("dvMn");
var GenericWorker = __webpack_require__("ZKdc");
var utf8 = __webpack_require__("Sm7/");
var crc32 = __webpack_require__("cvyR");
var signature = __webpack_require__("Ctqd");

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function (dec, bytes) {
    var hex = "",
        i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function (dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0) & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function (streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
        compression = streamInfo['compression'],
        useCustomEncoding = encodeFileName !== utf8.utf8encode,
        encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
        utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
        comment = file.comment,
        encodedComment = utils.transformTo("string", encodeFileName(comment)),
        utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
        useUTF8ForComment = utfEncodedComment.length !== comment.length,
        dosTime,
        dosDate,
        extraFields = "",
        unicodePathExtraField = "",
        unicodeCommentExtraField = "",
        dir = file.dir,
        date = file.date;

    var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }

    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if (platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
        // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
        // Version
        decToHex(1, 1) +
        // NameCRC32
        decToHex(crc32(encodedFileName), 4) +
        // UnicodeName
        utfEncodedFileName;

        extraFields +=
        // Info-ZIP Unicode Path Extra Field
        "\x75\x70" +
        // size
        decToHex(unicodePathExtraField.length, 2) +
        // content
        unicodePathExtraField;
    }

    if (useUTF8ForComment) {

        unicodeCommentExtraField =
        // Version
        decToHex(1, 1) +
        // CommentCRC32
        decToHex(crc32(encodedComment), 4) +
        // UnicodeName
        utfEncodedComment;

        extraFields +=
        // Info-ZIP Unicode Path Extra Field
        "\x75\x63" +
        // size
        decToHex(unicodeCommentExtraField.length, 2) +
        // content
        unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);

    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
    // version made by (00: DOS)
    decToHex(versionMadeBy, 2) +
    // file header (common to file and central directory)
    header +
    // file comment length
    decToHex(encodedComment.length, 2) +
    // disk number start
    "\x00\x00" +
    // internal file attributes TODO
    "\x00\x00" +
    // external file attributes
    decToHex(extFileAttr, 4) +
    // relative offset of local header
    decToHex(offset, 4) +
    // file name
    encodedFileName +
    // extra field
    extraFields +
    // file comment
    encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
    // number of this disk
    "\x00\x00" +
    // number of the disk with the start of the central directory
    "\x00\x00" +
    // total number of entries in the central directory on this disk
    decToHex(entriesCount, 2) +
    // total number of entries in the central directory
    decToHex(entriesCount, 2) +
    // size of the central directory   4 bytes
    decToHex(centralDirLength, 4) +
    // offset of start of central directory with respect to the starting disk number
    decToHex(localDirLength, 4) +
    // .ZIP file comment length
    decToHex(encodedComment.length, 2) +
    // .ZIP file comment
    encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
    // crc-32                          4 bytes
    decToHex(streamInfo['crc32'], 4) +
    // compressed size                 4 bytes
    decToHex(streamInfo['compressedSize'], 4) +
    // uncompressed size               4 bytes
    decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};

/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;

    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if (this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data: chunk.data,
            meta: {
                currentFile: this.currentFile,
                percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data: generateDataDescriptors(streamInfo),
            meta: { percent: 100 }
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data: this.dirRecords[i],
            meta: { percent: 100 }
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data: dirEnd,
        meta: { percent: 100 }
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if (self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for (var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch (e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

/***/ }),

/***/ "xwD+":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};

/***/ }),

/***/ "xypO":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("y+6Q");
__webpack_require__("pvap");
__webpack_require__("a6mx");

module.exports = __webpack_require__("HOGQ").f('iterator');

/***/ }),

/***/ "xyxa":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("uebg").f;
var has = __webpack_require__("UYRC");
var TO_STRING_TAG = __webpack_require__("95jh")('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};

/***/ }),

/***/ "xz3w":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var immediate = __webpack_require__("uUPe");

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["finally"] = function (callback) {
  if (typeof callback !== 'function') {
    return this;
  }
  var p = this.constructor;
  return this.then(resolve, reject);

  function resolve(value) {
    function yes() {
      return value;
    }
    return p.resolve(callback()).then(yes);
  }
  function reject(reason) {
    function no() {
      throw reason;
    }
    return p.resolve(callback()).then(no);
  }
};
Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

/***/ }),

/***/ "y+6Q":
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
__webpack_require__("KGgk")('iterator');

/***/ }),

/***/ "yLr7":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Supported keybindings:
 *   Too many to list. Refer to defaultKeymap below.
 *
 * Supported Ex commands:
 *   Refer to defaultExCommandMap below.
 *
 * Registers: unnamed, -, a-z, A-Z, 0-9
 *   (Does not respect the special case for number registers when delete
 *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )
 *   TODO: Implement the remaining registers.
 *
 * Marks: a-z, A-Z, and 0-9
 *   TODO: Implement the remaining special marks. They have more complex
 *       behavior.
 *
 * Events:
 *  'vim-mode-change' - raised on the editor anytime the current mode changes,
 *                      Event object: {mode: "visual", subMode: "linewise"}
 *
 * Code structure:
 *  1. Default keymap
 *  2. Variable declarations and short basic helpers
 *  3. Instance (External API) implementation
 *  4. Internal state tracking objects (input state, counter) implementation
 *     and instantiation
 *  5. Key handler (the main command dispatcher) implementation
 *  6. Motion, operator, and action implementations
 *  7. Helper functions for the key handler, motions, operators, and actions
 *  8. Set up Vim to work as a keymap for CodeMirror.
 *  9. Ex command implementations.
 */

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"), __webpack_require__("29F7"), __webpack_require__("4e7A"), __webpack_require__("uQIK"));else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/dialog/dialog", "../addon/edit/matchbrackets"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  'use strict';

  var defaultKeymap = [
  // Key to key mapping. This goes first to make it possible to override
  // existing mappings.
  { keys: '<Left>', type: 'keyToKey', toKeys: 'h' }, { keys: '<Right>', type: 'keyToKey', toKeys: 'l' }, { keys: '<Up>', type: 'keyToKey', toKeys: 'k' }, { keys: '<Down>', type: 'keyToKey', toKeys: 'j' }, { keys: '<Space>', type: 'keyToKey', toKeys: 'l' }, { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal' }, { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal' }, { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' }, { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' }, { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' }, { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' }, { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' }, { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' }, { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' }, { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' }, { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' }, { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' }, { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' }, { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual' }, { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' }, { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' }, { keys: '<Home>', type: 'keyToKey', toKeys: '0' }, { keys: '<End>', type: 'keyToKey', toKeys: '$' }, { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' }, { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' }, { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' }, { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },
  // Motions
  { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true } }, { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true } }, { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true } }, { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false } }, { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true } }, { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true } }, { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true } }, { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true } }, { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false } }, { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false } }, { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true } }, { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true } }, { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } }, { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false } }, { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true } }, { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true } }, { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } }, { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true } }, { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true } }, { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false } }, { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true } }, { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true } }, { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false } }, { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true } }, { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true } }, { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } }, { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } }, { keys: '0', type: 'motion', motion: 'moveToStartOfLine' }, { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' }, { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true } }, { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar: true } }, { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } }, { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true } }, { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true } }, { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true, inclusive: true } }, { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false } }, { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true } }, { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false } }, { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true } }, { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false } }, { keys: '\'<character>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true, linewise: true } }, { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true } }, { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } }, { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } }, { keys: ']\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } }, { keys: '[\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },
  // the next two aren't motions but must come before more general motion declarations
  { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } }, { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } }, { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true } }, { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true } }, { keys: '|', type: 'motion', motion: 'moveToColumn' }, { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context: 'visual' }, { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: { sameLine: true }, context: 'visual' },
  // Operators
  { keys: 'd', type: 'operator', operator: 'delete' }, { keys: 'y', type: 'operator', operator: 'yank' }, { keys: 'c', type: 'operator', operator: 'change' }, { keys: '=', type: 'operator', operator: 'indentAuto' }, { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true } }, { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false } }, { keys: 'g~', type: 'operator', operator: 'changeCase' }, { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, isEdit: true }, { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, isEdit: true }, { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true } }, { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true } },
  // Operator-Motion dual commands
  { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } }, { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } }, { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' }, { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual' }, { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal' }, { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual' }, { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' }, { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual' }, { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal' }, { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual' }, { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },
  //ignore C-w in normal mode
  { keys: '<C-w>', type: 'idle', context: 'normal' },
  // Actions
  { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true } }, { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false } }, { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true } }, { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true } }, { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' }, { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' }, { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' }, { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' }, { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank' }, context: 'normal' }, { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' }, { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' }, { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' }, { keys: 'v', type: 'action', action: 'toggleVisualMode' }, { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true } }, { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } }, { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } }, { keys: 'gv', type: 'action', action: 'reselectLastSelection' }, { keys: 'J', type: 'action', action: 'joinLines', isEdit: true }, { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true } }, { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true } }, { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true }, { keys: '@<character>', type: 'action', action: 'replayMacro' }, { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },
  // Handle Replace-mode as a special case of insert mode.
  { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true } }, { keys: 'u', type: 'action', action: 'undo', context: 'normal' }, { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, context: 'visual', isEdit: true }, { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, context: 'visual', isEdit: true }, { keys: '<C-r>', type: 'action', action: 'redo' }, { keys: 'm<character>', type: 'action', action: 'setMark' }, { keys: '"<character>', type: 'action', action: 'setRegister' }, { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' } }, { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' }, { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' } }, { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' }, { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' } }, { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' }, { keys: '.', type: 'action', action: 'repeatLastEdit' }, { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: true, backtrack: false } }, { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: false, backtrack: false } }, { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' }, { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },
  // Text object motions
  { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' }, { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true } },
  // Search
  { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true } }, { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true } }, { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } }, { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } }, { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true } }, { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true } },
  // Ex command
  { keys: ':', type: 'ex' }];
  var defaultKeymapLength = defaultKeymap.length;

  /**
   * Ex commands
   * Care must be taken when adding to the default Ex command map. For any
   * pair of commands that have a shared prefix, at least one of their
   * shortNames must not match the prefix of the other command.
   */
  var defaultExCommandMap = [{ name: 'colorscheme', shortName: 'colo' }, { name: 'map' }, { name: 'imap', shortName: 'im' }, { name: 'nmap', shortName: 'nm' }, { name: 'vmap', shortName: 'vm' }, { name: 'unmap' }, { name: 'write', shortName: 'w' }, { name: 'undo', shortName: 'u' }, { name: 'redo', shortName: 'red' }, { name: 'set', shortName: 'se' }, { name: 'set', shortName: 'se' }, { name: 'setlocal', shortName: 'setl' }, { name: 'setglobal', shortName: 'setg' }, { name: 'sort', shortName: 'sor' }, { name: 'substitute', shortName: 's', possiblyAsync: true }, { name: 'nohlsearch', shortName: 'noh' }, { name: 'yank', shortName: 'y' }, { name: 'delmarks', shortName: 'delm' }, { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true }, { name: 'global', shortName: 'g' }];

  var Pos = CodeMirror.Pos;

  var Vim = function () {
    function enterVimMode(cm) {
      cm.setOption('disableInput', true);
      cm.setOption('showCursorWhenSelecting', false);
      CodeMirror.signal(cm, "vim-mode-change", { mode: "normal" });
      cm.on('cursorActivity', onCursorActivity);
      maybeInitVimState(cm);
      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));
    }

    function leaveVimMode(cm) {
      cm.setOption('disableInput', false);
      cm.off('cursorActivity', onCursorActivity);
      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));
      cm.state.vim = null;
    }

    function detachVimMap(cm, next) {
      if (this == CodeMirror.keyMap.vim) {
        CodeMirror.rmClass(cm.getWrapperElement(), "cm-fat-cursor");
        if (cm.getOption("inputStyle") == "contenteditable" && document.body.style.caretColor != null) {
          disableFatCursorMark(cm);
          cm.getInputField().style.caretColor = "";
        }
      }

      if (!next || next.attach != attachVimMap) leaveVimMode(cm);
    }
    function attachVimMap(cm, prev) {
      if (this == CodeMirror.keyMap.vim) {
        CodeMirror.addClass(cm.getWrapperElement(), "cm-fat-cursor");
        if (cm.getOption("inputStyle") == "contenteditable" && document.body.style.caretColor != null) {
          enableFatCursorMark(cm);
          cm.getInputField().style.caretColor = "transparent";
        }
      }

      if (!prev || prev.attach != attachVimMap) enterVimMode(cm);
    }

    function updateFatCursorMark(cm) {
      if (!cm.state.fatCursorMarks) return;
      clearFatCursorMark(cm);
      var ranges = cm.listSelections(),
          result = [];
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.empty()) {
          if (range.anchor.ch < cm.getLine(range.anchor.line).length) {
            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1), { className: "cm-fat-cursor-mark" }));
          } else {
            var widget = document.createElement("span");
            widget.textContent = "\u00a0";
            widget.className = "cm-fat-cursor-mark";
            result.push(cm.setBookmark(range.anchor, { widget: widget }));
          }
        }
      }
      cm.state.fatCursorMarks = result;
    }

    function clearFatCursorMark(cm) {
      var marks = cm.state.fatCursorMarks;
      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
    }

    function enableFatCursorMark(cm) {
      cm.state.fatCursorMarks = [];
      updateFatCursorMark(cm);
      cm.on("cursorActivity", updateFatCursorMark);
    }

    function disableFatCursorMark(cm) {
      clearFatCursorMark(cm);
      cm.off("cursorActivity", updateFatCursorMark);
      // explicitly set fatCursorMarks to null because event listener above
      // can be invoke after removing it, if off is called from operation
      cm.state.fatCursorMarks = null;
    }

    // Deprecated, simply setting the keymap works again.
    CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {
      if (val && cm.getOption("keyMap") != "vim") cm.setOption("keyMap", "vim");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption("keyMap"))) cm.setOption("keyMap", "default");
    });

    function cmKey(key, cm) {
      if (!cm) {
        return undefined;
      }
      if (this[key]) {
        return this[key];
      }
      var vimKey = cmKeyToVimKey(key);
      if (!vimKey) {
        return false;
      }
      var cmd = CodeMirror.Vim.findKey(cm, vimKey);
      if (typeof cmd == 'function') {
        CodeMirror.signal(cm, 'vim-keypress', vimKey);
      }
      return cmd;
    }

    var modifiers = { 'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A' };
    var specialKeys = { Enter: 'CR', Backspace: 'BS', Delete: 'Del', Insert: 'Ins' };
    function cmKeyToVimKey(key) {
      if (key.charAt(0) == '\'') {
        // Keypress character binding of format "'a'"
        return key.charAt(1);
      }
      var pieces = key.split(/-(?!$)/);
      var lastPiece = pieces[pieces.length - 1];
      if (pieces.length == 1 && pieces[0].length == 1) {
        // No-modifier bindings use literal character bindings above. Skip.
        return false;
      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {
        // Ignore Shift+char bindings as they should be handled by literal character.
        return false;
      }
      var hasCharacter = false;
      for (var i = 0; i < pieces.length; i++) {
        var piece = pieces[i];
        if (piece in modifiers) {
          pieces[i] = modifiers[piece];
        } else {
          hasCharacter = true;
        }
        if (piece in specialKeys) {
          pieces[i] = specialKeys[piece];
        }
      }
      if (!hasCharacter) {
        // Vim does not support modifier only keys.
        return false;
      }
      // TODO: Current bindings expect the character to be lower case, but
      // it looks like vim key notation uses upper case.
      if (isUpperCase(lastPiece)) {
        pieces[pieces.length - 1] = lastPiece.toLowerCase();
      }
      return '<' + pieces.join('-') + '>';
    }

    function getOnPasteFn(cm) {
      var vim = cm.state.vim;
      if (!vim.onPasteFn) {
        vim.onPasteFn = function () {
          if (!vim.insertMode) {
            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
            actions.enterInsertMode(cm, {}, vim);
          }
        };
      }
      return vim.onPasteFn;
    }

    var numberRegex = /[\d]/;
    var wordCharTest = [CodeMirror.isWordChar, function (ch) {
      return ch && !CodeMirror.isWordChar(ch) && !/\s/.test(ch);
    }],
        bigWordCharTest = [function (ch) {
      return (/\S/.test(ch)
      );
    }];
    function makeKeyRange(start, size) {
      var keys = [];
      for (var i = start; i < start + size; i++) {
        keys.push(String.fromCharCode(i));
      }
      return keys;
    }
    var upperCaseAlphabet = makeKeyRange(65, 26);
    var lowerCaseAlphabet = makeKeyRange(97, 26);
    var numbers = makeKeyRange(48, 10);
    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);
    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '"', '.', ':', '/']);

    function isLine(cm, line) {
      return line >= cm.firstLine() && line <= cm.lastLine();
    }
    function isLowerCase(k) {
      return (/^[a-z]$/.test(k)
      );
    }
    function isMatchableSymbol(k) {
      return '()[]{}'.indexOf(k) != -1;
    }
    function isNumber(k) {
      return numberRegex.test(k);
    }
    function isUpperCase(k) {
      return (/^[A-Z]$/.test(k)
      );
    }
    function isWhiteSpaceString(k) {
      return (/^\s*$/.test(k)
      );
    }
    function isEndOfSentenceSymbol(k) {
      return '.?!'.indexOf(k) != -1;
    }
    function inArray(val, arr) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] == val) {
          return true;
        }
      }
      return false;
    }

    var options = {};
    function defineOption(name, defaultValue, type, aliases, callback) {
      if (defaultValue === undefined && !callback) {
        throw Error('defaultValue is required unless callback is provided');
      }
      if (!type) {
        type = 'string';
      }
      options[name] = {
        type: type,
        defaultValue: defaultValue,
        callback: callback
      };
      if (aliases) {
        for (var i = 0; i < aliases.length; i++) {
          options[aliases[i]] = options[name];
        }
      }
      if (defaultValue) {
        setOption(name, defaultValue);
      }
    }

    function setOption(name, value, cm, cfg) {
      var option = options[name];
      cfg = cfg || {};
      var scope = cfg.scope;
      if (!option) {
        return new Error('Unknown option: ' + name);
      }
      if (option.type == 'boolean') {
        if (value && value !== true) {
          return new Error('Invalid argument: ' + name + '=' + value);
        } else if (value !== false) {
          // Boolean options are set to true if value is not defined.
          value = true;
        }
      }
      if (option.callback) {
        if (scope !== 'local') {
          option.callback(value, undefined);
        }
        if (scope !== 'global' && cm) {
          option.callback(value, cm);
        }
      } else {
        if (scope !== 'local') {
          option.value = option.type == 'boolean' ? !!value : value;
        }
        if (scope !== 'global' && cm) {
          cm.state.vim.options[name] = { value: value };
        }
      }
    }

    function getOption(name, cm, cfg) {
      var option = options[name];
      cfg = cfg || {};
      var scope = cfg.scope;
      if (!option) {
        return new Error('Unknown option: ' + name);
      }
      if (option.callback) {
        var local = cm && option.callback(undefined, cm);
        if (scope !== 'global' && local !== undefined) {
          return local;
        }
        if (scope !== 'local') {
          return option.callback();
        }
        return;
      } else {
        var local = scope !== 'global' && cm && cm.state.vim.options[name];
        return (local || scope !== 'local' && option || {}).value;
      }
    }

    defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {
      // Option is local. Do nothing for global.
      if (cm === undefined) {
        return;
      }
      // The 'filetype' option proxies to the CodeMirror 'mode' option.
      if (name === undefined) {
        var mode = cm.getOption('mode');
        return mode == 'null' ? '' : mode;
      } else {
        var mode = name == '' ? 'null' : name;
        cm.setOption('mode', mode);
      }
    });

    var createCircularJumpList = function () {
      var size = 100;
      var pointer = -1;
      var head = 0;
      var tail = 0;
      var buffer = new Array(size);
      function add(cm, oldCur, newCur) {
        var current = pointer % size;
        var curMark = buffer[current];
        function useNextSlot(cursor) {
          var next = ++pointer % size;
          var trashMark = buffer[next];
          if (trashMark) {
            trashMark.clear();
          }
          buffer[next] = cm.setBookmark(cursor);
        }
        if (curMark) {
          var markPos = curMark.find();
          // avoid recording redundant cursor position
          if (markPos && !cursorEqual(markPos, oldCur)) {
            useNextSlot(oldCur);
          }
        } else {
          useNextSlot(oldCur);
        }
        useNextSlot(newCur);
        head = pointer;
        tail = pointer - size + 1;
        if (tail < 0) {
          tail = 0;
        }
      }
      function move(cm, offset) {
        pointer += offset;
        if (pointer > head) {
          pointer = head;
        } else if (pointer < tail) {
          pointer = tail;
        }
        var mark = buffer[(size + pointer) % size];
        // skip marks that are temporarily removed from text buffer
        if (mark && !mark.find()) {
          var inc = offset > 0 ? 1 : -1;
          var newCur;
          var oldCur = cm.getCursor();
          do {
            pointer += inc;
            mark = buffer[(size + pointer) % size];
            // skip marks that are the same as current position
            if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {
              break;
            }
          } while (pointer < head && pointer > tail);
        }
        return mark;
      }
      return {
        cachedCursor: undefined, //used for # and * jumps
        add: add,
        move: move
      };
    };

    // Returns an object to track the changes associated insert mode.  It
    // clones the object that is passed in, or creates an empty object one if
    // none is provided.
    var createInsertModeChanges = function (c) {
      if (c) {
        // Copy construction
        return {
          changes: c.changes,
          expectCursorActivityForChange: c.expectCursorActivityForChange
        };
      }
      return {
        // Change list
        changes: [],
        // Set to true on change, false on cursorActivity.
        expectCursorActivityForChange: false
      };
    };

    function MacroModeState() {
      this.latestRegister = undefined;
      this.isPlaying = false;
      this.isRecording = false;
      this.replaySearchQueries = [];
      this.onRecordingDone = undefined;
      this.lastInsertModeChanges = createInsertModeChanges();
    }
    MacroModeState.prototype = {
      exitMacroRecordMode: function () {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.onRecordingDone) {
          macroModeState.onRecordingDone(); // close dialog
        }
        macroModeState.onRecordingDone = undefined;
        macroModeState.isRecording = false;
      },
      enterMacroRecordMode: function (cm, registerName) {
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (register) {
          register.clear();
          this.latestRegister = registerName;
          if (cm.openDialog) {
            this.onRecordingDone = cm.openDialog('(recording)[' + registerName + ']', null, { bottom: true });
          }
          this.isRecording = true;
        }
      }
    };

    function maybeInitVimState(cm) {
      if (!cm.state.vim) {
        // Store instance state in the CodeMirror object.
        cm.state.vim = {
          inputState: new InputState(),
          // Vim's input state that triggered the last edit, used to repeat
          // motions and operators with '.'.
          lastEditInputState: undefined,
          // Vim's action command before the last edit, used to repeat actions
          // with '.' and insert mode repeat.
          lastEditActionCommand: undefined,
          // When using jk for navigation, if you move from a longer line to a
          // shorter line, the cursor may clip to the end of the shorter line.
          // If j is pressed again and cursor goes to the next line, the
          // cursor should go back to its horizontal position on the longer
          // line if it can. This is to keep track of the horizontal position.
          lastHPos: -1,
          // Doing the same with screen-position for gj/gk
          lastHSPos: -1,
          // The last motion command run. Cleared if a non-motion command gets
          // executed in between.
          lastMotion: null,
          marks: {},
          // Mark for rendering fake cursor for visual mode.
          fakeCursor: null,
          insertMode: false,
          // Repeat count for changes made in insert mode, triggered by key
          // sequences like 3,i. Only exists when insertMode is true.
          insertModeRepeat: undefined,
          visualMode: false,
          // If we are in visual line mode. No effect if visualMode is false.
          visualLine: false,
          visualBlock: false,
          lastSelection: null,
          lastPastedText: null,
          sel: {},
          // Buffer-local/window-local values of vim options.
          options: {}
        };
      }
      return cm.state.vim;
    }
    var vimGlobalState;
    function resetVimGlobalState() {
      vimGlobalState = {
        // The current search query.
        searchQuery: null,
        // Whether we are searching backwards.
        searchIsReversed: false,
        // Replace part of the last substituted pattern
        lastSubstituteReplacePart: undefined,
        jumpList: createCircularJumpList(),
        macroModeState: new MacroModeState(),
        // Recording latest f, t, F or T motion command.
        lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: '' },
        registerController: new RegisterController({}),
        // search history buffer
        searchHistoryController: new HistoryController(),
        // ex Command history buffer
        exCommandHistoryController: new HistoryController()
      };
      for (var optionName in options) {
        var option = options[optionName];
        option.value = option.defaultValue;
      }
    }

    var lastInsertModeKeyTimer;
    var vimApi = {
      buildKeyMap: function () {
        // TODO: Convert keymap into dictionary format for fast lookup.
      },
      // Testing hook, though it might be useful to expose the register
      // controller anyways.
      getRegisterController: function () {
        return vimGlobalState.registerController;
      },
      // Testing hook.
      resetVimGlobalState_: resetVimGlobalState,

      // Testing hook.
      getVimGlobalState_: function () {
        return vimGlobalState;
      },

      // Testing hook.
      maybeInitVimState_: maybeInitVimState,

      suppressErrorLogging: false,

      InsertModeKey: InsertModeKey,
      map: function (lhs, rhs, ctx) {
        // Add user defined key bindings.
        exCommandDispatcher.map(lhs, rhs, ctx);
      },
      unmap: function (lhs, ctx) {
        exCommandDispatcher.unmap(lhs, ctx);
      },
      // Non-recursive map function.
      // NOTE: This will not create mappings to key maps that aren't present
      // in the default key map. See TODO at bottom of function.
      noremap: function (lhs, rhs, ctx) {
        function toCtxArray(ctx) {
          return ctx ? [ctx] : ['normal', 'insert', 'visual'];
        }
        var ctxsToMap = toCtxArray(ctx);
        // Look through all actual defaults to find a map candidate.
        var actualLength = defaultKeymap.length,
            origLength = defaultKeymapLength;
        for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {
          var mapping = defaultKeymap[i];
          // Omit mappings that operate in the wrong context(s) and those of invalid type.
          if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== 'ex' && mapping.type.substr(0, 3) !== 'key') {
            // Make a shallow copy of the original keymap entry.
            var newMapping = {};
            for (var key in mapping) {
              newMapping[key] = mapping[key];
            }
            // Modify it point to the new mapping with the proper context.
            newMapping.keys = lhs;
            if (ctx && !newMapping.context) {
              newMapping.context = ctx;
            }
            // Add it to the keymap with a higher priority than the original.
            this._mapCommand(newMapping);
            // Record the mapped contexts as complete.
            var mappedCtxs = toCtxArray(mapping.context);
            ctxsToMap = ctxsToMap.filter(function (el) {
              return mappedCtxs.indexOf(el) === -1;
            });
          }
        }
        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.
      },
      // Remove all user-defined mappings for the provided context.
      mapclear: function (ctx) {
        // Partition the existing keymap into user-defined and true defaults.
        var actualLength = defaultKeymap.length,
            origLength = defaultKeymapLength;
        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);
        defaultKeymap = defaultKeymap.slice(actualLength - origLength);
        if (ctx) {
          // If a specific context is being cleared, we need to keep mappings
          // from all other contexts.
          for (var i = userKeymap.length - 1; i >= 0; i--) {
            var mapping = userKeymap[i];
            if (ctx !== mapping.context) {
              if (mapping.context) {
                this._mapCommand(mapping);
              } else {
                // `mapping` applies to all contexts so create keymap copies
                // for each context except the one being cleared.
                var contexts = ['normal', 'insert', 'visual'];
                for (var j in contexts) {
                  if (contexts[j] !== ctx) {
                    var newMapping = {};
                    for (var key in mapping) {
                      newMapping[key] = mapping[key];
                    }
                    newMapping.context = contexts[j];
                    this._mapCommand(newMapping);
                  }
                }
              }
            }
          }
        }
      },
      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace
      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.
      setOption: setOption,
      getOption: getOption,
      defineOption: defineOption,
      defineEx: function (name, prefix, func) {
        if (!prefix) {
          prefix = name;
        } else if (name.indexOf(prefix) !== 0) {
          throw new Error('(Vim.defineEx) "' + prefix + '" is not a prefix of "' + name + '", command not registered');
        }
        exCommands[name] = func;
        exCommandDispatcher.commandMap_[prefix] = { name: name, shortName: prefix, type: 'api' };
      },
      handleKey: function (cm, key, origin) {
        var command = this.findKey(cm, key, origin);
        if (typeof command === 'function') {
          return command();
        }
      },
      /**
       * This is the outermost function called by CodeMirror, after keys have
       * been mapped to their Vim equivalents.
       *
       * Finds a command based on the key (and cached keys if there is a
       * multi-key sequence). Returns `undefined` if no key is matched, a noop
       * function if a partial match is found (multi-key), and a function to
       * execute the bound command if a a key is matched. The function always
       * returns true.
       */
      findKey: function (cm, key, origin) {
        var vim = maybeInitVimState(cm);
        function handleMacroRecording() {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isRecording) {
            if (key == 'q') {
              macroModeState.exitMacroRecordMode();
              clearInputState(cm);
              return true;
            }
            if (origin != 'mapping') {
              logKey(macroModeState, key);
            }
          }
        }
        function handleEsc() {
          if (key == '<Esc>') {
            // Clear input state and get back to normal mode.
            clearInputState(cm);
            if (vim.visualMode) {
              exitVisualMode(cm);
            } else if (vim.insertMode) {
              exitInsertMode(cm);
            }
            return true;
          }
        }
        function doKeyToKey(keys) {
          // TODO: prevent infinite recursion.
          var match;
          while (keys) {
            // Pull off one command key, which is either a single character
            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.
            match = /<\w+-.+?>|<\w+>|./.exec(keys);
            key = match[0];
            keys = keys.substring(match.index + key.length);
            CodeMirror.Vim.handleKey(cm, key, 'mapping');
          }
        }

        function handleKeyInsertMode() {
          if (handleEsc()) {
            return true;
          }
          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
          var keysAreChars = key.length == 1;
          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');
          // Need to check all key substrings in insert mode.
          while (keys.length > 1 && match.type != 'full') {
            var keys = vim.inputState.keyBuffer = keys.slice(1);
            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');
            if (thisMatch.type != 'none') {
              match = thisMatch;
            }
          }
          if (match.type == 'none') {
            clearInputState(cm);return false;
          } else if (match.type == 'partial') {
            if (lastInsertModeKeyTimer) {
              window.clearTimeout(lastInsertModeKeyTimer);
            }
            lastInsertModeKeyTimer = window.setTimeout(function () {
              if (vim.insertMode && vim.inputState.keyBuffer) {
                clearInputState(cm);
              }
            }, getOption('insertModeEscKeysTimeout'));
            return !keysAreChars;
          }

          if (lastInsertModeKeyTimer) {
            window.clearTimeout(lastInsertModeKeyTimer);
          }
          if (keysAreChars) {
            var selections = cm.listSelections();
            for (var i = 0; i < selections.length; i++) {
              var here = selections[i].head;
              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');
            }
            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
          }
          clearInputState(cm);
          return match.command;
        }

        function handleKeyNonInsertMode() {
          if (handleMacroRecording() || handleEsc()) {
            return true;
          }

          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
          if (/^[1-9]\d*$/.test(keys)) {
            return true;
          }

          var keysMatcher = /^(\d*)(.*)$/.exec(keys);
          if (!keysMatcher) {
            clearInputState(cm);return false;
          }
          var context = vim.visualMode ? 'visual' : 'normal';
          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);
          if (match.type == 'none') {
            clearInputState(cm);return false;
          } else if (match.type == 'partial') {
            return true;
          }

          vim.inputState.keyBuffer = '';
          var keysMatcher = /^(\d*)(.*)$/.exec(keys);
          if (keysMatcher[1] && keysMatcher[1] != '0') {
            vim.inputState.pushRepeatDigit(keysMatcher[1]);
          }
          return match.command;
        }

        var command;
        if (vim.insertMode) {
          command = handleKeyInsertMode();
        } else {
          command = handleKeyNonInsertMode();
        }
        if (command === false) {
          return !vim.insertMode && key.length === 1 ? function () {
            return true;
          } : undefined;
        } else if (command === true) {
          // TODO: Look into using CodeMirror's multi-key handling.
          // Return no-op since we are caching the key. Counts as handled, but
          // don't want act on it just yet.
          return function () {
            return true;
          };
        } else {
          return function () {
            return cm.operation(function () {
              cm.curOp.isVimOp = true;
              try {
                if (command.type == 'keyToKey') {
                  doKeyToKey(command.toKeys);
                } else {
                  commandDispatcher.processCommand(cm, vim, command);
                }
              } catch (e) {
                // clear VIM state in case it's in a bad state.
                cm.state.vim = undefined;
                maybeInitVimState(cm);
                if (!CodeMirror.Vim.suppressErrorLogging) {
                  console['log'](e);
                }
                throw e;
              }
              return true;
            });
          };
        }
      },
      handleEx: function (cm, input) {
        exCommandDispatcher.processCommand(cm, input);
      },

      defineMotion: defineMotion,
      defineAction: defineAction,
      defineOperator: defineOperator,
      mapCommand: mapCommand,
      _mapCommand: _mapCommand,

      defineRegister: defineRegister,

      exitVisualMode: exitVisualMode,
      exitInsertMode: exitInsertMode
    };

    // Represents the current input state.
    function InputState() {
      this.prefixRepeat = [];
      this.motionRepeat = [];

      this.operator = null;
      this.operatorArgs = null;
      this.motion = null;
      this.motionArgs = null;
      this.keyBuffer = []; // For matching multi-key commands.
      this.registerName = null; // Defaults to the unnamed register.
    }
    InputState.prototype.pushRepeatDigit = function (n) {
      if (!this.operator) {
        this.prefixRepeat = this.prefixRepeat.concat(n);
      } else {
        this.motionRepeat = this.motionRepeat.concat(n);
      }
    };
    InputState.prototype.getRepeat = function () {
      var repeat = 0;
      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
        repeat = 1;
        if (this.prefixRepeat.length > 0) {
          repeat *= parseInt(this.prefixRepeat.join(''), 10);
        }
        if (this.motionRepeat.length > 0) {
          repeat *= parseInt(this.motionRepeat.join(''), 10);
        }
      }
      return repeat;
    };

    function clearInputState(cm, reason) {
      cm.state.vim.inputState = new InputState();
      CodeMirror.signal(cm, 'vim-command-done', reason);
    }

    /*
     * Register stores information about copy and paste registers.  Besides
     * text, a register must store whether it is linewise (i.e., when it is
     * pasted, should it insert itself into a new line, or should the text be
     * inserted at the cursor position.)
     */
    function Register(text, linewise, blockwise) {
      this.clear();
      this.keyBuffer = [text || ''];
      this.insertModeChanges = [];
      this.searchQueries = [];
      this.linewise = !!linewise;
      this.blockwise = !!blockwise;
    }
    Register.prototype = {
      setText: function (text, linewise, blockwise) {
        this.keyBuffer = [text || ''];
        this.linewise = !!linewise;
        this.blockwise = !!blockwise;
      },
      pushText: function (text, linewise) {
        // if this register has ever been set to linewise, use linewise.
        if (linewise) {
          if (!this.linewise) {
            this.keyBuffer.push('\n');
          }
          this.linewise = true;
        }
        this.keyBuffer.push(text);
      },
      pushInsertModeChanges: function (changes) {
        this.insertModeChanges.push(createInsertModeChanges(changes));
      },
      pushSearchQuery: function (query) {
        this.searchQueries.push(query);
      },
      clear: function () {
        this.keyBuffer = [];
        this.insertModeChanges = [];
        this.searchQueries = [];
        this.linewise = false;
      },
      toString: function () {
        return this.keyBuffer.join('');
      }
    };

    /**
     * Defines an external register.
     *
     * The name should be a single character that will be used to reference the register.
     * The register should support setText, pushText, clear, and toString(). See Register
     * for a reference implementation.
     */
    function defineRegister(name, register) {
      var registers = vimGlobalState.registerController.registers;
      if (!name || name.length != 1) {
        throw Error('Register name must be 1 character');
      }
      if (registers[name]) {
        throw Error('Register already defined ' + name);
      }
      registers[name] = register;
      validRegisters.push(name);
    }

    /*
     * vim registers allow you to keep many independent copy and paste buffers.
     * See http://usevim.com/2012/04/13/registers/ for an introduction.
     *
     * RegisterController keeps the state of all the registers.  An initial
     * state may be passed in.  The unnamed register '"' will always be
     * overridden.
     */
    function RegisterController(registers) {
      this.registers = registers;
      this.unnamedRegister = registers['"'] = new Register();
      registers['.'] = new Register();
      registers[':'] = new Register();
      registers['/'] = new Register();
    }
    RegisterController.prototype = {
      pushText: function (registerName, operator, text, linewise, blockwise) {
        if (linewise && text.charAt(text.length - 1) !== '\n') {
          text += '\n';
        }
        // Lowercase and uppercase registers refer to the same register.
        // Uppercase just means append.
        var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;
        // if no register/an invalid register was specified, things go to the
        // default registers
        if (!register) {
          switch (operator) {
            case 'yank':
              // The 0 register contains the text from the most recent yank.
              this.registers['0'] = new Register(text, linewise, blockwise);
              break;
            case 'delete':
            case 'change':
              if (text.indexOf('\n') == -1) {
                // Delete less than 1 line. Update the small delete register.
                this.registers['-'] = new Register(text, linewise);
              } else {
                // Shift down the contents of the numbered registers and put the
                // deleted text into register 1.
                this.shiftNumericRegisters_();
                this.registers['1'] = new Register(text, linewise);
              }
              break;
          }
          // Make sure the unnamed register is set to what just happened
          this.unnamedRegister.setText(text, linewise, blockwise);
          return;
        }

        // If we've gotten to this point, we've actually specified a register
        var append = isUpperCase(registerName);
        if (append) {
          register.pushText(text, linewise);
        } else {
          register.setText(text, linewise, blockwise);
        }
        // The unnamed register always has the same value as the last used
        // register.
        this.unnamedRegister.setText(register.toString(), linewise);
      },
      // Gets the register named @name.  If one of @name doesn't already exist,
      // create it.  If @name is invalid, return the unnamedRegister.
      getRegister: function (name) {
        if (!this.isValidRegister(name)) {
          return this.unnamedRegister;
        }
        name = name.toLowerCase();
        if (!this.registers[name]) {
          this.registers[name] = new Register();
        }
        return this.registers[name];
      },
      isValidRegister: function (name) {
        return name && inArray(name, validRegisters);
      },
      shiftNumericRegisters_: function () {
        for (var i = 9; i >= 2; i--) {
          this.registers[i] = this.getRegister('' + (i - 1));
        }
      }
    };
    function HistoryController() {
      this.historyBuffer = [];
      this.iterator = 0;
      this.initialPrefix = null;
    }
    HistoryController.prototype = {
      // the input argument here acts a user entered prefix for a small time
      // until we start autocompletion in which case it is the autocompleted.
      nextMatch: function (input, up) {
        var historyBuffer = this.historyBuffer;
        var dir = up ? -1 : 1;
        if (this.initialPrefix === null) this.initialPrefix = input;
        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {
          var element = historyBuffer[i];
          for (var j = 0; j <= element.length; j++) {
            if (this.initialPrefix == element.substring(0, j)) {
              this.iterator = i;
              return element;
            }
          }
        }
        // should return the user input in case we reach the end of buffer.
        if (i >= historyBuffer.length) {
          this.iterator = historyBuffer.length;
          return this.initialPrefix;
        }
        // return the last autocompleted query or exCommand as it is.
        if (i < 0) return input;
      },
      pushInput: function (input) {
        var index = this.historyBuffer.indexOf(input);
        if (index > -1) this.historyBuffer.splice(index, 1);
        if (input.length) this.historyBuffer.push(input);
      },
      reset: function () {
        this.initialPrefix = null;
        this.iterator = this.historyBuffer.length;
      }
    };
    var commandDispatcher = {
      matchCommand: function (keys, keyMap, inputState, context) {
        var matches = commandMatches(keys, keyMap, context, inputState);
        if (!matches.full && !matches.partial) {
          return { type: 'none' };
        } else if (!matches.full && matches.partial) {
          return { type: 'partial' };
        }

        var bestMatch;
        for (var i = 0; i < matches.full.length; i++) {
          var match = matches.full[i];
          if (!bestMatch) {
            bestMatch = match;
          }
        }
        if (bestMatch.keys.slice(-11) == '<character>') {
          var character = lastChar(keys);
          if (!character) return { type: 'none' };
          inputState.selectedCharacter = character;
        }
        return { type: 'full', command: bestMatch };
      },
      processCommand: function (cm, vim, command) {
        vim.inputState.repeatOverride = command.repeatOverride;
        switch (command.type) {
          case 'motion':
            this.processMotion(cm, vim, command);
            break;
          case 'operator':
            this.processOperator(cm, vim, command);
            break;
          case 'operatorMotion':
            this.processOperatorMotion(cm, vim, command);
            break;
          case 'action':
            this.processAction(cm, vim, command);
            break;
          case 'search':
            this.processSearch(cm, vim, command);
            break;
          case 'ex':
          case 'keyToEx':
            this.processEx(cm, vim, command);
            break;
          default:
            break;
        }
      },
      processMotion: function (cm, vim, command) {
        vim.inputState.motion = command.motion;
        vim.inputState.motionArgs = copyArgs(command.motionArgs);
        this.evalInput(cm, vim);
      },
      processOperator: function (cm, vim, command) {
        var inputState = vim.inputState;
        if (inputState.operator) {
          if (inputState.operator == command.operator) {
            // Typing an operator twice like 'dd' makes the operator operate
            // linewise
            inputState.motion = 'expandToLine';
            inputState.motionArgs = { linewise: true };
            this.evalInput(cm, vim);
            return;
          } else {
            // 2 different operators in a row doesn't make sense.
            clearInputState(cm);
          }
        }
        inputState.operator = command.operator;
        inputState.operatorArgs = copyArgs(command.operatorArgs);
        if (vim.visualMode) {
          // Operating on a selection in visual mode. We don't need a motion.
          this.evalInput(cm, vim);
        }
      },
      processOperatorMotion: function (cm, vim, command) {
        var visualMode = vim.visualMode;
        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
        if (operatorMotionArgs) {
          // Operator motions may have special behavior in visual mode.
          if (visualMode && operatorMotionArgs.visualLine) {
            vim.visualLine = true;
          }
        }
        this.processOperator(cm, vim, command);
        if (!visualMode) {
          this.processMotion(cm, vim, command);
        }
      },
      processAction: function (cm, vim, command) {
        var inputState = vim.inputState;
        var repeat = inputState.getRepeat();
        var repeatIsExplicit = !!repeat;
        var actionArgs = copyArgs(command.actionArgs) || {};
        if (inputState.selectedCharacter) {
          actionArgs.selectedCharacter = inputState.selectedCharacter;
        }
        // Actions may or may not have motions and operators. Do these first.
        if (command.operator) {
          this.processOperator(cm, vim, command);
        }
        if (command.motion) {
          this.processMotion(cm, vim, command);
        }
        if (command.motion || command.operator) {
          this.evalInput(cm, vim);
        }
        actionArgs.repeat = repeat || 1;
        actionArgs.repeatIsExplicit = repeatIsExplicit;
        actionArgs.registerName = inputState.registerName;
        clearInputState(cm);
        vim.lastMotion = null;
        if (command.isEdit) {
          this.recordLastEdit(vim, inputState, command);
        }
        actions[command.action](cm, actionArgs, vim);
      },
      processSearch: function (cm, vim, command) {
        if (!cm.getSearchCursor) {
          // Search depends on SearchCursor.
          return;
        }
        var forward = command.searchArgs.forward;
        var wholeWordOnly = command.searchArgs.wholeWordOnly;
        getSearchState(cm).setReversed(!forward);
        var promptPrefix = forward ? '/' : '?';
        var originalQuery = getSearchState(cm).getQuery();
        var originalScrollPos = cm.getScrollInfo();
        function handleQuery(query, ignoreCase, smartCase) {
          vimGlobalState.searchHistoryController.pushInput(query);
          vimGlobalState.searchHistoryController.reset();
          try {
            updateSearchQuery(cm, query, ignoreCase, smartCase);
          } catch (e) {
            showConfirm(cm, 'Invalid regex: ' + query);
            clearInputState(cm);
            return;
          }
          commandDispatcher.processMotion(cm, vim, {
            type: 'motion',
            motion: 'findNext',
            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }
          });
        }
        function onPromptClose(query) {
          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          handleQuery(query, true /** ignoreCase */, true /** smartCase */);
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isRecording) {
            logSearchQuery(macroModeState, query);
          }
        }
        function onPromptKeyUp(e, query, close) {
          var keyName = CodeMirror.keyName(e),
              up,
              offset;
          if (keyName == 'Up' || keyName == 'Down') {
            up = keyName == 'Up' ? true : false;
            offset = e.target ? e.target.selectionEnd : 0;
            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';
            close(query);
            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
          } else {
            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();
          }
          var parsedQuery;
          try {
            parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);
          } catch (e) {
            // Swallow bad regexes for incremental search.
          }
          if (parsedQuery) {
            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
          } else {
            clearSearchHighlight(cm);
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          }
        }
        function onPromptKeyDown(e, query, close) {
          var keyName = CodeMirror.keyName(e);
          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {
            vimGlobalState.searchHistoryController.pushInput(query);
            vimGlobalState.searchHistoryController.reset();
            updateSearchQuery(cm, originalQuery);
            clearSearchHighlight(cm);
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
            CodeMirror.e_stop(e);
            clearInputState(cm);
            close();
            cm.focus();
          } else if (keyName == 'Up' || keyName == 'Down') {
            CodeMirror.e_stop(e);
          } else if (keyName == 'Ctrl-U') {
            // Ctrl-U clears input.
            CodeMirror.e_stop(e);
            close('');
          }
        }
        switch (command.searchArgs.querySrc) {
          case 'prompt':
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isPlaying) {
              var query = macroModeState.replaySearchQueries.shift();
              handleQuery(query, true /** ignoreCase */, false /** smartCase */);
            } else {
              showPrompt(cm, {
                onClose: onPromptClose,
                prefix: promptPrefix,
                desc: searchPromptDesc,
                onKeyUp: onPromptKeyUp,
                onKeyDown: onPromptKeyDown
              });
            }
            break;
          case 'wordUnderCursor':
            var word = expandWordUnderCursor(cm, false /** inclusive */
            , true /** forward */, false /** bigWord */
            , true /** noSymbol */);
            var isKeyword = true;
            if (!word) {
              word = expandWordUnderCursor(cm, false /** inclusive */
              , true /** forward */, false /** bigWord */
              , false /** noSymbol */);
              isKeyword = false;
            }
            if (!word) {
              return;
            }
            var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);
            if (isKeyword && wholeWordOnly) {
              query = '\\b' + query + '\\b';
            } else {
              query = escapeRegex(query);
            }

            // cachedCursor is used to save the old position of the cursor
            // when * or # causes vim to seek for the nearest word and shift
            // the cursor before entering the motion.
            vimGlobalState.jumpList.cachedCursor = cm.getCursor();
            cm.setCursor(word.start);

            handleQuery(query, true /** ignoreCase */, false /** smartCase */);
            break;
        }
      },
      processEx: function (cm, vim, command) {
        function onPromptClose(input) {
          // Give the prompt some time to close so that if processCommand shows
          // an error, the elements don't overlap.
          vimGlobalState.exCommandHistoryController.pushInput(input);
          vimGlobalState.exCommandHistoryController.reset();
          exCommandDispatcher.processCommand(cm, input);
        }
        function onPromptKeyDown(e, input, close) {
          var keyName = CodeMirror.keyName(e),
              up,
              offset;
          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {
            vimGlobalState.exCommandHistoryController.pushInput(input);
            vimGlobalState.exCommandHistoryController.reset();
            CodeMirror.e_stop(e);
            clearInputState(cm);
            close();
            cm.focus();
          }
          if (keyName == 'Up' || keyName == 'Down') {
            CodeMirror.e_stop(e);
            up = keyName == 'Up' ? true : false;
            offset = e.target ? e.target.selectionEnd : 0;
            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';
            close(input);
            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
          } else if (keyName == 'Ctrl-U') {
            // Ctrl-U clears input.
            CodeMirror.e_stop(e);
            close('');
          } else {
            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();
          }
        }
        if (command.type == 'keyToEx') {
          // Handle user defined Ex to Ex mappings
          exCommandDispatcher.processCommand(cm, command.exArgs.input);
        } else {
          if (vim.visualMode) {
            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\'<,\'>',
              onKeyDown: onPromptKeyDown, selectValueOnOpen: false });
          } else {
            showPrompt(cm, { onClose: onPromptClose, prefix: ':',
              onKeyDown: onPromptKeyDown });
          }
        }
      },
      evalInput: function (cm, vim) {
        // If the motion command is set, execute both the operator and motion.
        // Otherwise return.
        var inputState = vim.inputState;
        var motion = inputState.motion;
        var motionArgs = inputState.motionArgs || {};
        var operator = inputState.operator;
        var operatorArgs = inputState.operatorArgs || {};
        var registerName = inputState.registerName;
        var sel = vim.sel;
        // TODO: Make sure cm and vim selections are identical outside visual mode.
        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));
        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));
        var oldHead = copyCursor(origHead);
        var oldAnchor = copyCursor(origAnchor);
        var newHead, newAnchor;
        var repeat;
        if (operator) {
          this.recordLastEdit(vim, inputState);
        }
        if (inputState.repeatOverride !== undefined) {
          // If repeatOverride is specified, that takes precedence over the
          // input state's repeat. Used by Ex mode and can be user defined.
          repeat = inputState.repeatOverride;
        } else {
          repeat = inputState.getRepeat();
        }
        if (repeat > 0 && motionArgs.explicitRepeat) {
          motionArgs.repeatIsExplicit = true;
        } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {
          repeat = 1;
          motionArgs.repeatIsExplicit = false;
        }
        if (inputState.selectedCharacter) {
          // If there is a character input, stick it in all of the arg arrays.
          motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;
        }
        motionArgs.repeat = repeat;
        clearInputState(cm);
        if (motion) {
          var motionResult = motions[motion](cm, origHead, motionArgs, vim);
          vim.lastMotion = motions[motion];
          if (!motionResult) {
            return;
          }
          if (motionArgs.toJumplist) {
            var jumpList = vimGlobalState.jumpList;
            // if the current motion is # or *, use cachedCursor
            var cachedCursor = jumpList.cachedCursor;
            if (cachedCursor) {
              recordJumpPosition(cm, cachedCursor, motionResult);
              delete jumpList.cachedCursor;
            } else {
              recordJumpPosition(cm, origHead, motionResult);
            }
          }
          if (motionResult instanceof Array) {
            newAnchor = motionResult[0];
            newHead = motionResult[1];
          } else {
            newHead = motionResult;
          }
          // TODO: Handle null returns from motion commands better.
          if (!newHead) {
            newHead = copyCursor(origHead);
          }
          if (vim.visualMode) {
            if (!(vim.visualBlock && newHead.ch === Infinity)) {
              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);
            }
            if (newAnchor) {
              newAnchor = clipCursorToContent(cm, newAnchor, true);
            }
            newAnchor = newAnchor || oldAnchor;
            sel.anchor = newAnchor;
            sel.head = newHead;
            updateCmSelection(cm);
            updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);
            updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);
          } else if (!operator) {
            newHead = clipCursorToContent(cm, newHead);
            cm.setCursor(newHead.line, newHead.ch);
          }
        }
        if (operator) {
          if (operatorArgs.lastSel) {
            // Replaying a visual mode operation
            newAnchor = oldAnchor;
            var lastSel = operatorArgs.lastSel;
            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
            if (lastSel.visualLine) {
              // Linewise Visual mode: The same number of lines.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
            } else if (lastSel.visualBlock) {
              // Blockwise Visual mode: The same number of lines and columns.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
            } else if (lastSel.head.line == lastSel.anchor.line) {
              // Normal Visual mode within one line: The same number of characters.
              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);
            } else {
              // Normal Visual mode with several lines: The same number of lines, in the
              // last line the same number of characters as in the last line the last time.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
            }
            vim.visualMode = true;
            vim.visualLine = lastSel.visualLine;
            vim.visualBlock = lastSel.visualBlock;
            sel = vim.sel = {
              anchor: newAnchor,
              head: newHead
            };
            updateCmSelection(cm);
          } else if (vim.visualMode) {
            operatorArgs.lastSel = {
              anchor: copyCursor(sel.anchor),
              head: copyCursor(sel.head),
              visualBlock: vim.visualBlock,
              visualLine: vim.visualLine
            };
          }
          var curStart, curEnd, linewise, mode;
          var cmSel;
          if (vim.visualMode) {
            // Init visual op
            curStart = cursorMin(sel.head, sel.anchor);
            curEnd = cursorMax(sel.head, sel.anchor);
            linewise = vim.visualLine || operatorArgs.linewise;
            mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';
            cmSel = makeCmSelection(cm, {
              anchor: curStart,
              head: curEnd
            }, mode);
            if (linewise) {
              var ranges = cmSel.ranges;
              if (mode == 'block') {
                // Linewise operators in visual block mode extend to end of line
                for (var i = 0; i < ranges.length; i++) {
                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
                }
              } else if (mode == 'line') {
                ranges[0].head = Pos(ranges[0].head.line + 1, 0);
              }
            }
          } else {
            // Init motion op
            curStart = copyCursor(newAnchor || oldAnchor);
            curEnd = copyCursor(newHead || oldHead);
            if (cursorIsBefore(curEnd, curStart)) {
              var tmp = curStart;
              curStart = curEnd;
              curEnd = tmp;
            }
            linewise = motionArgs.linewise || operatorArgs.linewise;
            if (linewise) {
              // Expand selection to entire line.
              expandSelectionToLine(cm, curStart, curEnd);
            } else if (motionArgs.forward) {
              // Clip to trailing newlines only if the motion goes forward.
              clipToLine(cm, curStart, curEnd);
            }
            mode = 'char';
            var exclusive = !motionArgs.inclusive || linewise;
            cmSel = makeCmSelection(cm, {
              anchor: curStart,
              head: curEnd
            }, mode, exclusive);
          }
          cm.setSelections(cmSel.ranges, cmSel.primary);
          vim.lastMotion = null;
          operatorArgs.repeat = repeat; // For indent in visual mode.
          operatorArgs.registerName = registerName;
          // Keep track of linewise as it affects how paste and change behave.
          operatorArgs.linewise = linewise;
          var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);
          if (vim.visualMode) {
            exitVisualMode(cm, operatorMoveTo != null);
          }
          if (operatorMoveTo) {
            cm.setCursor(operatorMoveTo);
          }
        }
      },
      recordLastEdit: function (vim, inputState, actionCommand) {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) {
          return;
        }
        vim.lastEditInputState = inputState;
        vim.lastEditActionCommand = actionCommand;
        macroModeState.lastInsertModeChanges.changes = [];
        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;
      }
    };

    /**
     * typedef {Object{line:number,ch:number}} Cursor An object containing the
     *     position of the cursor.
     */
    // All of the functions below return Cursor objects.
    var motions = {
      moveToTopLine: function (cm, _head, motionArgs) {
        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      moveToMiddleLine: function (cm) {
        var range = getUserVisibleLines(cm);
        var line = Math.floor((range.top + range.bottom) * 0.5);
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      moveToBottomLine: function (cm, _head, motionArgs) {
        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      expandToLine: function (_cm, head, motionArgs) {
        // Expands forward to end of line, and then to next line if repeat is
        // >1. Does not handle backward motion!
        var cur = head;
        return Pos(cur.line + motionArgs.repeat - 1, Infinity);
      },
      findNext: function (cm, _head, motionArgs) {
        var state = getSearchState(cm);
        var query = state.getQuery();
        if (!query) {
          return;
        }
        var prev = !motionArgs.forward;
        // If search is initiated with ? instead of /, negate direction.
        prev = state.isReversed() ? !prev : prev;
        highlightSearchMatches(cm, query);
        return findNext(cm, prev /** prev */, query, motionArgs.repeat);
      },
      goToMark: function (cm, _head, motionArgs, vim) {
        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);
        if (pos) {
          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
        }
        return null;
      },
      moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {
        if (vim.visualBlock && motionArgs.sameLine) {
          var sel = vim.sel;
          return [clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))];
        } else {
          return [vim.sel.head, vim.sel.anchor];
        }
      },
      jumpToMark: function (cm, head, motionArgs, vim) {
        var best = head;
        for (var i = 0; i < motionArgs.repeat; i++) {
          var cursor = best;
          for (var key in vim.marks) {
            if (!isLowerCase(key)) {
              continue;
            }
            var mark = vim.marks[key].find();
            var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);

            if (isWrongDirection) {
              continue;
            }
            if (motionArgs.linewise && mark.line == cursor.line) {
              continue;
            }

            var equal = cursorEqual(cursor, best);
            var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);

            if (equal || between) {
              best = mark;
            }
          }
        }

        if (motionArgs.linewise) {
          // Vim places the cursor on the first non-whitespace character of
          // the line if there is one, else it places the cursor at the end
          // of the line, regardless of whether a mark was found.
          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
        }
        return best;
      },
      moveByCharacters: function (_cm, head, motionArgs) {
        var cur = head;
        var repeat = motionArgs.repeat;
        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
        return Pos(cur.line, ch);
      },
      moveByLines: function (cm, head, motionArgs, vim) {
        var cur = head;
        var endCh = cur.ch;
        // Depending what our last motion was, we may want to do different
        // things. If our last motion was moving vertically, we want to
        // preserve the HPos from our last horizontal move.  If our last motion
        // was going to the end of a line, moving vertically we should go to
        // the end of the line, etc.
        switch (vim.lastMotion) {
          case this.moveByLines:
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveToColumn:
          case this.moveToEol:
            endCh = vim.lastHPos;
            break;
          default:
            vim.lastHPos = endCh;
        }
        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);
        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
        var first = cm.firstLine();
        var last = cm.lastLine();
        // Vim go to line begin or line end when cursor at first/last line and
        // move to previous/next line is triggered.
        if (line < first && cur.line == first) {
          return this.moveToStartOfLine(cm, head, motionArgs, vim);
        } else if (line > last && cur.line == last) {
          return this.moveToEol(cm, head, motionArgs, vim, true);
        }
        if (motionArgs.toFirstChar) {
          endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));
          vim.lastHPos = endCh;
        }
        vim.lastHSPos = cm.charCoords(Pos(line, endCh), 'div').left;
        return Pos(line, endCh);
      },
      moveByDisplayLines: function (cm, head, motionArgs, vim) {
        var cur = head;
        switch (vim.lastMotion) {
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveByLines:
          case this.moveToColumn:
          case this.moveToEol:
            break;
          default:
            vim.lastHSPos = cm.charCoords(cur, 'div').left;
        }
        var repeat = motionArgs.repeat;
        var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);
        if (res.hitSide) {
          if (motionArgs.forward) {
            var lastCharCoords = cm.charCoords(res, 'div');
            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };
            var res = cm.coordsChar(goalCoords, 'div');
          } else {
            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');
            resCoords.left = vim.lastHSPos;
            res = cm.coordsChar(resCoords, 'div');
          }
        }
        vim.lastHPos = res.ch;
        return res;
      },
      moveByPage: function (cm, head, motionArgs) {
        // CodeMirror only exposes functions that move the cursor page down, so
        // doing this bad hack to move the cursor and move it back. evalInput
        // will move the cursor to where it should be in the end.
        var curStart = head;
        var repeat = motionArgs.repeat;
        return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');
      },
      moveByParagraph: function (cm, head, motionArgs) {
        var dir = motionArgs.forward ? 1 : -1;
        return findParagraph(cm, head, motionArgs.repeat, dir);
      },
      moveBySentence: function (cm, head, motionArgs) {
        var dir = motionArgs.forward ? 1 : -1;
        return findSentence(cm, head, motionArgs.repeat, dir);
      },
      moveByScroll: function (cm, head, motionArgs, vim) {
        var scrollbox = cm.getScrollInfo();
        var curEnd = null;
        var repeat = motionArgs.repeat;
        if (!repeat) {
          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
        }
        var orig = cm.charCoords(head, 'local');
        motionArgs.repeat = repeat;
        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);
        if (!curEnd) {
          return null;
        }
        var dest = cm.charCoords(curEnd, 'local');
        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
        return curEnd;
      },
      moveByWords: function (cm, head, motionArgs) {
        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);
      },
      moveTillCharacter: function (cm, _head, motionArgs) {
        var repeat = motionArgs.repeat;
        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);
        var increment = motionArgs.forward ? -1 : 1;
        recordLastCharacterSearch(increment, motionArgs);
        if (!curEnd) return null;
        curEnd.ch += increment;
        return curEnd;
      },
      moveToCharacter: function (cm, head, motionArgs) {
        var repeat = motionArgs.repeat;
        recordLastCharacterSearch(0, motionArgs);
        return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
      },
      moveToSymbol: function (cm, head, motionArgs) {
        var repeat = motionArgs.repeat;
        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
      },
      moveToColumn: function (cm, head, motionArgs, vim) {
        var repeat = motionArgs.repeat;
        // repeat is equivalent to which column we want to move to!
        vim.lastHPos = repeat - 1;
        vim.lastHSPos = cm.charCoords(head, 'div').left;
        return moveToColumn(cm, repeat);
      },
      moveToEol: function (cm, head, motionArgs, vim, keepHPos) {
        var cur = head;
        var retval = Pos(cur.line + motionArgs.repeat - 1, Infinity);
        var end = cm.clipPos(retval);
        end.ch--;
        if (!keepHPos) {
          vim.lastHPos = Infinity;
          vim.lastHSPos = cm.charCoords(end, 'div').left;
        }
        return retval;
      },
      moveToFirstNonWhiteSpaceCharacter: function (cm, head) {
        // Go to the start of the line where the text begins, or the end for
        // whitespace-only lines
        var cursor = head;
        return Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
      },
      moveToMatchedSymbol: function (cm, head) {
        var cursor = head;
        var line = cursor.line;
        var ch = cursor.ch;
        var lineText = cm.getLine(line);
        var symbol;
        for (; ch < lineText.length; ch++) {
          symbol = lineText.charAt(ch);
          if (symbol && isMatchableSymbol(symbol)) {
            var style = cm.getTokenTypeAt(Pos(line, ch + 1));
            if (style !== "string" && style !== "comment") {
              break;
            }
          }
        }
        if (ch < lineText.length) {
          // Only include angle brackets in analysis if they are being matched.
          var re = ch === '<' || ch === '>' ? /[(){}[\]<>]/ : /[(){}[\]]/;
          var matched = cm.findMatchingBracket(Pos(line, ch), { bracketRegex: re });
          return matched.to;
        } else {
          return cursor;
        }
      },
      moveToStartOfLine: function (_cm, head) {
        return Pos(head.line, 0);
      },
      moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {
        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
        if (motionArgs.repeatIsExplicit) {
          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');
        }
        return Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
      },
      textObjectManipulation: function (cm, head, motionArgs, vim) {
        // TODO: lots of possible exceptions that can be thrown here. Try da(
        //     outside of a () block.
        var mirroredPairs = { '(': ')', ')': '(',
          '{': '}', '}': '{',
          '[': ']', ']': '[',
          '<': '>', '>': '<' };
        var selfPaired = { '\'': true, '"': true, '`': true };

        var character = motionArgs.selectedCharacter;
        // 'b' refers to  '()' block.
        // 'B' refers to  '{}' block.
        if (character == 'b') {
          character = '(';
        } else if (character == 'B') {
          character = '{';
        }

        // Inclusive is the difference between a and i
        // TODO: Instead of using the additional text object map to perform text
        //     object operations, merge the map into the defaultKeyMap and use
        //     motionArgs to define behavior. Define separate entries for 'aw',
        //     'iw', 'a[', 'i[', etc.
        var inclusive = !motionArgs.textObjectInner;

        var tmp;
        if (mirroredPairs[character]) {
          tmp = selectCompanionObject(cm, head, character, inclusive);
        } else if (selfPaired[character]) {
          tmp = findBeginningAndEnd(cm, head, character, inclusive);
        } else if (character === 'W') {
          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */
          , true /** bigWord */);
        } else if (character === 'w') {
          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */
          , false /** bigWord */);
        } else if (character === 'p') {
          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
          motionArgs.linewise = true;
          if (vim.visualMode) {
            if (!vim.visualLine) {
              vim.visualLine = true;
            }
          } else {
            var operatorArgs = vim.inputState.operatorArgs;
            if (operatorArgs) {
              operatorArgs.linewise = true;
            }
            tmp.end.line--;
          }
        } else {
          // No text object defined for this, don't move.
          return null;
        }

        if (!cm.state.vim.visualMode) {
          return [tmp.start, tmp.end];
        } else {
          return expandSelection(cm, tmp.start, tmp.end);
        }
      },

      repeatLastCharacterSearch: function (cm, head, motionArgs) {
        var lastSearch = vimGlobalState.lastCharacterSearch;
        var repeat = motionArgs.repeat;
        var forward = motionArgs.forward === lastSearch.forward;
        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
        cm.moveH(-increment, 'char');
        motionArgs.inclusive = forward ? true : false;
        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
        if (!curEnd) {
          cm.moveH(increment, 'char');
          return head;
        }
        curEnd.ch += increment;
        return curEnd;
      }
    };

    function defineMotion(name, fn) {
      motions[name] = fn;
    }

    function fillArray(val, times) {
      var arr = [];
      for (var i = 0; i < times; i++) {
        arr.push(val);
      }
      return arr;
    }
    /**
     * An operator acts on a text selection. It receives the list of selections
     * as input. The corresponding CodeMirror selection is guaranteed to
    * match the input selection.
     */
    var operators = {
      change: function (cm, args, ranges) {
        var finalHead, text;
        var vim = cm.state.vim;
        if (!vim.visualMode) {
          var anchor = ranges[0].anchor,
              head = ranges[0].head;
          text = cm.getRange(anchor, head);
          var lastState = vim.lastEditInputState || {};
          if (lastState.motion == "moveByWords" && !isWhiteSpaceString(text)) {
            // Exclude trailing whitespace if the range is not all whitespace.
            var match = /\s+$/.exec(text);
            if (match && lastState.motionArgs && lastState.motionArgs.forward) {
              head = offsetCursor(head, 0, -match[0].length);
              text = text.slice(0, -match[0].length);
            }
          }
          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);
          var wasLastLine = cm.firstLine() == cm.lastLine();
          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {
            cm.replaceRange('', prevLineEnd, head);
          } else {
            cm.replaceRange('', anchor, head);
          }
          if (args.linewise) {
            // Push the next line back down, if there is a next line.
            if (!wasLastLine) {
              cm.setCursor(prevLineEnd);
              CodeMirror.commands.newlineAndIndent(cm);
            }
            // make sure cursor ends up at the end of the line.
            anchor.ch = Number.MAX_VALUE;
          }
          finalHead = anchor;
        } else {
          text = cm.getSelection();
          var replacement = fillArray('', ranges.length);
          cm.replaceSelections(replacement);
          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
        }
        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);
        actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);
      },
      // delete is a javascript keyword.
      'delete': function (cm, args, ranges) {
        var finalHead, text;
        var vim = cm.state.vim;
        if (!vim.visualBlock) {
          var anchor = ranges[0].anchor,
              head = ranges[0].head;
          if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {
            // Special case for dd on last line (and first line).
            if (anchor.line == cm.firstLine()) {
              anchor.ch = 0;
            } else {
              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));
            }
          }
          text = cm.getRange(anchor, head);
          cm.replaceRange('', anchor, head);
          finalHead = anchor;
          if (args.linewise) {
            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
          }
        } else {
          text = cm.getSelection();
          var replacement = fillArray('', ranges.length);
          cm.replaceSelections(replacement);
          finalHead = ranges[0].anchor;
        }
        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);
        var includeLineBreak = vim.insertMode;
        return clipCursorToContent(cm, finalHead, includeLineBreak);
      },
      indent: function (cm, args, ranges) {
        var vim = cm.state.vim;
        var startLine = ranges[0].anchor.line;
        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;
        // In visual mode, n> shifts the selection right n times, instead of
        // shifting n lines right once.
        var repeat = vim.visualMode ? args.repeat : 1;
        if (args.linewise) {
          // The only way to delete a newline is to delete until the start of
          // the next line, so in linewise mode evalInput will include the next
          // line. We don't want this in indent, so we go back a line.
          endLine--;
        }
        for (var i = startLine; i <= endLine; i++) {
          for (var j = 0; j < repeat; j++) {
            cm.indentLine(i, args.indentRight);
          }
        }
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
      },
      indentAuto: function (cm, _args, ranges) {
        cm.execCommand("indentAuto");
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
      },
      changeCase: function (cm, args, ranges, oldAnchor, newHead) {
        var selections = cm.getSelections();
        var swapped = [];
        var toLower = args.toLower;
        for (var j = 0; j < selections.length; j++) {
          var toSwap = selections[j];
          var text = '';
          if (toLower === true) {
            text = toSwap.toLowerCase();
          } else if (toLower === false) {
            text = toSwap.toUpperCase();
          } else {
            for (var i = 0; i < toSwap.length; i++) {
              var character = toSwap.charAt(i);
              text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();
            }
          }
          swapped.push(text);
        }
        cm.replaceSelections(swapped);
        if (args.shouldMoveCursor) {
          return newHead;
        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {
          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
        } else if (args.linewise) {
          return oldAnchor;
        } else {
          return cursorMin(ranges[0].anchor, ranges[0].head);
        }
      },
      yank: function (cm, args, ranges, oldAnchor) {
        var vim = cm.state.vim;
        var text = cm.getSelection();
        var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;
        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);
        return endPos;
      }
    };

    function defineOperator(name, fn) {
      operators[name] = fn;
    }

    var actions = {
      jumpListWalk: function (cm, actionArgs, vim) {
        if (vim.visualMode) {
          return;
        }
        var repeat = actionArgs.repeat;
        var forward = actionArgs.forward;
        var jumpList = vimGlobalState.jumpList;

        var mark = jumpList.move(cm, forward ? repeat : -repeat);
        var markPos = mark ? mark.find() : undefined;
        markPos = markPos ? markPos : cm.getCursor();
        cm.setCursor(markPos);
      },
      scroll: function (cm, actionArgs, vim) {
        if (vim.visualMode) {
          return;
        }
        var repeat = actionArgs.repeat || 1;
        var lineHeight = cm.defaultTextHeight();
        var top = cm.getScrollInfo().top;
        var delta = lineHeight * repeat;
        var newPos = actionArgs.forward ? top + delta : top - delta;
        var cursor = copyCursor(cm.getCursor());
        var cursorCoords = cm.charCoords(cursor, 'local');
        if (actionArgs.forward) {
          if (newPos > cursorCoords.top) {
            cursor.line += (newPos - cursorCoords.top) / lineHeight;
            cursor.line = Math.ceil(cursor.line);
            cm.setCursor(cursor);
            cursorCoords = cm.charCoords(cursor, 'local');
            cm.scrollTo(null, cursorCoords.top);
          } else {
            // Cursor stays within bounds.  Just reposition the scroll window.
            cm.scrollTo(null, newPos);
          }
        } else {
          var newBottom = newPos + cm.getScrollInfo().clientHeight;
          if (newBottom < cursorCoords.bottom) {
            cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
            cursor.line = Math.floor(cursor.line);
            cm.setCursor(cursor);
            cursorCoords = cm.charCoords(cursor, 'local');
            cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
          } else {
            // Cursor stays within bounds.  Just reposition the scroll window.
            cm.scrollTo(null, newPos);
          }
        }
      },
      scrollToCursor: function (cm, actionArgs) {
        var lineNum = cm.getCursor().line;
        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');
        var height = cm.getScrollInfo().clientHeight;
        var y = charCoords.top;
        var lineHeight = charCoords.bottom - y;
        switch (actionArgs.position) {
          case 'center':
            y = y - height / 2 + lineHeight;
            break;
          case 'bottom':
            y = y - height + lineHeight;
            break;
        }
        cm.scrollTo(null, y);
      },
      replayMacro: function (cm, actionArgs, vim) {
        var registerName = actionArgs.selectedCharacter;
        var repeat = actionArgs.repeat;
        var macroModeState = vimGlobalState.macroModeState;
        if (registerName == '@') {
          registerName = macroModeState.latestRegister;
        } else {
          macroModeState.latestRegister = registerName;
        }
        while (repeat--) {
          executeMacroRegister(cm, vim, macroModeState, registerName);
        }
      },
      enterMacroRecordMode: function (cm, actionArgs) {
        var macroModeState = vimGlobalState.macroModeState;
        var registerName = actionArgs.selectedCharacter;
        if (vimGlobalState.registerController.isValidRegister(registerName)) {
          macroModeState.enterMacroRecordMode(cm, registerName);
        }
      },
      toggleOverwrite: function (cm) {
        if (!cm.state.overwrite) {
          cm.toggleOverwrite(true);
          cm.setOption('keyMap', 'vim-replace');
          CodeMirror.signal(cm, "vim-mode-change", { mode: "replace" });
        } else {
          cm.toggleOverwrite(false);
          cm.setOption('keyMap', 'vim-insert');
          CodeMirror.signal(cm, "vim-mode-change", { mode: "insert" });
        }
      },
      enterInsertMode: function (cm, actionArgs, vim) {
        if (cm.getOption('readOnly')) {
          return;
        }
        vim.insertMode = true;
        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
        var insertAt = actionArgs ? actionArgs.insertAt : null;
        var sel = vim.sel;
        var head = actionArgs.head || cm.getCursor('head');
        var height = cm.listSelections().length;
        if (insertAt == 'eol') {
          head = Pos(head.line, lineLength(cm, head.line));
        } else if (insertAt == 'charAfter') {
          head = offsetCursor(head, 0, 1);
        } else if (insertAt == 'firstNonBlank') {
          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);
        } else if (insertAt == 'startOfSelectedArea') {
          if (!vim.visualMode) return;
          if (!vim.visualBlock) {
            if (sel.head.line < sel.anchor.line) {
              head = sel.head;
            } else {
              head = Pos(sel.anchor.line, 0);
            }
          } else {
            head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));
            height = Math.abs(sel.head.line - sel.anchor.line) + 1;
          }
        } else if (insertAt == 'endOfSelectedArea') {
          if (!vim.visualMode) return;
          if (!vim.visualBlock) {
            if (sel.head.line >= sel.anchor.line) {
              head = offsetCursor(sel.head, 0, 1);
            } else {
              head = Pos(sel.anchor.line, 0);
            }
          } else {
            head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch + 1, sel.anchor.ch));
            height = Math.abs(sel.head.line - sel.anchor.line) + 1;
          }
        } else if (insertAt == 'inplace') {
          if (vim.visualMode) {
            return;
          }
        }
        cm.setOption('disableInput', false);
        if (actionArgs && actionArgs.replace) {
          // Handle Replace-mode as a special case of insert mode.
          cm.toggleOverwrite(true);
          cm.setOption('keyMap', 'vim-replace');
          CodeMirror.signal(cm, "vim-mode-change", { mode: "replace" });
        } else {
          cm.toggleOverwrite(false);
          cm.setOption('keyMap', 'vim-insert');
          CodeMirror.signal(cm, "vim-mode-change", { mode: "insert" });
        }
        if (!vimGlobalState.macroModeState.isPlaying) {
          // Only record if not replaying.
          cm.on('change', onChange);
          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);
        }
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
        selectForInsert(cm, head, height);
      },
      toggleVisualMode: function (cm, actionArgs, vim) {
        var repeat = actionArgs.repeat;
        var anchor = cm.getCursor();
        var head;
        // TODO: The repeat should actually select number of characters/lines
        //     equal to the repeat times the size of the previous visual
        //     operation.
        if (!vim.visualMode) {
          // Entering visual mode
          vim.visualMode = true;
          vim.visualLine = !!actionArgs.linewise;
          vim.visualBlock = !!actionArgs.blockwise;
          head = clipCursorToContent(cm, Pos(anchor.line, anchor.ch + repeat - 1), true /** includeLineBreak */);
          vim.sel = {
            anchor: anchor,
            head: head
          };
          CodeMirror.signal(cm, "vim-mode-change", { mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : "" });
          updateCmSelection(cm);
          updateMark(cm, vim, '<', cursorMin(anchor, head));
          updateMark(cm, vim, '>', cursorMax(anchor, head));
        } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {
          // Toggling between modes
          vim.visualLine = !!actionArgs.linewise;
          vim.visualBlock = !!actionArgs.blockwise;
          CodeMirror.signal(cm, "vim-mode-change", { mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : "" });
          updateCmSelection(cm);
        } else {
          exitVisualMode(cm);
        }
      },
      reselectLastSelection: function (cm, _actionArgs, vim) {
        var lastSelection = vim.lastSelection;
        if (vim.visualMode) {
          updateLastSelection(cm, vim);
        }
        if (lastSelection) {
          var anchor = lastSelection.anchorMark.find();
          var head = lastSelection.headMark.find();
          if (!anchor || !head) {
            // If the marks have been destroyed due to edits, do nothing.
            return;
          }
          vim.sel = {
            anchor: anchor,
            head: head
          };
          vim.visualMode = true;
          vim.visualLine = lastSelection.visualLine;
          vim.visualBlock = lastSelection.visualBlock;
          updateCmSelection(cm);
          updateMark(cm, vim, '<', cursorMin(anchor, head));
          updateMark(cm, vim, '>', cursorMax(anchor, head));
          CodeMirror.signal(cm, 'vim-mode-change', {
            mode: 'visual',
            subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : '' });
        }
      },
      joinLines: function (cm, actionArgs, vim) {
        var curStart, curEnd;
        if (vim.visualMode) {
          curStart = cm.getCursor('anchor');
          curEnd = cm.getCursor('head');
          if (cursorIsBefore(curEnd, curStart)) {
            var tmp = curEnd;
            curEnd = curStart;
            curStart = tmp;
          }
          curEnd.ch = lineLength(cm, curEnd.line) - 1;
        } else {
          // Repeat is the number of lines to join. Minimum 2 lines.
          var repeat = Math.max(actionArgs.repeat, 2);
          curStart = cm.getCursor();
          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1, Infinity));
        }
        var finalCh = 0;
        for (var i = curStart.line; i < curEnd.line; i++) {
          finalCh = lineLength(cm, curStart.line);
          var tmp = Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));
          var text = cm.getRange(curStart, tmp);
          text = text.replace(/\n\s*/g, ' ');
          cm.replaceRange(text, curStart, tmp);
        }
        var curFinalPos = Pos(curStart.line, finalCh);
        if (vim.visualMode) {
          exitVisualMode(cm, false);
        }
        cm.setCursor(curFinalPos);
      },
      newLineAndEnterInsertMode: function (cm, actionArgs, vim) {
        vim.insertMode = true;
        var insertAt = copyCursor(cm.getCursor());
        if (insertAt.line === cm.firstLine() && !actionArgs.after) {
          // Special case for inserting newline before start of document.
          cm.replaceRange('\n', Pos(cm.firstLine(), 0));
          cm.setCursor(cm.firstLine(), 0);
        } else {
          insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;
          insertAt.ch = lineLength(cm, insertAt.line);
          cm.setCursor(insertAt);
          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;
          newlineFn(cm);
        }
        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);
      },
      paste: function (cm, actionArgs, vim) {
        var cur = copyCursor(cm.getCursor());
        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);
        var text = register.toString();
        if (!text) {
          return;
        }
        if (actionArgs.matchIndent) {
          var tabSize = cm.getOption("tabSize");
          // length that considers tabs and tabSize
          var whitespaceLength = function (str) {
            var tabs = str.split("\t").length - 1;
            var spaces = str.split(" ").length - 1;
            return tabs * tabSize + spaces * 1;
          };
          var currentLine = cm.getLine(cm.getCursor().line);
          var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
          // chomp last newline b/c don't want it to match /^\s*/gm
          var chompedText = text.replace(/\n$/, '');
          var wasChomped = text !== chompedText;
          var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
          var text = chompedText.replace(/^\s*/gm, function (wspace) {
            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
            if (newIndent < 0) {
              return "";
            } else if (cm.getOption("indentWithTabs")) {
              var quotient = Math.floor(newIndent / tabSize);
              return Array(quotient + 1).join('\t');
            } else {
              return Array(newIndent + 1).join(' ');
            }
          });
          text += wasChomped ? "\n" : "";
        }
        if (actionArgs.repeat > 1) {
          var text = Array(actionArgs.repeat + 1).join(text);
        }
        var linewise = register.linewise;
        var blockwise = register.blockwise;
        if (blockwise) {
          text = text.split('\n');
          if (linewise) {
            text.pop();
          }
          for (var i = 0; i < text.length; i++) {
            text[i] = text[i] == '' ? ' ' : text[i];
          }
          cur.ch += actionArgs.after ? 1 : 0;
          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
        } else if (linewise) {
          if (vim.visualMode) {
            text = vim.visualLine ? text.slice(0, -1) : '\n' + text.slice(0, text.length - 1) + '\n';
          } else if (actionArgs.after) {
            // Move the newline at the end to the start instead, and paste just
            // before the newline character of the line we are on right now.
            text = '\n' + text.slice(0, text.length - 1);
            cur.ch = lineLength(cm, cur.line);
          } else {
            cur.ch = 0;
          }
        } else {
          cur.ch += actionArgs.after ? 1 : 0;
        }
        var curPosFinal;
        var idx;
        if (vim.visualMode) {
          //  save the pasted text for reselection if the need arises
          vim.lastPastedText = text;
          var lastSelectionCurEnd;
          var selectedArea = getSelectedAreaRange(cm, vim);
          var selectionStart = selectedArea[0];
          var selectionEnd = selectedArea[1];
          var selectedText = cm.getSelection();
          var selections = cm.listSelections();
          var emptyStrings = new Array(selections.length).join('1').split('1');
          // save the curEnd marker before it get cleared due to cm.replaceRange.
          if (vim.lastSelection) {
            lastSelectionCurEnd = vim.lastSelection.headMark.find();
          }
          // push the previously selected text to unnamed register
          vimGlobalState.registerController.unnamedRegister.setText(selectedText);
          if (blockwise) {
            // first delete the selected text
            cm.replaceSelections(emptyStrings);
            // Set new selections as per the block length of the yanked text
            selectionEnd = Pos(selectionStart.line + text.length - 1, selectionStart.ch);
            cm.setCursor(selectionStart);
            selectBlock(cm, selectionEnd);
            cm.replaceSelections(text);
            curPosFinal = selectionStart;
          } else if (vim.visualBlock) {
            cm.replaceSelections(emptyStrings);
            cm.setCursor(selectionStart);
            cm.replaceRange(text, selectionStart, selectionStart);
            curPosFinal = selectionStart;
          } else {
            cm.replaceRange(text, selectionStart, selectionEnd);
            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
          }
          // restore the the curEnd marker
          if (lastSelectionCurEnd) {
            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
          }
          if (linewise) {
            curPosFinal.ch = 0;
          }
        } else {
          if (blockwise) {
            cm.setCursor(cur);
            for (var i = 0; i < text.length; i++) {
              var line = cur.line + i;
              if (line > cm.lastLine()) {
                cm.replaceRange('\n', Pos(line, 0));
              }
              var lastCh = lineLength(cm, line);
              if (lastCh < cur.ch) {
                extendLineToColumn(cm, line, cur.ch);
              }
            }
            cm.setCursor(cur);
            selectBlock(cm, Pos(cur.line + text.length - 1, cur.ch));
            cm.replaceSelections(text);
            curPosFinal = cur;
          } else {
            cm.replaceRange(text, cur);
            // Now fine tune the cursor to where we want it.
            if (linewise && actionArgs.after) {
              curPosFinal = Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));
            } else if (linewise && !actionArgs.after) {
              curPosFinal = Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));
            } else if (!linewise && actionArgs.after) {
              idx = cm.indexFromPos(cur);
              curPosFinal = cm.posFromIndex(idx + text.length - 1);
            } else {
              idx = cm.indexFromPos(cur);
              curPosFinal = cm.posFromIndex(idx + text.length);
            }
          }
        }
        if (vim.visualMode) {
          exitVisualMode(cm, false);
        }
        cm.setCursor(curPosFinal);
      },
      undo: function (cm, actionArgs) {
        cm.operation(function () {
          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();
          cm.setCursor(cm.getCursor('anchor'));
        });
      },
      redo: function (cm, actionArgs) {
        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();
      },
      setRegister: function (_cm, actionArgs, vim) {
        vim.inputState.registerName = actionArgs.selectedCharacter;
      },
      setMark: function (cm, actionArgs, vim) {
        var markName = actionArgs.selectedCharacter;
        updateMark(cm, vim, markName, cm.getCursor());
      },
      replace: function (cm, actionArgs, vim) {
        var replaceWith = actionArgs.selectedCharacter;
        var curStart = cm.getCursor();
        var replaceTo;
        var curEnd;
        var selections = cm.listSelections();
        if (vim.visualMode) {
          curStart = cm.getCursor('start');
          curEnd = cm.getCursor('end');
        } else {
          var line = cm.getLine(curStart.line);
          replaceTo = curStart.ch + actionArgs.repeat;
          if (replaceTo > line.length) {
            replaceTo = line.length;
          }
          curEnd = Pos(curStart.line, replaceTo);
        }
        if (replaceWith == '\n') {
          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);
          // special case, where vim help says to replace by just one line-break
          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);
        } else {
          var replaceWithStr = cm.getRange(curStart, curEnd);
          //replace all characters in range by selected, but keep linebreaks
          replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
          if (vim.visualBlock) {
            // Tabs are split in visua block before replacing
            var spaces = new Array(cm.getOption("tabSize") + 1).join(' ');
            replaceWithStr = cm.getSelection();
            replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split('\n');
            cm.replaceSelections(replaceWithStr);
          } else {
            cm.replaceRange(replaceWithStr, curStart, curEnd);
          }
          if (vim.visualMode) {
            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;
            cm.setCursor(curStart);
            exitVisualMode(cm, false);
          } else {
            cm.setCursor(offsetCursor(curEnd, 0, -1));
          }
        }
      },
      incrementNumberToken: function (cm, actionArgs) {
        var cur = cm.getCursor();
        var lineStr = cm.getLine(cur.line);
        var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
        var match;
        var start;
        var end;
        var numberStr;
        while ((match = re.exec(lineStr)) !== null) {
          start = match.index;
          end = start + match[0].length;
          if (cur.ch < end) break;
        }
        if (!actionArgs.backtrack && end <= cur.ch) return;
        if (match) {
          var baseStr = match[2] || match[4];
          var digits = match[3] || match[5];
          var increment = actionArgs.increase ? 1 : -1;
          var base = { '0b': 2, '0': 8, '': 10, '0x': 16 }[baseStr.toLowerCase()];
          var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;
          numberStr = number.toString(base);
          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';
          if (numberStr.charAt(0) === '-') {
            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);
          } else {
            numberStr = baseStr + zeroPadding + numberStr;
          }
          var from = Pos(cur.line, start);
          var to = Pos(cur.line, end);
          cm.replaceRange(numberStr, from, to);
        } else {
          return;
        }
        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));
      },
      repeatLastEdit: function (cm, actionArgs, vim) {
        var lastEditInputState = vim.lastEditInputState;
        if (!lastEditInputState) {
          return;
        }
        var repeat = actionArgs.repeat;
        if (repeat && actionArgs.repeatIsExplicit) {
          vim.lastEditInputState.repeatOverride = repeat;
        } else {
          repeat = vim.lastEditInputState.repeatOverride || repeat;
        }
        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);
      },
      indent: function (cm, actionArgs) {
        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
      },
      exitInsertMode: exitInsertMode
    };

    function defineAction(name, fn) {
      actions[name] = fn;
    }

    /*
     * Below are miscellaneous utility functions used by vim.js
     */

    /**
     * Clips cursor to ensure that line is within the buffer's range
     * If includeLineBreak is true, then allow cur.ch == lineLength.
     */
    function clipCursorToContent(cm, cur, includeLineBreak) {
      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());
      var maxCh = lineLength(cm, line) - 1;
      maxCh = includeLineBreak ? maxCh + 1 : maxCh;
      var ch = Math.min(Math.max(0, cur.ch), maxCh);
      return Pos(line, ch);
    }
    function copyArgs(args) {
      var ret = {};
      for (var prop in args) {
        if (args.hasOwnProperty(prop)) {
          ret[prop] = args[prop];
        }
      }
      return ret;
    }
    function offsetCursor(cur, offsetLine, offsetCh) {
      if (typeof offsetLine === 'object') {
        offsetCh = offsetLine.ch;
        offsetLine = offsetLine.line;
      }
      return Pos(cur.line + offsetLine, cur.ch + offsetCh);
    }
    function commandMatches(keys, keyMap, context, inputState) {
      // Partial matches are not applied. They inform the key handler
      // that the current key sequence is a subsequence of a valid key
      // sequence, so that the key buffer is not cleared.
      var match,
          partial = [],
          full = [];
      for (var i = 0; i < keyMap.length; i++) {
        var command = keyMap[i];
        if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {
          continue;
        }
        if (match == 'partial') {
          partial.push(command);
        }
        if (match == 'full') {
          full.push(command);
        }
      }
      return {
        partial: partial.length && partial,
        full: full.length && full
      };
    }
    function commandMatch(pressed, mapped) {
      if (mapped.slice(-11) == '<character>') {
        // Last character matches anything.
        var prefixLen = mapped.length - 11;
        var pressedPrefix = pressed.slice(0, prefixLen);
        var mappedPrefix = mapped.slice(0, prefixLen);
        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;
      } else {
        return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;
      }
    }
    function lastChar(keys) {
      var match = /^.*(<[^>]+>)$/.exec(keys);
      var selectedCharacter = match ? match[1] : keys.slice(-1);
      if (selectedCharacter.length > 1) {
        switch (selectedCharacter) {
          case '<CR>':
            selectedCharacter = '\n';
            break;
          case '<Space>':
            selectedCharacter = ' ';
            break;
          default:
            selectedCharacter = '';
            break;
        }
      }
      return selectedCharacter;
    }
    function repeatFn(cm, fn, repeat) {
      return function () {
        for (var i = 0; i < repeat; i++) {
          fn(cm);
        }
      };
    }
    function copyCursor(cur) {
      return Pos(cur.line, cur.ch);
    }
    function cursorEqual(cur1, cur2) {
      return cur1.ch == cur2.ch && cur1.line == cur2.line;
    }
    function cursorIsBefore(cur1, cur2) {
      if (cur1.line < cur2.line) {
        return true;
      }
      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {
        return true;
      }
      return false;
    }
    function cursorMin(cur1, cur2) {
      if (arguments.length > 2) {
        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));
      }
      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
    }
    function cursorMax(cur1, cur2) {
      if (arguments.length > 2) {
        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));
      }
      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
    }
    function cursorIsBetween(cur1, cur2, cur3) {
      // returns true if cur2 is between cur1 and cur3.
      var cur1before2 = cursorIsBefore(cur1, cur2);
      var cur2before3 = cursorIsBefore(cur2, cur3);
      return cur1before2 && cur2before3;
    }
    function lineLength(cm, lineNum) {
      return cm.getLine(lineNum).length;
    }
    function trim(s) {
      if (s.trim) {
        return s.trim();
      }
      return s.replace(/^\s+|\s+$/g, '');
    }
    function escapeRegex(s) {
      return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, '\\$1');
    }
    function extendLineToColumn(cm, lineNum, column) {
      var endCh = lineLength(cm, lineNum);
      var spaces = new Array(column - endCh + 1).join(' ');
      cm.setCursor(Pos(lineNum, endCh));
      cm.replaceRange(spaces, cm.getCursor());
    }
    // This functions selects a rectangular block
    // of text with selectionEnd as any of its corner
    // Height of block:
    // Difference in selectionEnd.line and first/last selection.line
    // Width of the block:
    // Distance between selectionEnd.ch and any(first considered here) selection.ch
    function selectBlock(cm, selectionEnd) {
      var selections = [],
          ranges = cm.listSelections();
      var head = copyCursor(cm.clipPos(selectionEnd));
      var isClipped = !cursorEqual(selectionEnd, head);
      var curHead = cm.getCursor('head');
      var primIndex = getIndex(ranges, curHead);
      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
      var max = ranges.length - 1;
      var index = max - primIndex > primIndex ? max : 0;
      var base = ranges[index].anchor;

      var firstLine = Math.min(base.line, head.line);
      var lastLine = Math.max(base.line, head.line);
      var baseCh = base.ch,
          headCh = head.ch;

      var dir = ranges[index].head.ch - baseCh;
      var newDir = headCh - baseCh;
      if (dir > 0 && newDir <= 0) {
        baseCh++;
        if (!isClipped) {
          headCh--;
        }
      } else if (dir < 0 && newDir >= 0) {
        baseCh--;
        if (!wasClipped) {
          headCh++;
        }
      } else if (dir < 0 && newDir == -1) {
        baseCh--;
        headCh++;
      }
      for (var line = firstLine; line <= lastLine; line++) {
        var range = { anchor: new Pos(line, baseCh), head: new Pos(line, headCh) };
        selections.push(range);
      }
      cm.setSelections(selections);
      selectionEnd.ch = headCh;
      base.ch = baseCh;
      return base;
    }
    function selectForInsert(cm, head, height) {
      var sel = [];
      for (var i = 0; i < height; i++) {
        var lineHead = offsetCursor(head, i, 0);
        sel.push({ anchor: lineHead, head: lineHead });
      }
      cm.setSelections(sel, 0);
    }
    // getIndex returns the index of the cursor in the selections.
    function getIndex(ranges, cursor, end) {
      for (var i = 0; i < ranges.length; i++) {
        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);
        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);
        if (atAnchor || atHead) {
          return i;
        }
      }
      return -1;
    }
    function getSelectedAreaRange(cm, vim) {
      var lastSelection = vim.lastSelection;
      var getCurrentSelectedAreaRange = function () {
        var selections = cm.listSelections();
        var start = selections[0];
        var end = selections[selections.length - 1];
        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
        return [selectionStart, selectionEnd];
      };
      var getLastSelectedAreaRange = function () {
        var selectionStart = cm.getCursor();
        var selectionEnd = cm.getCursor();
        var block = lastSelection.visualBlock;
        if (block) {
          var width = block.width;
          var height = block.height;
          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);
          var selections = [];
          // selectBlock creates a 'proper' rectangular block.
          // We do not want that in all cases, so we manually set selections.
          for (var i = selectionStart.line; i < selectionEnd.line; i++) {
            var anchor = Pos(i, selectionStart.ch);
            var head = Pos(i, selectionEnd.ch);
            var range = { anchor: anchor, head: head };
            selections.push(range);
          }
          cm.setSelections(selections);
        } else {
          var start = lastSelection.anchorMark.find();
          var end = lastSelection.headMark.find();
          var line = end.line - start.line;
          var ch = end.ch - start.ch;
          selectionEnd = { line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch };
          if (lastSelection.visualLine) {
            selectionStart = Pos(selectionStart.line, 0);
            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
          }
          cm.setSelection(selectionStart, selectionEnd);
        }
        return [selectionStart, selectionEnd];
      };
      if (!vim.visualMode) {
        // In case of replaying the action.
        return getLastSelectedAreaRange();
      } else {
        return getCurrentSelectedAreaRange();
      }
    }
    // Updates the previous selection with the current selection's values. This
    // should only be called in visual mode.
    function updateLastSelection(cm, vim) {
      var anchor = vim.sel.anchor;
      var head = vim.sel.head;
      // To accommodate the effect of lastPastedText in the last selection
      if (vim.lastPastedText) {
        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);
        vim.lastPastedText = null;
      }
      vim.lastSelection = { 'anchorMark': cm.setBookmark(anchor),
        'headMark': cm.setBookmark(head),
        'anchor': copyCursor(anchor),
        'head': copyCursor(head),
        'visualMode': vim.visualMode,
        'visualLine': vim.visualLine,
        'visualBlock': vim.visualBlock };
    }
    function expandSelection(cm, start, end) {
      var sel = cm.state.vim.sel;
      var head = sel.head;
      var anchor = sel.anchor;
      var tmp;
      if (cursorIsBefore(end, start)) {
        tmp = end;
        end = start;
        start = tmp;
      }
      if (cursorIsBefore(head, anchor)) {
        head = cursorMin(start, head);
        anchor = cursorMax(anchor, end);
      } else {
        anchor = cursorMin(start, anchor);
        head = cursorMax(head, end);
        head = offsetCursor(head, 0, -1);
        if (head.ch == -1 && head.line != cm.firstLine()) {
          head = Pos(head.line - 1, lineLength(cm, head.line - 1));
        }
      }
      return [anchor, head];
    }
    /**
     * Updates the CodeMirror selection to match the provided vim selection.
     * If no arguments are given, it uses the current vim selection state.
     */
    function updateCmSelection(cm, sel, mode) {
      var vim = cm.state.vim;
      sel = sel || vim.sel;
      var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';
      var cmSel = makeCmSelection(cm, sel, mode);
      cm.setSelections(cmSel.ranges, cmSel.primary);
      updateFakeCursor(cm);
    }
    function makeCmSelection(cm, sel, mode, exclusive) {
      var head = copyCursor(sel.head);
      var anchor = copyCursor(sel.anchor);
      if (mode == 'char') {
        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
        head = offsetCursor(sel.head, 0, headOffset);
        anchor = offsetCursor(sel.anchor, 0, anchorOffset);
        return {
          ranges: [{ anchor: anchor, head: head }],
          primary: 0
        };
      } else if (mode == 'line') {
        if (!cursorIsBefore(sel.head, sel.anchor)) {
          anchor.ch = 0;

          var lastLine = cm.lastLine();
          if (head.line > lastLine) {
            head.line = lastLine;
          }
          head.ch = lineLength(cm, head.line);
        } else {
          head.ch = 0;
          anchor.ch = lineLength(cm, anchor.line);
        }
        return {
          ranges: [{ anchor: anchor, head: head }],
          primary: 0
        };
      } else if (mode == 'block') {
        var top = Math.min(anchor.line, head.line),
            left = Math.min(anchor.ch, head.ch),
            bottom = Math.max(anchor.line, head.line),
            right = Math.max(anchor.ch, head.ch) + 1;
        var height = bottom - top + 1;
        var primary = head.line == top ? 0 : height - 1;
        var ranges = [];
        for (var i = 0; i < height; i++) {
          ranges.push({
            anchor: Pos(top + i, left),
            head: Pos(top + i, right)
          });
        }
        return {
          ranges: ranges,
          primary: primary
        };
      }
    }
    function getHead(cm) {
      var cur = cm.getCursor('head');
      if (cm.getSelection().length == 1) {
        // Small corner case when only 1 character is selected. The "real"
        // head is the left of head and anchor.
        cur = cursorMin(cur, cm.getCursor('anchor'));
      }
      return cur;
    }

    /**
     * If moveHead is set to false, the CodeMirror selection will not be
     * touched. The caller assumes the responsibility of putting the cursor
    * in the right place.
     */
    function exitVisualMode(cm, moveHead) {
      var vim = cm.state.vim;
      if (moveHead !== false) {
        cm.setCursor(clipCursorToContent(cm, vim.sel.head));
      }
      updateLastSelection(cm, vim);
      vim.visualMode = false;
      vim.visualLine = false;
      vim.visualBlock = false;
      CodeMirror.signal(cm, "vim-mode-change", { mode: "normal" });
      if (vim.fakeCursor) {
        vim.fakeCursor.clear();
      }
    }

    // Remove any trailing newlines from the selection. For
    // example, with the caret at the start of the last word on the line,
    // 'dw' should word, but not the newline, while 'w' should advance the
    // caret to the first character of the next line.
    function clipToLine(cm, curStart, curEnd) {
      var selection = cm.getRange(curStart, curEnd);
      // Only clip if the selection ends with trailing newline + whitespace
      if (/\n\s*$/.test(selection)) {
        var lines = selection.split('\n');
        // We know this is all whitespace.
        lines.pop();

        // Cases:
        // 1. Last word is an empty line - do not clip the trailing '\n'
        // 2. Last word is not an empty line - clip the trailing '\n'
        var line;
        // Find the line containing the last word, and clip all whitespace up
        // to it.
        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {
          curEnd.line--;
          curEnd.ch = 0;
        }
        // If the last word is not an empty line, clip an additional newline
        if (line) {
          curEnd.line--;
          curEnd.ch = lineLength(cm, curEnd.line);
        } else {
          curEnd.ch = 0;
        }
      }
    }

    // Expand the selection to line ends.
    function expandSelectionToLine(_cm, curStart, curEnd) {
      curStart.ch = 0;
      curEnd.ch = 0;
      curEnd.line++;
    }

    function findFirstNonWhiteSpaceCharacter(text) {
      if (!text) {
        return 0;
      }
      var firstNonWS = text.search(/\S/);
      return firstNonWS == -1 ? text.length : firstNonWS;
    }

    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
      var cur = getHead(cm);
      var line = cm.getLine(cur.line);
      var idx = cur.ch;

      // Seek to first word or non-whitespace character, depending on if
      // noSymbol is true.
      var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];
      while (!test(line.charAt(idx))) {
        idx++;
        if (idx >= line.length) {
          return null;
        }
      }

      if (bigWord) {
        test = bigWordCharTest[0];
      } else {
        test = wordCharTest[0];
        if (!test(line.charAt(idx))) {
          test = wordCharTest[1];
        }
      }

      var end = idx,
          start = idx;
      while (test(line.charAt(end)) && end < line.length) {
        end++;
      }
      while (test(line.charAt(start)) && start >= 0) {
        start--;
      }
      start++;

      if (inclusive) {
        // If present, include all whitespace after word.
        // Otherwise, include all whitespace before word, except indentation.
        var wordEnd = end;
        while (/\s/.test(line.charAt(end)) && end < line.length) {
          end++;
        }
        if (wordEnd == end) {
          var wordStart = start;
          while (/\s/.test(line.charAt(start - 1)) && start > 0) {
            start--;
          }
          if (!start) {
            start = wordStart;
          }
        }
      }
      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };
    }

    function recordJumpPosition(cm, oldCur, newCur) {
      if (!cursorEqual(oldCur, newCur)) {
        vimGlobalState.jumpList.add(cm, oldCur, newCur);
      }
    }

    function recordLastCharacterSearch(increment, args) {
      vimGlobalState.lastCharacterSearch.increment = increment;
      vimGlobalState.lastCharacterSearch.forward = args.forward;
      vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
    }

    var symbolToMode = {
      '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',
      '[': 'section', ']': 'section',
      '*': 'comment', '/': 'comment',
      'm': 'method', 'M': 'method',
      '#': 'preprocess'
    };
    var findSymbolModes = {
      bracket: {
        isComplete: function (state) {
          if (state.nextCh === state.symb) {
            state.depth++;
            if (state.depth >= 1) return true;
          } else if (state.nextCh === state.reverseSymb) {
            state.depth--;
          }
          return false;
        }
      },
      section: {
        init: function (state) {
          state.curMoveThrough = true;
          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';
        },
        isComplete: function (state) {
          return state.index === 0 && state.nextCh === state.symb;
        }
      },
      comment: {
        isComplete: function (state) {
          var found = state.lastCh === '*' && state.nextCh === '/';
          state.lastCh = state.nextCh;
          return found;
        }
      },
      // TODO: The original Vim implementation only operates on level 1 and 2.
      // The current implementation doesn't check for code block level and
      // therefore it operates on any levels.
      method: {
        init: function (state) {
          state.symb = state.symb === 'm' ? '{' : '}';
          state.reverseSymb = state.symb === '{' ? '}' : '{';
        },
        isComplete: function (state) {
          if (state.nextCh === state.symb) return true;
          return false;
        }
      },
      preprocess: {
        init: function (state) {
          state.index = 0;
        },
        isComplete: function (state) {
          if (state.nextCh === '#') {
            var token = state.lineText.match(/#(\w+)/)[1];
            if (token === 'endif') {
              if (state.forward && state.depth === 0) {
                return true;
              }
              state.depth++;
            } else if (token === 'if') {
              if (!state.forward && state.depth === 0) {
                return true;
              }
              state.depth--;
            }
            if (token === 'else' && state.depth === 0) return true;
          }
          return false;
        }
      }
    };
    function findSymbol(cm, repeat, forward, symb) {
      var cur = copyCursor(cm.getCursor());
      var increment = forward ? 1 : -1;
      var endLine = forward ? cm.lineCount() : -1;
      var curCh = cur.ch;
      var line = cur.line;
      var lineText = cm.getLine(line);
      var state = {
        lineText: lineText,
        nextCh: lineText.charAt(curCh),
        lastCh: null,
        index: curCh,
        symb: symb,
        reverseSymb: (forward ? { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],
        forward: forward,
        depth: 0,
        curMoveThrough: false
      };
      var mode = symbolToMode[symb];
      if (!mode) return cur;
      var init = findSymbolModes[mode].init;
      var isComplete = findSymbolModes[mode].isComplete;
      if (init) {
        init(state);
      }
      while (line !== endLine && repeat) {
        state.index += increment;
        state.nextCh = state.lineText.charAt(state.index);
        if (!state.nextCh) {
          line += increment;
          state.lineText = cm.getLine(line) || '';
          if (increment > 0) {
            state.index = 0;
          } else {
            var lineLen = state.lineText.length;
            state.index = lineLen > 0 ? lineLen - 1 : 0;
          }
          state.nextCh = state.lineText.charAt(state.index);
        }
        if (isComplete(state)) {
          cur.line = line;
          cur.ch = state.index;
          repeat--;
        }
      }
      if (state.nextCh || state.curMoveThrough) {
        return Pos(line, state.index);
      }
      return cur;
    }

    /*
     * Returns the boundaries of the next word. If the cursor in the middle of
     * the word, then returns the boundaries of the current word, starting at
     * the cursor. If the cursor is at the start/end of a word, and we are going
     * forward/backward, respectively, find the boundaries of the next word.
     *
     * @param {CodeMirror} cm CodeMirror object.
     * @param {Cursor} cur The cursor position.
     * @param {boolean} forward True to search forward. False to search
     *     backward.
     * @param {boolean} bigWord True if punctuation count as part of the word.
     *     False if only [a-zA-Z0-9] characters count as part of the word.
     * @param {boolean} emptyLineIsWord True if empty lines should be treated
     *     as words.
     * @return {Object{from:number, to:number, line: number}} The boundaries of
     *     the word, or null if there are no more words.
     */
    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
      var lineNum = cur.line;
      var pos = cur.ch;
      var line = cm.getLine(lineNum);
      var dir = forward ? 1 : -1;
      var charTests = bigWord ? bigWordCharTest : wordCharTest;

      if (emptyLineIsWord && line == '') {
        lineNum += dir;
        line = cm.getLine(lineNum);
        if (!isLine(cm, lineNum)) {
          return null;
        }
        pos = forward ? 0 : line.length;
      }

      while (true) {
        if (emptyLineIsWord && line == '') {
          return { from: 0, to: 0, line: lineNum };
        }
        var stop = dir > 0 ? line.length : -1;
        var wordStart = stop,
            wordEnd = stop;
        // Find bounds of next word.
        while (pos != stop) {
          var foundWord = false;
          for (var i = 0; i < charTests.length && !foundWord; ++i) {
            if (charTests[i](line.charAt(pos))) {
              wordStart = pos;
              // Advance to end of word.
              while (pos != stop && charTests[i](line.charAt(pos))) {
                pos += dir;
              }
              wordEnd = pos;
              foundWord = wordStart != wordEnd;
              if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {
                // We started at the end of a word. Find the next one.
                continue;
              } else {
                return {
                  from: Math.min(wordStart, wordEnd + 1),
                  to: Math.max(wordStart, wordEnd),
                  line: lineNum };
              }
            }
          }
          if (!foundWord) {
            pos += dir;
          }
        }
        // Advance to next/prev line.
        lineNum += dir;
        if (!isLine(cm, lineNum)) {
          return null;
        }
        line = cm.getLine(lineNum);
        pos = dir > 0 ? 0 : line.length;
      }
    }

    /**
     * @param {CodeMirror} cm CodeMirror object.
     * @param {Pos} cur The position to start from.
     * @param {int} repeat Number of words to move past.
     * @param {boolean} forward True to search forward. False to search
     *     backward.
     * @param {boolean} wordEnd True to move to end of word. False to move to
     *     beginning of word.
     * @param {boolean} bigWord True if punctuation count as part of the word.
     *     False if only alphabet characters count as part of the word.
     * @return {Cursor} The position the cursor should move to.
     */
    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
      var curStart = copyCursor(cur);
      var words = [];
      if (forward && !wordEnd || !forward && wordEnd) {
        repeat++;
      }
      // For 'e', empty lines are not considered words, go figure.
      var emptyLineIsWord = !(forward && wordEnd);
      for (var i = 0; i < repeat; i++) {
        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
        if (!word) {
          var eodCh = lineLength(cm, cm.lastLine());
          words.push(forward ? { line: cm.lastLine(), from: eodCh, to: eodCh } : { line: 0, from: 0, to: 0 });
          break;
        }
        words.push(word);
        cur = Pos(word.line, forward ? word.to - 1 : word.from);
      }
      var shortCircuit = words.length != repeat;
      var firstWord = words[0];
      var lastWord = words.pop();
      if (forward && !wordEnd) {
        // w
        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
          // We did not start in the middle of a word. Discard the extra word at the end.
          lastWord = words.pop();
        }
        return Pos(lastWord.line, lastWord.from);
      } else if (forward && wordEnd) {
        return Pos(lastWord.line, lastWord.to - 1);
      } else if (!forward && wordEnd) {
        // ge
        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
          // We did not start in the middle of a word. Discard the extra word at the end.
          lastWord = words.pop();
        }
        return Pos(lastWord.line, lastWord.to);
      } else {
        // b
        return Pos(lastWord.line, lastWord.from);
      }
    }

    function moveToCharacter(cm, repeat, forward, character) {
      var cur = cm.getCursor();
      var start = cur.ch;
      var idx;
      for (var i = 0; i < repeat; i++) {
        var line = cm.getLine(cur.line);
        idx = charIdxInLine(start, line, character, forward, true);
        if (idx == -1) {
          return null;
        }
        start = idx;
      }
      return Pos(cm.getCursor().line, idx);
    }

    function moveToColumn(cm, repeat) {
      // repeat is always >= 1, so repeat - 1 always corresponds
      // to the column we want to go to.
      var line = cm.getCursor().line;
      return clipCursorToContent(cm, Pos(line, repeat - 1));
    }

    function updateMark(cm, vim, markName, pos) {
      if (!inArray(markName, validMarks)) {
        return;
      }
      if (vim.marks[markName]) {
        vim.marks[markName].clear();
      }
      vim.marks[markName] = cm.setBookmark(pos);
    }

    function charIdxInLine(start, line, character, forward, includeChar) {
      // Search for char in line.
      // motion_options: {forward, includeChar}
      // If includeChar = true, include it too.
      // If forward = true, search forward, else search backwards.
      // If char is not found on this line, do nothing
      var idx;
      if (forward) {
        idx = line.indexOf(character, start + 1);
        if (idx != -1 && !includeChar) {
          idx -= 1;
        }
      } else {
        idx = line.lastIndexOf(character, start - 1);
        if (idx != -1 && !includeChar) {
          idx += 1;
        }
      }
      return idx;
    }

    function findParagraph(cm, head, repeat, dir, inclusive) {
      var line = head.line;
      var min = cm.firstLine();
      var max = cm.lastLine();
      var start,
          end,
          i = line;
      function isEmpty(i) {
        return !cm.getLine(i);
      }
      function isBoundary(i, dir, any) {
        if (any) {
          return isEmpty(i) != isEmpty(i + dir);
        }
        return !isEmpty(i) && isEmpty(i + dir);
      }
      if (dir) {
        while (min <= i && i <= max && repeat > 0) {
          if (isBoundary(i, dir)) {
            repeat--;
          }
          i += dir;
        }
        return new Pos(i, 0);
      }

      var vim = cm.state.vim;
      if (vim.visualLine && isBoundary(line, 1, true)) {
        var anchor = vim.sel.anchor;
        if (isBoundary(anchor.line, -1, true)) {
          if (!inclusive || anchor.line != line) {
            line += 1;
          }
        }
      }
      var startState = isEmpty(line);
      for (i = line; i <= max && repeat; i++) {
        if (isBoundary(i, 1, true)) {
          if (!inclusive || isEmpty(i) != startState) {
            repeat--;
          }
        }
      }
      end = new Pos(i, 0);
      // select boundary before paragraph for the last one
      if (i > max && !startState) {
        startState = true;
      } else {
        inclusive = false;
      }
      for (i = line; i > min; i--) {
        if (!inclusive || isEmpty(i) == startState || i == line) {
          if (isBoundary(i, -1, true)) {
            break;
          }
        }
      }
      start = new Pos(i, 0);
      return { start: start, end: end };
    }

    function findSentence(cm, cur, repeat, dir) {

      /*
        Takes an index object
        {
          line: the line string,
          ln: line number,
          pos: index in line,
          dir: direction of traversal (-1 or 1)
        }
        and modifies the line, ln, and pos members to represent the
        next valid position or sets them to null if there are
        no more valid positions.
       */
      function nextChar(cm, idx) {
        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
          idx.ln += idx.dir;
          if (!isLine(cm, idx.ln)) {
            idx.line = null;
            idx.ln = null;
            idx.pos = null;
            return;
          }
          idx.line = cm.getLine(idx.ln);
          idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;
        } else {
          idx.pos += idx.dir;
        }
      }

      /*
        Performs one iteration of traversal in forward direction
        Returns an index object of the new location
       */
      function forward(cm, ln, pos, dir) {
        var line = cm.getLine(ln);
        var stop = line === "";

        var curr = {
          line: line,
          ln: ln,
          pos: pos,
          dir: dir
        };

        var last_valid = {
          ln: curr.ln,
          pos: curr.pos
        };

        var skip_empty_lines = curr.line === "";

        // Move one step to skip character we start on
        nextChar(cm, curr);

        while (curr.line !== null) {
          last_valid.ln = curr.ln;
          last_valid.pos = curr.pos;

          if (curr.line === "" && !skip_empty_lines) {
            return { ln: curr.ln, pos: curr.pos };
          } else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
            return { ln: curr.ln, pos: curr.pos };
          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
            stop = true;
          }

          nextChar(cm, curr);
        }

        /*
          Set the position to the last non whitespace character on the last
          valid line in the case that we reach the end of the document.
        */
        var line = cm.getLine(last_valid.ln);
        last_valid.pos = 0;
        for (var i = line.length - 1; i >= 0; --i) {
          if (!isWhiteSpaceString(line[i])) {
            last_valid.pos = i;
            break;
          }
        }

        return last_valid;
      }

      /*
        Performs one iteration of traversal in reverse direction
        Returns an index object of the new location
       */
      function reverse(cm, ln, pos, dir) {
        var line = cm.getLine(ln);

        var curr = {
          line: line,
          ln: ln,
          pos: pos,
          dir: dir
        };

        var last_valid = {
          ln: curr.ln,
          pos: null
        };

        var skip_empty_lines = curr.line === "";

        // Move one step to skip character we start on
        nextChar(cm, curr);

        while (curr.line !== null) {

          if (curr.line === "" && !skip_empty_lines) {
            if (last_valid.pos !== null) {
              return last_valid;
            } else {
              return { ln: curr.ln, pos: curr.pos };
            }
          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {
            return last_valid;
          } else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
            skip_empty_lines = false;
            last_valid = { ln: curr.ln, pos: curr.pos };
          }

          nextChar(cm, curr);
        }

        /*
          Set the position to the first non whitespace character on the last
          valid line in the case that we reach the beginning of the document.
        */
        var line = cm.getLine(last_valid.ln);
        last_valid.pos = 0;
        for (var i = 0; i < line.length; ++i) {
          if (!isWhiteSpaceString(line[i])) {
            last_valid.pos = i;
            break;
          }
        }
        return last_valid;
      }

      var curr_index = {
        ln: cur.line,
        pos: cur.ch
      };

      while (repeat > 0) {
        if (dir < 0) {
          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
        } else {
          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
        }
        repeat--;
      }

      return Pos(curr_index.ln, curr_index.pos);
    }

    // TODO: perhaps this finagling of start and end positions belonds
    // in codemirror/replaceRange?
    function selectCompanionObject(cm, head, symb, inclusive) {
      var cur = head,
          start,
          end;

      var bracketRegexp = {
        '(': /[()]/, ')': /[()]/,
        '[': /[[\]]/, ']': /[[\]]/,
        '{': /[{}]/, '}': /[{}]/,
        '<': /[<>]/, '>': /[<>]/ }[symb];
      var openSym = {
        '(': '(', ')': '(',
        '[': '[', ']': '[',
        '{': '{', '}': '{',
        '<': '<', '>': '<' }[symb];
      var curChar = cm.getLine(cur.line).charAt(cur.ch);
      // Due to the behavior of scanForBracket, we need to add an offset if the
      // cursor is on a matching open bracket.
      var offset = curChar === openSym ? 1 : 0;

      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, { 'bracketRegex': bracketRegexp });
      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, { 'bracketRegex': bracketRegexp });

      if (!start || !end) {
        return { start: cur, end: cur };
      }

      start = start.pos;
      end = end.pos;

      if (start.line == end.line && start.ch > end.ch || start.line > end.line) {
        var tmp = start;
        start = end;
        end = tmp;
      }

      if (inclusive) {
        end.ch += 1;
      } else {
        start.ch += 1;
      }

      return { start: start, end: end };
    }

    // Takes in a symbol and a cursor and tries to simulate text objects that
    // have identical opening and closing symbols
    // TODO support across multiple lines
    function findBeginningAndEnd(cm, head, symb, inclusive) {
      var cur = copyCursor(head);
      var line = cm.getLine(cur.line);
      var chars = line.split('');
      var start, end, i, len;
      var firstIndex = chars.indexOf(symb);

      // the decision tree is to always look backwards for the beginning first,
      // but if the cursor is in front of the first instance of the symb,
      // then move the cursor forward
      if (cur.ch < firstIndex) {
        cur.ch = firstIndex;
        // Why is this line even here???
        // cm.setCursor(cur.line, firstIndex+1);
      }
      // otherwise if the cursor is currently on the closing symbol
      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {
          end = cur.ch; // assign end to the current cursor
          --cur.ch; // make sure to look backwards
        }

      // if we're currently on the symbol, we've got a start
      if (chars[cur.ch] == symb && !end) {
        start = cur.ch + 1; // assign start to ahead of the cursor
      } else {
        // go backwards to find the start
        for (i = cur.ch; i > -1 && !start; i--) {
          if (chars[i] == symb) {
            start = i + 1;
          }
        }
      }

      // look forwards for the end symbol
      if (start && !end) {
        for (i = start, len = chars.length; i < len && !end; i++) {
          if (chars[i] == symb) {
            end = i;
          }
        }
      }

      // nothing found
      if (!start || !end) {
        return { start: cur, end: cur };
      }

      // include the symbols
      if (inclusive) {
        --start;++end;
      }

      return {
        start: Pos(cur.line, start),
        end: Pos(cur.line, end)
      };
    }

    // Search functions
    defineOption('pcre', true, 'boolean');
    function SearchState() {}
    SearchState.prototype = {
      getQuery: function () {
        return vimGlobalState.query;
      },
      setQuery: function (query) {
        vimGlobalState.query = query;
      },
      getOverlay: function () {
        return this.searchOverlay;
      },
      setOverlay: function (overlay) {
        this.searchOverlay = overlay;
      },
      isReversed: function () {
        return vimGlobalState.isReversed;
      },
      setReversed: function (reversed) {
        vimGlobalState.isReversed = reversed;
      },
      getScrollbarAnnotate: function () {
        return this.annotate;
      },
      setScrollbarAnnotate: function (annotate) {
        this.annotate = annotate;
      }
    };
    function getSearchState(cm) {
      var vim = cm.state.vim;
      return vim.searchState_ || (vim.searchState_ = new SearchState());
    }
    function dialog(cm, template, shortText, onClose, options) {
      if (cm.openDialog) {
        cm.openDialog(template, onClose, { bottom: true, value: options.value,
          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,
          selectValueOnOpen: false });
      } else {
        onClose(prompt(shortText, ''));
      }
    }
    function splitBySlash(argString) {
      return splitBySeparator(argString, '/');
    }

    function findUnescapedSlashes(argString) {
      return findUnescapedSeparators(argString, '/');
    }

    function splitBySeparator(argString, separator) {
      var slashes = findUnescapedSeparators(argString, separator) || [];
      if (!slashes.length) return [];
      var tokens = [];
      // in case of strings like foo/bar
      if (slashes[0] !== 0) return;
      for (var i = 0; i < slashes.length; i++) {
        if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));
      }
      return tokens;
    }

    function findUnescapedSeparators(str, separator) {
      if (!separator) separator = '/';

      var escapeNextChar = false;
      var slashes = [];
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i);
        if (!escapeNextChar && c == separator) {
          slashes.push(i);
        }
        escapeNextChar = !escapeNextChar && c == '\\';
      }
      return slashes;
    }

    // Translates a search string from ex (vim) syntax into javascript form.
    function translateRegex(str) {
      // When these match, add a '\' if unescaped or remove one if escaped.
      var specials = '|(){';
      // Remove, but never add, a '\' for these.
      var unescape = '}';
      var escapeNextChar = false;
      var out = [];
      for (var i = -1; i < str.length; i++) {
        var c = str.charAt(i) || '';
        var n = str.charAt(i + 1) || '';
        var specialComesNext = n && specials.indexOf(n) != -1;
        if (escapeNextChar) {
          if (c !== '\\' || !specialComesNext) {
            out.push(c);
          }
          escapeNextChar = false;
        } else {
          if (c === '\\') {
            escapeNextChar = true;
            // Treat the unescape list as special for removing, but not adding '\'.
            if (n && unescape.indexOf(n) != -1) {
              specialComesNext = true;
            }
            // Not passing this test means removing a '\'.
            if (!specialComesNext || n === '\\') {
              out.push(c);
            }
          } else {
            out.push(c);
            if (specialComesNext && n !== '\\') {
              out.push('\\');
            }
          }
        }
      }
      return out.join('');
    }

    // Translates the replace part of a search and replace from ex (vim) syntax into
    // javascript form.  Similar to translateRegex, but additionally fixes back references
    // (translates '\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.
    var charUnescapes = { '\\n': '\n', '\\r': '\r', '\\t': '\t' };
    function translateRegexReplace(str) {
      var escapeNextChar = false;
      var out = [];
      for (var i = -1; i < str.length; i++) {
        var c = str.charAt(i) || '';
        var n = str.charAt(i + 1) || '';
        if (charUnescapes[c + n]) {
          out.push(charUnescapes[c + n]);
          i++;
        } else if (escapeNextChar) {
          // At any point in the loop, escapeNextChar is true if the previous
          // character was a '\' and was not escaped.
          out.push(c);
          escapeNextChar = false;
        } else {
          if (c === '\\') {
            escapeNextChar = true;
            if (isNumber(n) || n === '$') {
              out.push('$');
            } else if (n !== '/' && n !== '\\') {
              out.push('\\');
            }
          } else {
            if (c === '$') {
              out.push('$');
            }
            out.push(c);
            if (n === '/') {
              out.push('\\');
            }
          }
        }
      }
      return out.join('');
    }

    // Unescape \ and / in the replace part, for PCRE mode.
    var unescapes = { '\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r': '\r', '\\t': '\t', '\\&': '&' };
    function unescapeRegexReplace(str) {
      var stream = new CodeMirror.StringStream(str);
      var output = [];
      while (!stream.eol()) {
        // Search for \.
        while (stream.peek() && stream.peek() != '\\') {
          output.push(stream.next());
        }
        var matched = false;
        for (var matcher in unescapes) {
          if (stream.match(matcher, true)) {
            matched = true;
            output.push(unescapes[matcher]);
            break;
          }
        }
        if (!matched) {
          // Don't change anything
          output.push(stream.next());
        }
      }
      return output.join('');
    }

    /**
     * Extract the regular expression from the query and return a Regexp object.
     * Returns null if the query is blank.
     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.
     * If smartCase is passed in, and the query contains upper case letters,
     *   then ignoreCase is overridden, and the 'i' flag will not be set.
     * If the query contains the /i in the flag part of the regular expression,
     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed
     *   through to the Regex object.
     */
    function parseQuery(query, ignoreCase, smartCase) {
      // First update the last search register
      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');
      lastSearchRegister.setText(query);
      // Check if the query is already a regex.
      if (query instanceof RegExp) {
        return query;
      }
      // First try to extract regex + flags from the input. If no flags found,
      // extract just the regex. IE does not accept flags directly defined in
      // the regex string in the form /regex/flags
      var slashes = findUnescapedSlashes(query);
      var regexPart;
      var forceIgnoreCase;
      if (!slashes.length) {
        // Query looks like 'regexp'
        regexPart = query;
      } else {
        // Query looks like 'regexp/...'
        regexPart = query.substring(0, slashes[0]);
        var flagsPart = query.substring(slashes[0]);
        forceIgnoreCase = flagsPart.indexOf('i') != -1;
      }
      if (!regexPart) {
        return null;
      }
      if (!getOption('pcre')) {
        regexPart = translateRegex(regexPart);
      }
      if (smartCase) {
        ignoreCase = /^[^A-Z]*$/.test(regexPart);
      }
      var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'i' : undefined);
      return regexp;
    }
    function showConfirm(cm, text) {
      if (cm.openNotification) {
        cm.openNotification('<span style="color: red">' + text + '</span>', { bottom: true, duration: 5000 });
      } else {
        alert(text);
      }
    }
    function makePrompt(prefix, desc) {
      var raw = '<span style="font-family: monospace; white-space: pre">' + (prefix || "") + '<input type="text"></span>';
      if (desc) raw += ' <span style="color: #888">' + desc + '</span>';
      return raw;
    }
    var searchPromptDesc = '(Javascript regexp)';
    function showPrompt(cm, options) {
      var shortText = (options.prefix || '') + ' ' + (options.desc || '');
      var prompt = makePrompt(options.prefix, options.desc);
      dialog(cm, prompt, shortText, options.onClose, options);
    }
    function regexEqual(r1, r2) {
      if (r1 instanceof RegExp && r2 instanceof RegExp) {
        var props = ['global', 'multiline', 'ignoreCase', 'source'];
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          if (r1[prop] !== r2[prop]) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    // Returns true if the query is valid.
    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
      if (!rawQuery) {
        return;
      }
      var state = getSearchState(cm);
      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
      if (!query) {
        return;
      }
      highlightSearchMatches(cm, query);
      if (regexEqual(query, state.getQuery())) {
        return query;
      }
      state.setQuery(query);
      return query;
    }
    function searchOverlay(query) {
      if (query.source.charAt(0) == '^') {
        var matchSol = true;
      }
      return {
        token: function (stream) {
          if (matchSol && !stream.sol()) {
            stream.skipToEnd();
            return;
          }
          var match = stream.match(query, false);
          if (match) {
            if (match[0].length == 0) {
              // Matched empty string, skip to next.
              stream.next();
              return 'searching';
            }
            if (!stream.sol()) {
              // Backtrack 1 to match \b
              stream.backUp(1);
              if (!query.exec(stream.next() + match[0])) {
                stream.next();
                return null;
              }
            }
            stream.match(query);
            return 'searching';
          }
          while (!stream.eol()) {
            stream.next();
            if (stream.match(query, false)) break;
          }
        },
        query: query
      };
    }
    var highlightTimeout = 0;
    function highlightSearchMatches(cm, query) {
      clearTimeout(highlightTimeout);
      highlightTimeout = setTimeout(function () {
        var searchState = getSearchState(cm);
        var overlay = searchState.getOverlay();
        if (!overlay || query != overlay.query) {
          if (overlay) {
            cm.removeOverlay(overlay);
          }
          overlay = searchOverlay(query);
          cm.addOverlay(overlay);
          if (cm.showMatchesOnScrollbar) {
            if (searchState.getScrollbarAnnotate()) {
              searchState.getScrollbarAnnotate().clear();
            }
            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
          }
          searchState.setOverlay(overlay);
        }
      }, 50);
    }
    function findNext(cm, prev, query, repeat) {
      if (repeat === undefined) {
        repeat = 1;
      }
      return cm.operation(function () {
        var pos = cm.getCursor();
        var cursor = cm.getSearchCursor(query, pos);
        for (var i = 0; i < repeat; i++) {
          var found = cursor.find(prev);
          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {
            found = cursor.find(prev);
          }
          if (!found) {
            // SearchCursor may have returned null because it hit EOF, wrap
            // around and try again.
            cursor = cm.getSearchCursor(query, prev ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0));
            if (!cursor.find(prev)) {
              return;
            }
          }
        }
        return cursor.from();
      });
    }
    function clearSearchHighlight(cm) {
      var state = getSearchState(cm);
      cm.removeOverlay(getSearchState(cm).getOverlay());
      state.setOverlay(null);
      if (state.getScrollbarAnnotate()) {
        state.getScrollbarAnnotate().clear();
        state.setScrollbarAnnotate(null);
      }
    }
    /**
     * Check if pos is in the specified range, INCLUSIVE.
     * Range can be specified with 1 or 2 arguments.
     * If the first range argument is an array, treat it as an array of line
     * numbers. Match pos against any of the lines.
     * If the first range argument is a number,
     *   if there is only 1 range argument, check if pos has the same line
     *       number
     *   if there are 2 range arguments, then check if pos is in between the two
     *       range arguments.
     */
    function isInRange(pos, start, end) {
      if (typeof pos != 'number') {
        // Assume it is a cursor position. Get the line number.
        pos = pos.line;
      }
      if (start instanceof Array) {
        return inArray(pos, start);
      } else {
        if (end) {
          return pos >= start && pos <= end;
        } else {
          return pos == start;
        }
      }
    }
    function getUserVisibleLines(cm) {
      var scrollInfo = cm.getScrollInfo();
      var occludeToleranceTop = 6;
      var occludeToleranceBottom = 10;
      var from = cm.coordsChar({ left: 0, top: occludeToleranceTop + scrollInfo.top }, 'local');
      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
      var to = cm.coordsChar({ left: 0, top: bottomY }, 'local');
      return { top: from.line, bottom: to.line };
    }

    function getMarkPos(cm, vim, markName) {
      if (markName == '\'') {
        var history = cm.doc.history.done;
        var event = history[history.length - 2];
        return event && event.ranges && event.ranges[0].head;
      } else if (markName == '.') {
        if (cm.doc.history.lastModTime == 0) {
          return; // If no changes, bail out; don't bother to copy or reverse history array.
        } else {
          var changeHistory = cm.doc.history.done.filter(function (el) {
            if (el.changes !== undefined) {
              return el;
            }
          });
          changeHistory.reverse();
          var lastEditPos = changeHistory[0].changes[0].to;
        }
        return lastEditPos;
      }

      var mark = vim.marks[markName];
      return mark && mark.find();
    }

    var ExCommandDispatcher = function () {
      this.buildCommandMap_();
    };
    ExCommandDispatcher.prototype = {
      processCommand: function (cm, input, opt_params) {
        var that = this;
        cm.operation(function () {
          cm.curOp.isVimOp = true;
          that._processCommand(cm, input, opt_params);
        });
      },
      _processCommand: function (cm, input, opt_params) {
        var vim = cm.state.vim;
        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');
        var previousCommand = commandHistoryRegister.toString();
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
        var inputStream = new CodeMirror.StringStream(input);
        // update ": with the latest command whether valid or invalid
        commandHistoryRegister.setText(input);
        var params = opt_params || {};
        params.input = input;
        try {
          this.parseInput_(cm, inputStream, params);
        } catch (e) {
          showConfirm(cm, e);
          throw e;
        }
        var command;
        var commandName;
        if (!params.commandName) {
          // If only a line range is defined, move to the line.
          if (params.line !== undefined) {
            commandName = 'move';
          }
        } else {
          command = this.matchCommand_(params.commandName);
          if (command) {
            commandName = command.name;
            if (command.excludeFromCommandHistory) {
              commandHistoryRegister.setText(previousCommand);
            }
            this.parseCommandArgs_(inputStream, params, command);
            if (command.type == 'exToKey') {
              // Handle Ex to Key mapping.
              for (var i = 0; i < command.toKeys.length; i++) {
                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');
              }
              return;
            } else if (command.type == 'exToEx') {
              // Handle Ex to Ex mapping.
              this.processCommand(cm, command.toInput);
              return;
            }
          }
        }
        if (!commandName) {
          showConfirm(cm, 'Not an editor command ":' + input + '"');
          return;
        }
        try {
          exCommands[commandName](cm, params);
          // Possibly asynchronous commands (e.g. substitute, which might have a
          // user confirmation), are responsible for calling the callback when
          // done. All others have it taken care of for them here.
          if ((!command || !command.possiblyAsync) && params.callback) {
            params.callback();
          }
        } catch (e) {
          showConfirm(cm, e);
          throw e;
        }
      },
      parseInput_: function (cm, inputStream, result) {
        inputStream.eatWhile(':');
        // Parse range.
        if (inputStream.eat('%')) {
          result.line = cm.firstLine();
          result.lineEnd = cm.lastLine();
        } else {
          result.line = this.parseLineSpec_(cm, inputStream);
          if (result.line !== undefined && inputStream.eat(',')) {
            result.lineEnd = this.parseLineSpec_(cm, inputStream);
          }
        }

        // Parse command name.
        var commandMatch = inputStream.match(/^(\w+)/);
        if (commandMatch) {
          result.commandName = commandMatch[1];
        } else {
          result.commandName = inputStream.match(/.*/)[0];
        }

        return result;
      },
      parseLineSpec_: function (cm, inputStream) {
        var numberMatch = inputStream.match(/^(\d+)/);
        if (numberMatch) {
          // Absolute line number plus offset (N+M or N-M) is probably a typo,
          // not something the user actually wanted. (NB: vim does allow this.)
          return parseInt(numberMatch[1], 10) - 1;
        }
        switch (inputStream.next()) {
          case '.':
            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
          case '$':
            return this.parseLineSpecOffset_(inputStream, cm.lastLine());
          case '\'':
            var markName = inputStream.next();
            var markPos = getMarkPos(cm, cm.state.vim, markName);
            if (!markPos) throw new Error('Mark not set');
            return this.parseLineSpecOffset_(inputStream, markPos.line);
          case '-':
          case '+':
            inputStream.backUp(1);
            // Offset is relative to current line if not otherwise specified.
            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
          default:
            inputStream.backUp(1);
            return undefined;
        }
      },
      parseLineSpecOffset_: function (inputStream, line) {
        var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
        if (offsetMatch) {
          var offset = parseInt(offsetMatch[2], 10);
          if (offsetMatch[1] == "-") {
            line -= offset;
          } else {
            line += offset;
          }
        }
        return line;
      },
      parseCommandArgs_: function (inputStream, params, command) {
        if (inputStream.eol()) {
          return;
        }
        params.argString = inputStream.match(/.*/)[0];
        // Parse command-line arguments
        var delim = command.argDelimiter || /\s+/;
        var args = trim(params.argString).split(delim);
        if (args.length && args[0]) {
          params.args = args;
        }
      },
      matchCommand_: function (commandName) {
        // Return the command in the command map that matches the shortest
        // prefix of the passed in command name. The match is guaranteed to be
        // unambiguous if the defaultExCommandMap's shortNames are set up
        // correctly. (see @code{defaultExCommandMap}).
        for (var i = commandName.length; i > 0; i--) {
          var prefix = commandName.substring(0, i);
          if (this.commandMap_[prefix]) {
            var command = this.commandMap_[prefix];
            if (command.name.indexOf(commandName) === 0) {
              return command;
            }
          }
        }
        return null;
      },
      buildCommandMap_: function () {
        this.commandMap_ = {};
        for (var i = 0; i < defaultExCommandMap.length; i++) {
          var command = defaultExCommandMap[i];
          var key = command.shortName || command.name;
          this.commandMap_[key] = command;
        }
      },
      map: function (lhs, rhs, ctx) {
        if (lhs != ':' && lhs.charAt(0) == ':') {
          if (ctx) {
            throw Error('Mode not supported for ex mappings');
          }
          var commandName = lhs.substring(1);
          if (rhs != ':' && rhs.charAt(0) == ':') {
            // Ex to Ex mapping
            this.commandMap_[commandName] = {
              name: commandName,
              type: 'exToEx',
              toInput: rhs.substring(1),
              user: true
            };
          } else {
            // Ex to key mapping
            this.commandMap_[commandName] = {
              name: commandName,
              type: 'exToKey',
              toKeys: rhs,
              user: true
            };
          }
        } else {
          if (rhs != ':' && rhs.charAt(0) == ':') {
            // Key to Ex mapping.
            var mapping = {
              keys: lhs,
              type: 'keyToEx',
              exArgs: { input: rhs.substring(1) }
            };
            if (ctx) {
              mapping.context = ctx;
            }
            defaultKeymap.unshift(mapping);
          } else {
            // Key to key mapping
            var mapping = {
              keys: lhs,
              type: 'keyToKey',
              toKeys: rhs
            };
            if (ctx) {
              mapping.context = ctx;
            }
            defaultKeymap.unshift(mapping);
          }
        }
      },
      unmap: function (lhs, ctx) {
        if (lhs != ':' && lhs.charAt(0) == ':') {
          // Ex to Ex or Ex to key mapping
          if (ctx) {
            throw Error('Mode not supported for ex mappings');
          }
          var commandName = lhs.substring(1);
          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
            delete this.commandMap_[commandName];
            return;
          }
        } else {
          // Key to Ex or key to key mapping
          var keys = lhs;
          for (var i = 0; i < defaultKeymap.length; i++) {
            if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {
              defaultKeymap.splice(i, 1);
              return;
            }
          }
        }
        throw Error('No such mapping.');
      }
    };

    var exCommands = {
      colorscheme: function (cm, params) {
        if (!params.args || params.args.length < 1) {
          showConfirm(cm, cm.getOption('theme'));
          return;
        }
        cm.setOption('theme', params.args[0]);
      },
      map: function (cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length < 2) {
          if (cm) {
            showConfirm(cm, 'Invalid mapping: ' + params.input);
          }
          return;
        }
        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
      },
      imap: function (cm, params) {
        this.map(cm, params, 'insert');
      },
      nmap: function (cm, params) {
        this.map(cm, params, 'normal');
      },
      vmap: function (cm, params) {
        this.map(cm, params, 'visual');
      },
      unmap: function (cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length < 1) {
          if (cm) {
            showConfirm(cm, 'No such mapping: ' + params.input);
          }
          return;
        }
        exCommandDispatcher.unmap(mapArgs[0], ctx);
      },
      move: function (cm, params) {
        commandDispatcher.processCommand(cm, cm.state.vim, {
          type: 'motion',
          motion: 'moveToLineOrEdgeOfDocument',
          motionArgs: { forward: false, explicitRepeat: true,
            linewise: true },
          repeatOverride: params.line + 1 });
      },
      set: function (cm, params) {
        var setArgs = params.args;
        // Options passed through to the setOption/getOption calls. May be passed in by the
        // local/global versions of the set command
        var setCfg = params.setCfg || {};
        if (!setArgs || setArgs.length < 1) {
          if (cm) {
            showConfirm(cm, 'Invalid mapping: ' + params.input);
          }
          return;
        }
        var expr = setArgs[0].split('=');
        var optionName = expr[0];
        var value = expr[1];
        var forceGet = false;

        if (optionName.charAt(optionName.length - 1) == '?') {
          // If post-fixed with ?, then the set is actually a get.
          if (value) {
            throw Error('Trailing characters: ' + params.argString);
          }
          optionName = optionName.substring(0, optionName.length - 1);
          forceGet = true;
        }
        if (value === undefined && optionName.substring(0, 2) == 'no') {
          // To set boolean options to false, the option name is prefixed with
          // 'no'.
          optionName = optionName.substring(2);
          value = false;
        }

        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';
        if (optionIsBoolean && value == undefined) {
          // Calling set with a boolean option sets it to true.
          value = true;
        }
        // If no value is provided, then we assume this is a get.
        if (!optionIsBoolean && value === undefined || forceGet) {
          var oldValue = getOption(optionName, cm, setCfg);
          if (oldValue instanceof Error) {
            showConfirm(cm, oldValue.message);
          } else if (oldValue === true || oldValue === false) {
            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);
          } else {
            showConfirm(cm, '  ' + optionName + '=' + oldValue);
          }
        } else {
          var setOptionReturn = setOption(optionName, value, cm, setCfg);
          if (setOptionReturn instanceof Error) {
            showConfirm(cm, setOptionReturn.message);
          }
        }
      },
      setlocal: function (cm, params) {
        // setCfg is passed through to setOption
        params.setCfg = { scope: 'local' };
        this.set(cm, params);
      },
      setglobal: function (cm, params) {
        // setCfg is passed through to setOption
        params.setCfg = { scope: 'global' };
        this.set(cm, params);
      },
      registers: function (cm, params) {
        var regArgs = params.args;
        var registers = vimGlobalState.registerController.registers;
        var regInfo = '----------Registers----------<br><br>';
        if (!regArgs) {
          for (var registerName in registers) {
            var text = registers[registerName].toString();
            if (text.length) {
              regInfo += '"' + registerName + '    ' + text + '<br>';
            }
          }
        } else {
          var registerName;
          regArgs = regArgs.join('');
          for (var i = 0; i < regArgs.length; i++) {
            registerName = regArgs.charAt(i);
            if (!vimGlobalState.registerController.isValidRegister(registerName)) {
              continue;
            }
            var register = registers[registerName] || new Register();
            regInfo += '"' + registerName + '    ' + register.toString() + '<br>';
          }
        }
        showConfirm(cm, regInfo);
      },
      sort: function (cm, params) {
        var reverse, ignoreCase, unique, number, pattern;
        function parseArgs() {
          if (params.argString) {
            var args = new CodeMirror.StringStream(params.argString);
            if (args.eat('!')) {
              reverse = true;
            }
            if (args.eol()) {
              return;
            }
            if (!args.eatSpace()) {
              return 'Invalid arguments';
            }
            var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
            if (!opts && !args.eol()) {
              return 'Invalid arguments';
            }
            if (opts[1]) {
              ignoreCase = opts[1].indexOf('i') != -1;
              unique = opts[1].indexOf('u') != -1;
              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;
              var hex = opts[1].indexOf('x') != -1 && 1;
              var octal = opts[1].indexOf('o') != -1 && 1;
              if (decimal + hex + octal > 1) {
                return 'Invalid arguments';
              }
              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';
            }
            if (opts[2]) {
              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');
            }
          }
        }
        var err = parseArgs();
        if (err) {
          showConfirm(cm, err + ': ' + params.argString);
          return;
        }
        var lineStart = params.line || cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        if (lineStart == lineEnd) {
          return;
        }
        var curStart = Pos(lineStart, 0);
        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));
        var text = cm.getRange(curStart, curEnd).split('\n');
        var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;
        var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;
        var numPart = [],
            textPart = [];
        if (number || pattern) {
          for (var i = 0; i < text.length; i++) {
            var matchPart = pattern ? text[i].match(pattern) : null;
            if (matchPart && matchPart[0] != '') {
              numPart.push(matchPart);
            } else if (!pattern && numberRegex.exec(text[i])) {
              numPart.push(text[i]);
            } else {
              textPart.push(text[i]);
            }
          }
        } else {
          textPart = text;
        }
        function compareFn(a, b) {
          if (reverse) {
            var tmp;tmp = a;a = b;b = tmp;
          }
          if (ignoreCase) {
            a = a.toLowerCase();b = b.toLowerCase();
          }
          var anum = number && numberRegex.exec(a);
          var bnum = number && numberRegex.exec(b);
          if (!anum) {
            return a < b ? -1 : 1;
          }
          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
          return anum - bnum;
        }
        function comparePatternFn(a, b) {
          if (reverse) {
            var tmp;tmp = a;a = b;b = tmp;
          }
          if (ignoreCase) {
            a[0] = a[0].toLowerCase();b[0] = b[0].toLowerCase();
          }
          return a[0] < b[0] ? -1 : 1;
        }
        numPart.sort(pattern ? comparePatternFn : compareFn);
        if (pattern) {
          for (var i = 0; i < numPart.length; i++) {
            numPart[i] = numPart[i].input;
          }
        } else if (!number) {
          textPart.sort(compareFn);
        }
        text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);
        if (unique) {
          // Remove duplicate lines
          var textOld = text;
          var lastLine;
          text = [];
          for (var i = 0; i < textOld.length; i++) {
            if (textOld[i] != lastLine) {
              text.push(textOld[i]);
            }
            lastLine = textOld[i];
          }
        }
        cm.replaceRange(text.join('\n'), curStart, curEnd);
      },
      global: function (cm, params) {
        // a global command is of the form
        // :[range]g/pattern/[cmd]
        // argString holds the string /pattern/[cmd]
        var argString = params.argString;
        if (!argString) {
          showConfirm(cm, 'Regular Expression missing from global');
          return;
        }
        // range is specified here
        var lineStart = params.line !== undefined ? params.line : cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        // get the tokens from argString
        var tokens = splitBySlash(argString);
        var regexPart = argString,
            cmd;
        if (tokens.length) {
          regexPart = tokens[0];
          cmd = tokens.slice(1, tokens.length).join('/');
        }
        if (regexPart) {
          // If regex part is empty, then use the previous query. Otherwise
          // use the regex part as the new query.
          try {
            updateSearchQuery(cm, regexPart, true /** ignoreCase */
            , true /** smartCase */);
          } catch (e) {
            showConfirm(cm, 'Invalid regex: ' + regexPart);
            return;
          }
        }
        // now that we have the regexPart, search for regex matches in the
        // specified range of lines
        var query = getSearchState(cm).getQuery();
        var matchedLines = [],
            content = '';
        for (var i = lineStart; i <= lineEnd; i++) {
          var matched = query.test(cm.getLine(i));
          if (matched) {
            matchedLines.push(i + 1);
            content += cm.getLine(i) + '<br>';
          }
        }
        // if there is no [cmd], just display the list of matched lines
        if (!cmd) {
          showConfirm(cm, content);
          return;
        }
        var index = 0;
        var nextCommand = function () {
          if (index < matchedLines.length) {
            var command = matchedLines[index] + cmd;
            exCommandDispatcher.processCommand(cm, command, {
              callback: nextCommand
            });
          }
          index++;
        };
        nextCommand();
      },
      substitute: function (cm, params) {
        if (!cm.getSearchCursor) {
          throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');
        }
        var argString = params.argString;
        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
        var regexPart,
            replacePart = '',
            trailing,
            flagsPart,
            count;
        var confirm = false; // Whether to confirm each replace.
        var global = false; // True to replace all instances on a line, false to replace only 1.
        if (tokens.length) {
          regexPart = tokens[0];
          if (getOption('pcre') && regexPart !== '') {
            regexPart = new RegExp(regexPart).source; //normalize not escaped characters
          }
          replacePart = tokens[1];
          if (regexPart && regexPart[regexPart.length - 1] === '$') {
            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\n';
            replacePart = replacePart ? replacePart + '\n' : '\n';
          }
          if (replacePart !== undefined) {
            if (getOption('pcre')) {
              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g, "$1$$&"));
            } else {
              replacePart = translateRegexReplace(replacePart);
            }
            vimGlobalState.lastSubstituteReplacePart = replacePart;
          }
          trailing = tokens[2] ? tokens[2].split(' ') : [];
        } else {
          // either the argString is empty or its of the form ' hello/world'
          // actually splitBySlash returns a list of tokens
          // only if the string starts with a '/'
          if (argString && argString.length) {
            showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');
            return;
          }
        }
        // After the 3rd slash, we can have flags followed by a space followed
        // by count.
        if (trailing) {
          flagsPart = trailing[0];
          count = parseInt(trailing[1]);
          if (flagsPart) {
            if (flagsPart.indexOf('c') != -1) {
              confirm = true;
              flagsPart.replace('c', '');
            }
            if (flagsPart.indexOf('g') != -1) {
              global = true;
              flagsPart.replace('g', '');
            }
            if (getOption('pcre')) {
              regexPart = regexPart + '/' + flagsPart;
            } else {
              regexPart = regexPart.replace(/\//g, "\\/") + '/' + flagsPart;
            }
          }
        }
        if (regexPart) {
          // If regex part is empty, then use the previous query. Otherwise use
          // the regex part as the new query.
          try {
            updateSearchQuery(cm, regexPart, true /** ignoreCase */
            , true /** smartCase */);
          } catch (e) {
            showConfirm(cm, 'Invalid regex: ' + regexPart);
            return;
          }
        }
        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
        if (replacePart === undefined) {
          showConfirm(cm, 'No previous substitute regular expression');
          return;
        }
        var state = getSearchState(cm);
        var query = state.getQuery();
        var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;
        var lineEnd = params.lineEnd || lineStart;
        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {
          lineEnd = Infinity;
        }
        if (count) {
          lineStart = lineEnd;
          lineEnd = lineStart + count - 1;
        }
        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));
        var cursor = cm.getSearchCursor(query, startPos);
        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);
      },
      redo: CodeMirror.commands.redo,
      undo: CodeMirror.commands.undo,
      write: function (cm) {
        if (CodeMirror.commands.save) {
          // If a save command is defined, call it.
          CodeMirror.commands.save(cm);
        } else if (cm.save) {
          // Saves to text area if no save command is defined and cm.save() is available.
          cm.save();
        }
      },
      nohlsearch: function (cm) {
        clearSearchHighlight(cm);
      },
      yank: function (cm) {
        var cur = copyCursor(cm.getCursor());
        var line = cur.line;
        var lineText = cm.getLine(line);
        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);
      },
      delmarks: function (cm, params) {
        if (!params.argString || !trim(params.argString)) {
          showConfirm(cm, 'Argument required');
          return;
        }

        var state = cm.state.vim;
        var stream = new CodeMirror.StringStream(trim(params.argString));
        while (!stream.eol()) {
          stream.eatSpace();

          // Record the streams position at the beginning of the loop for use
          // in error messages.
          var count = stream.pos;

          if (!stream.match(/[a-zA-Z]/, false)) {
            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
            return;
          }

          var sym = stream.next();
          // Check if this symbol is part of a range
          if (stream.match('-', true)) {
            // This symbol is part of a range.

            // The range must terminate at an alphabetic character.
            if (!stream.match(/[a-zA-Z]/, false)) {
              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
              return;
            }

            var startMark = sym;
            var finishMark = stream.next();
            // The range must terminate at an alphabetic character which
            // shares the same case as the start of the range.
            if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {
              var start = startMark.charCodeAt(0);
              var finish = finishMark.charCodeAt(0);
              if (start >= finish) {
                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
                return;
              }

              // Because marks are always ASCII values, and we have
              // determined that they are the same case, we can use
              // their char codes to iterate through the defined range.
              for (var j = 0; j <= finish - start; j++) {
                var mark = String.fromCharCode(start + j);
                delete state.marks[mark];
              }
            } else {
              showConfirm(cm, 'Invalid argument: ' + startMark + '-');
              return;
            }
          } else {
            // This symbol is a valid mark, and is not part of a range.
            delete state.marks[sym];
          }
        }
      }
    };

    var exCommandDispatcher = new ExCommandDispatcher();

    /**
    * @param {CodeMirror} cm CodeMirror instance we are in.
    * @param {boolean} confirm Whether to confirm each replace.
    * @param {Cursor} lineStart Line to start replacing from.
    * @param {Cursor} lineEnd Line to stop replacing at.
    * @param {RegExp} query Query for performing matches with.
    * @param {string} replaceWith Text to replace matches with. May contain $1,
    *     $2, etc for replacing captured groups using Javascript replace.
    * @param {function()} callback A callback for when the replace is done.
    */
    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {
      // Set up all the functions.
      cm.state.vim.exMode = true;
      var done = false;
      var lastPos = searchCursor.from();
      function replaceAll() {
        cm.operation(function () {
          while (!done) {
            replace();
            next();
          }
          stop();
        });
      }
      function replace() {
        var text = cm.getRange(searchCursor.from(), searchCursor.to());
        var newText = text.replace(query, replaceWith);
        searchCursor.replace(newText);
      }
      function next() {
        // The below only loops to skip over multiple occurrences on the same
        // line when 'global' is not true.
        while (searchCursor.findNext() && isInRange(searchCursor.from(), lineStart, lineEnd)) {
          if (!global && lastPos && searchCursor.from().line == lastPos.line) {
            continue;
          }
          cm.scrollIntoView(searchCursor.from(), 30);
          cm.setSelection(searchCursor.from(), searchCursor.to());
          lastPos = searchCursor.from();
          done = false;
          return;
        }
        done = true;
      }
      function stop(close) {
        if (close) {
          close();
        }
        cm.focus();
        if (lastPos) {
          cm.setCursor(lastPos);
          var vim = cm.state.vim;
          vim.exMode = false;
          vim.lastHPos = vim.lastHSPos = lastPos.ch;
        }
        if (callback) {
          callback();
        }
      }
      function onPromptKeyDown(e, _value, close) {
        // Swallow all keys.
        CodeMirror.e_stop(e);
        var keyName = CodeMirror.keyName(e);
        switch (keyName) {
          case 'Y':
            replace();next();break;
          case 'N':
            next();break;
          case 'A':
            // replaceAll contains a call to close of its own. We don't want it
            // to fire too early or multiple times.
            var savedCallback = callback;
            callback = undefined;
            cm.operation(replaceAll);
            callback = savedCallback;
            break;
          case 'L':
            replace();
          // fall through and exit.
          case 'Q':
          case 'Esc':
          case 'Ctrl-C':
          case 'Ctrl-[':
            stop(close);
            break;
        }
        if (done) {
          stop(close);
        }
        return true;
      }

      // Actually do replace.
      next();
      if (done) {
        showConfirm(cm, 'No matches for ' + query.source);
        return;
      }
      if (!confirm) {
        replaceAll();
        if (callback) {
          callback();
        }
        return;
      }
      showPrompt(cm, {
        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',
        onKeyDown: onPromptKeyDown
      });
    }

    CodeMirror.keyMap.vim = {
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    function exitInsertMode(cm) {
      var vim = cm.state.vim;
      var macroModeState = vimGlobalState.macroModeState;
      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');
      var isPlaying = macroModeState.isPlaying;
      var lastChange = macroModeState.lastInsertModeChanges;
      if (!isPlaying) {
        cm.off('change', onChange);
        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);
      }
      if (!isPlaying && vim.insertModeRepeat > 1) {
        // Perform insert mode repeat for commands like 3,a and 3,o.
        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);
        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
      }
      delete vim.insertModeRepeat;
      vim.insertMode = false;
      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);
      cm.setOption('keyMap', 'vim');
      cm.setOption('disableInput', true);
      cm.toggleOverwrite(false); // exit replace mode if we were in it.
      // update the ". register before exiting insert mode
      insertModeChangeRegister.setText(lastChange.changes.join(''));
      CodeMirror.signal(cm, "vim-mode-change", { mode: "normal" });
      if (macroModeState.isRecording) {
        logInsertModeChange(macroModeState);
      }
    }

    function _mapCommand(command) {
      defaultKeymap.unshift(command);
    }

    function mapCommand(keys, type, name, args, extra) {
      var command = { keys: keys, type: type };
      command[type] = name;
      command[type + "Args"] = args;
      for (var key in extra) command[key] = extra[key];
      _mapCommand(command);
    }

    // The timeout in milliseconds for the two-character ESC keymap should be
    // adjusted according to your typing speed to prevent false positives.
    defineOption('insertModeEscKeysTimeout', 200, 'number');

    CodeMirror.keyMap['vim-insert'] = {
      // TODO: override navigation keys so that Esc will cancel automatic
      // indentation from o, O, i_<CR>
      fallthrough: ['default'],
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    CodeMirror.keyMap['vim-replace'] = {
      'Backspace': 'goCharLeft',
      fallthrough: ['vim-insert'],
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    function executeMacroRegister(cm, vim, macroModeState, registerName) {
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (registerName == ':') {
        // Read-only register containing last Ex command.
        if (register.keyBuffer[0]) {
          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
        }
        macroModeState.isPlaying = false;
        return;
      }
      var keyBuffer = register.keyBuffer;
      var imc = 0;
      macroModeState.isPlaying = true;
      macroModeState.replaySearchQueries = register.searchQueries.slice(0);
      for (var i = 0; i < keyBuffer.length; i++) {
        var text = keyBuffer[i];
        var match, key;
        while (text) {
          // Pull off one command key, which is either a single character
          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.
          match = /<\w+-.+?>|<\w+>|./.exec(text);
          key = match[0];
          text = text.substring(match.index + key.length);
          CodeMirror.Vim.handleKey(cm, key, 'macro');
          if (vim.insertMode) {
            var changes = register.insertModeChanges[imc++].changes;
            vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;
            repeatInsertModeChanges(cm, changes, 1);
            exitInsertMode(cm);
          }
        }
      }
      macroModeState.isPlaying = false;
    }

    function logKey(macroModeState, key) {
      if (macroModeState.isPlaying) {
        return;
      }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register) {
        register.pushText(key);
      }
    }

    function logInsertModeChange(macroModeState) {
      if (macroModeState.isPlaying) {
        return;
      }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register && register.pushInsertModeChanges) {
        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
      }
    }

    function logSearchQuery(macroModeState, query) {
      if (macroModeState.isPlaying) {
        return;
      }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register && register.pushSearchQuery) {
        register.pushSearchQuery(query);
      }
    }

    /**
     * Listens for changes made in insert mode.
     * Should only be active in insert mode.
     */
    function onChange(cm, changeObj) {
      var macroModeState = vimGlobalState.macroModeState;
      var lastChange = macroModeState.lastInsertModeChanges;
      if (!macroModeState.isPlaying) {
        while (changeObj) {
          lastChange.expectCursorActivityForChange = true;
          if (lastChange.ignoreCount > 1) {
            lastChange.ignoreCount--;
          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined /* only in testing */) {
              var selectionCount = cm.listSelections().length;
              if (selectionCount > 1) lastChange.ignoreCount = selectionCount;
              var text = changeObj.text.join('\n');
              if (lastChange.maybeReset) {
                lastChange.changes = [];
                lastChange.maybeReset = false;
              }
              if (text) {
                if (cm.state.overwrite && !/\n/.test(text)) {
                  lastChange.changes.push([text]);
                } else {
                  lastChange.changes.push(text);
                }
              }
            }
          // Change objects may be chained with next.
          changeObj = changeObj.next;
        }
      }
    }

    /**
    * Listens for any kind of cursor activity on CodeMirror.
    */
    function onCursorActivity(cm) {
      var vim = cm.state.vim;
      if (vim.insertMode) {
        // Tracking cursor activity in insert mode (for macro support).
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) {
          return;
        }
        var lastChange = macroModeState.lastInsertModeChanges;
        if (lastChange.expectCursorActivityForChange) {
          lastChange.expectCursorActivityForChange = false;
        } else {
          // Cursor moved outside the context of an edit. Reset the change.
          lastChange.maybeReset = true;
        }
      } else if (!cm.curOp.isVimOp) {
        handleExternalSelection(cm, vim);
      }
      if (vim.visualMode) {
        updateFakeCursor(cm);
      }
    }
    function updateFakeCursor(cm) {
      var vim = cm.state.vim;
      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));
      var to = offsetCursor(from, 0, 1);
      if (vim.fakeCursor) {
        vim.fakeCursor.clear();
      }
      vim.fakeCursor = cm.markText(from, to, { className: 'cm-animate-fat-cursor' });
    }
    function handleExternalSelection(cm, vim) {
      var anchor = cm.getCursor('anchor');
      var head = cm.getCursor('head');
      // Enter or exit visual mode to match mouse selection.
      if (vim.visualMode && !cm.somethingSelected()) {
        exitVisualMode(cm, false);
      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {
        vim.visualMode = true;
        vim.visualLine = false;
        CodeMirror.signal(cm, "vim-mode-change", { mode: "visual" });
      }
      if (vim.visualMode) {
        // Bind CodeMirror selection model to vim selection model.
        // Mouse selections are considered visual characterwise.
        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
        head = offsetCursor(head, 0, headOffset);
        anchor = offsetCursor(anchor, 0, anchorOffset);
        vim.sel = {
          anchor: anchor,
          head: head
        };
        updateMark(cm, vim, '<', cursorMin(head, anchor));
        updateMark(cm, vim, '>', cursorMax(head, anchor));
      } else if (!vim.insertMode) {
        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.
        vim.lastHPos = cm.getCursor().ch;
      }
    }

    /** Wrapper for special keys pressed in insert mode */
    function InsertModeKey(keyName) {
      this.keyName = keyName;
    }

    /**
    * Handles raw key down events from the text area.
    * - Should only be active in insert mode.
    * - For recording deletes in insert mode.
    */
    function onKeyEventTargetKeyDown(e) {
      var macroModeState = vimGlobalState.macroModeState;
      var lastChange = macroModeState.lastInsertModeChanges;
      var keyName = CodeMirror.keyName(e);
      if (!keyName) {
        return;
      }
      function onKeyFound() {
        if (lastChange.maybeReset) {
          lastChange.changes = [];
          lastChange.maybeReset = false;
        }
        lastChange.changes.push(new InsertModeKey(keyName));
        return true;
      }
      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {
        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);
      }
    }

    /**
     * Repeats the last edit, which includes exactly 1 command and at most 1
     * insert. Operator and motion commands are read from lastEditInputState,
     * while action commands are read from lastEditActionCommand.
     *
     * If repeatForInsert is true, then the function was called by
     * exitInsertMode to repeat the insert mode changes the user just made. The
     * corresponding enterInsertMode call was made with a count.
     */
    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {
      var macroModeState = vimGlobalState.macroModeState;
      macroModeState.isPlaying = true;
      var isAction = !!vim.lastEditActionCommand;
      var cachedInputState = vim.inputState;
      function repeatCommand() {
        if (isAction) {
          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
        } else {
          commandDispatcher.evalInput(cm, vim);
        }
      }
      function repeatInsert(repeat) {
        if (macroModeState.lastInsertModeChanges.changes.length > 0) {
          // For some reason, repeat cw in desktop VIM does not repeat
          // insert mode changes. Will conform to that behavior.
          repeat = !vim.lastEditActionCommand ? 1 : repeat;
          var changeObject = macroModeState.lastInsertModeChanges;
          repeatInsertModeChanges(cm, changeObject.changes, repeat);
        }
      }
      vim.inputState = vim.lastEditInputState;
      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {
        // o and O repeat have to be interlaced with insert repeats so that the
        // insertions appear on separate lines instead of the last line.
        for (var i = 0; i < repeat; i++) {
          repeatCommand();
          repeatInsert(1);
        }
      } else {
        if (!repeatForInsert) {
          // Hack to get the cursor to end up at the right place. If I is
          // repeated in insert mode repeat, cursor will be 1 insert
          // change set left of where it should be.
          repeatCommand();
        }
        repeatInsert(repeat);
      }
      vim.inputState = cachedInputState;
      if (vim.insertMode && !repeatForInsert) {
        // Don't exit insert mode twice. If repeatForInsert is set, then we
        // were called by an exitInsertMode call lower on the stack.
        exitInsertMode(cm);
      }
      macroModeState.isPlaying = false;
    }

    function repeatInsertModeChanges(cm, changes, repeat) {
      function keyHandler(binding) {
        if (typeof binding == 'string') {
          CodeMirror.commands[binding](cm);
        } else {
          binding(cm);
        }
        return true;
      }
      var head = cm.getCursor('head');
      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
      if (visualBlock) {
        // Set up block selection again for repeating the changes.
        selectForInsert(cm, head, visualBlock + 1);
        repeat = cm.listSelections().length;
        cm.setCursor(head);
      }
      for (var i = 0; i < repeat; i++) {
        if (visualBlock) {
          cm.setCursor(offsetCursor(head, i, 0));
        }
        for (var j = 0; j < changes.length; j++) {
          var change = changes[j];
          if (change instanceof InsertModeKey) {
            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);
          } else if (typeof change == "string") {
            var cur = cm.getCursor();
            cm.replaceRange(change, cur, cur);
          } else {
            var start = cm.getCursor();
            var end = offsetCursor(start, 0, change[0].length);
            cm.replaceRange(change[0], start, end);
          }
        }
      }
      if (visualBlock) {
        cm.setCursor(offsetCursor(head, 0, 1));
      }
    }

    resetVimGlobalState();
    return vimApi;
  };
  // Initialize Vim and make it available as an API.
  CodeMirror.Vim = Vim();
});

/***/ }),

/***/ "yM1o":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("h6ac")))

/***/ }),

/***/ "yOG5":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("vSO4");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__("TNJq") });

/***/ }),

/***/ "yPXq":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__("ZKdc");
var utils = __webpack_require__("dvMn");

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data: utils.transformTo(this.destType, chunk.data),
        meta: chunk.meta
    });
};
module.exports = ConvertWorker;

/***/ }),

/***/ "yS17":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "ycyv":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("knrM");
var gOPS = __webpack_require__("Ocr3");
var pIE = __webpack_require__("z7R8");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  }return result;
};

/***/ }),

/***/ "yeEC":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("cjsw"), __esModule: true };

/***/ }),

/***/ "yh9p":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "yocI":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("Vhc8");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};

/***/ }),

/***/ "z0rv":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__("38Wu").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "z7R8":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "zCAL":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

/***/ }),

/***/ "zKeE":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "zKjx":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_auth__ = __webpack_require__("EkFk");


/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//# sourceMappingURL=index.esm.js.map

/***/ }),

/***/ "zadB":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("wJQ+");

/***/ }),

/***/ "zkJf":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("Jc5s");

module.exports = __webpack_require__("ALBP")('String', 'repeat');

/***/ }),

/***/ "zotD":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("BxvP");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "zs1I":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("tQq4"));else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.registerHelper("fold", "brace", function (cm, start) {
    var line = start.line,
        lineText = cm.getLine(line);
    var tokenType;

    function findOpening(openCh) {
      for (var at = start.ch, pass = 0;;) {
        var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
        if (found == -1) {
          if (pass == 1) break;
          pass = 1;
          at = lineText.length;
          continue;
        }
        if (pass == 1 && found < start.ch) break;
        tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));
        if (!/^(comment|string)/.test(tokenType)) return found + 1;
        at = found - 1;
      }
    }

    var startToken = "{",
        endToken = "}",
        startCh = findOpening("{");
    if (startCh == null) {
      startToken = "[", endToken = "]";
      startCh = findOpening("[");
    }

    if (startCh == null) return;
    var count = 1,
        lastLine = cm.lastLine(),
        end,
        endCh;
    outer: for (var i = line; i <= lastLine; ++i) {
      var text = cm.getLine(i),
          pos = i == line ? startCh : 0;
      for (;;) {
        var nextOpen = text.indexOf(startToken, pos),
            nextClose = text.indexOf(endToken, pos);
        if (nextOpen < 0) nextOpen = text.length;
        if (nextClose < 0) nextClose = text.length;
        pos = Math.min(nextOpen, nextClose);
        if (pos == text.length) break;
        if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {
          if (pos == nextOpen) ++count;else if (! --count) {
            end = i;endCh = pos;break outer;
          }
        }
        ++pos;
      }
    }
    if (end == null || line == end) return;
    return { from: CodeMirror.Pos(line, startCh),
      to: CodeMirror.Pos(end, endCh) };
  });

  CodeMirror.registerHelper("fold", "import", function (cm, start) {
    function hasImport(line) {
      if (line < cm.firstLine() || line > cm.lastLine()) return null;
      var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
      if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
      if (start.type != "keyword" || start.string != "import") return null;
      // Now find closing semicolon, return its position
      for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
        var text = cm.getLine(i),
            semi = text.indexOf(";");
        if (semi != -1) return { startCh: start.end, end: CodeMirror.Pos(i, semi) };
      }
    }

    var startLine = start.line,
        has = hasImport(startLine),
        prev;
    if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1) return null;
    for (var end = has.end;;) {
      var next = hasImport(end.line + 1);
      if (next == null) break;
      end = next.end;
    }
    return { from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end };
  });

  CodeMirror.registerHelper("fold", "include", function (cm, start) {
    function hasInclude(line) {
      if (line < cm.firstLine() || line > cm.lastLine()) return null;
      var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
      if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
      if (start.type == "meta" && start.string.slice(0, 8) == "#include") return start.start + 8;
    }

    var startLine = start.line,
        has = hasInclude(startLine);
    if (has == null || hasInclude(startLine - 1) != null) return null;
    for (var end = startLine;;) {
      var next = hasInclude(end + 1);
      if (next == null) break;
      ++end;
    }
    return { from: CodeMirror.Pos(startLine, has + 1),
      to: cm.clipPos(CodeMirror.Pos(end)) };
  });
});

/***/ })

/******/ });
"use strict";
(self["webpackChunkaxen"] = self["webpackChunkaxen"] || []).push([["default-node_modules_ngx-gauge_fesm2015_ngx-gauge_js-node_modules_ngx-echarts_fesm2015_ngx-ec-50ebe3"],{

/***/ 65383:
/*!******************************************************!*\
  !*** ./node_modules/ngx-gauge/fesm2015/ngx-gauge.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NgxGauge": () => (/* binding */ NgxGauge),
/* harmony export */   "NgxGaugeAppend": () => (/* binding */ NgxGaugeAppend),
/* harmony export */   "NgxGaugeLabel": () => (/* binding */ NgxGaugeLabel),
/* harmony export */   "NgxGaugeModule": () => (/* binding */ NgxGaugeModule),
/* harmony export */   "NgxGaugePrepend": () => (/* binding */ NgxGaugePrepend),
/* harmony export */   "NgxGaugeValue": () => (/* binding */ NgxGaugeValue)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 3184);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ 36362);




const _c0 = ["canvas"];
const _c1 = ["rLabel"];
const _c2 = ["reading"];

function NgxGauge_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0, 0, ["*ngSwitchCase", "true"]);
  }
}

function NgxGauge_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }

  if (rf & 2) {
    const ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r2.prepend);
  }
}

function NgxGauge_ng_content_6_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0, 1, ["*ngSwitchCase", "true"]);
  }
}

function NgxGauge_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](2, "number");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }

  if (rf & 2) {
    const ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind1"](2, 1, ctx_r4.value));
  }
}

function NgxGauge_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0, 2, ["*ngSwitchCase", "true"]);
  }
}

function NgxGauge_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }

  if (rf & 2) {
    const ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r6.append);
  }
}

function NgxGauge_ng_content_13_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0, 3, ["*ngSwitchCase", "true"]);
  }
}

function NgxGauge_ng_container_14_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }

  if (rf & 2) {
    const ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r9.label);
  }
}

const _c3 = [[["ngx-gauge-prepend"]], [["ngx-gauge-value"]], [["ngx-gauge-append"]], [["ngx-gauge-label"]]];
const _c4 = ["ngx-gauge-prepend", "ngx-gauge-value", "ngx-gauge-append", "ngx-gauge-label"];

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function coerceBooleanProperty(value) {
  return value != null && `${value}` !== 'false';
}

function coerceNumberProperty(value, fallbackValue = 0) {
  return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);
}

function cssUnit(value) {
  return `${value}px`;
}

function isNumber(value) {
  return value != undefined && !isNaN(parseFloat(value)) && !isNaN(Number(value));
}

class NgxGaugeAppend {}

NgxGaugeAppend.ɵfac = function NgxGaugeAppend_Factory(t) {
  return new (t || NgxGaugeAppend)();
};

NgxGaugeAppend.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: NgxGaugeAppend,
  selectors: [["ngx-gauge-append"]],
  exportAs: ["ngxGaugeAppend"]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxGaugeAppend, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
    args: [{
      selector: "ngx-gauge-append",
      exportAs: "ngxGaugeAppend"
    }]
  }], null, null);
})();

class NgxGaugePrepend {}

NgxGaugePrepend.ɵfac = function NgxGaugePrepend_Factory(t) {
  return new (t || NgxGaugePrepend)();
};

NgxGaugePrepend.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: NgxGaugePrepend,
  selectors: [["ngx-gauge-prepend"]],
  exportAs: ["ngxGaugePrepend"]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxGaugePrepend, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
    args: [{
      selector: "ngx-gauge-prepend",
      exportAs: "ngxGaugePrepend"
    }]
  }], null, null);
})();

class NgxGaugeValue {}

NgxGaugeValue.ɵfac = function NgxGaugeValue_Factory(t) {
  return new (t || NgxGaugeValue)();
};

NgxGaugeValue.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: NgxGaugeValue,
  selectors: [["ngx-gauge-value"]],
  exportAs: ["ngxGaugeValue"]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxGaugeValue, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
    args: [{
      selector: "ngx-gauge-value",
      exportAs: "ngxGaugeValue"
    }]
  }], null, null);
})();

class NgxGaugeLabel {}

NgxGaugeLabel.ɵfac = function NgxGaugeLabel_Factory(t) {
  return new (t || NgxGaugeLabel)();
};

NgxGaugeLabel.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: NgxGaugeLabel,
  selectors: [["ngx-gauge-label"]],
  exportAs: ["ngxGaugeLabel"]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxGaugeLabel, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
    args: [{
      selector: "ngx-gauge-label",
      exportAs: "ngxGaugeLabel"
    }]
  }], null, null);
})();

const DEFAULTS = {
  MIN: 0,
  MAX: 100,
  TYPE: 'arch',
  THICK: 4,
  FOREGROUND_COLOR: 'rgba(0, 150, 136, 1)',
  BACKGROUND_COLOR: 'rgba(0, 0, 0, 0.1)',
  CAP: 'butt',
  SIZE: 200
};

class NgxGauge {
  constructor(_elementRef, _renderer) {
    this._elementRef = _elementRef;
    this._renderer = _renderer;
    this._size = DEFAULTS.SIZE;
    this._min = DEFAULTS.MIN;
    this._max = DEFAULTS.MAX;
    this._animate = true;
    this._initialized = false;
    this._animationRequestID = 0;
    this.ariaLabel = '';
    this.ariaLabelledby = null;
    this.type = DEFAULTS.TYPE;
    this.cap = DEFAULTS.CAP;
    this.thick = DEFAULTS.THICK;
    this.foregroundColor = DEFAULTS.FOREGROUND_COLOR;
    this.backgroundColor = DEFAULTS.BACKGROUND_COLOR;
    this.thresholds = Object.create(null);
    this._value = 0;
    this.duration = 1200;
  }

  get size() {
    return this._size;
  }

  set size(value) {
    this._size = coerceNumberProperty(value);
  }

  get min() {
    return this._min;
  }

  set min(value) {
    this._min = coerceNumberProperty(value, DEFAULTS.MIN);
  }

  get animate() {
    return this._animate;
  }

  set animate(value) {
    this._animate = coerceBooleanProperty(value);
  }

  get max() {
    return this._max;
  }

  set max(value) {
    this._max = coerceNumberProperty(value, DEFAULTS.MAX);
  }

  get value() {
    return this._value;
  }

  set value(val) {
    this._value = coerceNumberProperty(val);
  }

  ngOnChanges(changes) {
    const isCanvasPropertyChanged = changes['thick'] || changes['type'] || changes['cap'] || changes['size'];
    const isDataChanged = changes['value'] || changes['min'] || changes['max'];

    if (this._initialized) {
      if (isDataChanged) {
        let nv, ov;

        if (changes['value']) {
          nv = changes['value'].currentValue;
          ov = changes['value'].previousValue;
        }

        this._update(nv, ov);
      }

      if (isCanvasPropertyChanged) {
        this._destroy();

        this._init();
      }
    }
  }

  _updateSize() {
    this._renderer.setStyle(this._elementRef.nativeElement, 'width', cssUnit(this._getWidth()));

    this._renderer.setStyle(this._elementRef.nativeElement, 'height', cssUnit(this._getCanvasHeight()));

    this._canvas.nativeElement.width = this._getWidth();
    this._canvas.nativeElement.height = this._getCanvasHeight();

    this._renderer.setStyle(this._label.nativeElement, 'transform', 'translateY(' + (this.size / 3 * 2 - this.size / 13 / 4) + 'px)');

    this._renderer.setStyle(this._reading.nativeElement, 'transform', 'translateY(' + (this.size / 2 - this.size * 0.22 / 2) + 'px)');
  }

  ngAfterViewInit() {
    if (this._canvas) {
      this._init();
    }
  }

  ngOnDestroy() {
    this._destroy();
  }

  _getBounds(type) {
    let head, tail;

    if (type == 'semi') {
      head = Math.PI;
      tail = 2 * Math.PI;
    } else if (type == 'full') {
      head = 1.5 * Math.PI;
      tail = 3.5 * Math.PI;
    } else if (type === 'arch') {
      head = 0.8 * Math.PI;
      tail = 2.2 * Math.PI;
    }

    return {
      head,
      tail
    };
  }

  _drawShell(start, middle, tail, color) {
    let center = this._getCenter(),
        radius = this._getRadius();

    middle = Math.max(middle, start); // never below 0%

    middle = Math.min(middle, tail); // never exceed 100%

    if (this._initialized) {
      this._clear();

      this._context.beginPath();

      this._context.strokeStyle = this.backgroundColor;

      this._context.arc(center.x, center.y, radius, middle, tail, false);

      this._context.stroke();

      this._context.beginPath();

      this._context.strokeStyle = color;

      this._context.arc(center.x, center.y, radius, start, middle, false);

      this._context.stroke();
    }
  }

  _clear() {
    this._context.clearRect(0, 0, this._getWidth(), this._getHeight());
  }

  _getWidth() {
    return this.size;
  }

  _getHeight() {
    return this.size;
  } // canvas height will be shorter for type 'semi' and 'arch'


  _getCanvasHeight() {
    return this.type == 'arch' || this.type == 'semi' ? 0.85 * this._getHeight() : this._getHeight();
  }

  _getRadius() {
    var center = this._getCenter();

    return center.x - this.thick;
  }

  _getCenter() {
    var x = this._getWidth() / 2,
        y = this._getHeight() / 2;
    return {
      x,
      y
    };
  }

  _init() {
    this._context = this._canvas.nativeElement.getContext('2d');
    this._initialized = true;

    this._updateSize();

    this._setupStyles();

    this._create();
  }

  _destroy() {
    if (this._animationRequestID) {
      window.cancelAnimationFrame(this._animationRequestID);
      this._animationRequestID = 0;
    }

    this._clear();

    this._context = null;
    this._initialized = false;
  }

  _setupStyles() {
    this._context.lineCap = this.cap;
    this._context.lineWidth = this.thick;
  }

  _getForegroundColorByRange(value) {
    const match = Object.keys(this.thresholds).filter(function (item) {
      return isNumber(item) && Number(item) <= value;
    }).sort((a, b) => Number(a) - Number(b)).reverse()[0];
    return match !== undefined ? this.thresholds[match].color || this.foregroundColor : this.foregroundColor;
  }

  _create(nv, ov) {
    let self = this,
        type = this.type,
        bounds = this._getBounds(type),
        duration = this.duration,
        min = this.min,
        max = this.max,
        value = clamp(this.value, this.min, this.max),
        start = bounds.head,
        unit = (bounds.tail - bounds.head) / (max - min),
        displacement = unit * (value - min),
        tail = bounds.tail,
        color = this._getForegroundColorByRange(value),
        startTime;

    if (self._animationRequestID) {
      window.cancelAnimationFrame(self._animationRequestID);
    }

    function animate(timestamp) {
      timestamp = timestamp || new Date().getTime();
      let runtime = timestamp - startTime;
      let progress = Math.min(runtime / duration, 1);
      let previousProgress = ov ? (ov - min) * unit : 0;
      let middle = start + previousProgress + displacement * progress;

      self._drawShell(start, middle, tail, color);

      if (self._animationRequestID && runtime < duration) {
        self._animationRequestID = window.requestAnimationFrame(timestamp => animate(timestamp));
      } else {
        window.cancelAnimationFrame(self._animationRequestID);
      }
    }

    if (this._animate) {
      if (nv != undefined && ov != undefined) {
        displacement = unit * nv - unit * ov;
      }

      self._animationRequestID = window.requestAnimationFrame(timestamp => {
        startTime = timestamp || new Date().getTime();
        animate(startTime);
      });
    } else {
      self._drawShell(start, start + displacement, tail, color);
    }
  }

  _update(nv, ov) {
    this._clear();

    this._create(nv, ov);
  }

}

NgxGauge.ɵfac = function NgxGauge_Factory(t) {
  return new (t || NgxGauge)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2));
};

NgxGauge.ɵcmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: NgxGauge,
  selectors: [["ngx-gauge"]],
  contentQueries: function NgxGauge_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, NgxGaugeLabel, 5);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, NgxGaugePrepend, 5);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, NgxGaugeAppend, 5);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, NgxGaugeValue, 5);
    }

    if (rf & 2) {
      let _t;

      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._labelChild = _t.first);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._prependChild = _t.first);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._appendChild = _t.first);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._valueDisplayChild = _t.first);
    }
  },
  viewQuery: function NgxGauge_Query(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c0, 7);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c1, 7);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c2, 7);
    }

    if (rf & 2) {
      let _t;

      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._canvas = _t.first);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._label = _t.first);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._reading = _t.first);
    }
  },
  hostAttrs: ["role", "slider", "aria-readonly", "true"],
  hostVars: 7,
  hostBindings: function NgxGauge_HostBindings(rf, ctx) {
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("ngx-gauge-meter", true);
    }
  },
  inputs: {
    ariaLabel: ["aria-label", "ariaLabel"],
    ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
    size: "size",
    min: "min",
    animate: "animate",
    max: "max",
    type: "type",
    cap: "cap",
    thick: "thick",
    label: "label",
    append: "append",
    prepend: "prepend",
    foregroundColor: "foregroundColor",
    backgroundColor: "backgroundColor",
    thresholds: "thresholds",
    value: "value",
    duration: "duration"
  },
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
  ngContentSelectors: _c4,
  decls: 17,
  vars: 16,
  consts: [[1, "reading-block"], ["reading", ""], [1, "reading-affix", 3, "ngSwitch"], [4, "ngSwitchCase"], [3, "ngSwitch"], [1, "reading-label", 3, "ngSwitch"], ["rLabel", ""], ["canvas", ""]],
  template: function NgxGauge_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"](_c3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0, 1)(2, "u", 2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgxGauge_ng_content_3_Template, 1, 0, "ng-content", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, NgxGauge_ng_container_4_Template, 2, 1, "ng-container", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](5, 4);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, NgxGauge_ng_content_6_Template, 1, 0, "ng-content", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](7, NgxGauge_ng_container_7_Template, 3, 3, "ng-container", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](8, "u", 2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](9, NgxGauge_ng_content_9_Template, 1, 0, "ng-content", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](10, NgxGauge_ng_container_10_Template, 2, 1, "ng-container", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]()();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](11, "div", 5, 6);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](13, NgxGauge_ng_content_13_Template, 1, 0, "ng-content", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](14, NgxGauge_ng_container_14_Template, 2, 1, "ng-container", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](15, "canvas", null, 7);
    }

    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("font-size", ctx.size * 0.22 + "px");
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx._prependChild != null);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", true);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", false);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx._valueDisplayChild != null);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", true);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", false);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx._appendChild != null);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", true);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", false);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("font-size", ctx.size / 13 + "px");
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx._labelChild != null);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", true);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", false);
    }
  },
  directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgSwitch, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgSwitchCase],
  pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DecimalPipe],
  styles: [".ngx-gauge-meter{display:inline-block;text-align:center;position:relative}.reading-block,.reading-label{position:absolute;width:100%;font-weight:400;white-space:nowrap;text-align:center;overflow:hidden;text-overflow:ellipsis}.reading-label{font-family:inherit;display:inline-block}.reading-affix{text-decoration:none;font-size:.6em;opacity:.8;font-weight:200;padding:0 .18em}.reading-affix:first-child{padding-left:0}.reading-affix:last-child{padding-right:0}"],
  encapsulation: 2
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxGauge, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
    args: [{
      selector: 'ngx-gauge',
      templateUrl: 'gauge.html',
      styleUrls: ['gauge.css'],
      host: {
        'role': 'slider',
        'aria-readonly': 'true',
        '[class.ngx-gauge-meter]': 'true',
        '[attr.aria-valuemin]': 'min',
        '[attr.aria-valuemax]': 'max',
        '[attr.aria-valuenow]': 'value',
        '[attr.aria-label]': 'ariaLabel',
        '[attr.aria-labelledby]': 'ariaLabelledby'
      },
      encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
    }];
  }, {
    _canvas: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
      args: ['canvas', {
        static: true
      }]
    }],
    _label: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
      args: ['rLabel', {
        static: true
      }]
    }],
    _reading: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
      args: ['reading', {
        static: true
      }]
    }],
    _labelChild: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ContentChild,
      args: [NgxGaugeLabel]
    }],
    _prependChild: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ContentChild,
      args: [NgxGaugePrepend]
    }],
    _appendChild: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ContentChild,
      args: [NgxGaugeAppend]
    }],
    _valueDisplayChild: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ContentChild,
      args: [NgxGaugeValue]
    }],
    ariaLabel: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
      args: ['aria-label']
    }],
    ariaLabelledby: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
      args: ['aria-labelledby']
    }],
    size: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    min: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    animate: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    max: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    type: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    cap: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    thick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    label: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    append: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    prepend: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    foregroundColor: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    backgroundColor: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    thresholds: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    value: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    duration: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }]
  });
})();

class NgxGaugeModule {}

NgxGaugeModule.ɵfac = function NgxGaugeModule_Factory(t) {
  return new (t || NgxGaugeModule)();
};

NgxGaugeModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
  type: NgxGaugeModule
});
NgxGaugeModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
  imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxGaugeModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
    args: [{
      imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule],
      declarations: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel],
      exports: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel]
    }]
  }], null, null);
})();
/*
 * Public APIs of ngx-gauge
 */

/**
 * Generated bundle index. Do not edit.
 */




/***/ }),

/***/ 9156:
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm/internal/operators/throttle.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultThrottleConfig": () => (/* binding */ defaultThrottleConfig),
/* harmony export */   "throttle": () => (/* binding */ throttle)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 41944);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 93945);
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observable/innerFrom */ 54987);



const defaultThrottleConfig = {
    leading: true,
    trailing: false,
};
function throttle(durationSelector, config = defaultThrottleConfig) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((source, subscriber) => {
        const { leading, trailing } = config;
        let hasValue = false;
        let sendValue = null;
        let throttled = null;
        let isComplete = false;
        const endThrottling = () => {
            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
            throttled = null;
            if (trailing) {
                send();
                isComplete && subscriber.complete();
            }
        };
        const cleanupThrottling = () => {
            throttled = null;
            isComplete && subscriber.complete();
        };
        const startThrottle = (value) => (throttled = (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(durationSelector(value)).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, endThrottling, cleanupThrottling)));
        const send = () => {
            if (hasValue) {
                hasValue = false;
                const value = sendValue;
                sendValue = null;
                subscriber.next(value);
                !isComplete && startThrottle(value);
            }
        };
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, (value) => {
            hasValue = true;
            sendValue = value;
            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, () => {
            isComplete = true;
            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
    });
}


/***/ }),

/***/ 35004:
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm/internal/operators/throttleTime.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "throttleTime": () => (/* binding */ throttleTime)
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/async */ 96936);
/* harmony import */ var _throttle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./throttle */ 9156);
/* harmony import */ var _observable_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/timer */ 78947);



function throttleTime(duration, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.asyncScheduler, config = _throttle__WEBPACK_IMPORTED_MODULE_1__.defaultThrottleConfig) {
  const duration$ = (0,_observable_timer__WEBPACK_IMPORTED_MODULE_2__.timer)(duration, scheduler);
  return (0,_throttle__WEBPACK_IMPORTED_MODULE_1__.throttle)(() => duration$, config);
}

/***/ }),

/***/ 45877:
/*!***********************************************************!*\
  !*** ./node_modules/ngx-echarts/fesm2015/ngx-echarts.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NGX_ECHARTS_CONFIG": () => (/* binding */ NGX_ECHARTS_CONFIG),
/* harmony export */   "NgxEchartsDirective": () => (/* binding */ NgxEchartsDirective),
/* harmony export */   "NgxEchartsModule": () => (/* binding */ NgxEchartsModule)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 3184);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ 34929);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ 10745);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ 20591);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 80228);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ 96936);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ 90833);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ 35004);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ 32673);






class ChangeFilter {
  constructor(changes) {
    this.changes = changes;
  }

  static of(changes) {
    return new ChangeFilter(changes);
  }

  notEmpty(key) {
    if (this.changes[key]) {
      const value = this.changes[key].currentValue;

      if (value !== undefined && value !== null) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value);
      }
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
  }

  has(key) {
    if (this.changes[key]) {
      const value = this.changes[key].currentValue;
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value);
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
  }

  notFirst(key) {
    if (this.changes[key] && !this.changes[key].isFirstChange()) {
      const value = this.changes[key].currentValue;
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value);
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
  }

  notFirstAndEmpty(key) {
    if (this.changes[key] && !this.changes[key].isFirstChange()) {
      const value = this.changes[key].currentValue;

      if (value !== undefined && value !== null) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value);
      }
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
  }

}

const NGX_ECHARTS_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('NGX_ECHARTS_CONFIG');

class NgxEchartsDirective {
  constructor(config, el, ngZone) {
    this.el = el;
    this.ngZone = ngZone;
    this.autoResize = true;
    this.loadingType = 'default'; // ngx-echarts events

    this.chartInit = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.EventEmitter();
    this.optionsError = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.EventEmitter(); // echarts mouse events

    this.chartClick = this.createLazyEvent('click');
    this.chartDblClick = this.createLazyEvent('dblclick');
    this.chartMouseDown = this.createLazyEvent('mousedown');
    this.chartMouseMove = this.createLazyEvent('mousemove');
    this.chartMouseUp = this.createLazyEvent('mouseup');
    this.chartMouseOver = this.createLazyEvent('mouseover');
    this.chartMouseOut = this.createLazyEvent('mouseout');
    this.chartGlobalOut = this.createLazyEvent('globalout');
    this.chartContextMenu = this.createLazyEvent('contextmenu'); // echarts mouse events

    this.chartLegendSelectChanged = this.createLazyEvent('legendselectchanged');
    this.chartLegendSelected = this.createLazyEvent('legendselected');
    this.chartLegendUnselected = this.createLazyEvent('legendunselected');
    this.chartLegendScroll = this.createLazyEvent('legendscroll');
    this.chartDataZoom = this.createLazyEvent('datazoom');
    this.chartDataRangeSelected = this.createLazyEvent('datarangeselected');
    this.chartTimelineChanged = this.createLazyEvent('timelinechanged');
    this.chartTimelinePlayChanged = this.createLazyEvent('timelineplaychanged');
    this.chartRestore = this.createLazyEvent('restore');
    this.chartDataViewChanged = this.createLazyEvent('dataviewchanged');
    this.chartMagicTypeChanged = this.createLazyEvent('magictypechanged');
    this.chartPieSelectChanged = this.createLazyEvent('pieselectchanged');
    this.chartPieSelected = this.createLazyEvent('pieselected');
    this.chartPieUnselected = this.createLazyEvent('pieunselected');
    this.chartMapSelectChanged = this.createLazyEvent('mapselectchanged');
    this.chartMapSelected = this.createLazyEvent('mapselected');
    this.chartMapUnselected = this.createLazyEvent('mapunselected');
    this.chartAxisAreaSelected = this.createLazyEvent('axisareaselected');
    this.chartFocusNodeAdjacency = this.createLazyEvent('focusnodeadjacency');
    this.chartUnfocusNodeAdjacency = this.createLazyEvent('unfocusnodeadjacency');
    this.chartBrush = this.createLazyEvent('brush');
    this.chartBrushEnd = this.createLazyEvent('brushend');
    this.chartBrushSelected = this.createLazyEvent('brushselected');
    this.chartRendered = this.createLazyEvent('rendered');
    this.chartFinished = this.createLazyEvent('finished');
    this.animationFrameID = null;
    this.resize$ = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
    this.echarts = config.echarts;
  }

  ngOnChanges(changes) {
    const filter = ChangeFilter.of(changes);
    filter.notFirstAndEmpty('options').subscribe(opt => this.onOptionsChange(opt));
    filter.notFirstAndEmpty('merge').subscribe(opt => this.setOption(opt));
    filter.has('loading').subscribe(v => this.toggleLoading(!!v));
    filter.notFirst('theme').subscribe(() => this.refreshChart());
  }

  ngOnInit() {
    if (!window.ResizeObserver) {
      throw new Error('please install a polyfill for ResizeObserver');
    }

    this.resizeSub = this.resize$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.throttleTime)(100, rxjs__WEBPACK_IMPORTED_MODULE_5__.asyncScheduler, {
      leading: false,
      trailing: true
    })).subscribe(() => this.resize());

    if (this.autoResize) {
      this.resizeOb = this.ngZone.runOutsideAngular(() => new window.ResizeObserver(() => {
        this.animationFrameID = window.requestAnimationFrame(() => this.resize$.next());
      }));
      this.resizeOb.observe(this.el.nativeElement);
    }
  }

  ngOnDestroy() {
    window.clearTimeout(this.initChartTimer);

    if (this.resizeSub) {
      this.resizeSub.unsubscribe();
    }

    if (this.animationFrameID) {
      window.cancelAnimationFrame(this.animationFrameID);
    }

    if (this.resizeOb) {
      this.resizeOb.unobserve(this.el.nativeElement);
    }

    this.dispose();
  }

  ngAfterViewInit() {
    this.initChartTimer = window.setTimeout(() => this.initChart());
  }

  dispose() {
    if (this.chart) {
      if (!this.chart.isDisposed()) {
        this.chart.dispose();
      }

      this.chart = null;
    }
  }
  /**
   * resize chart
   */


  resize() {
    if (this.chart) {
      this.chart.resize();
    }
  }

  toggleLoading(loading) {
    if (this.chart) {
      loading ? this.chart.showLoading(this.loadingType, this.loadingOpts) : this.chart.hideLoading();
    }
  }

  setOption(option, opts) {
    if (this.chart) {
      try {
        this.chart.setOption(option, opts);
      } catch (e) {
        console.error(e);
        this.optionsError.emit(e);
      }
    }
  }
  /**
   * dispose old chart and create a new one.
   */


  refreshChart() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__awaiter)(this, void 0, void 0, function* () {
      this.dispose();
      yield this.initChart();
    });
  }

  createChart() {
    const dom = this.el.nativeElement;

    if (window && window.getComputedStyle) {
      const prop = window.getComputedStyle(dom, null).getPropertyValue('height');

      if ((!prop || prop === '0px') && (!dom.style.height || dom.style.height === '0px')) {
        dom.style.height = '400px';
      }
    } // here a bit tricky: we check if the echarts module is provided as function returning native import('...') then use the promise
    // otherwise create the function that imitates behaviour above with a provided as is module


    return this.ngZone.runOutsideAngular(() => {
      const load = typeof this.echarts === 'function' ? this.echarts : () => Promise.resolve(this.echarts);
      return load().then(({
        init
      }) => init(dom, this.theme, this.initOpts));
    });
  }

  initChart() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__awaiter)(this, void 0, void 0, function* () {
      yield this.onOptionsChange(this.options);

      if (this.merge && this.chart) {
        this.setOption(this.merge);
      }
    });
  }

  onOptionsChange(opt) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__awaiter)(this, void 0, void 0, function* () {
      if (!opt) {
        return;
      }

      if (this.chart) {
        this.setOption(this.options, true);
      } else {
        this.chart = yield this.createChart();
        this.chartInit.emit(this.chart);
        this.setOption(this.options, true);
      }
    });
  } // allows to lazily bind to only those events that are requested through the `@Output` by parent components
  // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info


  createLazyEvent(eventName) {
    return this.chartInit.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.switchMap)(chart => new rxjs__WEBPACK_IMPORTED_MODULE_8__.Observable(observer => {
      chart.on(eventName, data => this.ngZone.run(() => observer.next(data)));
      return () => {
        if (this.chart) {
          if (!this.chart.isDisposed()) {
            chart.off(eventName);
          }
        }
      };
    })));
  }

}

NgxEchartsDirective.ɵfac = function NgxEchartsDirective_Factory(t) {
  return new (t || NgxEchartsDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](NGX_ECHARTS_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone));
};

NgxEchartsDirective.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]({
  type: NgxEchartsDirective,
  selectors: [["echarts"], ["", "echarts", ""]],
  inputs: {
    options: "options",
    theme: "theme",
    loading: "loading",
    initOpts: "initOpts",
    merge: "merge",
    autoResize: "autoResize",
    loadingType: "loadingType",
    loadingOpts: "loadingOpts"
  },
  outputs: {
    chartInit: "chartInit",
    optionsError: "optionsError",
    chartClick: "chartClick",
    chartDblClick: "chartDblClick",
    chartMouseDown: "chartMouseDown",
    chartMouseMove: "chartMouseMove",
    chartMouseUp: "chartMouseUp",
    chartMouseOver: "chartMouseOver",
    chartMouseOut: "chartMouseOut",
    chartGlobalOut: "chartGlobalOut",
    chartContextMenu: "chartContextMenu",
    chartLegendSelectChanged: "chartLegendSelectChanged",
    chartLegendSelected: "chartLegendSelected",
    chartLegendUnselected: "chartLegendUnselected",
    chartLegendScroll: "chartLegendScroll",
    chartDataZoom: "chartDataZoom",
    chartDataRangeSelected: "chartDataRangeSelected",
    chartTimelineChanged: "chartTimelineChanged",
    chartTimelinePlayChanged: "chartTimelinePlayChanged",
    chartRestore: "chartRestore",
    chartDataViewChanged: "chartDataViewChanged",
    chartMagicTypeChanged: "chartMagicTypeChanged",
    chartPieSelectChanged: "chartPieSelectChanged",
    chartPieSelected: "chartPieSelected",
    chartPieUnselected: "chartPieUnselected",
    chartMapSelectChanged: "chartMapSelectChanged",
    chartMapSelected: "chartMapSelected",
    chartMapUnselected: "chartMapUnselected",
    chartAxisAreaSelected: "chartAxisAreaSelected",
    chartFocusNodeAdjacency: "chartFocusNodeAdjacency",
    chartUnfocusNodeAdjacency: "chartUnfocusNodeAdjacency",
    chartBrush: "chartBrush",
    chartBrushEnd: "chartBrushEnd",
    chartBrushSelected: "chartBrushSelected",
    chartRendered: "chartRendered",
    chartFinished: "chartFinished"
  },
  exportAs: ["echarts"],
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵNgOnChangesFeature"]]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](NgxEchartsDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,
    args: [{
      selector: 'echarts, [echarts]',
      exportAs: 'echarts'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
        args: [NGX_ECHARTS_CONFIG]
      }]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone
    }];
  }, {
    options: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    theme: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    loading: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    initOpts: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    merge: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    autoResize: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    loadingType: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    loadingOpts: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    chartInit: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    optionsError: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartDblClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseDown: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseMove: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseUp: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseOver: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseOut: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartGlobalOut: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartContextMenu: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartLegendSelectChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartLegendSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartLegendUnselected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartLegendScroll: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartDataZoom: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartDataRangeSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartTimelineChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartTimelinePlayChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartRestore: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartDataViewChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMagicTypeChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartPieSelectChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartPieSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartPieUnselected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMapSelectChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMapSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMapUnselected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartAxisAreaSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartFocusNodeAdjacency: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartUnfocusNodeAdjacency: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartBrush: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartBrushEnd: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartBrushSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartRendered: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartFinished: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }]
  });
})();

class NgxEchartsModule {
  static forRoot(config) {
    return {
      ngModule: NgxEchartsModule,
      providers: [{
        provide: NGX_ECHARTS_CONFIG,
        useValue: config
      }]
    };
  }

  static forChild() {
    return {
      ngModule: NgxEchartsModule
    };
  }

}

NgxEchartsModule.ɵfac = function NgxEchartsModule_Factory(t) {
  return new (t || NgxEchartsModule)();
};

NgxEchartsModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
  type: NgxEchartsModule
});
NgxEchartsModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({
  imports: [[]]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](NgxEchartsModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
    args: [{
      imports: [],
      declarations: [NgxEchartsDirective],
      exports: [NgxEchartsDirective]
    }]
  }], null, null);
})();
/*
 * Public API Surface of ngx-echarts
 */

/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=default-node_modules_ngx-gauge_fesm2015_ngx-gauge_js-node_modules_ngx-echarts_fesm2015_ngx-ec-50ebe3.js.map